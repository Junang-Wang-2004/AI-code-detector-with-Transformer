class DSU:
    def __init__(self, n):
        self.p = list(range(n))
        self.rnk = [0] * n

    def get(self, x):
        if self.p[x] != x:
            self.p[x] = self.get(self.p[x])
        return self.p[x]

    def merge(self, x, y):
        px = self.get(x)
        py = self.get(y)
        if px == py:
            return
        if self.rnk[px] > self.rnk[py]:
            self.p[py] = px
        elif self.rnk[px] < self.rnk[py]:
            self.p[px] = py
        else:
            self.p[py] = px
            self.rnk[px] += 1


class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        dsu = DSU(n)
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j]:
                    dsu.merge(i, j)
        comp_sizes = {}
        for i in range(n):
            root = dsu.get(i)
            comp_sizes[root] = comp_sizes.get(root, 0) + 1
        inf_counts = {}
        for node in initial:
            root = dsu.get(node)
            inf_counts[root] = inf_counts.get(root, 0) + 1
        max_save = -1
        ans = float('inf')
        for node in initial:
            root = dsu.get(node)
            count = inf_counts[root]
            save = comp_sizes[root] if count == 1 else 0
            if save > max_save or (save == max_save and node < ans):
                max_save = save
                ans = node
        return ans
