{"id": "llm_code\\longest-palindrome-after-substring-concatenation-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def longestPalindrome(self, a1, a2):\n        v1 = a2[::-1]\n\n        def pal_prefix_lens(a1):\n            v1 = len(a1)\n            v2 = [1] * v1\n            for v3 in range(v1):\n                v4, v5 = (v3, v3)\n                while v4 >= 0 and v5 < v1 and (a1[v4] == a1[v5]):\n                    v2[v4] = max(v2[v4], v5 - v4 + 1)\n                    v4 -= 1\n                    v5 += 1\n                v4, v5 = (v3, v3 + 1)\n                while v4 >= 0 and v5 < v1 and (a1[v4] == a1[v5]):\n                    v2[v4] = max(v2[v4], v5 - v4 + 1)\n                    v4 -= 1\n                    v5 += 1\n            return v2 + [0]\n        v2 = pal_prefix_lens(a1)\n        v3 = pal_prefix_lens(v1)\n        v4, v5 = (len(a1), len(v1))\n        v6 = 0\n        v7 = [[0] * (v5 + 1) for v8 in range(2)]\n        for v9 in range(v4):\n            v10 = v9 % 2\n            v11 = 1 - v10\n            v7[v10][0] = 0\n            for v12 in range(v5):\n                v13 = a1[v9] == v1[v12]\n                v7[v10][v12 + 1] = v7[v11][v12] + 2 if v13 else 0\n                v14 = 1 if v13 else 0\n                v6 = max(v6, v7[v10][v12 + 1] + v2[v9 + v14])\n                v6 = max(v6, v7[v10][v12 + 1] + v3[v12 + v14])\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def longestPalindrome(self, a1, a2):\n        v1 = a2[::-1]\n\n        def pal_prefix_lens(a1):\n            v1 = len(a1)\n            v2 = [1] * v1\n            for v3 in range(v1):\n                v4, v5 = (v3, v3)\n                while v4 >= 0 and v5 < v1 and (a1[v4] == a1[v5]):\n                    v2[v4] = max(v2[v4], v5 - v4 + 1)\n                    v4 -= 1\n                    v5 += 1\n                v4, v5 = (v3, v3 + 1)\n                while v4 >= 0 and v5 < v1 and (a1[v4] == a1[v5]):\n                    v2[v4] = max(v2[v4], v5 - v4 + 1)\n                    v4 -= 1\n                    v5 += 1\n            return v2 + [0]\n        v2 = pal_prefix_lens(a1)\n        v3 = pal_prefix_lens(v1)\n        v4, v5 = (len(a1), len(v1))\n        v6 = 0\n        v7 = [[0] * (v5 + 1) for v8 in range(2)]\n        for v9 in range(v4):\n            v10 = v9 % 2\n            v11 = 1 - v10\n            v7[v10][0] = 0\n            for v12 in range(v5):\n                v13 = a1[v9] == v1[v12]\n                v7[v10][v12 + 1] = v7[v11][v12] + 2 if v13 else 0\n                v14 = 1 if v13 else 0\n                v6 = max(v6, v7[v10][v12 + 1] + v2[v9 + v14])\n                v6 = max(v6, v7[v10][v12 + 1] + v3[v12 + v14])\n        return v6\n"}
{"id": "human_code\\p03426__s884021355.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = []\nfor v5 in range(v1):\n    v4.append(list(map(int, input().split())))\nv6 = int(input())\nv7 = []\nv8 = []\nfor v5 in range(v6):\n    v9, v10 = map(int, input().split())\n    v7.append(v9)\n    v8.append(v10)\nv11 = dict()\nfor v12, v13 in enumerate(v4):\n    for v14, v15 in enumerate(v13):\n        v11[v15] = (v14, v12)\nv16 = [[] for v17 in range(v3)]\nfor v5 in range(v1 * v2):\n    v5 += 1\n    v16[v5 % v3].append(v11[v5])\nv18 = [[0] for v17 in range(v3)]\nfor v5 in range(v3):\n    for v19 in range(1, len(v16[v5])):\n        v18[v5].append(v18[v5][v19 - 1] + abs(v16[v5][v19 - 1][0] - v16[v5][v19][0]) + abs(v16[v5][v19 - 1][1] - v16[v5][v19][1]))\nfor v5 in range(v6):\n    v20 = v18[v7[v5] % v3]\n    v21 = (v7[v5] - 1) // v3\n    v22 = (v8[v5] - 1) // v3\n    print(v20[v22] - v20[v21])\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = []\nfor v5 in range(v1):\n    v4.append(list(map(int, input().split())))\nv6 = int(input())\nv7 = []\nv8 = []\nfor v5 in range(v6):\n    v9, v10 = map(int, input().split())\n    v7.append(v9)\n    v8.append(v10)\nv11 = dict()\nfor v12, v13 in enumerate(v4):\n    for v14, v15 in enumerate(v13):\n        v11[v15] = (v14, v12)\nv16 = [[] for v17 in range(v3)]\nfor v5 in range(v1 * v2):\n    v5 += 1\n    v16[v5 % v3].append(v11[v5])\nv18 = [[0] for v17 in range(v3)]\nfor v5 in range(v3):\n    for v19 in range(1, len(v16[v5])):\n        v18[v5].append(v18[v5][v19 - 1] + abs(v16[v5][v19 - 1][0] - v16[v5][v19][0]) + abs(v16[v5][v19 - 1][1] - v16[v5][v19][1]))\nfor v5 in range(v6):\n    v20 = v18[v7[v5] % v3]\n    v21 = (v7[v5] - 1) // v3\n    v22 = (v8[v5] - 1) // v3\n    print(v20[v22] - v20[v21])\n"}
{"id": "human_code\\longest-path-with-different-adjacent-characters__part3.py", "text": "class C1(object):\n\n    def longestPath(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3, a4):\n            v1 = [0] * 2\n            for v2 in a2[a3]:\n                v3 = dfs(a1, a2, v2, a4)\n                if a1[v2] == a1[a3]:\n                    continue\n                if v3 > v1[0]:\n                    v1[0], v1[1] = (v3, v1[0])\n                elif v3 > v1[1]:\n                    v1[1] = v3\n            a4[0] = max(a4[0], v1[0] + v1[1] + 1)\n            return v1[0] + 1\n        v1 = [[] for v2 in range(len(a2))]\n        for v3 in range(1, len(a1)):\n            v1[a1[v3]].append(v3)\n        v4 = [0]\n        dfs(a2, v1, 0, v4)\n        return v4[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestPath(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3, a4):\n            v1 = [0] * 2\n            for v2 in a2[a3]:\n                v3 = dfs(a1, a2, v2, a4)\n                if a1[v2] == a1[a3]:\n                    continue\n                if v3 > v1[0]:\n                    v1[0], v1[1] = (v3, v1[0])\n                elif v3 > v1[1]:\n                    v1[1] = v3\n            a4[0] = max(a4[0], v1[0] + v1[1] + 1)\n            return v1[0] + 1\n        v1 = [[] for v2 in range(len(a2))]\n        for v3 in range(1, len(a1)):\n            v1[a1[v3]].append(v3)\n        v4 = [0]\n        dfs(a2, v1, 0, v4)\n        return v4[0]\n"}
{"id": "human_code\\number-of-people-that-can-be-seen-in-a-grid__part3.py", "text": "class C1(object):\n\n    def seePeople(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def count(a1, a2, a3, a4):\n            while a3 and a1(a3[-1]) < a1(a2):\n                increase(a3.pop())\n            if a3:\n                increase(a3[-1])\n            if a3 and a1(a3[-1]) == a1(a2):\n                a3.pop()\n            a3.append(a2)\n        v1 = [[0] * len(a1[0]) for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            v4 = []\n\n            def increase(a1):\n                v1[v3][a1] += 1\n            for v5 in range(len(a1[0])):\n                count(lambda x: a1[v3][x], v5, v4, add)\n        for v5 in range(len(a1[0])):\n            v4 = []\n\n            def increase(a1):\n                v1[a1][v5] += 1\n            for v3 in range(len(a1)):\n                count(lambda x: a1[x][v5], v3, v4, add)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def seePeople(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def count(a1, a2, a3, a4):\n            while a3 and a1(a3[-1]) < a1(a2):\n                increase(a3.pop())\n            if a3:\n                increase(a3[-1])\n            if a3 and a1(a3[-1]) == a1(a2):\n                a3.pop()\n            a3.append(a2)\n        v1 = [[0] * len(a1[0]) for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            v4 = []\n\n            def increase(a1):\n                v1[v3][a1] += 1\n            for v5 in range(len(a1[0])):\n                count(lambda x: a1[v3][x], v5, v4, add)\n        for v5 in range(len(a1[0])):\n            v4 = []\n\n            def increase(a1):\n                v1[a1][v5] += 1\n            for v3 in range(len(a1)):\n                count(lambda x: a1[x][v5], v3, v4, add)\n        return v1\n"}
{"id": "human_code\\p03229__s413012724.py", "text": "import bisect\nimport copy\nimport heapq\nimport math\nimport sys\nfrom collections import *\nfrom functools import lru_cache\nfrom itertools import accumulate, combinations, permutations, product\n\ndef f1():\n    return sys.stdin.readline()[:-1]\n\ndef f2(a1):\n    return [0] + list(accumulate(a1))\nsys.setrecursionlimit(500000)\nv1 = pow(10, 9) + 7\nv2 = [chr(ord('a') + i) for v3 in range(26)]\nv4 = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nv5 = int(f1())\nv6 = [int(f1()) for v3 in range(v5)]\nv6.sort()\nv7 = 0\nif v5 % 2 == 0:\n    for v3 in range(v5):\n        if v3 < v5 // 2:\n            v7 -= v6[v3] * 2\n        else:\n            v7 += v6[v3] * 2\n    v7 -= v6[v5 // 2]\n    v7 += v6[v5 // 2 - 1]\n    print(v7)\nelse:\n    for v3 in range(v5):\n        if v3 < v5 // 2:\n            v7 -= v6[v3] * 2\n        elif v3 > v5 // 2:\n            v7 += v6[v3] * 2\n    print(max(v7 + v6[v5 // 2] - v6[v5 // 2 + 1], v7 - v6[v5 // 2] + v6[v5 // 2 - 1]))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import bisect\nimport copy\nimport heapq\nimport math\nimport sys\nfrom collections import *\nfrom functools import lru_cache\nfrom itertools import accumulate, combinations, permutations, product\n\ndef f1():\n    return sys.stdin.readline()[:-1]\n\ndef f2(a1):\n    return [0] + list(accumulate(a1))\nsys.setrecursionlimit(500000)\nv1 = pow(10, 9) + 7\nv2 = [chr(ord('a') + i) for v3 in range(26)]\nv4 = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nv5 = int(f1())\nv6 = [int(f1()) for v3 in range(v5)]\nv6.sort()\nv7 = 0\nif v5 % 2 == 0:\n    for v3 in range(v5):\n        if v3 < v5 // 2:\n            v7 -= v6[v3] * 2\n        else:\n            v7 += v6[v3] * 2\n    v7 -= v6[v5 // 2]\n    v7 += v6[v5 // 2 - 1]\n    print(v7)\nelse:\n    for v3 in range(v5):\n        if v3 < v5 // 2:\n            v7 -= v6[v3] * 2\n        elif v3 > v5 // 2:\n            v7 += v6[v3] * 2\n    print(max(v7 + v6[v5 // 2] - v6[v5 // 2 + 1], v7 - v6[v5 // 2] + v6[v5 // 2 - 1]))\n"}
{"id": "llm_code\\p02639__s860751690.py", "text": "import sys, io, os, re\nimport bisect\nfrom pprint import pprint\nfrom math import sin, cos, pi, radians, sqrt, floor\nfrom copy import copy, deepcopy\nfrom collections import deque\nfrom fractions import gcd\nfrom functools import reduce\nfrom itertools import groupby\nv1 = lambda: int(sys.stdin.readline().strip())\nv2 = lambda: list(map(int, sys.stdin.readline().strip().split()))\nv3 = lambda: float(sys.stdin.readline().strip())\nv4 = lambda: list(map(float, sys.stdin.readline().strip().split()))\nv5 = lambda: sys.stdin.readline().strip()\nv6 = lambda: list(sys.stdin.readline().strip().split())\nv7 = lambda n: [v1() for v8 in range(n)]\nv9 = lambda n: [v3() for v8 in range(n)]\nv10 = lambda n: [v5() for v8 in range(n)]\nv11 = lambda n: [v2() for v8 in range(n)]\nv12 = lambda n: [v4() for v8 in range(n)]\nv13 = lambda n: [v6() for v8 in range(n)]\n\ndef f1(a1):\n    return [0] * a1\n\ndef f2(a1, a2):\n    return [[0] * a2 for v1 in range(a1)]\n\ndef f3(a1, a2, a3):\n    return [[[0] * a3 for v1 in xrange(a2)] for v2 in xrange(a1)]\nv14 = v2()\nfor v15 in range(len(v14)):\n    if v14[v15] == 0:\n        print(v15 + 1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys, io, os, re\nimport bisect\nfrom pprint import pprint\nfrom math import sin, cos, pi, radians, sqrt, floor\nfrom copy import copy, deepcopy\nfrom collections import deque\nfrom fractions import gcd\nfrom functools import reduce\nfrom itertools import groupby\nv1 = lambda: int(sys.stdin.readline().strip())\nv2 = lambda: list(map(int, sys.stdin.readline().strip().split()))\nv3 = lambda: float(sys.stdin.readline().strip())\nv4 = lambda: list(map(float, sys.stdin.readline().strip().split()))\nv5 = lambda: sys.stdin.readline().strip()\nv6 = lambda: list(sys.stdin.readline().strip().split())\nv7 = lambda n: [v1() for v8 in range(n)]\nv9 = lambda n: [v3() for v8 in range(n)]\nv10 = lambda n: [v5() for v8 in range(n)]\nv11 = lambda n: [v2() for v8 in range(n)]\nv12 = lambda n: [v4() for v8 in range(n)]\nv13 = lambda n: [v6() for v8 in range(n)]\n\ndef f1(a1):\n    return [0] * a1\n\ndef f2(a1, a2):\n    return [[0] * a2 for v1 in range(a1)]\n\ndef f3(a1, a2, a3):\n    return [[[0] * a3 for v1 in xrange(a2)] for v2 in xrange(a1)]\nv14 = v2()\nfor v15 in range(len(v14)):\n    if v14[v15] == 0:\n        print(v15 + 1)\n"}
{"id": "human_code\\find-array-given-subset-sums__part1.py", "text": "class C1(object):\n\n    def recoverArray(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        a2.sort()\n        v1, v2 = (0, len(a2))\n        v3 = []\n        for v4 in range(a1):\n            v5 = a2[0] - a2[1]\n            assert v5 <= 0\n            v6, v7, v8 = (False, 0, 0)\n            for v9 in range(v2):\n                if v8 < v7 and a2[v8] == a2[v9]:\n                    v8 += 1\n                else:\n                    if v1 == a2[v9] - v5:\n                        v6 = True\n                    a2[v7] = a2[v9] - v5\n                    v7 += 1\n            if v6:\n                v3.append(v5)\n            else:\n                v3.append(-v5)\n                v1 -= v5\n            v2 //= 2\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def recoverArray(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        a2.sort()\n        v1, v2 = (0, len(a2))\n        v3 = []\n        for v4 in range(a1):\n            v5 = a2[0] - a2[1]\n            assert v5 <= 0\n            v6, v7, v8 = (False, 0, 0)\n            for v9 in range(v2):\n                if v8 < v7 and a2[v8] == a2[v9]:\n                    v8 += 1\n                else:\n                    if v1 == a2[v9] - v5:\n                        v6 = True\n                    a2[v7] = a2[v9] - v5\n                    v7 += 1\n            if v6:\n                v3.append(v5)\n            else:\n                v3.append(-v5)\n                v1 -= v5\n            v2 //= 2\n        return v3\n"}
{"id": "human_code\\trionic-array-ii.py", "text": "class C1(object):\n\n    def maxSumTrionic(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = float('-inf')\n        v2 = v3 = v4 = 0\n        v5 = a1[0]\n        for v6 in range(1, len(a1)):\n            v5 += a1[v6]\n            if a1[v6 - 1] > a1[v6]:\n                if v6 - 2 >= 0 and a1[v6 - 2] < a1[v6 - 1]:\n                    v3 = v6 - 1\n                    while v2 < v4 or (a1[v2] < 0 and v2 + 1 < v3):\n                        v5 -= a1[v2]\n                        v2 += 1\n            elif a1[v6 - 1] < a1[v6]:\n                if v6 - 2 >= 0 and a1[v6 - 2] > a1[v6 - 1]:\n                    v4 = v6 - 1\n                if v2 != v3:\n                    v1 = max(v1, v5)\n            else:\n                v2 = v3 = v4 = v6\n                v5 = a1[v6]\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxSumTrionic(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = float('-inf')\n        v2 = v3 = v4 = 0\n        v5 = a1[0]\n        for v6 in range(1, len(a1)):\n            v5 += a1[v6]\n            if a1[v6 - 1] > a1[v6]:\n                if v6 - 2 >= 0 and a1[v6 - 2] < a1[v6 - 1]:\n                    v3 = v6 - 1\n                    while v2 < v4 or (a1[v2] < 0 and v2 + 1 < v3):\n                        v5 -= a1[v2]\n                        v2 += 1\n            elif a1[v6 - 1] < a1[v6]:\n                if v6 - 2 >= 0 and a1[v6 - 2] > a1[v6 - 1]:\n                    v4 = v6 - 1\n                if v2 != v3:\n                    v1 = max(v1, v5)\n            else:\n                v2 = v3 = v4 = v6\n                v5 = a1[v6]\n        return v1\n"}
{"id": "llm_code\\p02580__s550348176.py", "text": "import sys\nv1, v2, v3 = map(int, input().split())\nv4 = [0] * v1\nv5 = [0] * v2\nv6 = [[0] * v2 for v7 in [1] * v1]\nfor v7 in range(v3):\n    v8, v9 = map(int, input().split())\n    v4[v8 - 1] += 1\n    v5[v9 - 1] += 1\n    v6[v8 - 1][v9 - 1] = 1\nv10 = max(v4)\nv11 = max(v5)\nv12 = [n for v13, v14 in enumerate(v4) if v14 == v10]\nv15 = [v13 for v13, v14 in enumerate(v5) if v14 == v11]\nv16 = 0\nfor v8 in v12:\n    for v9 in v15:\n        if v6[v8][v9] == 0:\n            print(v10 + v11)\n            v16 = 1\n            sys.exit()\nif v16 == 0:\n    print(v10 + v11 - 1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1, v2, v3 = map(int, input().split())\nv4 = [0] * v1\nv5 = [0] * v2\nv6 = [[0] * v2 for v7 in [1] * v1]\nfor v7 in range(v3):\n    v8, v9 = map(int, input().split())\n    v4[v8 - 1] += 1\n    v5[v9 - 1] += 1\n    v6[v8 - 1][v9 - 1] = 1\nv10 = max(v4)\nv11 = max(v5)\nv12 = [n for v13, v14 in enumerate(v4) if v14 == v10]\nv15 = [v13 for v13, v14 in enumerate(v5) if v14 == v11]\nv16 = 0\nfor v8 in v12:\n    for v9 in v15:\n        if v6[v8][v9] == 0:\n            print(v10 + v11)\n            v16 = 1\n            sys.exit()\nif v16 == 0:\n    print(v10 + v11 - 1)\n"}
{"id": "llm_code\\maximum-number-of-accepted-invitations__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumInvitations(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n\n        def build_graph(a1, a2, a3):\n            v1 = {}\n            for v2 in range(a1):\n                v3 = []\n                for v4 in range(a2):\n                    if a1[v2][v4] if a3 else a1[v4][v2]:\n                        v3.append(v4)\n                v1[v2] = v3\n            return v1\n        if v1 <= v2:\n            v3 = build_graph(v1, v2, True)\n            v4 = v1\n            v5 = v2\n        else:\n            v3 = build_graph(v2, v1, False)\n            v4 = v2\n            v5 = v1\n        v6 = [-1] * v4\n        v7 = [-1] * v5\n\n        def find_path(a1, a2):\n            for v1 in v3[a1]:\n                if a2[v1]:\n                    continue\n                a2[v1] = True\n                if v7[v1] == -1 or find_path(v7[v1], a2):\n                    v6[a1] = v1\n                    v7[v1] = a1\n                    return True\n            return False\n        v8 = 0\n        for v9 in range(v4):\n            if v6[v9] == -1:\n                v10 = [False] * v5\n                if find_path(v9, v10):\n                    v8 += 1\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumInvitations(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n\n        def build_graph(a1, a2, a3):\n            v1 = {}\n            for v2 in range(a1):\n                v3 = []\n                for v4 in range(a2):\n                    if a1[v2][v4] if a3 else a1[v4][v2]:\n                        v3.append(v4)\n                v1[v2] = v3\n            return v1\n        if v1 <= v2:\n            v3 = build_graph(v1, v2, True)\n            v4 = v1\n            v5 = v2\n        else:\n            v3 = build_graph(v2, v1, False)\n            v4 = v2\n            v5 = v1\n        v6 = [-1] * v4\n        v7 = [-1] * v5\n\n        def find_path(a1, a2):\n            for v1 in v3[a1]:\n                if a2[v1]:\n                    continue\n                a2[v1] = True\n                if v7[v1] == -1 or find_path(v7[v1], a2):\n                    v6[a1] = v1\n                    v7[v1] = a1\n                    return True\n            return False\n        v8 = 0\n        for v9 in range(v4):\n            if v6[v9] == -1:\n                v10 = [False] * v5\n                if find_path(v9, v10):\n                    v8 += 1\n        return v8\n"}
{"id": "llm_code\\fruits-into-baskets-iii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def numOfUnplacedFruits(self, a1, a2):\n\n        class SegTree:\n\n            def __init__(self, a1):\n                self.size = len(a1)\n                self.tree = [0] * (4 * self.size)\n                if self.size > 0:\n                    self._construct(1, 0, self.size - 1, a1)\n\n            def _construct(self, a1, a2, a3, a4):\n                if a2 == a3:\n                    self.tree[a1] = a4[a2]\n                    return\n                v1 = (a2 + a3) // 2\n                self._construct(2 * a1, a2, v1, a4)\n                self._construct(2 * a1 + 1, v1 + 1, a3, a4)\n                self.tree[a1] = max(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n            def _modify(self, a1, a2, a3, a4, a5):\n                if a2 == a3:\n                    self.tree[a1] = a5\n                    return\n                v1 = (a2 + a3) // 2\n                if a4 <= v1:\n                    self._modify(2 * a1, a2, v1, a4, a5)\n                else:\n                    self._modify(2 * a1 + 1, v1 + 1, a3, a4, a5)\n                self.tree[a1] = max(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n            def find_first_ge(self, a1, a2, a3, a4):\n                if self.tree[a1] < a4:\n                    return -1\n                if a2 == a3:\n                    return a2\n                v1 = (a2 + a3) // 2\n                v2 = self.find_first_ge(2 * a1, a2, v1, a4)\n                if v2 != -1:\n                    return v2\n                return self.find_first_ge(2 * a1 + 1, v1 + 1, a3, a4)\n        if not a2:\n            return len(a1)\n        v1 = SegTree(a2)\n        v2 = 0\n        for v3 in a1:\n            v4 = v1.find_first_ge(1, 0, v1.size - 1, v3)\n            if v4 == -1:\n                v2 += 1\n            else:\n                v1._modify(1, 0, v1.size - 1, v4, 0)\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def numOfUnplacedFruits(self, a1, a2):\n\n        class SegTree:\n\n            def __init__(self, a1):\n                self.size = len(a1)\n                self.tree = [0] * (4 * self.size)\n                if self.size > 0:\n                    self._construct(1, 0, self.size - 1, a1)\n\n            def _construct(self, a1, a2, a3, a4):\n                if a2 == a3:\n                    self.tree[a1] = a4[a2]\n                    return\n                v1 = (a2 + a3) // 2\n                self._construct(2 * a1, a2, v1, a4)\n                self._construct(2 * a1 + 1, v1 + 1, a3, a4)\n                self.tree[a1] = max(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n            def _modify(self, a1, a2, a3, a4, a5):\n                if a2 == a3:\n                    self.tree[a1] = a5\n                    return\n                v1 = (a2 + a3) // 2\n                if a4 <= v1:\n                    self._modify(2 * a1, a2, v1, a4, a5)\n                else:\n                    self._modify(2 * a1 + 1, v1 + 1, a3, a4, a5)\n                self.tree[a1] = max(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n            def find_first_ge(self, a1, a2, a3, a4):\n                if self.tree[a1] < a4:\n                    return -1\n                if a2 == a3:\n                    return a2\n                v1 = (a2 + a3) // 2\n                v2 = self.find_first_ge(2 * a1, a2, v1, a4)\n                if v2 != -1:\n                    return v2\n                return self.find_first_ge(2 * a1 + 1, v1 + 1, a3, a4)\n        if not a2:\n            return len(a1)\n        v1 = SegTree(a2)\n        v2 = 0\n        for v3 in a1:\n            v4 = v1.find_first_ge(1, 0, v1.size - 1, v3)\n            if v4 == -1:\n                v2 += 1\n            else:\n                v1._modify(1, 0, v1.size - 1, v4, 0)\n        return v2\n"}
{"id": "human_code\\construct-quad-tree.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4, a5, a6):\n        self.val = a1\n        self.isLeaf = a2\n        self.topLeft = a3\n        self.topRight = a4\n        self.bottomLeft = a5\n        self.bottomRight = a6\n\nclass C2(object):\n\n    def construct(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3, a4):\n            if a4 == 1:\n                return C1(a1[a2][a3] == 1, True, None, None, None, None)\n            v1 = a4 // 2\n            v2 = dfs(a1, a2, a3, v1)\n            v3 = dfs(a1, a2, a3 + v1, v1)\n            v4 = dfs(a1, a2 + v1, a3, v1)\n            v5 = dfs(a1, a2 + v1, a3 + v1, v1)\n            if v2.isLeaf and v3.isLeaf and v4.isLeaf and v5.isLeaf and (v2.val == v3.val == v4.val == v5.val):\n                return C1(v2.val, True, None, None, None, None)\n            return C1(True, False, v2, v3, v4, v5)\n        if not a1:\n            return None\n        return dfs(a1, 0, 0, len(a1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4, a5, a6):\n        self.val = a1\n        self.isLeaf = a2\n        self.topLeft = a3\n        self.topRight = a4\n        self.bottomLeft = a5\n        self.bottomRight = a6\n\nclass C2(object):\n\n    def construct(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3, a4):\n            if a4 == 1:\n                return C1(a1[a2][a3] == 1, True, None, None, None, None)\n            v1 = a4 // 2\n            v2 = dfs(a1, a2, a3, v1)\n            v3 = dfs(a1, a2, a3 + v1, v1)\n            v4 = dfs(a1, a2 + v1, a3, v1)\n            v5 = dfs(a1, a2 + v1, a3 + v1, v1)\n            if v2.isLeaf and v3.isLeaf and v4.isLeaf and v5.isLeaf and (v2.val == v3.val == v4.val == v5.val):\n                return C1(v2.val, True, None, None, None, None)\n            return C1(True, False, v2, v3, v4, v5)\n        if not a1:\n            return None\n        return dfs(a1, 0, 0, len(a1))\n"}
{"id": "human_code\\validate-binary-tree-nodes.py", "text": "class C1(object):\n\n    def validateBinaryTreeNodes(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = set(range(a1)) - set(a2) - set(a3)\n        if len(v1) != 1:\n            return False\n        v2, = v1\n        v3 = [v2]\n        v4 = set([v2])\n        while v3:\n            v5 = v3.pop()\n            for v6 in (a2[v5], a3[v5]):\n                if v6 < 0:\n                    continue\n                if v6 in v4:\n                    return False\n                v4.add(v6)\n                v3.append(v6)\n        return len(v4) == a1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def validateBinaryTreeNodes(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = set(range(a1)) - set(a2) - set(a3)\n        if len(v1) != 1:\n            return False\n        v2, = v1\n        v3 = [v2]\n        v4 = set([v2])\n        while v3:\n            v5 = v3.pop()\n            for v6 in (a2[v5], a3[v5]):\n                if v6 < 0:\n                    continue\n                if v6 in v4:\n                    return False\n                v4.add(v6)\n                v3.append(v6)\n        return len(v4) == a1\n"}
{"id": "human_code\\p02574__s812194560.py", "text": "def f1(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f2(a1):\n    \"\"\"Miller Rabin primality test. 2 <= n <= 2 ** 64 is required\"\"\"\n    if a1 % 2 == 0:\n        return a1 == 2\n    v1 = a1 - 1\n    v2 = (v1 & -v1).bit_length() - 1\n    v1 >>= v2\n    if a1 < 2152302898747:\n        if a1 < 9080191:\n            if a1 < 2047:\n                v3 = [2]\n            else:\n                v3 = [31, 73]\n        elif a1 < 4759123141:\n            v3 = [2, 7, 61]\n        else:\n            v3 = [2, 3, 5, 7, 11]\n    elif a1 < 341550071728321:\n        if a1 < 3474749660383:\n            v3 = [2, 3, 5, 7, 11, 13]\n        else:\n            v3 = [2, 3, 5, 7, 11, 13, 17]\n    elif a1 < 3825123056546413051:\n        v3 = [2, 3, 5, 7, 11, 13, 17, 19]\n    else:\n        v3 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    for v4 in v3:\n        v5 = pow(v4, v1, a1)\n        if v5 == 1 or v5 == a1 - 1:\n            continue\n        for v6 in range(v2 - 1):\n            v5 *= v5\n            v5 %= a1\n            if v5 == a1 - 1:\n                break\n        else:\n            return False\n    return True\n\ndef f3(a1):\n    \"\"\"Find a non-trivial factor of n by using Pollard's rho algorithm.\"\"\"\n    v1 = int(a1 ** 0.125) + 1\n    v2 = 1\n    while True:\n        v3 = 1\n        v4 = 1\n        v5 = 1\n        v6 = 1\n        while v6 == 1:\n            v7 = v3\n            for v8 in range(v4):\n                v3 = (v3 * v3 + v2) % a1\n            for v9 in range(0, v4, v1):\n                v10 = v3\n                for v8 in range(v1):\n                    v3 = (v3 * v3 + v2) % a1\n                    v5 = v5 * (v7 - v3) % a1\n                v6 = f1(v5, a1)\n                if v6 != 1:\n                    break\n            else:\n                v10 = v3\n                for v8 in range(v4 - v9):\n                    v3 = (v3 * v3 + v2) % a1\n                    v5 = v5 * (v7 - v3) % a1\n                v6 = f1(v5, a1)\n            v4 *= 2\n        if v6 == a1:\n            v6 = 1\n            while v6 == 1:\n                v10 = (v10 * v10 + v2) % a1\n                v6 = f1(v7 - v10, a1)\n        if v6 == a1:\n            v2 += 1\n        else:\n            return v6\n\ndef f4(a1):\n    \"\"\"計算量は O(n ^ 1/4) 程度。\"\"\"\n    if a1 == 1:\n        return []\n    if f2(a1):\n        return [a1]\n    v1 = []\n    for v2 in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]:\n        while a1 % v2 == 0:\n            v1.append(v2)\n            a1 //= v2\n        if a1 == 1:\n            return v1\n    while a1 != 1 and (not f2(a1)):\n        v4 = f3(a1)\n        if f2(v4):\n            while a1 % v4 == 0:\n                v1.append(v4)\n                a1 //= v4\n        elif f2(a1 // v4):\n            v1.append(a1 // v4)\n            a1 = v4\n        else:\n            return sorted(v1 + f4(v4) + f4(a1 // v4))\n    if a1 == 1:\n        return sorted(v1)\n    else:\n        v1.append(a1)\n        return sorted(v1)\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 0\nfor v4 in v2:\n    v3 = f1(v3, v4)\nif v3 != 1:\n    print('not coprime')\n    exit()\nv5 = set()\nfor v4 in v2:\n    v6 = set(f4(v4))\n    if v6 & v5:\n        print('setwise coprime')\n        exit()\n    else:\n        v5 |= v6\nprint('pairwise coprime')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f2(a1):\n    \"\"\"Miller Rabin primality test. 2 <= n <= 2 ** 64 is required\"\"\"\n    if a1 % 2 == 0:\n        return a1 == 2\n    v1 = a1 - 1\n    v2 = (v1 & -v1).bit_length() - 1\n    v1 >>= v2\n    if a1 < 2152302898747:\n        if a1 < 9080191:\n            if a1 < 2047:\n                v3 = [2]\n            else:\n                v3 = [31, 73]\n        elif a1 < 4759123141:\n            v3 = [2, 7, 61]\n        else:\n            v3 = [2, 3, 5, 7, 11]\n    elif a1 < 341550071728321:\n        if a1 < 3474749660383:\n            v3 = [2, 3, 5, 7, 11, 13]\n        else:\n            v3 = [2, 3, 5, 7, 11, 13, 17]\n    elif a1 < 3825123056546413051:\n        v3 = [2, 3, 5, 7, 11, 13, 17, 19]\n    else:\n        v3 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    for v4 in v3:\n        v5 = pow(v4, v1, a1)\n        if v5 == 1 or v5 == a1 - 1:\n            continue\n        for v6 in range(v2 - 1):\n            v5 *= v5\n            v5 %= a1\n            if v5 == a1 - 1:\n                break\n        else:\n            return False\n    return True\n\ndef f3(a1):\n    \"\"\"Find a non-trivial factor of n by using Pollard's rho algorithm.\"\"\"\n    v1 = int(a1 ** 0.125) + 1\n    v2 = 1\n    while True:\n        v3 = 1\n        v4 = 1\n        v5 = 1\n        v6 = 1\n        while v6 == 1:\n            v7 = v3\n            for v8 in range(v4):\n                v3 = (v3 * v3 + v2) % a1\n            for v9 in range(0, v4, v1):\n                v10 = v3\n                for v8 in range(v1):\n                    v3 = (v3 * v3 + v2) % a1\n                    v5 = v5 * (v7 - v3) % a1\n                v6 = f1(v5, a1)\n                if v6 != 1:\n                    break\n            else:\n                v10 = v3\n                for v8 in range(v4 - v9):\n                    v3 = (v3 * v3 + v2) % a1\n                    v5 = v5 * (v7 - v3) % a1\n                v6 = f1(v5, a1)\n            v4 *= 2\n        if v6 == a1:\n            v6 = 1\n            while v6 == 1:\n                v10 = (v10 * v10 + v2) % a1\n                v6 = f1(v7 - v10, a1)\n        if v6 == a1:\n            v2 += 1\n        else:\n            return v6\n\ndef f4(a1):\n    \"\"\"計算量は O(n ^ 1/4) 程度。\"\"\"\n    if a1 == 1:\n        return []\n    if f2(a1):\n        return [a1]\n    v1 = []\n    for v2 in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]:\n        while a1 % v2 == 0:\n            v1.append(v2)\n            a1 //= v2\n        if a1 == 1:\n            return v1\n    while a1 != 1 and (not f2(a1)):\n        v4 = f3(a1)\n        if f2(v4):\n            while a1 % v4 == 0:\n                v1.append(v4)\n                a1 //= v4\n        elif f2(a1 // v4):\n            v1.append(a1 // v4)\n            a1 = v4\n        else:\n            return sorted(v1 + f4(v4) + f4(a1 // v4))\n    if a1 == 1:\n        return sorted(v1)\n    else:\n        v1.append(a1)\n        return sorted(v1)\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 0\nfor v4 in v2:\n    v3 = f1(v3, v4)\nif v3 != 1:\n    print('not coprime')\n    exit()\nv5 = set()\nfor v4 in v2:\n    v6 = set(f4(v4))\n    if v6 & v5:\n        print('setwise coprime')\n        exit()\n    else:\n        v5 |= v6\nprint('pairwise coprime')\n"}
{"id": "human_code\\different-ways-to-add-parentheses__part2.py", "text": "import operator\nimport re\n\nclass C1(object):\n\n    def diffWaysToCompute(self, a1):\n        v1 = [[None for v2 in range(len(a1) + 1)] for v2 in range(len(a1) + 1)]\n        v3 = {'+': operator.add, '-': operator.sub, '*': operator.mul}\n\n        def diffWaysToComputeRecu(a1, a2):\n            if v1[a1][a2]:\n                return v1[a1][a2]\n            v1 = []\n            for v2 in range(a1, a2):\n                if a1[v2] in v3:\n                    for v3 in diffWaysToComputeRecu(a1, v2):\n                        for v4 in diffWaysToComputeRecu(v2 + 1, a2):\n                            v1.append(v3[a1[v2]](v3, v4))\n            if not v1:\n                v1 = [int(a1[a1:a2])]\n            v1[a1][a2] = v1\n            return v1[a1][a2]\n        return diffWaysToComputeRecu(0, len(a1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import operator\nimport re\n\nclass C1(object):\n\n    def diffWaysToCompute(self, a1):\n        v1 = [[None for v2 in range(len(a1) + 1)] for v2 in range(len(a1) + 1)]\n        v3 = {'+': operator.add, '-': operator.sub, '*': operator.mul}\n\n        def diffWaysToComputeRecu(a1, a2):\n            if v1[a1][a2]:\n                return v1[a1][a2]\n            v1 = []\n            for v2 in range(a1, a2):\n                if a1[v2] in v3:\n                    for v3 in diffWaysToComputeRecu(a1, v2):\n                        for v4 in diffWaysToComputeRecu(v2 + 1, a2):\n                            v1.append(v3[a1[v2]](v3, v4))\n            if not v1:\n                v1 = [int(a1[a1:a2])]\n            v1[a1][a2] = v1\n            return v1[a1][a2]\n        return diffWaysToComputeRecu(0, len(a1))\n"}
{"id": "human_code\\p03504__s226486800.py", "text": "import sys\nfrom collections import *\nimport heapq\nimport math\nimport bisect\nimport copy\nfrom itertools import permutations, accumulate, combinations, product\n\ndef f1():\n    return sys.stdin.readline()[:-1]\n\ndef f2(a1):\n    return [0] + list(accumulate(a1))\nv1 = pow(10, 9) + 7\nv2 = [chr(ord('a') + i) for v3 in range(26)]\nv4 = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nv5, v6 = map(int, f1().split())\nv7 = [list(map(int, f1().split())) for v3 in range(v5)]\nv7.sort()\nv8 = [0] * v6\nfor v3 in range(v5):\n    v9, v10, v11 = v7[v3]\n    for v12 in range(v6):\n        if v8[v12] == 0:\n            v8[v12] = v7[v3]\n            break\n        elif v8[v12][2] == v11:\n            v8[v12] = v7[v3]\n            break\n        elif v8[v12][1] < v9:\n            v8[v12] = v7[v3]\n            break\nv13 = 0\nfor v3 in range(v6):\n    if v8[v3] != 0:\n        v13 += 1\nprint(v13)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nfrom collections import *\nimport heapq\nimport math\nimport bisect\nimport copy\nfrom itertools import permutations, accumulate, combinations, product\n\ndef f1():\n    return sys.stdin.readline()[:-1]\n\ndef f2(a1):\n    return [0] + list(accumulate(a1))\nv1 = pow(10, 9) + 7\nv2 = [chr(ord('a') + i) for v3 in range(26)]\nv4 = [[1, 0], [0, 1], [-1, 0], [0, -1]]\nv5, v6 = map(int, f1().split())\nv7 = [list(map(int, f1().split())) for v3 in range(v5)]\nv7.sort()\nv8 = [0] * v6\nfor v3 in range(v5):\n    v9, v10, v11 = v7[v3]\n    for v12 in range(v6):\n        if v8[v12] == 0:\n            v8[v12] = v7[v3]\n            break\n        elif v8[v12][2] == v11:\n            v8[v12] = v7[v3]\n            break\n        elif v8[v12][1] < v9:\n            v8[v12] = v7[v3]\n            break\nv13 = 0\nfor v3 in range(v6):\n    if v8[v3] != 0:\n        v13 += 1\nprint(v13)\n"}
{"id": "llm_code\\p03700__s360766883.py", "text": "import numpy as np\nimport math\n\ndef f1(a1, a2, a3, a4, a5):\n    if a1 == a2:\n        return a1\n    v1 = (a2 + a1) // 2\n    v2 = a5 - v1 * a4\n    if len(v2) == 0:\n        return f1(a1, v1, a3, a4, a5)\n    v2 = np.maximum(v2, 0)\n    v2 = np.ceil(v2 / (a3 - a4))\n    v3 = np.sum(v2)\n    if v3 <= v1:\n        return f1(a1, v1, a3, a4, a5)\n    else:\n        return f1(v1 + 1, a2, a3, a4, a5)\nv1, v2, v3 = list(map(int, input().split()))\nv4 = []\nfor v5 in range(v1):\n    v6 = int(input())\n    v4.append(v6)\nv4 = sorted(v4, reverse=True)\nv4 = np.array(v4)\nv7 = v4[0] // v3 + 1\nv8 = v4[-1] // v2\nv9 = f1(v8, v7, v2, v3, v4)\nprint(v9)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import numpy as np\nimport math\n\ndef f1(a1, a2, a3, a4, a5):\n    if a1 == a2:\n        return a1\n    v1 = (a2 + a1) // 2\n    v2 = a5 - v1 * a4\n    if len(v2) == 0:\n        return f1(a1, v1, a3, a4, a5)\n    v2 = np.maximum(v2, 0)\n    v2 = np.ceil(v2 / (a3 - a4))\n    v3 = np.sum(v2)\n    if v3 <= v1:\n        return f1(a1, v1, a3, a4, a5)\n    else:\n        return f1(v1 + 1, a2, a3, a4, a5)\nv1, v2, v3 = list(map(int, input().split()))\nv4 = []\nfor v5 in range(v1):\n    v6 = int(input())\n    v4.append(v6)\nv4 = sorted(v4, reverse=True)\nv4 = np.array(v4)\nv7 = v4[0] // v3 + 1\nv8 = v4[-1] // v2\nv9 = f1(v8, v7, v2, v3, v4)\nprint(v9)\n"}
{"id": "human_code\\p03090__s547900248.py", "text": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nv1 = float('inf')\nv2 = 10 ** 9 + 7\n\ndef f1():\n    v1 = int(input())\n    v2 = []\n    v3 = v1\n    if v1 % 2 != 0:\n        v3 -= 1\n    for v4 in range(1, v1 + 1):\n        for v5 in range(v4 + 1, v1 + 1):\n            if v5 == v3:\n                continue\n            v2.append([v4, v5])\n        v3 -= 1\n    print(len(v2))\n    for v4 in v2:\n        print(*v4)\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nv1 = float('inf')\nv2 = 10 ** 9 + 7\n\ndef f1():\n    v1 = int(input())\n    v2 = []\n    v3 = v1\n    if v1 % 2 != 0:\n        v3 -= 1\n    for v4 in range(1, v1 + 1):\n        for v5 in range(v4 + 1, v1 + 1):\n            if v5 == v3:\n                continue\n            v2.append([v4, v5])\n        v3 -= 1\n    print(len(v2))\n    for v4 in v2:\n        print(*v4)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\maximum-number-of-occurrences-of-a-substring__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def maxFreq(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (10 ** 9 + 7, 113)\n        v3, v4 = (pow(v2, a3 - 1, v1), 0)\n        v5 = 0\n        v6, v7 = (collections.defaultdict(int), collections.defaultdict(int))\n        for v8 in range(len(a1)):\n            v7[a1[v8]] += 1\n            if v8 - v5 + 1 > a3:\n                v7[a1[v5]] -= 1\n                v4 = (v4 - ord(a1[v5]) * v3) % v1\n                if v7[a1[v5]] == 0:\n                    v7.pop(a1[v5])\n                v5 += 1\n            v4 = (v4 * v2 + ord(a1[v8])) % v1\n            if v8 - v5 + 1 == a3 and len(v7) <= a2:\n                v6[v4] += 1\n        return max(list(v6.values()) or [0])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def maxFreq(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (10 ** 9 + 7, 113)\n        v3, v4 = (pow(v2, a3 - 1, v1), 0)\n        v5 = 0\n        v6, v7 = (collections.defaultdict(int), collections.defaultdict(int))\n        for v8 in range(len(a1)):\n            v7[a1[v8]] += 1\n            if v8 - v5 + 1 > a3:\n                v7[a1[v5]] -= 1\n                v4 = (v4 - ord(a1[v5]) * v3) % v1\n                if v7[a1[v5]] == 0:\n                    v7.pop(a1[v5])\n                v5 += 1\n            v4 = (v4 * v2 + ord(a1[v8])) % v1\n            if v8 - v5 + 1 == a3 and len(v7) <= a2:\n                v6[v4] += 1\n        return max(list(v6.values()) or [0])\n"}
{"id": "llm_code\\find-all-possible-stable-binary-arrays-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def numberOfStableArrays(self, a1, a2, a3):\n        v1 = 10 ** 9 + 7\n        v2 = [[[0] * 2 for v3 in range(a2 + 1)] for v3 in range(a1 + 1)]\n        v4 = [[[[0] * (a3 + 1) for v3 in range(2)] for v3 in range(a2 + 1)] for v3 in range(a1 + 1)]\n        v2[0][0][0] = 1\n        v2[0][0][1] = 1\n        for v5 in range(a1 + 1):\n            for v6 in range(a2 + 1):\n                if v5 == 0 and v6 == 0:\n                    continue\n                if v5 > 0:\n                    v4[v5][v6][0][1] = v2[v5 - 1][v6][1]\n                    for v7 in range(2, a3 + 1):\n                        v4[v5][v6][0][v7] = v4[v5 - 1][v6][0][v7 - 1]\n                if v6 > 0:\n                    v4[v5][v6][1][1] = v2[v5][v6 - 1][0]\n                    for v7 in range(2, a3 + 1):\n                        v4[v5][v6][1][v7] = v4[v5][v6 - 1][1][v7 - 1]\n                v2[v5][v6][0] = sum(v4[v5][v6][0][1:]) % v1\n                v2[v5][v6][1] = sum(v4[v5][v6][1][1:]) % v1\n        return (v2[a1][a2][0] + v2[a1][a2][1]) % v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numberOfStableArrays(self, a1, a2, a3):\n        v1 = 10 ** 9 + 7\n        v2 = [[[0] * 2 for v3 in range(a2 + 1)] for v3 in range(a1 + 1)]\n        v4 = [[[[0] * (a3 + 1) for v3 in range(2)] for v3 in range(a2 + 1)] for v3 in range(a1 + 1)]\n        v2[0][0][0] = 1\n        v2[0][0][1] = 1\n        for v5 in range(a1 + 1):\n            for v6 in range(a2 + 1):\n                if v5 == 0 and v6 == 0:\n                    continue\n                if v5 > 0:\n                    v4[v5][v6][0][1] = v2[v5 - 1][v6][1]\n                    for v7 in range(2, a3 + 1):\n                        v4[v5][v6][0][v7] = v4[v5 - 1][v6][0][v7 - 1]\n                if v6 > 0:\n                    v4[v5][v6][1][1] = v2[v5][v6 - 1][0]\n                    for v7 in range(2, a3 + 1):\n                        v4[v5][v6][1][v7] = v4[v5][v6 - 1][1][v7 - 1]\n                v2[v5][v6][0] = sum(v4[v5][v6][0][1:]) % v1\n                v2[v5][v6][1] = sum(v4[v5][v6][1][1:]) % v1\n        return (v2[a1][a2][0] + v2[a1][a2][1]) % v1\n"}
{"id": "human_code\\check-if-digits-are-equal-in-string-after-operations-i__part2.py", "text": "v1 = [[-1] * (5 + 1) for v2 in range(5 + 1)]\n\nclass C1(object):\n\n    def hasSameDigits(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nCr(a1, a2):\n            if a1 - a2 < a2:\n                a2 = a1 - a2\n            if v1[a1][a2] == -1:\n                v2 = 1\n                for v3 in range(1, a2 + 1):\n                    v2 *= a1 - v3 + 1\n                    v2 //= v3\n                v1[a1][a2] = v2\n            return v1[a1][a2]\n\n        def nCr_mod(a1, a2, a3):\n            v1 = 1\n            while a1 > 0 or a2 > 0:\n                a1, v3 = divmod(a1, a3)\n                a2, v5 = divmod(a2, a3)\n                if v3 < v5:\n                    return 0\n                v1 = v1 * nCr(v3, v5) % a3\n            return v1\n\n        def nC10(a1, a2):\n            return lookup[nCr_mod(a1, a2, 2)][nCr_mod(a1, a2, 5)]\n        v1 = [[0] * 5 for v2 in range(2)]\n        for v2 in range(10):\n            v1[v2 % 2][v2 % 5] = v2\n        v3 = 0\n        for v2 in range(len(a1) - 1):\n            v3 = (v3 + nC10(len(a1) - 2, v2) * (ord(a1[v2]) - ord(a1[v2 + 1]))) % 10\n        return v3 == 0\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "v1 = [[-1] * (5 + 1) for v2 in range(5 + 1)]\n\nclass C1(object):\n\n    def hasSameDigits(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nCr(a1, a2):\n            if a1 - a2 < a2:\n                a2 = a1 - a2\n            if v1[a1][a2] == -1:\n                v2 = 1\n                for v3 in range(1, a2 + 1):\n                    v2 *= a1 - v3 + 1\n                    v2 //= v3\n                v1[a1][a2] = v2\n            return v1[a1][a2]\n\n        def nCr_mod(a1, a2, a3):\n            v1 = 1\n            while a1 > 0 or a2 > 0:\n                a1, v3 = divmod(a1, a3)\n                a2, v5 = divmod(a2, a3)\n                if v3 < v5:\n                    return 0\n                v1 = v1 * nCr(v3, v5) % a3\n            return v1\n\n        def nC10(a1, a2):\n            return lookup[nCr_mod(a1, a2, 2)][nCr_mod(a1, a2, 5)]\n        v1 = [[0] * 5 for v2 in range(2)]\n        for v2 in range(10):\n            v1[v2 % 2][v2 % 5] = v2\n        v3 = 0\n        for v2 in range(len(a1) - 1):\n            v3 = (v3 + nC10(len(a1) - 2, v2) * (ord(a1[v2]) - ord(a1[v2 + 1]))) % 10\n        return v3 == 0\n"}
{"id": "llm_code\\p02549__s458143661.py", "text": "v1, v2 = map(int, input().split())\nv3 = [0 for v4 in range(v1)]\nv5 = [-1 for v4 in range(v1)]\nmin = v1\nfor v4 in range(v2):\n    v6, v7 = map(int, input().split())\n    if v6 < min:\n        min = v6\n    for v8 in range(v6 - 1, v7):\n        v3[v8] = 1\nfor v8 in range(min - 1):\n    v5[v8] = 0\nv5[min - 1] = 1\n\ndef f1(a1, a2, a3):\n    v1 = 0\n    for v2 in range(0, a1 - 1):\n        if a2[v2] == 1:\n            if a3[a1 - v2 - 2] == -1:\n                a3 = f1(a1 - v2 - 1, a2, a3)\n            v1 += a3[a1 - v2 - 2]\n    a3[a1 - 1] = v1\n    return a3\nv5 = f1(v1, v3, v5)\nv9 = v5[-1]\nprint(v9 % 998244353)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = [0 for v4 in range(v1)]\nv5 = [-1 for v4 in range(v1)]\nmin = v1\nfor v4 in range(v2):\n    v6, v7 = map(int, input().split())\n    if v6 < min:\n        min = v6\n    for v8 in range(v6 - 1, v7):\n        v3[v8] = 1\nfor v8 in range(min - 1):\n    v5[v8] = 0\nv5[min - 1] = 1\n\ndef f1(a1, a2, a3):\n    v1 = 0\n    for v2 in range(0, a1 - 1):\n        if a2[v2] == 1:\n            if a3[a1 - v2 - 2] == -1:\n                a3 = f1(a1 - v2 - 1, a2, a3)\n            v1 += a3[a1 - v2 - 2]\n    a3[a1 - 1] = v1\n    return a3\nv5 = f1(v1, v3, v5)\nv9 = v5[-1]\nprint(v9 % 998244353)\n"}
{"id": "llm_code\\p03600__s710164134.py", "text": "import heapq\nv1 = int(input())\nv2 = [list(map(int, input().split())) for v3 in range(v1)]\nv4 = [[] for v3 in range(v1)]\nv5 = []\nv6 = 0\nfor v7 in range(v1):\n    for v8 in range(v7 + 1, v1):\n        v5.append((v2[v7][v8], (v7, v8)))\nv5.sort()\nv9 = [[-1] * v1 for v3 in range(v1)]\n\ndef f1(a1, a2):\n    global dd\n    v1 = []\n    v2 = v9[a2]\n    v2[a2] = 0\n    heapq.heappush(v1, (0, a2))\n    while v1:\n        v3, v4 = heapq.heappop(v1)\n        for v5, v6 in a1[v4]:\n            if v2[v5] == -1 or v2[v5] > v3 + v6:\n                v2[v5] = v3 + v6\n                heapq.heappush(v1, (v3 + v6, v5))\n    return v2\nfor v10, v11 in v5:\n    v12 = f1(v4, v11[0])\n    if v12[v11[1]] == -1:\n        v4[v11[0]].append((v11[1], v10))\n        v4[v11[1]].append((v11[0], v10))\n        v6 += v10\n    elif v12[v11[1]] < v10:\n        print(-1)\n        exit()\n    elif v12[v11[1]] > v10:\n        v4[v11[0]].append((v11[1], v10))\n        v4[v11[1]].append((v11[0], v10))\n        v6 += v10\nprint(v6)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import heapq\nv1 = int(input())\nv2 = [list(map(int, input().split())) for v3 in range(v1)]\nv4 = [[] for v3 in range(v1)]\nv5 = []\nv6 = 0\nfor v7 in range(v1):\n    for v8 in range(v7 + 1, v1):\n        v5.append((v2[v7][v8], (v7, v8)))\nv5.sort()\nv9 = [[-1] * v1 for v3 in range(v1)]\n\ndef f1(a1, a2):\n    global dd\n    v1 = []\n    v2 = v9[a2]\n    v2[a2] = 0\n    heapq.heappush(v1, (0, a2))\n    while v1:\n        v3, v4 = heapq.heappop(v1)\n        for v5, v6 in a1[v4]:\n            if v2[v5] == -1 or v2[v5] > v3 + v6:\n                v2[v5] = v3 + v6\n                heapq.heappush(v1, (v3 + v6, v5))\n    return v2\nfor v10, v11 in v5:\n    v12 = f1(v4, v11[0])\n    if v12[v11[1]] == -1:\n        v4[v11[0]].append((v11[1], v10))\n        v4[v11[1]].append((v11[0], v10))\n        v6 += v10\n    elif v12[v11[1]] < v10:\n        print(-1)\n        exit()\n    elif v12[v11[1]] > v10:\n        v4[v11[0]].append((v11[1], v10))\n        v4[v11[1]].append((v11[0], v10))\n        v6 += v10\nprint(v6)\n"}
{"id": "llm_code\\prison-cells-after-n-days__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def prisonAfterNDays(self, a1, a2):\n\n        def nxt(a1):\n            return tuple([0] + [int(a1[i - 1] == a1[i + 1]) for v1 in range(1, 7)] + [0])\n        if a2 == 0:\n            return a1[:]\n        v1 = {}\n        v2 = tuple(a1)\n        v3 = 0\n        while v3 < a2:\n            if v2 in v1:\n                break\n            v1[v2] = v3\n            v2 = nxt(v2)\n            v3 += 1\n        else:\n            return list(v2)\n        v4 = v1[v2]\n        v5 = v3 - v4\n        v6 = v4 + (a2 - v4) % v5\n        v2 = tuple(a1)\n        for v7 in range(v6):\n            v2 = nxt(v2)\n        return list(v2)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def prisonAfterNDays(self, a1, a2):\n\n        def nxt(a1):\n            return tuple([0] + [int(a1[i - 1] == a1[i + 1]) for v1 in range(1, 7)] + [0])\n        if a2 == 0:\n            return a1[:]\n        v1 = {}\n        v2 = tuple(a1)\n        v3 = 0\n        while v3 < a2:\n            if v2 in v1:\n                break\n            v1[v2] = v3\n            v2 = nxt(v2)\n            v3 += 1\n        else:\n            return list(v2)\n        v4 = v1[v2]\n        v5 = v3 - v4\n        v6 = v4 + (a2 - v4) % v5\n        v2 = tuple(a1)\n        for v7 in range(v6):\n            v2 = nxt(v2)\n        return list(v2)\n"}
{"id": "human_code\\p03569__s747030400.py", "text": "def f1():\n    v1 = input()\n    v2 = 0\n    v3 = len(v1) - 1\n    v4 = 0\n    while v2 < v3:\n        if v1[v2] == v1[v3]:\n            v2 += 1\n            v3 -= 1\n            continue\n        if v1[v2] == 'x':\n            v2 += 1\n            v4 += 1\n            continue\n        if v1[v3] == 'x':\n            v3 -= 1\n            v4 += 1\n            continue\n        print(-1)\n        return\n    print(v4)\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1():\n    v1 = input()\n    v2 = 0\n    v3 = len(v1) - 1\n    v4 = 0\n    while v2 < v3:\n        if v1[v2] == v1[v3]:\n            v2 += 1\n            v3 -= 1\n            continue\n        if v1[v2] == 'x':\n            v2 += 1\n            v4 += 1\n            continue\n        if v1[v3] == 'x':\n            v3 -= 1\n            v4 += 1\n            continue\n        print(-1)\n        return\n    print(v4)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "llm_code\\count-stepping-numbers-in-range__grok-4.1-fast__v1.py", "text": "from functools import lru_cache\n\nclass C1:\n\n    def countSteppingNumbers(self, a1, a2):\n        v1 = 10 ** 9 + 7\n\n        def digit_dp(a1):\n            v1 = str(a1)\n            v2 = len(v1)\n\n            @lru_cache(None)\n            def dfs(a1, a2, a3, a4):\n                if a1 == v2:\n                    return 1 if not a4 else 0\n                v1 = 0\n                v2 = int(v1[a1]) if a2 else 9\n                for v3 in range(v2 + 1):\n                    v4 = 1 if a2 and v3 == v2 else 0\n                    if a4 and v3 == 0:\n                        v1 = (v1 + dfs(a1 + 1, v4, -1, 1)) % v1\n                    else:\n                        v5 = v3\n                        if not a4 and abs(v3 - a3) != 1:\n                            continue\n                        v1 = (v1 + dfs(a1 + 1, v4, v5, 0)) % v1\n                return v1\n            return dfs(0, 1, -1, 1)\n        return (digit_dp(a2) - digit_dp(a1 - 1) + v1) % v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from functools import lru_cache\n\nclass C1:\n\n    def countSteppingNumbers(self, a1, a2):\n        v1 = 10 ** 9 + 7\n\n        def digit_dp(a1):\n            v1 = str(a1)\n            v2 = len(v1)\n\n            @lru_cache(None)\n            def dfs(a1, a2, a3, a4):\n                if a1 == v2:\n                    return 1 if not a4 else 0\n                v1 = 0\n                v2 = int(v1[a1]) if a2 else 9\n                for v3 in range(v2 + 1):\n                    v4 = 1 if a2 and v3 == v2 else 0\n                    if a4 and v3 == 0:\n                        v1 = (v1 + dfs(a1 + 1, v4, -1, 1)) % v1\n                    else:\n                        v5 = v3\n                        if not a4 and abs(v3 - a3) != 1:\n                            continue\n                        v1 = (v1 + dfs(a1 + 1, v4, v5, 0)) % v1\n                return v1\n            return dfs(0, 1, -1, 1)\n        return (digit_dp(a2) - digit_dp(a1 - 1) + v1) % v1\n"}
{"id": "llm_code\\p02844__s873482584.py", "text": "v1 = 0\n\ndef f1(a1, a2, a3):\n    v1 = 0\n    for v2 in range(N):\n        if S[v2] == a1:\n            v1 += 1\n            for v3 in range(v2 + 1, N):\n                if S[v3] == a2:\n                    v1 += 1\n                    for v4 in range(v3 + 1, N):\n                        if S[v4] == a3:\n                            v1 += 1\n                            break\n    return v1 == 3\nif __name__ == '__main__':\n    v2 = int(input())\n    v3 = list(map(int, list(input())))\n    for v4 in range(1000):\n        v5 = v4 // 100\n        v6 = v4 // 10 % 10\n        v7 = v4 % 10\n        if f1(v5, v6, v7):\n            v1 += 1\n    print(v1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = 0\n\ndef f1(a1, a2, a3):\n    v1 = 0\n    for v2 in range(N):\n        if S[v2] == a1:\n            v1 += 1\n            for v3 in range(v2 + 1, N):\n                if S[v3] == a2:\n                    v1 += 1\n                    for v4 in range(v3 + 1, N):\n                        if S[v4] == a3:\n                            v1 += 1\n                            break\n    return v1 == 3\nif __name__ == '__main__':\n    v2 = int(input())\n    v3 = list(map(int, list(input())))\n    for v4 in range(1000):\n        v5 = v4 // 100\n        v6 = v4 // 10 % 10\n        v7 = v4 % 10\n        if f1(v5, v6, v7):\n            v1 += 1\n    print(v1)\n"}
{"id": "llm_code\\largest-number-after-mutating-substring__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maximumNumber(self, a1, a2):\n        v1 = len(a1)\n        v2 = -1\n        for v3 in range(v1):\n            v4 = int(a1[v3])\n            if a2[v4] > v4:\n                v2 = v3\n                break\n        if v2 == -1:\n            return a1\n        v5 = v1\n        for v3 in range(v2, v1):\n            v4 = int(a1[v3])\n            if a2[v4] < v4:\n                v5 = v3\n                break\n        v6 = []\n        for v3 in range(v1):\n            v4 = int(a1[v3])\n            if v2 <= v3 < v5:\n                v6.append(str(a2[v4]))\n            else:\n                v6.append(a1[v3])\n        return ''.join(v6)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumNumber(self, a1, a2):\n        v1 = len(a1)\n        v2 = -1\n        for v3 in range(v1):\n            v4 = int(a1[v3])\n            if a2[v4] > v4:\n                v2 = v3\n                break\n        if v2 == -1:\n            return a1\n        v5 = v1\n        for v3 in range(v2, v1):\n            v4 = int(a1[v3])\n            if a2[v4] < v4:\n                v5 = v3\n                break\n        v6 = []\n        for v3 in range(v1):\n            v4 = int(a1[v3])\n            if v2 <= v3 < v5:\n                v6.append(str(a2[v4]))\n            else:\n                v6.append(a1[v3])\n        return ''.join(v6)\n"}
{"id": "llm_code\\p02574__s788441041.py", "text": "def f1(a1):\n    v1 = [-1] * (a1 + 1)\n    for v2 in range(2, a1 + 1):\n        if v1[v2] != -1:\n            continue\n        v3 = v2\n        while v3 <= a1:\n            v1[v3] = v2\n            v3 += v2\n\n    def fuctorization(a1):\n        if a1 == 1:\n            return 1\n        elif a1 < 0:\n            a1 = abs(a1)\n        elif a1 > a1:\n            return -1\n        v2 = {}\n        while a1 != 1:\n            v3 = v1[a1]\n            v2.setdefault(v3, 0)\n            v2[v3] += 1\n            a1 //= v3\n        return v2\n    return fuctorization\nv1 = int(input())\nv2 = f1(10 ** 6 + 10)\nv3 = list(map(int, input().split()))\nv4 = {}\nfor v5 in v3:\n    if v5 == 1:\n        continue\n    v6 = v2(v5)\n    for v7 in v6:\n        v4.setdefault(v7, 0)\n        v4[v7] += 1\nv8 = max(v4.values())\nv9 = min(v4.values())\nif v8 == 1:\n    print('pairwise coprime')\nelif v9 == v1:\n    print('not coprime')\nelse:\n    print('setwise coprime')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1):\n    v1 = [-1] * (a1 + 1)\n    for v2 in range(2, a1 + 1):\n        if v1[v2] != -1:\n            continue\n        v3 = v2\n        while v3 <= a1:\n            v1[v3] = v2\n            v3 += v2\n\n    def fuctorization(a1):\n        if a1 == 1:\n            return 1\n        elif a1 < 0:\n            a1 = abs(a1)\n        elif a1 > a1:\n            return -1\n        v2 = {}\n        while a1 != 1:\n            v3 = v1[a1]\n            v2.setdefault(v3, 0)\n            v2[v3] += 1\n            a1 //= v3\n        return v2\n    return fuctorization\nv1 = int(input())\nv2 = f1(10 ** 6 + 10)\nv3 = list(map(int, input().split()))\nv4 = {}\nfor v5 in v3:\n    if v5 == 1:\n        continue\n    v6 = v2(v5)\n    for v7 in v6:\n        v4.setdefault(v7, 0)\n        v4[v7] += 1\nv8 = max(v4.values())\nv9 = min(v4.values())\nif v8 == 1:\n    print('pairwise coprime')\nelif v9 == v1:\n    print('not coprime')\nelse:\n    print('setwise coprime')\n"}
{"id": "human_code\\minimum-height-trees.py", "text": "import collections\n\nclass C1(object):\n\n    def findMinHeightTrees(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if a1 == 1:\n            return [0]\n        v1 = collections.defaultdict(set)\n        for v2, v3 in a2:\n            v1[v2].add(v3)\n            v1[v3].add(v2)\n        v4, v5 = ([], set())\n        for v6 in range(a1):\n            if len(v1[v6]) == 1:\n                v4.append(v6)\n            v5.add(v6)\n        while len(v5) > 2:\n            v7 = []\n            for v2 in v4:\n                v5.remove(v2)\n                for v3 in v1[v2]:\n                    if v3 in v5:\n                        v1[v3].remove(v2)\n                        if len(v1[v3]) == 1:\n                            v7.append(v3)\n            v4 = v7\n        return list(v5)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def findMinHeightTrees(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if a1 == 1:\n            return [0]\n        v1 = collections.defaultdict(set)\n        for v2, v3 in a2:\n            v1[v2].add(v3)\n            v1[v3].add(v2)\n        v4, v5 = ([], set())\n        for v6 in range(a1):\n            if len(v1[v6]) == 1:\n                v4.append(v6)\n            v5.add(v6)\n        while len(v5) > 2:\n            v7 = []\n            for v2 in v4:\n                v5.remove(v2)\n                for v3 in v1[v2]:\n                    if v3 in v5:\n                        v1[v3].remove(v2)\n                        if len(v1[v3]) == 1:\n                            v7.append(v3)\n            v4 = v7\n        return list(v5)\n"}
{"id": "human_code\\range-sum-query-2d-mutable.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        if not a1:\n            return\n        self.__matrix = a1\n        self.__bit = [[0] * (len(self.__matrix[0]) + 1) for v1 in range(len(self.__matrix) + 1)]\n        for v2 in range(1, len(self.__bit)):\n            for v3 in range(1, len(self.__bit[0])):\n                self.__bit[v2][v3] = a1[v2 - 1][v3 - 1] + self.__bit[v2 - 1][v3] + self.__bit[v2][v3 - 1] - self.__bit[v2 - 1][v3 - 1]\n        for v2 in reversed(range(1, len(self.__bit))):\n            for v3 in reversed(range(1, len(self.__bit[0]))):\n                v4, v5 = (v2 - (v2 & -v2), v3 - (v3 & -v3))\n                self.__bit[v2][v3] = self.__bit[v2][v3] - self.__bit[v2][v5] - self.__bit[v4][v3] + self.__bit[v4][v5]\n\n    def update(self, a1, a2, a3):\n        \"\"\"\n        update the element at matrix[row,col] to val.\n        \"\"\"\n        if a3 - self.__matrix[a1][a2]:\n            self.__add(a1, a2, a3 - self.__matrix[a1][a2])\n            self.__matrix[a1][a2] = a3\n\n    def sumRegion(self, a1, a2, a3, a4):\n        \"\"\"\n        sum of elements matrix[(row1,col1)..(row2,col2)], inclusive.\n        \"\"\"\n        return self.__sum(a3, a4) - self.__sum(a3, a2 - 1) - self.__sum(a1 - 1, a4) + self.__sum(a1 - 1, a2 - 1)\n\n    def __sum(self, a1, a2):\n        a1 += 1\n        a2 += 1\n        v3 = 0\n        v4 = a1\n        while v4 > 0:\n            v5 = a2\n            while v5 > 0:\n                v3 += self.__bit[v4][v5]\n                v5 -= v5 & -v5\n            v4 -= v4 & -v4\n        return v3\n\n    def __add(self, a1, a2, a3):\n        a1 += 1\n        a2 += 1\n        v3 = a1\n        while v3 <= len(self.__matrix):\n            v4 = a2\n            while v4 <= len(self.__matrix[0]):\n                self.__bit[v3][v4] += a3\n                v4 += v4 & -v4\n            v3 += v3 & -v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        if not a1:\n            return\n        self.__matrix = a1\n        self.__bit = [[0] * (len(self.__matrix[0]) + 1) for v1 in range(len(self.__matrix) + 1)]\n        for v2 in range(1, len(self.__bit)):\n            for v3 in range(1, len(self.__bit[0])):\n                self.__bit[v2][v3] = a1[v2 - 1][v3 - 1] + self.__bit[v2 - 1][v3] + self.__bit[v2][v3 - 1] - self.__bit[v2 - 1][v3 - 1]\n        for v2 in reversed(range(1, len(self.__bit))):\n            for v3 in reversed(range(1, len(self.__bit[0]))):\n                v4, v5 = (v2 - (v2 & -v2), v3 - (v3 & -v3))\n                self.__bit[v2][v3] = self.__bit[v2][v3] - self.__bit[v2][v5] - self.__bit[v4][v3] + self.__bit[v4][v5]\n\n    def update(self, a1, a2, a3):\n        \"\"\"\n        update the element at matrix[row,col] to val.\n        \"\"\"\n        if a3 - self.__matrix[a1][a2]:\n            self.__add(a1, a2, a3 - self.__matrix[a1][a2])\n            self.__matrix[a1][a2] = a3\n\n    def sumRegion(self, a1, a2, a3, a4):\n        \"\"\"\n        sum of elements matrix[(row1,col1)..(row2,col2)], inclusive.\n        \"\"\"\n        return self.__sum(a3, a4) - self.__sum(a3, a2 - 1) - self.__sum(a1 - 1, a4) + self.__sum(a1 - 1, a2 - 1)\n\n    def __sum(self, a1, a2):\n        a1 += 1\n        a2 += 1\n        v3 = 0\n        v4 = a1\n        while v4 > 0:\n            v5 = a2\n            while v5 > 0:\n                v3 += self.__bit[v4][v5]\n                v5 -= v5 & -v5\n            v4 -= v4 & -v4\n        return v3\n\n    def __add(self, a1, a2, a3):\n        a1 += 1\n        a2 += 1\n        v3 = a1\n        while v3 <= len(self.__matrix):\n            v4 = a2\n            while v4 <= len(self.__matrix[0]):\n                self.__bit[v3][v4] += a3\n                v4 += v4 & -v4\n            v3 += v3 & -v3\n"}
{"id": "llm_code\\p03600__s600589484.py", "text": "import heapq\nimport sys\nv1 = int(input())\nv2 = []\nfor v3 in range(v1):\n    v4 = list(map(int, input().split()))\n    v2.append(v4)\nv5 = {}\nfor v3 in range(v1):\n    for v6 in range(v3, v1):\n        if v3 != v6:\n            v5[v3, v6] = v2[v3][v6]\nv5 = sorted(v5.items(), key=lambda x: x[1], reverse=True)\n\ndef f1(a1, a2, a3):\n    v1 = [float('inf')] * a1\n    v1[a2] = 0\n    v2 = []\n    v3 = [0] * a1\n    heapq.heappush(v2, (0, a2))\n    while v2:\n        v4, v5 = heapq.heappop(v2)\n        if v3[v5] == 0:\n            v3[v5] = 1\n            for v6 in range(a1):\n                if a3[v5][v6] != -1:\n                    if v1[v6] > v4 + a3[v5][v6]:\n                        v1[v6] = v4 + a3[v5][v6]\n                        heapq.heappush(v2, (v4 + a3[v5][v6], v6))\n    return v1\nv7 = [[-1] * v1 for v8 in range(v1)]\nv9 = 0\nfor v3 in range(v1):\n    v10, v11 = v5[v3]\n    v12, v13 = v10\n    v7[v12][v13] = v11\n    v7[v13][v12] = v11\n    v9 += v11\nfor v3 in range(v1):\n    v14 = f1(v1, v3, v7)\n    for v6 in range(v1):\n        if v14[v6] != v2[v3][v6]:\n            print(-1)\n            sys.exit()\nfor v3 in range(v1):\n    v10, v11 = v5[v3]\n    v12, v13 = v10\n    v7[v12][v13] = -1\n    v7[v13][v12] = -1\n    v15 = f1(v1, v12, v7)\n    v16 = f1(v1, v13, v7)\n    v17 = 0\n    for v6 in range(v1):\n        if v15[v6] != v2[v12][v6] or v16[v6] != v2[v13][v6]:\n            v7[v12][v13] = v11\n            v7[v13][v12] = v11\n            v17 = 1\n            break\n    if v17 == 0:\n        v9 -= v11\nprint(v9)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import heapq\nimport sys\nv1 = int(input())\nv2 = []\nfor v3 in range(v1):\n    v4 = list(map(int, input().split()))\n    v2.append(v4)\nv5 = {}\nfor v3 in range(v1):\n    for v6 in range(v3, v1):\n        if v3 != v6:\n            v5[v3, v6] = v2[v3][v6]\nv5 = sorted(v5.items(), key=lambda x: x[1], reverse=True)\n\ndef f1(a1, a2, a3):\n    v1 = [float('inf')] * a1\n    v1[a2] = 0\n    v2 = []\n    v3 = [0] * a1\n    heapq.heappush(v2, (0, a2))\n    while v2:\n        v4, v5 = heapq.heappop(v2)\n        if v3[v5] == 0:\n            v3[v5] = 1\n            for v6 in range(a1):\n                if a3[v5][v6] != -1:\n                    if v1[v6] > v4 + a3[v5][v6]:\n                        v1[v6] = v4 + a3[v5][v6]\n                        heapq.heappush(v2, (v4 + a3[v5][v6], v6))\n    return v1\nv7 = [[-1] * v1 for v8 in range(v1)]\nv9 = 0\nfor v3 in range(v1):\n    v10, v11 = v5[v3]\n    v12, v13 = v10\n    v7[v12][v13] = v11\n    v7[v13][v12] = v11\n    v9 += v11\nfor v3 in range(v1):\n    v14 = f1(v1, v3, v7)\n    for v6 in range(v1):\n        if v14[v6] != v2[v3][v6]:\n            print(-1)\n            sys.exit()\nfor v3 in range(v1):\n    v10, v11 = v5[v3]\n    v12, v13 = v10\n    v7[v12][v13] = -1\n    v7[v13][v12] = -1\n    v15 = f1(v1, v12, v7)\n    v16 = f1(v1, v13, v7)\n    v17 = 0\n    for v6 in range(v1):\n        if v15[v6] != v2[v12][v6] or v16[v6] != v2[v13][v6]:\n            v7[v12][v13] = v11\n            v7[v13][v12] = v11\n            v17 = 1\n            break\n    if v17 == 0:\n        v9 -= v11\nprint(v9)\n"}
{"id": "human_code\\sliding-puzzle__part2.py", "text": "class C1(object):\n\n    def slidingPuzzle(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def heuristic_estimate(a1, a2, a3, a4):\n            v1 = 0\n            for v2 in range(a2):\n                for v3 in range(a3):\n                    v4 = a1[a3 * v2 + v3]\n                    if v4 == 0:\n                        continue\n                    v5, v6 = a4[v4]\n                    v1 += abs(v5 - v2) + abs(v6 - v3)\n            return v1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = tuple(itertools.chain(*a1))\n        v4 = tuple(list(range(1, v1 * v2)) + [0])\n        v5 = tuple(list(range(1, v1 * v2 - 2)) + [v1 * v2 - 1, v1 * v2 - 2, 0])\n        v6 = {(v2 * i + j + 1) % (v1 * v2): (i, j) for v7 in range(v1) for v8 in range(v2)}\n        v9 = [(0, 0, v3.index(0), v3)]\n        v10 = {v3: 0}\n        while v9:\n            v11, v12, v13, a1 = heapq.heappop(v9)\n            if a1 == v4:\n                return v12\n            if a1 == v5:\n                return -1\n            if v11 > v10[a1]:\n                continue\n            v15, v16 = divmod(v13, v2)\n            for v17 in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                v7, v8 = (v15 + v17[0], v16 + v17[1])\n                if 0 <= v7 < v1 and 0 <= v8 < v2:\n                    v18 = v2 * v7 + v8\n                    v19 = list(a1)\n                    v19[v13], v19[v18] = (v19[v18], v19[v13])\n                    v20 = tuple(v19)\n                    v11 = v12 + 1 + heuristic_estimate(v20, v1, v2, v6)\n                    if v11 < v10.get(v20, float('inf')):\n                        v10[v20] = v11\n                        heapq.heappush(v9, (v11, v12 + 1, v18, v20))\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def slidingPuzzle(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def heuristic_estimate(a1, a2, a3, a4):\n            v1 = 0\n            for v2 in range(a2):\n                for v3 in range(a3):\n                    v4 = a1[a3 * v2 + v3]\n                    if v4 == 0:\n                        continue\n                    v5, v6 = a4[v4]\n                    v1 += abs(v5 - v2) + abs(v6 - v3)\n            return v1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = tuple(itertools.chain(*a1))\n        v4 = tuple(list(range(1, v1 * v2)) + [0])\n        v5 = tuple(list(range(1, v1 * v2 - 2)) + [v1 * v2 - 1, v1 * v2 - 2, 0])\n        v6 = {(v2 * i + j + 1) % (v1 * v2): (i, j) for v7 in range(v1) for v8 in range(v2)}\n        v9 = [(0, 0, v3.index(0), v3)]\n        v10 = {v3: 0}\n        while v9:\n            v11, v12, v13, a1 = heapq.heappop(v9)\n            if a1 == v4:\n                return v12\n            if a1 == v5:\n                return -1\n            if v11 > v10[a1]:\n                continue\n            v15, v16 = divmod(v13, v2)\n            for v17 in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                v7, v8 = (v15 + v17[0], v16 + v17[1])\n                if 0 <= v7 < v1 and 0 <= v8 < v2:\n                    v18 = v2 * v7 + v8\n                    v19 = list(a1)\n                    v19[v13], v19[v18] = (v19[v18], v19[v13])\n                    v20 = tuple(v19)\n                    v11 = v12 + 1 + heuristic_estimate(v20, v1, v2, v6)\n                    if v11 < v10.get(v20, float('inf')):\n                        v10[v20] = v11\n                        heapq.heappush(v9, (v11, v12 + 1, v18, v20))\n        return -1\n"}
{"id": "human_code\\p02733__s184160900.py", "text": "def f1():\n    v1, v2, v3 = map(int, input().split())\n    v4 = [input() for v5 in range(v1)]\n    v6 = 1 << 100\n    for v7 in range(1 << v1 - 1):\n        v8 = bin(v7).count('1')\n        v9 = v8 + 1\n        v10 = [0] * v9\n        v11 = 1\n        for v12 in range(v2):\n            v13 = 0\n            for v14 in range(v1):\n                v10[v13] += v4[v14][v12] == '1'\n                if v10[v13] > v3:\n                    break\n                v13 += v7 >> v14 & 1\n            else:\n                continue\n            v10 = [0] * v9\n            v8 += 1\n            if v8 > v6:\n                v11 = 0\n                break\n            v13 = 0\n            for v14 in range(v1):\n                v10[v13] += v4[v14][v12] == '1'\n                if v10[v13] > v3:\n                    break\n                v13 += v7 >> v14 & 1\n            else:\n                continue\n            v11 = 0\n            break\n        if v11:\n            v6 = min(v6, v8)\n    print(v6)\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1():\n    v1, v2, v3 = map(int, input().split())\n    v4 = [input() for v5 in range(v1)]\n    v6 = 1 << 100\n    for v7 in range(1 << v1 - 1):\n        v8 = bin(v7).count('1')\n        v9 = v8 + 1\n        v10 = [0] * v9\n        v11 = 1\n        for v12 in range(v2):\n            v13 = 0\n            for v14 in range(v1):\n                v10[v13] += v4[v14][v12] == '1'\n                if v10[v13] > v3:\n                    break\n                v13 += v7 >> v14 & 1\n            else:\n                continue\n            v10 = [0] * v9\n            v8 += 1\n            if v8 > v6:\n                v11 = 0\n                break\n            v13 = 0\n            for v14 in range(v1):\n                v10[v13] += v4[v14][v12] == '1'\n                if v10[v13] > v3:\n                    break\n                v13 += v7 >> v14 & 1\n            else:\n                continue\n            v11 = 0\n            break\n        if v11:\n            v6 = min(v6, v8)\n    print(v6)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\p03665__s679736791.py", "text": "from operator import mul\nfrom functools import reduce\n\ndef f1(a1, a2):\n    a2 = min(a1 - a2, a2)\n    if a2 == 0:\n        return 1\n    v2 = reduce(mul, range(a1, a1 - a2, -1))\n    v3 = reduce(mul, range(1, a2 + 1))\n    return v2 // v3\nv1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = sum([a % 2 == 0 for v5 in v3])\nv6 = sum([v5 % 2 != 0 for v5 in v3])\nv7 = 0\nif v2 == 0:\n    v7 += 1\nfor v8 in range(1, v1 + 1):\n    for v9 in range(0, v8 + 1):\n        v10 = v8 - v9\n        if v9 > v4 or v10 > v6:\n            continue\n        if v2 == 0 and v10 % 2 == 0:\n            v7 += f1(v4, v9) * f1(v6, v10)\n        elif v2 == 1 and v10 % 2 == 1:\n            v7 += f1(v4, v9) * f1(v6, v10)\nprint(v7)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from operator import mul\nfrom functools import reduce\n\ndef f1(a1, a2):\n    a2 = min(a1 - a2, a2)\n    if a2 == 0:\n        return 1\n    v2 = reduce(mul, range(a1, a1 - a2, -1))\n    v3 = reduce(mul, range(1, a2 + 1))\n    return v2 // v3\nv1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = sum([a % 2 == 0 for v5 in v3])\nv6 = sum([v5 % 2 != 0 for v5 in v3])\nv7 = 0\nif v2 == 0:\n    v7 += 1\nfor v8 in range(1, v1 + 1):\n    for v9 in range(0, v8 + 1):\n        v10 = v8 - v9\n        if v9 > v4 or v10 > v6:\n            continue\n        if v2 == 0 and v10 % 2 == 0:\n            v7 += f1(v4, v9) * f1(v6, v10)\n        elif v2 == 1 and v10 % 2 == 1:\n            v7 += f1(v4, v9) * f1(v6, v10)\nprint(v7)\n"}
{"id": "llm_code\\p03252__s698634359.py", "text": "import sys\ninput = sys.stdin.readline\nv1 = input().strip()\nv2 = input().strip()\nv3 = defaultdict(list)\n\ndef f1(a1):\n    for v1, v2 in a1.items():\n        if v1 != v2:\n            return False\n    else:\n        return True\nfor v4, v5 in zip(v1, v2):\n    if v4 not in v3:\n        v3[v4] = v5\n    elif v3[v4] != v5:\n        print('No')\n        exit()\nif len(v3) != len(set(v3.values())):\n    print('No')\nelse:\n    print('Yes')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nv1 = input().strip()\nv2 = input().strip()\nv3 = defaultdict(list)\n\ndef f1(a1):\n    for v1, v2 in a1.items():\n        if v1 != v2:\n            return False\n    else:\n        return True\nfor v4, v5 in zip(v1, v2):\n    if v4 not in v3:\n        v3[v4] = v5\n    elif v3[v4] != v5:\n        print('No')\n        exit()\nif len(v3) != len(set(v3.values())):\n    print('No')\nelse:\n    print('Yes')\n"}
{"id": "llm_code\\p02733__s084524724.py", "text": "import numpy as np\nv1, v2, v3 = list(map(int, input().split()))\nv4 = [list(map(int, list(input()))) for v5 in range(v1)]\nv6 = np.array(v4)\nv7 = v1 * v2\nfor v8 in range(2 ** (v1 - 1)):\n    v4 = np.copy(v6)\n    v9 = []\n    for v10 in range(v1 - 1):\n        if v8 >> v10 & 1:\n            v9.append(v10 + 1)\n    if len(v9) > v7:\n        continue\n    v11 = np.vsplit(v4, v9)\n    v11 = np.array([np.sum(row, axis=0) for v12 in v11])\n    v13 = np.hstack([np.zeros((v11.shape[0], 1), dtype=np.uint32), np.cumsum(v11, 1)])\n    v14 = len(v9)\n    v15 = 0\n    for v16 in range(v2 + 1):\n        if (v13[:, v16] - v13[:, v15] > v3).any():\n            v15 = v16\n            v14 += 1\n            if v14 > v7:\n                continue\n    v7 = min([v14, v7])\nprint(v7)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import numpy as np\nv1, v2, v3 = list(map(int, input().split()))\nv4 = [list(map(int, list(input()))) for v5 in range(v1)]\nv6 = np.array(v4)\nv7 = v1 * v2\nfor v8 in range(2 ** (v1 - 1)):\n    v4 = np.copy(v6)\n    v9 = []\n    for v10 in range(v1 - 1):\n        if v8 >> v10 & 1:\n            v9.append(v10 + 1)\n    if len(v9) > v7:\n        continue\n    v11 = np.vsplit(v4, v9)\n    v11 = np.array([np.sum(row, axis=0) for v12 in v11])\n    v13 = np.hstack([np.zeros((v11.shape[0], 1), dtype=np.uint32), np.cumsum(v11, 1)])\n    v14 = len(v9)\n    v15 = 0\n    for v16 in range(v2 + 1):\n        if (v13[:, v16] - v13[:, v15] > v3).any():\n            v15 = v16\n            v14 += 1\n            if v14 > v7:\n                continue\n    v7 = min([v14, v7])\nprint(v7)\n"}
{"id": "human_code\\rotate-list.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return '{} -> {}'.format(self.val, repr(self.__next__))\n\nclass C2(object):\n\n    def rotateRight(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if not a1 or not a1.__next__:\n            return a1\n        v1, v2 = (1, a1)\n        while v2.__next__:\n            v2 = v2.__next__\n            v1 += 1\n        v2.next = a1\n        v2, v3 = (a1, v2)\n        for v4 in range(v1 - a2 % v1):\n            v3 = v2\n            v2 = v2.__next__\n        v3.next = None\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return '{} -> {}'.format(self.val, repr(self.__next__))\n\nclass C2(object):\n\n    def rotateRight(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if not a1 or not a1.__next__:\n            return a1\n        v1, v2 = (1, a1)\n        while v2.__next__:\n            v2 = v2.__next__\n            v1 += 1\n        v2.next = a1\n        v2, v3 = (a1, v2)\n        for v4 in range(v1 - a2 % v1):\n            v3 = v2\n            v2 = v2.__next__\n        v3.next = None\n        return v2\n"}
{"id": "human_code\\p03253__s055729604.py", "text": "v1, v2 = map(int, input().split())\nv3 = 10 ** 9 + 7\nv4 = v1 + 1000\nv5 = [1] * v4\nv6 = [1] * v4\nfor v7 in range(v4 - 1):\n    v5[v7 + 1] = v5[v7] * (v7 + 1) % v3\nv6[v4 - 1] = pow(v5[v4 - 1], v3 - 2, v3)\nfor v7 in range(1, v4)[::-1]:\n    v6[v7 - 1] = v6[v7] * v7 % v3\n\ndef f1(a1, a2):\n    return v5[a1] * v6[a1 - a2] % v3 * v6[a2] % v3\nv8 = {}\nv7 = 2\nv9 = v2\nwhile v7 * v7 <= v2:\n    if v9 % v7 == 0:\n        v8[v7] = 0\n        while v9 % v7 == 0:\n            v9 = v9 // v7\n            v8[v7] += 1\n    v7 += 1\nif v9 > 1:\n    v8[v9] = 1\nv10 = 1\nfor v11 in v8.values():\n    v10 *= f1(v11 + v1 - 1, v1 - 1)\n    v10 %= v3\nprint(v10)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = 10 ** 9 + 7\nv4 = v1 + 1000\nv5 = [1] * v4\nv6 = [1] * v4\nfor v7 in range(v4 - 1):\n    v5[v7 + 1] = v5[v7] * (v7 + 1) % v3\nv6[v4 - 1] = pow(v5[v4 - 1], v3 - 2, v3)\nfor v7 in range(1, v4)[::-1]:\n    v6[v7 - 1] = v6[v7] * v7 % v3\n\ndef f1(a1, a2):\n    return v5[a1] * v6[a1 - a2] % v3 * v6[a2] % v3\nv8 = {}\nv7 = 2\nv9 = v2\nwhile v7 * v7 <= v2:\n    if v9 % v7 == 0:\n        v8[v7] = 0\n        while v9 % v7 == 0:\n            v9 = v9 // v7\n            v8[v7] += 1\n    v7 += 1\nif v9 > 1:\n    v8[v9] = 1\nv10 = 1\nfor v11 in v8.values():\n    v10 *= f1(v11 + v1 - 1, v1 - 1)\n    v10 %= v3\nprint(v10)\n"}
{"id": "llm_code\\maximum-sum-of-edge-values-in-a-graph__grok-4.1-fast__v1.py", "text": "from typing import List\nimport heapq\nfrom collections import deque\n\nclass C1:\n\n    def maxScore(self, a1: int, a2: List[List[int]]) -> int:\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [False] * a1\n        v6 = []\n        for v7 in range(a1):\n            if v5[v7]:\n                continue\n            v8 = deque([v7])\n            v5[v7] = True\n            v9 = [v7]\n            while v8:\n                v3 = v8.popleft()\n                for v4 in v1[v3]:\n                    if not v5[v4]:\n                        v5[v4] = True\n                        v8.append(v4)\n                        v9.append(v4)\n            v10 = len(v9)\n            if v10 >= 2:\n                v11 = all((len(v1[x]) == 2 for v12 in v9))\n                v6.append((v10, v11))\n        v6.sort(reverse=True)\n        v13 = len(v6)\n        v14 = {}\n        for v7 in range(v13):\n            v15 = a1 - 2 * v7\n            if v15 >= 1:\n                v14[v15] = v7\n        v16 = [[v6[j][0], v6[j][1], 0, 0, 0] for v17 in range(v13)]\n        v18 = []\n        v19 = 0\n        for v20 in range(a1, 0, -1):\n            if v20 in v14:\n                v21 = v14[v20]\n                v22 = v16[v21]\n                v22[2] = v20\n                v22[3] = v20\n                v22[4] = 1\n                if v22[0] > 1:\n                    heapq.heappush(v18, (-v20, v21))\n            else:\n                while v18:\n                    v23, v21 = heapq.heappop(v18)\n                    v24 = -v23\n                    v22 = v16[v21]\n                    if v22[4] >= v22[0] or v22[2] != v24:\n                        continue\n                    v19 += v24 * v20\n                    v22[2] = v22[3]\n                    v22[3] = v20\n                    v22[4] += 1\n                    if v22[4] == v22[0] and v22[1]:\n                        v19 += v22[2] * v22[3]\n                    if v22[4] < v22[0]:\n                        heapq.heappush(v18, (-v22[2], v21))\n                    break\n        return v19\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from typing import List\nimport heapq\nfrom collections import deque\n\nclass C1:\n\n    def maxScore(self, a1: int, a2: List[List[int]]) -> int:\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [False] * a1\n        v6 = []\n        for v7 in range(a1):\n            if v5[v7]:\n                continue\n            v8 = deque([v7])\n            v5[v7] = True\n            v9 = [v7]\n            while v8:\n                v3 = v8.popleft()\n                for v4 in v1[v3]:\n                    if not v5[v4]:\n                        v5[v4] = True\n                        v8.append(v4)\n                        v9.append(v4)\n            v10 = len(v9)\n            if v10 >= 2:\n                v11 = all((len(v1[x]) == 2 for v12 in v9))\n                v6.append((v10, v11))\n        v6.sort(reverse=True)\n        v13 = len(v6)\n        v14 = {}\n        for v7 in range(v13):\n            v15 = a1 - 2 * v7\n            if v15 >= 1:\n                v14[v15] = v7\n        v16 = [[v6[j][0], v6[j][1], 0, 0, 0] for v17 in range(v13)]\n        v18 = []\n        v19 = 0\n        for v20 in range(a1, 0, -1):\n            if v20 in v14:\n                v21 = v14[v20]\n                v22 = v16[v21]\n                v22[2] = v20\n                v22[3] = v20\n                v22[4] = 1\n                if v22[0] > 1:\n                    heapq.heappush(v18, (-v20, v21))\n            else:\n                while v18:\n                    v23, v21 = heapq.heappop(v18)\n                    v24 = -v23\n                    v22 = v16[v21]\n                    if v22[4] >= v22[0] or v22[2] != v24:\n                        continue\n                    v19 += v24 * v20\n                    v22[2] = v22[3]\n                    v22[3] = v20\n                    v22[4] += 1\n                    if v22[4] == v22[0] and v22[1]:\n                        v19 += v22[2] * v22[3]\n                    if v22[4] < v22[0]:\n                        heapq.heappush(v18, (-v22[2], v21))\n                    break\n        return v19\n"}
{"id": "llm_code\\sum-of-root-to-leaf-binary-numbers__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def sumRootToLeaf(self, a1):\n        v1 = 10 ** 9 + 7\n        if not a1:\n            return 0\n        v2 = 0\n        v3 = [(a1, 0)]\n        while v3:\n            v4, v5 = v3.pop()\n            v5 = ((v5 << 1) + v4.val) % v1\n            if not v4.left and (not v4.right):\n                v2 = (v2 + v5) % v1\n            else:\n                if v4.right:\n                    v3.append((v4.right, v5))\n                if v4.left:\n                    v3.append((v4.left, v5))\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def sumRootToLeaf(self, a1):\n        v1 = 10 ** 9 + 7\n        if not a1:\n            return 0\n        v2 = 0\n        v3 = [(a1, 0)]\n        while v3:\n            v4, v5 = v3.pop()\n            v5 = ((v5 << 1) + v4.val) % v1\n            if not v4.left and (not v4.right):\n                v2 = (v2 + v5) % v1\n            else:\n                if v4.right:\n                    v3.append((v4.right, v5))\n                if v4.left:\n                    v3.append((v4.left, v5))\n        return v2\n"}
{"id": "human_code\\split-the-array-to-make-coprime-products.py", "text": "import collections\n\nclass C1(object):\n\n    def findValidSplit(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def factorize(a1):\n            v1 = []\n            v2 = 2\n            while v2 * v2 <= a1:\n                v3 = 0\n                while a1 % v2 == 0:\n                    a1 //= v2\n                    v3 += 1\n                if v3:\n                    v1.append([v2, v3])\n                v2 += 1 if v2 == 2 else 2\n            if a1 > 1:\n                v1.append([a1, 1])\n            return v1\n        v1 = collections.Counter()\n        for v2 in reversed(a1):\n            for v3, v4 in factorize(v2):\n                v1[v3] += v4\n        v5 = collections.Counter()\n        v6 = 0\n        for v7 in range(len(a1) - 1):\n            for v3, v4 in factorize(a1[v7]):\n                if not v5[v3]:\n                    v6 += 1\n                v5[v3] += v4\n                v1[v3] -= v4\n                if not v1[v3]:\n                    v6 -= 1\n            if not v6:\n                return v7\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def findValidSplit(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def factorize(a1):\n            v1 = []\n            v2 = 2\n            while v2 * v2 <= a1:\n                v3 = 0\n                while a1 % v2 == 0:\n                    a1 //= v2\n                    v3 += 1\n                if v3:\n                    v1.append([v2, v3])\n                v2 += 1 if v2 == 2 else 2\n            if a1 > 1:\n                v1.append([a1, 1])\n            return v1\n        v1 = collections.Counter()\n        for v2 in reversed(a1):\n            for v3, v4 in factorize(v2):\n                v1[v3] += v4\n        v5 = collections.Counter()\n        v6 = 0\n        for v7 in range(len(a1) - 1):\n            for v3, v4 in factorize(a1[v7]):\n                if not v5[v3]:\n                    v6 += 1\n                v5[v3] += v4\n                v1[v3] -= v4\n                if not v1[v3]:\n                    v6 -= 1\n            if not v6:\n                return v7\n        return -1\n"}
{"id": "human_code\\number-of-ways-to-assign-edge-weights-ii__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        return True\n\nclass C2(object):\n\n    def assignEdgeWeights(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def iter_dfs():\n            v1 = [False] * len(adj)\n            v2 = [[] for v3 in range(len(adj))]\n            for v4, v5 in enumerate(a2):\n                for v6 in v5:\n                    v2[v6 - 1].append(v4)\n            v7 = C1(len(adj))\n            v8 = list(range(len(adj)))\n            v9 = [0] * len(adj)\n            v10 = [0] * len(a2)\n            v11 = [(1, (0,))]\n            while v11:\n                v12, v13 = v11.pop()\n                if v12 == 1:\n                    v14 = v13[0]\n                    for v4 in v2[v14]:\n                        if a2[v4][0] == a2[v4][1]:\n                            continue\n                        v10[v4] += v9[v14]\n                        for v6 in a2[v4]:\n                            if v1[v6 - 1]:\n                                v10[v4] -= 2 * v9[v8[v7.find_set(v6 - 1)]]\n                    v1[v14] = True\n                    v11.append((2, (v14, 0)))\n                elif v12 == 2:\n                    v14, v4 = v13\n                    if v4 == len(adj[v14]):\n                        continue\n                    v15 = adj[v14][v4]\n                    v11.append((2, (v14, v4 + 1)))\n                    if v1[v15]:\n                        continue\n                    v9[v15] = v9[v14] + 1\n                    v11.append((3, (v15, v14)))\n                    v11.append((1, (v15, v14)))\n                elif v12 == 3:\n                    v15, v14 = v13\n                    v7.union_set(v15, v14)\n                    v8[v7.find_set(v14)] = v14\n            return v10\n        v2 = [[] for v3 in range(len(a1) + 1)]\n        for v4, v5 in a1:\n            v2[v4 - 1].append(v5 - 1)\n            v2[v5 - 1].append(v4 - 1)\n        v6 = iter_dfs()\n        v7 = [1] * (len(v2) - 1)\n        for v8 in range(len(v7) - 1):\n            v7[v8 + 1] = v7[v8] * 2 % v1\n        return [v7[x - 1] if x - 1 >= 0 else 0 for v9 in v6]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        return True\n\nclass C2(object):\n\n    def assignEdgeWeights(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def iter_dfs():\n            v1 = [False] * len(adj)\n            v2 = [[] for v3 in range(len(adj))]\n            for v4, v5 in enumerate(a2):\n                for v6 in v5:\n                    v2[v6 - 1].append(v4)\n            v7 = C1(len(adj))\n            v8 = list(range(len(adj)))\n            v9 = [0] * len(adj)\n            v10 = [0] * len(a2)\n            v11 = [(1, (0,))]\n            while v11:\n                v12, v13 = v11.pop()\n                if v12 == 1:\n                    v14 = v13[0]\n                    for v4 in v2[v14]:\n                        if a2[v4][0] == a2[v4][1]:\n                            continue\n                        v10[v4] += v9[v14]\n                        for v6 in a2[v4]:\n                            if v1[v6 - 1]:\n                                v10[v4] -= 2 * v9[v8[v7.find_set(v6 - 1)]]\n                    v1[v14] = True\n                    v11.append((2, (v14, 0)))\n                elif v12 == 2:\n                    v14, v4 = v13\n                    if v4 == len(adj[v14]):\n                        continue\n                    v15 = adj[v14][v4]\n                    v11.append((2, (v14, v4 + 1)))\n                    if v1[v15]:\n                        continue\n                    v9[v15] = v9[v14] + 1\n                    v11.append((3, (v15, v14)))\n                    v11.append((1, (v15, v14)))\n                elif v12 == 3:\n                    v15, v14 = v13\n                    v7.union_set(v15, v14)\n                    v8[v7.find_set(v14)] = v14\n            return v10\n        v2 = [[] for v3 in range(len(a1) + 1)]\n        for v4, v5 in a1:\n            v2[v4 - 1].append(v5 - 1)\n            v2[v5 - 1].append(v4 - 1)\n        v6 = iter_dfs()\n        v7 = [1] * (len(v2) - 1)\n        for v8 in range(len(v7) - 1):\n            v7[v8 + 1] = v7[v8] * 2 % v1\n        return [v7[x - 1] if x - 1 >= 0 else 0 for v9 in v6]\n"}
{"id": "llm_code\\find-beautiful-indices-in-the-given-array-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def beautifulIndices(self, a1, a2, a3, a4):\n\n        def compute_failure(a1):\n            v1 = len(a1)\n            v2 = [0] * v1\n            v3 = 0\n            v4 = 1\n            while v4 < v1:\n                if a1[v4] == a1[v3]:\n                    v3 += 1\n                    v2[v4] = v3\n                    v4 += 1\n                elif v3 > 0:\n                    v3 = v2[v3 - 1]\n                else:\n                    v2[v4] = 0\n                    v4 += 1\n            return v2\n\n        def extract_starts(a1, a2):\n            v1 = []\n            if len(a2) > len(a1):\n                return v1\n            v2 = compute_failure(a2)\n            v3 = 0\n            for v4 in range(len(a1)):\n                while v3 > 0 and a2[v3] != a1[v4]:\n                    v3 = v2[v3 - 1]\n                if a2[v3] == a1[v4]:\n                    v3 += 1\n                if v3 == len(a2):\n                    v1.append(v4 - len(a2) + 1)\n                    v3 = v2[v3 - 1]\n            return v1\n        v1 = extract_starts(a1, a2)\n        v2 = extract_starts(a1, a3)\n        v3 = []\n        v4 = 0\n        for v5 in v1:\n            while v4 < len(v2) and v2[v4] < v5 - a4:\n                v4 += 1\n            if v4 < len(v2) and v2[v4] <= v5 + a4:\n                v3.append(v5)\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def beautifulIndices(self, a1, a2, a3, a4):\n\n        def compute_failure(a1):\n            v1 = len(a1)\n            v2 = [0] * v1\n            v3 = 0\n            v4 = 1\n            while v4 < v1:\n                if a1[v4] == a1[v3]:\n                    v3 += 1\n                    v2[v4] = v3\n                    v4 += 1\n                elif v3 > 0:\n                    v3 = v2[v3 - 1]\n                else:\n                    v2[v4] = 0\n                    v4 += 1\n            return v2\n\n        def extract_starts(a1, a2):\n            v1 = []\n            if len(a2) > len(a1):\n                return v1\n            v2 = compute_failure(a2)\n            v3 = 0\n            for v4 in range(len(a1)):\n                while v3 > 0 and a2[v3] != a1[v4]:\n                    v3 = v2[v3 - 1]\n                if a2[v3] == a1[v4]:\n                    v3 += 1\n                if v3 == len(a2):\n                    v1.append(v4 - len(a2) + 1)\n                    v3 = v2[v3 - 1]\n            return v1\n        v1 = extract_starts(a1, a2)\n        v2 = extract_starts(a1, a3)\n        v3 = []\n        v4 = 0\n        for v5 in v1:\n            while v4 < len(v2) and v2[v4] < v5 - a4:\n                v4 += 1\n            if v4 < len(v2) and v2[v4] <= v5 + a4:\n                v3.append(v5)\n        return v3\n"}
{"id": "human_code\\find-the-number-of-subsequences-with-equal-gcd__part1.py", "text": "v1 = 10 ** 9 + 7\nv2 = 200\n\ndef f1(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f2(a1, a2):\n    return a1 // f1(a1, a2) * a2\nv3 = [1] * (v2 + 1)\nfor v4 in range(len(v3) - 1):\n    v3[v4 + 1] = v3[v4] * 2 % v1\nv5 = [1] * (v2 + 1)\nfor v4 in range(len(v5) - 1):\n    v5[v4 + 1] = v5[v4] * 3 % v1\nv6 = [[0] * (v2 + 1) for v7 in range(v2 + 1)]\nfor v4 in range(1, v2 + 1):\n    for v8 in range(v4, v2 + 1):\n        v6[v4][v8] = v6[v8][v4] = f2(v4, v8)\nv9 = [0] * (v2 + 1)\nv9[1] = 1\nfor v4 in range(1, v2 + 1):\n    for v8 in range(v4 + v4, v2 + 1, v4):\n        v9[v8] -= v9[v4]\n\nclass C1(object):\n\n    def subsequencePairCount(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def count(a1):\n            return reduce(lambda accu, x: (accu + x) % v1, (v9[v4] * v9[v8] * f[v4 * a1][v8 * a1] for v4 in range(1, mx // a1 + 1) for v8 in range(1, mx // a1 + 1)), 0)\n        v1 = max(a1)\n        v2 = [0] * (v1 + 1)\n        for v3 in a1:\n            v2[v3] += 1\n        for v4 in range(1, v1 + 1):\n            for v5 in range(v4 + v4, v1 + 1, v4):\n                v2[v4] += v2[v5]\n        v6 = [[0] * (v1 + 1) for v7 in range(v1 + 1)]\n        for v7 in range(1, v1 + 1):\n            for v8 in range(v7, v1 + 1):\n                v9 = v6[v7][v8]\n                v10 = v2[v9] if v9 < len(v2) else 0\n                v11, v12 = (v2[v7], v2[v8])\n                v6[v7][v8] = v6[v8][v7] = (v5[v10] * v3[v11 - v10 + (v12 - v10)] - v3[v11] - v3[v12] + 1) % v1\n        return reduce(lambda accu, x: (accu + v3) % v1, (count(g) for v13 in range(1, v1 + 1)), 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "v1 = 10 ** 9 + 7\nv2 = 200\n\ndef f1(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f2(a1, a2):\n    return a1 // f1(a1, a2) * a2\nv3 = [1] * (v2 + 1)\nfor v4 in range(len(v3) - 1):\n    v3[v4 + 1] = v3[v4] * 2 % v1\nv5 = [1] * (v2 + 1)\nfor v4 in range(len(v5) - 1):\n    v5[v4 + 1] = v5[v4] * 3 % v1\nv6 = [[0] * (v2 + 1) for v7 in range(v2 + 1)]\nfor v4 in range(1, v2 + 1):\n    for v8 in range(v4, v2 + 1):\n        v6[v4][v8] = v6[v8][v4] = f2(v4, v8)\nv9 = [0] * (v2 + 1)\nv9[1] = 1\nfor v4 in range(1, v2 + 1):\n    for v8 in range(v4 + v4, v2 + 1, v4):\n        v9[v8] -= v9[v4]\n\nclass C1(object):\n\n    def subsequencePairCount(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def count(a1):\n            return reduce(lambda accu, x: (accu + x) % v1, (v9[v4] * v9[v8] * f[v4 * a1][v8 * a1] for v4 in range(1, mx // a1 + 1) for v8 in range(1, mx // a1 + 1)), 0)\n        v1 = max(a1)\n        v2 = [0] * (v1 + 1)\n        for v3 in a1:\n            v2[v3] += 1\n        for v4 in range(1, v1 + 1):\n            for v5 in range(v4 + v4, v1 + 1, v4):\n                v2[v4] += v2[v5]\n        v6 = [[0] * (v1 + 1) for v7 in range(v1 + 1)]\n        for v7 in range(1, v1 + 1):\n            for v8 in range(v7, v1 + 1):\n                v9 = v6[v7][v8]\n                v10 = v2[v9] if v9 < len(v2) else 0\n                v11, v12 = (v2[v7], v2[v8])\n                v6[v7][v8] = v6[v8][v7] = (v5[v10] * v3[v11 - v10 + (v12 - v10)] - v3[v11] - v3[v12] + 1) % v1\n        return reduce(lambda accu, x: (accu + v3) % v1, (count(g) for v13 in range(1, v1 + 1)), 0)\n"}
{"id": "human_code\\p02549__s118724353.py", "text": "import numpy as np\nfrom numba import njit\nfrom numba.types import i8\nv1 = np.int64\nv2 = 998244353\n\n@njit((i8[:, ::-1], i8[:], i8, i8), cache=True)\ndef f1(a1, a2, a3, a4):\n    v1 = np.ones_like(a2)\n    for v2 in range(1, a3):\n        v3 = 0\n        for v4 in range(a4):\n            v5 = v2 - a1[v4, 0]\n            if v5 < 0:\n                continue\n            v6 = v2 - a1[v4, 1] - 1\n            v3 += v1[v5] - (v1[v6] if v6 >= 0 else 0)\n        a2[v2] = v3 % v2\n        v1[v2] = (v1[v2 - 1] + a2[v2]) % v2\n    return a2[a3 - 1]\n\ndef f2():\n    v1 = open(0)\n    v2, v3 = [int(x) for v4 in v1.readline().split()]\n    v5 = np.fromstring(v1.read(), v1, sep=' ').reshape((-1, 2))\n    v6 = np.zeros(v2, v1)\n    v6[0] = 1\n    v7 = f1(v5, v6, v2, v3)\n    print(v7)\nf2()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import numpy as np\nfrom numba import njit\nfrom numba.types import i8\nv1 = np.int64\nv2 = 998244353\n\n@njit((i8[:, ::-1], i8[:], i8, i8), cache=True)\ndef f1(a1, a2, a3, a4):\n    v1 = np.ones_like(a2)\n    for v2 in range(1, a3):\n        v3 = 0\n        for v4 in range(a4):\n            v5 = v2 - a1[v4, 0]\n            if v5 < 0:\n                continue\n            v6 = v2 - a1[v4, 1] - 1\n            v3 += v1[v5] - (v1[v6] if v6 >= 0 else 0)\n        a2[v2] = v3 % v2\n        v1[v2] = (v1[v2 - 1] + a2[v2]) % v2\n    return a2[a3 - 1]\n\ndef f2():\n    v1 = open(0)\n    v2, v3 = [int(x) for v4 in v1.readline().split()]\n    v5 = np.fromstring(v1.read(), v1, sep=' ').reshape((-1, 2))\n    v6 = np.zeros(v2, v1)\n    v6[0] = 1\n    v7 = f1(v5, v6, v2, v3)\n    print(v7)\nf2()\n"}
{"id": "llm_code\\best-time-to-buy-and-sell-stock-using-strategy__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxProfit(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = a3 // 2\n        v3 = 0\n        v4 = 0\n        for v5 in range(v1):\n            v3 += a1[v5] * a2[v5]\n            if v5 < a3:\n                if v5 >= v2:\n                    v4 += a1[v5]\n            else:\n                v4 += a1[v5] * a2[v5]\n        v6 = max(v3, v4)\n        for v5 in range(a3, v1):\n            v4 += a1[v5 - a3] * a2[v5 - a3]\n            v4 += a1[v5] - a1[v5 - v2]\n            v4 -= a1[v5] * a2[v5]\n            v6 = max(v6, v4)\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxProfit(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = a3 // 2\n        v3 = 0\n        v4 = 0\n        for v5 in range(v1):\n            v3 += a1[v5] * a2[v5]\n            if v5 < a3:\n                if v5 >= v2:\n                    v4 += a1[v5]\n            else:\n                v4 += a1[v5] * a2[v5]\n        v6 = max(v3, v4)\n        for v5 in range(a3, v1):\n            v4 += a1[v5 - a3] * a2[v5 - a3]\n            v4 += a1[v5] - a1[v5 - v2]\n            v4 -= a1[v5] * a2[v5]\n            v6 = max(v6, v4)\n        return v6\n"}
{"id": "llm_code\\find-the-grid-of-region-average__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def resultGrid(self, a1, a2):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [[0] * v2 for v4 in range(v1)]\n        v5 = [[0] * v2 for v4 in range(v1)]\n        for v6 in range(1, v1 - 1):\n            for v7 in range(1, v2 - 1):\n                v8 = True\n                for v9 in range(3):\n                    for v10 in range(2):\n                        v11, v12 = (v6 - 1 + v10, v6 - 1 + v10 + 1)\n                        if abs(a1[v11][v7 - 1 + v9] - a1[v12][v7 - 1 + v9]) > a2:\n                            v8 = False\n                            break\n                    if not v8:\n                        break\n                if not v8:\n                    continue\n                for v10 in range(3):\n                    for v9 in range(2):\n                        v13, v14 = (v7 - 1 + v9, v7 - 1 + v9 + 1)\n                        if abs(a1[v6 - 1 + v10][v13] - a1[v6 - 1 + v10][v14]) > a2:\n                            v8 = False\n                            break\n                    if not v8:\n                        break\n                if not v8:\n                    continue\n                v15 = sum((a1[v6 - 1 + dy][v7 - 1 + dx] for v16 in range(3) for v17 in range(3)))\n                v18 = v15 // 9\n                for v16 in range(3):\n                    for v17 in range(3):\n                        v19, v20 = (v6 - 1 + v16, v7 - 1 + v17)\n                        v3[v19][v20] += v18\n                        v5[v19][v20] += 1\n        for v21 in range(v1):\n            for v22 in range(v2):\n                if v5[v21][v22] > 0:\n                    v3[v21][v22] //= v5[v21][v22]\n                else:\n                    v3[v21][v22] = a1[v21][v22]\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def resultGrid(self, a1, a2):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [[0] * v2 for v4 in range(v1)]\n        v5 = [[0] * v2 for v4 in range(v1)]\n        for v6 in range(1, v1 - 1):\n            for v7 in range(1, v2 - 1):\n                v8 = True\n                for v9 in range(3):\n                    for v10 in range(2):\n                        v11, v12 = (v6 - 1 + v10, v6 - 1 + v10 + 1)\n                        if abs(a1[v11][v7 - 1 + v9] - a1[v12][v7 - 1 + v9]) > a2:\n                            v8 = False\n                            break\n                    if not v8:\n                        break\n                if not v8:\n                    continue\n                for v10 in range(3):\n                    for v9 in range(2):\n                        v13, v14 = (v7 - 1 + v9, v7 - 1 + v9 + 1)\n                        if abs(a1[v6 - 1 + v10][v13] - a1[v6 - 1 + v10][v14]) > a2:\n                            v8 = False\n                            break\n                    if not v8:\n                        break\n                if not v8:\n                    continue\n                v15 = sum((a1[v6 - 1 + dy][v7 - 1 + dx] for v16 in range(3) for v17 in range(3)))\n                v18 = v15 // 9\n                for v16 in range(3):\n                    for v17 in range(3):\n                        v19, v20 = (v6 - 1 + v16, v7 - 1 + v17)\n                        v3[v19][v20] += v18\n                        v5[v19][v20] += 1\n        for v21 in range(v1):\n            for v22 in range(v2):\n                if v5[v21][v22] > 0:\n                    v3[v21][v22] //= v5[v21][v22]\n                else:\n                    v3[v21][v22] = a1[v21][v22]\n        return v3\n"}
{"id": "human_code\\max-difference-you-can-get-from-changing-an-integer__part1.py", "text": "class C1(object):\n\n    def maxDiff(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def find(a1, a2):\n            v1 = 0\n            while a1:\n                a1, v3 = divmod(a1, 10)\n                if a2(v3):\n                    v1 = v3\n            return v1\n\n        def reverse(a1, a2):\n            v1 = 0\n            while a1 or a2 > 0:\n                a1, v3 = divmod(a1, 10)\n                v1 = v1 * 10 + v3\n                a2 -= 1\n            return v1\n\n        def replace(a1, a2, a3):\n            v1 = v2 = 0\n            while a1:\n                a1, v4 = divmod(a1, 10)\n                if v4 == a2:\n                    v4 = a3\n                v1 = v1 * 10 + v4\n                v2 += 1\n            return reverse(v1, v2)\n        v1 = find(a1, lambda x: x < 9)\n        v2 = find(a1, lambda x: x > 1)\n        return replace(a1, v1, 9) - replace(a1, v2, 1 if reverse(a1, 0) % 10 != 1 else 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxDiff(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def find(a1, a2):\n            v1 = 0\n            while a1:\n                a1, v3 = divmod(a1, 10)\n                if a2(v3):\n                    v1 = v3\n            return v1\n\n        def reverse(a1, a2):\n            v1 = 0\n            while a1 or a2 > 0:\n                a1, v3 = divmod(a1, 10)\n                v1 = v1 * 10 + v3\n                a2 -= 1\n            return v1\n\n        def replace(a1, a2, a3):\n            v1 = v2 = 0\n            while a1:\n                a1, v4 = divmod(a1, 10)\n                if v4 == a2:\n                    v4 = a3\n                v1 = v1 * 10 + v4\n                v2 += 1\n            return reverse(v1, v2)\n        v1 = find(a1, lambda x: x < 9)\n        v2 = find(a1, lambda x: x > 1)\n        return replace(a1, v1, 9) - replace(a1, v2, 1 if reverse(a1, 0) % 10 != 1 else 0)\n"}
{"id": "llm_code\\p02935__s616004759.py", "text": "import itertools as it\nimport numpy as np\nfrom copy import deepcopy\n\ndef f1():\n    v1 = [input() for v2 in range(2)]\n    v3 = int(v1[0])\n    v4 = [float(i) for v5 in v1[1].split(' ')]\n    v6 = [list(it.combinations(range(l), 2)) for v7 in range(2, len(v4) + 1)]\n    v6.reverse()\n    v8 = np.empty((np.prod([len(c) for v9 in v6]), len(v6)), dtype='i')\n    for v5, v10 in enumerate(v6):\n        v8[:, v5] = np.array(list(range(len(v10))) * int(len(v8) / len(v10)))\n    v11 = 0.0\n    for v12 in v8:\n        v13 = []\n        v14 = deepcopy(v4)\n        for v15, v5 in enumerate(v12):\n            v13.append(v6[v15][v5])\n        for v16 in v13:\n            v5, v17 = v16\n            v18 = (v14.pop(max(v5, v17)) + v14.pop(min(v5, v17))) / 2.0\n            v14.append(v18)\n        if v11 < v14[0]:\n            v11 = v14[0]\n    print(v11)\nif __name__ == '__main__':\n    f1()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import itertools as it\nimport numpy as np\nfrom copy import deepcopy\n\ndef f1():\n    v1 = [input() for v2 in range(2)]\n    v3 = int(v1[0])\n    v4 = [float(i) for v5 in v1[1].split(' ')]\n    v6 = [list(it.combinations(range(l), 2)) for v7 in range(2, len(v4) + 1)]\n    v6.reverse()\n    v8 = np.empty((np.prod([len(c) for v9 in v6]), len(v6)), dtype='i')\n    for v5, v10 in enumerate(v6):\n        v8[:, v5] = np.array(list(range(len(v10))) * int(len(v8) / len(v10)))\n    v11 = 0.0\n    for v12 in v8:\n        v13 = []\n        v14 = deepcopy(v4)\n        for v15, v5 in enumerate(v12):\n            v13.append(v6[v15][v5])\n        for v16 in v13:\n            v5, v17 = v16\n            v18 = (v14.pop(max(v5, v17)) + v14.pop(min(v5, v17))) / 2.0\n            v14.append(v18)\n        if v11 < v14[0]:\n            v11 = v14[0]\n    print(v11)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\find-building-where-alice-and-bob-can-meet__part1.py", "text": "class C1(object):\n\n    def leftmostBuildingQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: max(x, y)):\n                self.tree = [None] * (2 * 2 ** (a1 - 1).bit_length())\n                self.build_fn = a2\n                self.query_fn = a3\n                self.build(0, a1 - 1, 1)\n\n            def build(self, a1, a2, a3):\n                if a1 == a2:\n                    self.tree[a3] = self.build_fn(a1)\n                    return\n                v1 = a1 + (a2 - a1) // 2\n                self.build(a1, v1, a3 * 2)\n                self.build(v1 + 1, a2, a3 * 2 + 1)\n                self.tree[a3] = self.query_fn(self.tree[a3 * 2], self.tree[a3 * 2 + 1])\n\n            def binary_search(self, a1, a2, a3, a4, a5, a6):\n                if a4 < a1 or a3 > a2:\n                    return -1\n                if a1 <= a3 and a4 <= a2:\n                    if not self.tree[a5] > a6:\n                        return -1\n                    if a3 == a4:\n                        return a3\n                v1 = a3 + (a4 - a3) // 2\n                v2 = self.binary_search(a1, a2, a3, v1, a5 * 2, a6)\n                return v2 if v2 != -1 else self.binary_search(a1, a2, v1 + 1, a4, a5 * 2 + 1, a6)\n\n        def build(a1):\n            return a1[a1]\n        v1 = [-1] * len(a2)\n        v2 = SegmentTree(len(a1), build_fn=build)\n        for v3, (v4, v5) in enumerate(a2):\n            if v4 > v5:\n                v4, v5 = (v5, v4)\n            if v4 == v5 or a1[v4] < a1[v5]:\n                v1[v3] = v5\n                continue\n            v1[v3] = v2.binary_search(v5 + 1, len(a1) - 1, 0, len(a1) - 1, 1, a1[v4])\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def leftmostBuildingQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: max(x, y)):\n                self.tree = [None] * (2 * 2 ** (a1 - 1).bit_length())\n                self.build_fn = a2\n                self.query_fn = a3\n                self.build(0, a1 - 1, 1)\n\n            def build(self, a1, a2, a3):\n                if a1 == a2:\n                    self.tree[a3] = self.build_fn(a1)\n                    return\n                v1 = a1 + (a2 - a1) // 2\n                self.build(a1, v1, a3 * 2)\n                self.build(v1 + 1, a2, a3 * 2 + 1)\n                self.tree[a3] = self.query_fn(self.tree[a3 * 2], self.tree[a3 * 2 + 1])\n\n            def binary_search(self, a1, a2, a3, a4, a5, a6):\n                if a4 < a1 or a3 > a2:\n                    return -1\n                if a1 <= a3 and a4 <= a2:\n                    if not self.tree[a5] > a6:\n                        return -1\n                    if a3 == a4:\n                        return a3\n                v1 = a3 + (a4 - a3) // 2\n                v2 = self.binary_search(a1, a2, a3, v1, a5 * 2, a6)\n                return v2 if v2 != -1 else self.binary_search(a1, a2, v1 + 1, a4, a5 * 2 + 1, a6)\n\n        def build(a1):\n            return a1[a1]\n        v1 = [-1] * len(a2)\n        v2 = SegmentTree(len(a1), build_fn=build)\n        for v3, (v4, v5) in enumerate(a2):\n            if v4 > v5:\n                v4, v5 = (v5, v4)\n            if v4 == v5 or a1[v4] < a1[v5]:\n                v1[v3] = v5\n                continue\n            v1[v3] = v2.binary_search(v5 + 1, len(a1) - 1, 0, len(a1) - 1, 1, a1[v4])\n        return v1\n"}
{"id": "llm_code\\minimum-operations-to-make-character-frequencies-equal__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def makeStringGood(self, a1):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = v1\n        v5 = [f for v6 in v2 if v6 > 0]\n        if not v5:\n            return v4\n        v7 = min(v5)\n        v8 = max(v2)\n        v9 = v1 + 1\n        for v10 in range(v7, v8 + 1):\n            v11 = [[v9] * 2 for v12 in range(27)]\n            v11[0][0] = v11[0][1] = 0\n            for v13 in range(1, 27):\n                v14 = v13 - 1\n                v15 = v2[v14]\n                v16 = 0\n                if v14 > 0:\n                    v17 = v2[v14 - 1]\n                    v16 = v17 - v10 if v17 >= v10 else v17\n                v18 = v11[v13 - 1][0]\n                v19 = v11[v13 - 1][1]\n                v20 = min(v18, v19)\n                if v15 == 0:\n                    v11[v13][0] = v18\n                    v11[v13][1] = v19\n                    continue\n                if v15 >= v10:\n                    v11[v13][0] = v9\n                    v11[v13][1] = v20 + v15 - v10\n                else:\n                    v21 = v10 - v15\n                    v22 = min(v20 + v21, v19 + max(0, v21 - v16))\n                    v23 = v20 + v15\n                    v11[v13][0] = v22\n                    v11[v13][1] = v23\n            v24 = min(v11[26][0], v11[26][1])\n            v4 = min(v4, v24)\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def makeStringGood(self, a1):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = v1\n        v5 = [f for v6 in v2 if v6 > 0]\n        if not v5:\n            return v4\n        v7 = min(v5)\n        v8 = max(v2)\n        v9 = v1 + 1\n        for v10 in range(v7, v8 + 1):\n            v11 = [[v9] * 2 for v12 in range(27)]\n            v11[0][0] = v11[0][1] = 0\n            for v13 in range(1, 27):\n                v14 = v13 - 1\n                v15 = v2[v14]\n                v16 = 0\n                if v14 > 0:\n                    v17 = v2[v14 - 1]\n                    v16 = v17 - v10 if v17 >= v10 else v17\n                v18 = v11[v13 - 1][0]\n                v19 = v11[v13 - 1][1]\n                v20 = min(v18, v19)\n                if v15 == 0:\n                    v11[v13][0] = v18\n                    v11[v13][1] = v19\n                    continue\n                if v15 >= v10:\n                    v11[v13][0] = v9\n                    v11[v13][1] = v20 + v15 - v10\n                else:\n                    v21 = v10 - v15\n                    v22 = min(v20 + v21, v19 + max(0, v21 - v16))\n                    v23 = v20 + v15\n                    v11[v13][0] = v22\n                    v11[v13][1] = v23\n            v24 = min(v11[26][0], v11[26][1])\n            v4 = min(v4, v24)\n        return v4\n"}
{"id": "human_code\\minimum-cost-path-with-teleportations__part1.py", "text": "class C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [[float('inf')] * v2 for v4 in range(v1)]\n        v3[-1][-1] = 0\n        v5 = max((max(row) for v6 in a1))\n        v7 = [float('inf')] * (v5 + 1)\n        for v8 in range(a2 + 1):\n            for v9 in reversed(range(v1)):\n                for v10 in reversed(range(v2)):\n                    if v9 + 1 < v1:\n                        if v3[v9 + 1][v10] + a1[v9 + 1][v10] < v3[v9][v10]:\n                            v3[v9][v10] = v3[v9 + 1][v10] + a1[v9 + 1][v10]\n                    if v10 + 1 < v2:\n                        if v3[v9][v10 + 1] + a1[v9][v10 + 1] < v3[v9][v10]:\n                            v3[v9][v10] = v3[v9][v10 + 1] + a1[v9][v10 + 1]\n                    if v7[a1[v9][v10]] < v3[v9][v10]:\n                        v3[v9][v10] = v7[a1[v9][v10]]\n            for v9 in range(v1):\n                for v10 in range(v2):\n                    if v3[v9][v10] < v7[a1[v9][v10]]:\n                        v7[a1[v9][v10]] = v3[v9][v10]\n            for v8 in range(v5):\n                if v7[v8] < v7[v8 + 1]:\n                    v7[v8 + 1] = v7[v8]\n        return v3[0][0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [[float('inf')] * v2 for v4 in range(v1)]\n        v3[-1][-1] = 0\n        v5 = max((max(row) for v6 in a1))\n        v7 = [float('inf')] * (v5 + 1)\n        for v8 in range(a2 + 1):\n            for v9 in reversed(range(v1)):\n                for v10 in reversed(range(v2)):\n                    if v9 + 1 < v1:\n                        if v3[v9 + 1][v10] + a1[v9 + 1][v10] < v3[v9][v10]:\n                            v3[v9][v10] = v3[v9 + 1][v10] + a1[v9 + 1][v10]\n                    if v10 + 1 < v2:\n                        if v3[v9][v10 + 1] + a1[v9][v10 + 1] < v3[v9][v10]:\n                            v3[v9][v10] = v3[v9][v10 + 1] + a1[v9][v10 + 1]\n                    if v7[a1[v9][v10]] < v3[v9][v10]:\n                        v3[v9][v10] = v7[a1[v9][v10]]\n            for v9 in range(v1):\n                for v10 in range(v2):\n                    if v3[v9][v10] < v7[a1[v9][v10]]:\n                        v7[a1[v9][v10]] = v3[v9][v10]\n            for v8 in range(v5):\n                if v7[v8] < v7[v8 + 1]:\n                    v7[v8 + 1] = v7[v8]\n        return v3[0][0]\n"}
{"id": "llm_code\\p03026__s099584355.py", "text": "import sys\nv1 = sys.stdin\nsys.setrecursionlimit(10 ** 7)\n\ndef f1():\n    return map(int, v1.readline().split())\n\ndef f2():\n    return map(lambda x: int(x) - 1, v1.readline().split())\n\ndef f3():\n    return map(float, v1.readline().split())\n\ndef f4():\n    return v1.readline().split()\n\ndef f5():\n    return v1.readline().rstrip()\n\ndef f6():\n    return list(f5())\n\ndef f7():\n    return int(v1.readline())\n\ndef f8():\n    return float(v1.readline())\nv2 = f7()\nv3 = [tuple(f2()) for v4 in range(v2 - 1)]\nv5 = list(f1())\nv5.sort()\nv6 = [[] for v4 in range(v2)]\nfor v7, v8 in v3:\n    v6[v7].append(v8)\n    v6[v8].append(v7)\nv9 = [i for v10 in range(v2) if len(v6[v10]) == 1]\nv11 = [0] * v2\nfor v10 in range(v2 - 1):\n    v12 = v9.pop(0)\n    v11[v12] = v5[v10]\n    for v13 in v6[v12]:\n        v6[v13].remove(v12)\n        if len(v6[v13]) == 1:\n            v9.append(v13)\nv11[v9[0]] = v5[-1]\nv14 = 0\nfor v7, v8 in v3:\n    v14 += min(v11[v7], v11[v8])\nprint(v14)\nprint(*v11)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1 = sys.stdin\nsys.setrecursionlimit(10 ** 7)\n\ndef f1():\n    return map(int, v1.readline().split())\n\ndef f2():\n    return map(lambda x: int(x) - 1, v1.readline().split())\n\ndef f3():\n    return map(float, v1.readline().split())\n\ndef f4():\n    return v1.readline().split()\n\ndef f5():\n    return v1.readline().rstrip()\n\ndef f6():\n    return list(f5())\n\ndef f7():\n    return int(v1.readline())\n\ndef f8():\n    return float(v1.readline())\nv2 = f7()\nv3 = [tuple(f2()) for v4 in range(v2 - 1)]\nv5 = list(f1())\nv5.sort()\nv6 = [[] for v4 in range(v2)]\nfor v7, v8 in v3:\n    v6[v7].append(v8)\n    v6[v8].append(v7)\nv9 = [i for v10 in range(v2) if len(v6[v10]) == 1]\nv11 = [0] * v2\nfor v10 in range(v2 - 1):\n    v12 = v9.pop(0)\n    v11[v12] = v5[v10]\n    for v13 in v6[v12]:\n        v6[v13].remove(v12)\n        if len(v6[v13]) == 1:\n            v9.append(v13)\nv11[v9[0]] = v5[-1]\nv14 = 0\nfor v7, v8 in v3:\n    v14 += min(v11[v7], v11[v8])\nprint(v14)\nprint(*v11)\n"}
{"id": "llm_code\\p03330__unrelated.py", "text": "import sys\nfrom typing import List\nv1 = sys.stdin.readline\nv2, v3 = map(int, v1().split())\nv4: List[List[int]] = [list(map(int, v1().split())) for v5 in range(v3)]\nv6: List[List[int]] = [list(map(int, v1().split())) for v5 in range(v2)]\nv7 = [[0] * v3 for v5 in range(3)]\nfor v8 in range(v2):\n    for v9 in range(v2):\n        v10 = (v8 + v9) % 3\n        v11 = v6[v8][v9] - 1\n        for v12 in range(v3):\n            if v12 != v11:\n                v7[v10][v12] += v4[v11][v12]\nv13 = 0\nfor v8 in range(v2):\n    for v9 in range(v2):\n        v10 = (v8 + v9) % 3\n        v11 = v6[v8][v9] - 1\n        v13 += min(v7[v10][v11], min(v7[0][v11], v7[1][v11], v7[2][v11]))\nprint(v13)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nfrom typing import List\nv1 = sys.stdin.readline\nv2, v3 = map(int, v1().split())\nv4: List[List[int]] = [list(map(int, v1().split())) for v5 in range(v3)]\nv6: List[List[int]] = [list(map(int, v1().split())) for v5 in range(v2)]\nv7 = [[0] * v3 for v5 in range(3)]\nfor v8 in range(v2):\n    for v9 in range(v2):\n        v10 = (v8 + v9) % 3\n        v11 = v6[v8][v9] - 1\n        for v12 in range(v3):\n            if v12 != v11:\n                v7[v10][v12] += v4[v11][v12]\nv13 = 0\nfor v8 in range(v2):\n    for v9 in range(v2):\n        v10 = (v8 + v9) % 3\n        v11 = v6[v8][v9] - 1\n        v13 += min(v7[v10][v11], min(v7[0][v11], v7[1][v11], v7[2][v11]))\nprint(v13)\n"}
{"id": "human_code\\find-a-value-of-a-mysterious-function-closest-to-target__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.__l = 0\n        self.__n = a1\n        self.__count = [0] * a1\n\n    def __iadd__(self, a1):\n        self.__l += 1\n        v1 = 1\n        for v2 in range(self.__n):\n            if a1 & v1:\n                self.__count[v2] += 1\n            v1 <<= 1\n        return self\n\n    def __isub__(self, a1):\n        self.__l -= 1\n        v1 = 1\n        for v2 in range(self.__n):\n            if a1 & v1:\n                self.__count[v2] -= 1\n            v1 <<= 1\n        return self\n\n    def bit_and(self):\n        v1, v2 = (0, 1)\n        for v3 in range(self.__n):\n            if self.__count[v3] == self.__l:\n                v1 |= v2\n            v2 <<= 1\n        return v1\n\nclass C2(object):\n\n    def closestToTarget(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = C1(max(a1).bit_length())\n        v2, v3 = (float('inf'), 0)\n        for v4 in range(len(a1)):\n            v1 += a1[v4]\n            while v3 <= v4:\n                v5 = v1.bit_and()\n                v2 = min(v2, abs(v5 - a2))\n                if v5 >= a2:\n                    break\n                v1 -= a1[v3]\n                v3 += 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.__l = 0\n        self.__n = a1\n        self.__count = [0] * a1\n\n    def __iadd__(self, a1):\n        self.__l += 1\n        v1 = 1\n        for v2 in range(self.__n):\n            if a1 & v1:\n                self.__count[v2] += 1\n            v1 <<= 1\n        return self\n\n    def __isub__(self, a1):\n        self.__l -= 1\n        v1 = 1\n        for v2 in range(self.__n):\n            if a1 & v1:\n                self.__count[v2] -= 1\n            v1 <<= 1\n        return self\n\n    def bit_and(self):\n        v1, v2 = (0, 1)\n        for v3 in range(self.__n):\n            if self.__count[v3] == self.__l:\n                v1 |= v2\n            v2 <<= 1\n        return v1\n\nclass C2(object):\n\n    def closestToTarget(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = C1(max(a1).bit_length())\n        v2, v3 = (float('inf'), 0)\n        for v4 in range(len(a1)):\n            v1 += a1[v4]\n            while v3 <= v4:\n                v5 = v1.bit_and()\n                v2 = min(v2, abs(v5 - a2))\n                if v5 >= a2:\n                    break\n                v1 -= a1[v3]\n                v3 += 1\n        return v2\n"}
{"id": "llm_code\\p03213__unrelated.py", "text": "import math\n\ndef f1(a1):\n    v1 = 0\n    for v2 in range(1, int(math.sqrt(a1)) + 1):\n        if a1 % v2 == 0:\n            v1 += 1\n            if v2 != a1 // v2:\n                v1 += 1\n    return v1\n\ndef f2(a1):\n    v1 = 1\n    for v2 in range(1, a1 + 1):\n        v1 *= v2\n    return v1\n\ndef f3(a1):\n    v1 = f2(a1)\n    v2 = 0\n    for v3 in range(1, v1 + 1):\n        if f1(v3) == 75:\n            if v1 % v3 == 0:\n                v2 += 1\n    return v2\nv1 = int(input())\nprint(f3(v1))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import math\n\ndef f1(a1):\n    v1 = 0\n    for v2 in range(1, int(math.sqrt(a1)) + 1):\n        if a1 % v2 == 0:\n            v1 += 1\n            if v2 != a1 // v2:\n                v1 += 1\n    return v1\n\ndef f2(a1):\n    v1 = 1\n    for v2 in range(1, a1 + 1):\n        v1 *= v2\n    return v1\n\ndef f3(a1):\n    v1 = f2(a1)\n    v2 = 0\n    for v3 in range(1, v1 + 1):\n        if f1(v3) == 75:\n            if v1 % v3 == 0:\n                v2 += 1\n    return v2\nv1 = int(input())\nprint(f3(v1))\n"}
{"id": "human_code\\subtree-inversion-sum__part1.py", "text": "class C1(object):\n\n    def subtreeInversionSum(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = []\n            v2 = [0] * 3\n            v3 = [(1, (0, -1, v2))]\n            while v3:\n                v4, v5 = v3.pop()\n                if v4 == 1:\n                    v6, v7, v2 = v5\n                    v1.append([0] * 2)\n                    v2[:] = [a2[v6], 0, 0]\n                    v3.append((4, (v6, v7, v2)))\n                    v3.append((2, (v6, v7, v2, 0)))\n                elif v4 == 2:\n                    v6, v7, v2, v8 = v5\n                    if v8 == len(adj[v6]):\n                        continue\n                    v9 = adj[v6][v8]\n                    v3.append((2, (v6, v7, v2, v8 + 1)))\n                    if v9 == v7:\n                        continue\n                    v10 = [0] * 3\n                    v3.append((3, (v6, v7, v10, v2, v8)))\n                    v3.append((1, (v9, v6, v10)))\n                elif v4 == 3:\n                    v6, v7, v10, v2, v8 = v5\n                    v2[0] += v10[0]\n                    v2[1] += v10[1]\n                    v2[2] += v10[2]\n                elif v4 == 4:\n                    v6, v7, v2 = v5\n                    v2[1] = max(v2[1], v1[-1][1] - 2 * v2[0])\n                    v2[2] = max(v2[2], v1[-1][0] + 2 * v2[0])\n                    v1.pop()\n                    if len(v1) - a3 >= 0:\n                        v1[len(v1) - a3][0] += v2[1]\n                        v1[len(v1) - a3][1] += v2[2]\n            return v2[0] + v2[1]\n        v1 = [[] for v2 in range(len(a2))]\n        for v3, v4 in a1:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        return iter_dfs()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def subtreeInversionSum(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = []\n            v2 = [0] * 3\n            v3 = [(1, (0, -1, v2))]\n            while v3:\n                v4, v5 = v3.pop()\n                if v4 == 1:\n                    v6, v7, v2 = v5\n                    v1.append([0] * 2)\n                    v2[:] = [a2[v6], 0, 0]\n                    v3.append((4, (v6, v7, v2)))\n                    v3.append((2, (v6, v7, v2, 0)))\n                elif v4 == 2:\n                    v6, v7, v2, v8 = v5\n                    if v8 == len(adj[v6]):\n                        continue\n                    v9 = adj[v6][v8]\n                    v3.append((2, (v6, v7, v2, v8 + 1)))\n                    if v9 == v7:\n                        continue\n                    v10 = [0] * 3\n                    v3.append((3, (v6, v7, v10, v2, v8)))\n                    v3.append((1, (v9, v6, v10)))\n                elif v4 == 3:\n                    v6, v7, v10, v2, v8 = v5\n                    v2[0] += v10[0]\n                    v2[1] += v10[1]\n                    v2[2] += v10[2]\n                elif v4 == 4:\n                    v6, v7, v2 = v5\n                    v2[1] = max(v2[1], v1[-1][1] - 2 * v2[0])\n                    v2[2] = max(v2[2], v1[-1][0] + 2 * v2[0])\n                    v1.pop()\n                    if len(v1) - a3 >= 0:\n                        v1[len(v1) - a3][0] += v2[1]\n                        v1[len(v1) - a3][1] += v2[2]\n            return v2[0] + v2[1]\n        v1 = [[] for v2 in range(len(a2))]\n        for v3, v4 in a1:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        return iter_dfs()\n"}
{"id": "llm_code\\contain-virus__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def containVirus(self, a1):\n        if not a1:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        v4 = 0\n        while True:\n            v5 = set()\n            v6 = []\n            for v7 in range(v1):\n                for v8 in range(v2):\n                    if a1[v7][v8] == 1 and (v7, v8) not in v5:\n                        v9 = []\n                        v10 = set()\n                        v11 = 0\n                        v12 = deque([(v7, v8)])\n                        v5.add((v7, v8))\n                        while v12:\n                            v13, v14 = v12.popleft()\n                            v9.append((v13, v14))\n                            for v15, v16 in v3:\n                                v17, v18 = (v13 + v15, v14 + v16)\n                                if 0 <= v17 < v1 and 0 <= v18 < v2:\n                                    if a1[v17][v18] == 1 and (v17, v18) not in v5:\n                                        v5.add((v17, v18))\n                                        v12.append((v17, v18))\n                                    elif a1[v17][v18] == 0:\n                                        v10.add((v17, v18))\n                                        v11 += 1\n                        v6.append((len(v10), v11, v9))\n            if not v6:\n                break\n            v6.sort(key=lambda g: -g[0])\n            v19, v20, v21 = v6[0]\n            v4 += v20\n            for v13, v14 in v21:\n                a1[v13][v14] = -1\n            for v19, v19, v22 in v6[1:]:\n                for v13, v14 in v22:\n                    for v15, v16 in v3:\n                        v17, v18 = (v13 + v15, v14 + v16)\n                        if 0 <= v17 < v1 and 0 <= v18 < v2 and (a1[v17][v18] == 0):\n                            a1[v17][v18] = 1\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def containVirus(self, a1):\n        if not a1:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        v4 = 0\n        while True:\n            v5 = set()\n            v6 = []\n            for v7 in range(v1):\n                for v8 in range(v2):\n                    if a1[v7][v8] == 1 and (v7, v8) not in v5:\n                        v9 = []\n                        v10 = set()\n                        v11 = 0\n                        v12 = deque([(v7, v8)])\n                        v5.add((v7, v8))\n                        while v12:\n                            v13, v14 = v12.popleft()\n                            v9.append((v13, v14))\n                            for v15, v16 in v3:\n                                v17, v18 = (v13 + v15, v14 + v16)\n                                if 0 <= v17 < v1 and 0 <= v18 < v2:\n                                    if a1[v17][v18] == 1 and (v17, v18) not in v5:\n                                        v5.add((v17, v18))\n                                        v12.append((v17, v18))\n                                    elif a1[v17][v18] == 0:\n                                        v10.add((v17, v18))\n                                        v11 += 1\n                        v6.append((len(v10), v11, v9))\n            if not v6:\n                break\n            v6.sort(key=lambda g: -g[0])\n            v19, v20, v21 = v6[0]\n            v4 += v20\n            for v13, v14 in v21:\n                a1[v13][v14] = -1\n            for v19, v19, v22 in v6[1:]:\n                for v13, v14 in v22:\n                    for v15, v16 in v3:\n                        v17, v18 = (v13 + v15, v14 + v16)\n                        if 0 <= v17 < v1 and 0 <= v18 < v2 and (a1[v17][v18] == 0):\n                            a1[v17][v18] = 1\n        return v4\n"}
{"id": "human_code\\p02937__s055810879.py", "text": "import bisect\nv1 = input()\nv2 = input()\nv3 = set(list(v1))\nfor v4 in v2:\n    if not v4 in v3:\n        print(-1)\n        exit()\nv5 = [[] for v6 in range(26)]\nfor v7, v8 in enumerate(v1):\n    v5[ord(v8) - ord('a')].append(v7)\nv9 = 0\nv10 = 0\nfor v7, v4 in enumerate(v2):\n    v11 = bisect.bisect_left(v5[ord(v4) - ord('a')], v10)\n    if v11 < len(v5[ord(v4) - ord('a')]):\n        v11 = v5[ord(v4) - ord('a')][v11]\n        v9 += v11 - v10 + 1\n        v10 = (v11 + 1) % len(v1)\n    else:\n        v9 += len(v1) - v10\n        v10 = 0\n        v11 = bisect.bisect_left(v5[ord(v4) - ord('a')], 0)\n        v11 = v5[ord(v4) - ord('a')][v11]\n        v9 += v11 - v10 + 1\n        v10 = v11 + 1\nprint(v9)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import bisect\nv1 = input()\nv2 = input()\nv3 = set(list(v1))\nfor v4 in v2:\n    if not v4 in v3:\n        print(-1)\n        exit()\nv5 = [[] for v6 in range(26)]\nfor v7, v8 in enumerate(v1):\n    v5[ord(v8) - ord('a')].append(v7)\nv9 = 0\nv10 = 0\nfor v7, v4 in enumerate(v2):\n    v11 = bisect.bisect_left(v5[ord(v4) - ord('a')], v10)\n    if v11 < len(v5[ord(v4) - ord('a')]):\n        v11 = v5[ord(v4) - ord('a')][v11]\n        v9 += v11 - v10 + 1\n        v10 = (v11 + 1) % len(v1)\n    else:\n        v9 += len(v1) - v10\n        v10 = 0\n        v11 = bisect.bisect_left(v5[ord(v4) - ord('a')], 0)\n        v11 = v5[ord(v4) - ord('a')][v11]\n        v9 += v11 - v10 + 1\n        v10 = v11 + 1\nprint(v9)\n"}
{"id": "human_code\\most-frequent-prime__part2.py", "text": "import collections\n\ndef f1(a1):\n    if a1 % 2 == 0 or a1 % 3 == 0:\n        return False\n    for v1 in range(5, a1, 6):\n        if v1 * v1 > a1:\n            break\n        if a1 % v1 == 0 or a1 % (v1 + 2) == 0:\n            return False\n    return True\n\nclass C1(object):\n\n    def mostFrequentPrime(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n\n        def numbers(a1, a2, a3, a4):\n            v1 = 0\n            while 0 <= a1 < len(a1) and 0 <= a2 < len(a1[0]):\n                v1 = v1 * 10 + a1[a1][a2]\n                yield v1\n                a1, a2 = (a1 + a3, a2 + a4)\n        v2 = collections.Counter((x for v3 in range(len(a1)) for v4 in range(len(a1[0])) for v5, v6 in v1 for v7 in numbers(v3, v4, v5, v6) if v7 > 10))\n        v2[-1] = 0\n        return max((p for v8 in v2.keys() if f1(v8) or v8 == -1), key=lambda x: (v2[v7], v7))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\ndef f1(a1):\n    if a1 % 2 == 0 or a1 % 3 == 0:\n        return False\n    for v1 in range(5, a1, 6):\n        if v1 * v1 > a1:\n            break\n        if a1 % v1 == 0 or a1 % (v1 + 2) == 0:\n            return False\n    return True\n\nclass C1(object):\n\n    def mostFrequentPrime(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n\n        def numbers(a1, a2, a3, a4):\n            v1 = 0\n            while 0 <= a1 < len(a1) and 0 <= a2 < len(a1[0]):\n                v1 = v1 * 10 + a1[a1][a2]\n                yield v1\n                a1, a2 = (a1 + a3, a2 + a4)\n        v2 = collections.Counter((x for v3 in range(len(a1)) for v4 in range(len(a1[0])) for v5, v6 in v1 for v7 in numbers(v3, v4, v5, v6) if v7 > 10))\n        v2[-1] = 0\n        return max((p for v8 in v2.keys() if f1(v8) or v8 == -1), key=lambda x: (v2[v7], v7))\n"}
{"id": "human_code\\p03263__s644565763.py", "text": "v1, v2 = map(int, input().split())\nv3 = [0 for v4 in range(v1)]\nfor v4 in range(v1):\n    v3[v4] = list(map(int, input().split()))\nv5 = []\nfor v4 in range(v1):\n    for v6 in range(v2):\n        if v4 == v1 - 1 and v6 == v2 - 1:\n            continue\n        if v6 == v2 - 1 and v3[v4][v6] % 2 == 1 and (v4 < v1 - 1):\n            v3[v4][v6] -= 1\n            v3[v4 + 1][v6] += 1\n            v5.append([v4 + 1, v6 + 1, v4 + 2, v6 + 1])\n        elif v3[v4][v6] % 2 == 1:\n            v3[v4][v6] -= 1\n            v3[v4][v6 + 1] += 1\n            v5.append([v4 + 1, v6 + 1, v4 + 1, v6 + 2])\nprint(len(v5))\nfor v4 in range(len(v5)):\n    print('%d %d %d %d' % (v5[v4][0], v5[v4][1], v5[v4][2], v5[v4][3]))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = [0 for v4 in range(v1)]\nfor v4 in range(v1):\n    v3[v4] = list(map(int, input().split()))\nv5 = []\nfor v4 in range(v1):\n    for v6 in range(v2):\n        if v4 == v1 - 1 and v6 == v2 - 1:\n            continue\n        if v6 == v2 - 1 and v3[v4][v6] % 2 == 1 and (v4 < v1 - 1):\n            v3[v4][v6] -= 1\n            v3[v4 + 1][v6] += 1\n            v5.append([v4 + 1, v6 + 1, v4 + 2, v6 + 1])\n        elif v3[v4][v6] % 2 == 1:\n            v3[v4][v6] -= 1\n            v3[v4][v6 + 1] += 1\n            v5.append([v4 + 1, v6 + 1, v4 + 1, v6 + 2])\nprint(len(v5))\nfor v4 in range(len(v5)):\n    print('%d %d %d %d' % (v5[v4][0], v5[v4][1], v5[v4][2], v5[v4][3]))\n"}
{"id": "llm_code\\shortest-path-visiting-all-nodes__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def shortestPathLength(self, a1):\n        v1 = len(a1)\n        v2 = (1 << v1) - 1\n        v3 = {}\n        v4 = collections.deque()\n        for v5 in range(v1):\n            v6 = 1 << v5\n            v3[v6, v5] = 0\n            v4.append((v6, v5))\n        while v4:\n            v6, v7 = v4.popleft()\n            v8 = v3[v6, v7]\n            for v9 in a1[v7]:\n                v10 = v6 | 1 << v9\n                v11 = (v10, v9)\n                if v11 not in v3:\n                    v3[v11] = v8 + 1\n                    v4.append(v11)\n        v12 = float('inf')\n        for v13 in range(v1):\n            v14 = (v2, v13)\n            if v14 in v3:\n                v12 = min(v12, v3[v14])\n        return v12\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def shortestPathLength(self, a1):\n        v1 = len(a1)\n        v2 = (1 << v1) - 1\n        v3 = {}\n        v4 = collections.deque()\n        for v5 in range(v1):\n            v6 = 1 << v5\n            v3[v6, v5] = 0\n            v4.append((v6, v5))\n        while v4:\n            v6, v7 = v4.popleft()\n            v8 = v3[v6, v7]\n            for v9 in a1[v7]:\n                v10 = v6 | 1 << v9\n                v11 = (v10, v9)\n                if v11 not in v3:\n                    v3[v11] = v8 + 1\n                    v4.append(v11)\n        v12 = float('inf')\n        for v13 in range(v1):\n            v14 = (v2, v13)\n            if v14 in v3:\n                v12 = min(v12, v3[v14])\n        return v12\n"}
{"id": "human_code\\p02787__s541093621.py", "text": "import bisect\nv1, v2 = map(int, list(input().split()))\nv3 = []\nv4 = 0\nfor v5 in range(v2):\n    v3.append(list(map(int, list(input().split()))))\n    v4 = max(v4, v3[-1][0])\nv6 = [int(1000000000.0)] * int(1000000.0)\nv7 = [False] * int(1000000.0)\nv6[0] = 0\nv8 = [0]\nwhile len(v8) > 0:\n    v9 = v8.pop(0)\n    if v9 > v1:\n        break\n    for v10 in range(v2):\n        if v7[v9 + v3[v10][0]] == False:\n            bisect.insort_right(v8, v9 + v3[v10][0])\n            v7[v9 + v3[v10][0]] = True\n        v6[v9 + v3[v10][0]] = min(v6[v9 + v3[v10][0]], v6[v9] + v3[v10][1])\nprint(min(v6[v9 - 1:]))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import bisect\nv1, v2 = map(int, list(input().split()))\nv3 = []\nv4 = 0\nfor v5 in range(v2):\n    v3.append(list(map(int, list(input().split()))))\n    v4 = max(v4, v3[-1][0])\nv6 = [int(1000000000.0)] * int(1000000.0)\nv7 = [False] * int(1000000.0)\nv6[0] = 0\nv8 = [0]\nwhile len(v8) > 0:\n    v9 = v8.pop(0)\n    if v9 > v1:\n        break\n    for v10 in range(v2):\n        if v7[v9 + v3[v10][0]] == False:\n            bisect.insort_right(v8, v9 + v3[v10][0])\n            v7[v9 + v3[v10][0]] = True\n        v6[v9 + v3[v10][0]] = min(v6[v9 + v3[v10][0]], v6[v9] + v3[v10][1])\nprint(min(v6[v9 - 1:]))\n"}
{"id": "human_code\\maximum-number-of-accepted-invitations__part4.py", "text": "import collections\n\nclass C1(object):\n\n    def maximumInvitations(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def augment(a1, a2, a3, a4):\n            for v1 in a1[a2]:\n                if v1 in a3:\n                    continue\n                a3.add(v1)\n                if v1 not in a4 or augment(a1, a4[v1], a3, a4):\n                    a4[v1] = a2\n                    return True\n            return False\n\n        def hungarian(a1):\n            v1 = {}\n            for v2 in a1.keys():\n                augment(a1, v2, set(), v1)\n            return len(v1)\n        v1 = collections.defaultdict(list)\n        for v2 in range(len(a1)):\n            for v3 in range(len(a1[0])):\n                if not a1[v2][v3]:\n                    continue\n                if len(a1) < len(a1[0]):\n                    v1[v2].append(v3)\n                else:\n                    v1[v3].append(v2)\n        return hungarian(v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def maximumInvitations(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def augment(a1, a2, a3, a4):\n            for v1 in a1[a2]:\n                if v1 in a3:\n                    continue\n                a3.add(v1)\n                if v1 not in a4 or augment(a1, a4[v1], a3, a4):\n                    a4[v1] = a2\n                    return True\n            return False\n\n        def hungarian(a1):\n            v1 = {}\n            for v2 in a1.keys():\n                augment(a1, v2, set(), v1)\n            return len(v1)\n        v1 = collections.defaultdict(list)\n        for v2 in range(len(a1)):\n            for v3 in range(len(a1[0])):\n                if not a1[v2][v3]:\n                    continue\n                if len(a1) < len(a1[0]):\n                    v1[v2].append(v3)\n                else:\n                    v1[v3].append(v2)\n        return hungarian(v1)\n"}
{"id": "human_code\\difference-between-maximum-and-minimum-price-sum__part2.py", "text": "class C1(object):\n\n    def maxOutput(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            v1 = [a3[a1], 0]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v3 = dfs(v2, a1)\n                result[0] = max(result[0], v1[0] + v3[1], v1[1] + v3[0])\n                v1[0] = max(v1[0], v3[0] + a3[a1])\n                v1[1] = max(v1[1], v3[1] + a3[a1])\n            return v1\n        v1 = [0]\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5 in a2:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        dfs(0, -1)\n        return v1[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxOutput(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            v1 = [a3[a1], 0]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v3 = dfs(v2, a1)\n                result[0] = max(result[0], v1[0] + v3[1], v1[1] + v3[0])\n                v1[0] = max(v1[0], v3[0] + a3[a1])\n                v1[1] = max(v1[1], v3[1] + a3[a1])\n            return v1\n        v1 = [0]\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5 in a2:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        dfs(0, -1)\n        return v1[0]\n"}
{"id": "llm_code\\deepest-leaves-sum__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def deepestLeavesSum(self, a1):\n        if not a1:\n            return 0\n        v1 = [a1]\n        while v1:\n            v2 = []\n            for v3 in v1:\n                if v3.left:\n                    v2.append(v3.left)\n                if v3.right:\n                    v2.append(v3.right)\n            if not v2:\n                return sum((v3.val for v3 in v1))\n            v1 = v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def deepestLeavesSum(self, a1):\n        if not a1:\n            return 0\n        v1 = [a1]\n        while v1:\n            v2 = []\n            for v3 in v1:\n                if v3.left:\n                    v2.append(v3.left)\n                if v3.right:\n                    v2.append(v3.right)\n            if not v2:\n                return sum((v3.val for v3 in v1))\n            v1 = v2\n"}
{"id": "llm_code\\lexicographically-smallest-string-after-applying-operations__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def findLexSmallestString(self, a1, a2, a3):\n        v1 = {a1}\n        v2 = deque([a1])\n        v3 = a1\n        v4 = len(a1)\n        while v2:\n            v5 = v2.popleft()\n            if v5 < v3:\n                v3 = v5\n            v6 = list(v5)\n            for v7 in range(1, v4, 2):\n                v8 = int(v6[v7])\n                v6[v7] = str((v8 + a2) % 10)\n            v9 = ''.join(v6)\n            if v9 not in v1:\n                v1.add(v9)\n                v2.append(v9)\n            v10 = v5[a3:] + v5[:a3]\n            if v10 not in v1:\n                v1.add(v10)\n                v2.append(v10)\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def findLexSmallestString(self, a1, a2, a3):\n        v1 = {a1}\n        v2 = deque([a1])\n        v3 = a1\n        v4 = len(a1)\n        while v2:\n            v5 = v2.popleft()\n            if v5 < v3:\n                v3 = v5\n            v6 = list(v5)\n            for v7 in range(1, v4, 2):\n                v8 = int(v6[v7])\n                v6[v7] = str((v8 + a2) % 10)\n            v9 = ''.join(v6)\n            if v9 not in v1:\n                v1.add(v9)\n                v2.append(v9)\n            v10 = v5[a3:] + v5[:a3]\n            if v10 not in v1:\n                v1.add(v10)\n                v2.append(v10)\n        return v3\n"}
{"id": "llm_code\\insert-delete-getrandom-o1__grok-4.1-fast__v1.py", "text": "import random\n\nclass C1:\n\n    def __init__(self):\n        self.container = []\n        self.mapping = {}\n\n    def insert(self, a1):\n        if a1 in self.mapping:\n            return False\n        self.mapping[a1] = len(self.container)\n        self.container.append(a1)\n        return True\n\n    def remove(self, a1):\n        if a1 not in self.mapping:\n            return False\n        v1 = self.mapping[a1]\n        if v1 != len(self.container) - 1:\n            v2 = self.container[-1]\n            self.container[v1] = v2\n            self.mapping[v2] = v1\n        self.container.pop()\n        del self.mapping[a1]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.container)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1:\n\n    def __init__(self):\n        self.container = []\n        self.mapping = {}\n\n    def insert(self, a1):\n        if a1 in self.mapping:\n            return False\n        self.mapping[a1] = len(self.container)\n        self.container.append(a1)\n        return True\n\n    def remove(self, a1):\n        if a1 not in self.mapping:\n            return False\n        v1 = self.mapping[a1]\n        if v1 != len(self.container) - 1:\n            v2 = self.container[-1]\n            self.container[v1] = v2\n            self.mapping[v2] = v1\n        self.container.pop()\n        del self.mapping[a1]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.container)\n"}
{"id": "human_code\\merge-k-sorted-lists__part2.py", "text": "class C1(object):\n\n    def mergeKLists(self, a1):\n\n        def mergeTwoLists(a1, a2):\n            v1 = v2 = ListNode(0)\n            while a1 and a2:\n                if a1.val < a2.val:\n                    v1.next = a1\n                    a1 = a1.__next__\n                else:\n                    v1.next = a2\n                    a2 = a2.__next__\n                v1 = v1.__next__\n            v1.next = a1 or a2\n            return v2.__next__\n\n        def mergeKListsHelper(a1, a2, a3):\n            if a2 > a3:\n                return None\n            if a2 == a3:\n                return a1[a2]\n            return mergeTwoLists(mergeKListsHelper(a1, a2, (a2 + a3) / 2), mergeKListsHelper(a1, (a2 + a3) / 2 + 1, a3))\n        return mergeKListsHelper(a1, 0, len(a1) - 1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def mergeKLists(self, a1):\n\n        def mergeTwoLists(a1, a2):\n            v1 = v2 = ListNode(0)\n            while a1 and a2:\n                if a1.val < a2.val:\n                    v1.next = a1\n                    a1 = a1.__next__\n                else:\n                    v1.next = a2\n                    a2 = a2.__next__\n                v1 = v1.__next__\n            v1.next = a1 or a2\n            return v2.__next__\n\n        def mergeKListsHelper(a1, a2, a3):\n            if a2 > a3:\n                return None\n            if a2 == a3:\n                return a1[a2]\n            return mergeTwoLists(mergeKListsHelper(a1, a2, (a2 + a3) / 2), mergeKListsHelper(a1, (a2 + a3) / 2 + 1, a3))\n        return mergeKListsHelper(a1, 0, len(a1) - 1)\n"}
{"id": "llm_code\\maximum-students-taking-exam__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxStudents(self, a1):\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = len(a1[0])\n        v3 = sum((s.count('.') for v4 in a1))\n        v5 = []\n        v6 = []\n        v7 = {}\n        v8 = {}\n        v9 = 0\n        v10 = 0\n        for v11 in range(v1):\n            for v12 in range(v2):\n                if a1[v11][v12] == '.':\n                    if v12 % 2 == 0:\n                        v5.append((v11, v12))\n                        v7[v11, v12] = v9\n                        v9 += 1\n                    else:\n                        v6.append((v11, v12))\n                        v8[v11, v12] = v10\n                        v10 += 1\n        v13 = len(v5)\n        v14 = len(v6)\n        v15 = [[] for v16 in range(v13)]\n        v17 = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]\n        for v18 in range(v13):\n            v19, v20 = v5[v18]\n            for v21, v22 in v17:\n                v23, v24 = (v19 + v21, v20 + v22)\n                if 0 <= v23 < v1 and 0 <= v24 < v2 and (a1[v23][v24] == '.') and (v24 % 2 == 1):\n                    if (v23, v24) in v8:\n                        v15[v18].append(v8[v23, v24])\n        v25 = [-1] * v14\n        v26 = [-1] * v13\n        v27 = [False] * v14\n\n        def find_path(a1):\n            for v1 in v15[a1]:\n                if v27[v1]:\n                    continue\n                v27[v1] = True\n                if v25[v1] == -1 or find_path(v25[v1]):\n                    v25[v1] = a1\n                    v26[a1] = v1\n                    return True\n            return False\n        v28 = 0\n        for v18 in range(v13):\n            if v26[v18] == -1:\n                v27 = [False] * v14\n                if find_path(v18):\n                    v28 += 1\n        return v3 - v28\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxStudents(self, a1):\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = len(a1[0])\n        v3 = sum((s.count('.') for v4 in a1))\n        v5 = []\n        v6 = []\n        v7 = {}\n        v8 = {}\n        v9 = 0\n        v10 = 0\n        for v11 in range(v1):\n            for v12 in range(v2):\n                if a1[v11][v12] == '.':\n                    if v12 % 2 == 0:\n                        v5.append((v11, v12))\n                        v7[v11, v12] = v9\n                        v9 += 1\n                    else:\n                        v6.append((v11, v12))\n                        v8[v11, v12] = v10\n                        v10 += 1\n        v13 = len(v5)\n        v14 = len(v6)\n        v15 = [[] for v16 in range(v13)]\n        v17 = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]\n        for v18 in range(v13):\n            v19, v20 = v5[v18]\n            for v21, v22 in v17:\n                v23, v24 = (v19 + v21, v20 + v22)\n                if 0 <= v23 < v1 and 0 <= v24 < v2 and (a1[v23][v24] == '.') and (v24 % 2 == 1):\n                    if (v23, v24) in v8:\n                        v15[v18].append(v8[v23, v24])\n        v25 = [-1] * v14\n        v26 = [-1] * v13\n        v27 = [False] * v14\n\n        def find_path(a1):\n            for v1 in v15[a1]:\n                if v27[v1]:\n                    continue\n                v27[v1] = True\n                if v25[v1] == -1 or find_path(v25[v1]):\n                    v25[v1] = a1\n                    v26[a1] = v1\n                    return True\n            return False\n        v28 = 0\n        for v18 in range(v13):\n            if v26[v18] == -1:\n                v27 = [False] * v14\n                if find_path(v18):\n                    v28 += 1\n        return v3 - v28\n"}
{"id": "human_code\\split-message-based-on-limit.py", "text": "class C1(object):\n\n    def splitMessage(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3, v4 = (1, 1, len(a1) + 1, 1)\n        while 3 + v2 * 2 < a2:\n            if v3 + (3 + v2) * v1 <= a2 * v1:\n                break\n            v1 += 1\n            if v1 == v4 * 10:\n                v2 += 1\n                v4 *= 10\n            v3 += v2\n        if 3 + v2 * 2 >= a2:\n            return []\n        v5 = []\n        v6 = 0\n        for v7 in range(v1):\n            v2 = a2 - (3 + len(str(v7 + 1)) + len(str(v1)))\n            v5.append('%s<%s/%s>' % (a1[v6:v6 + v2], v7 + 1, v1))\n            v6 += v2\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def splitMessage(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3, v4 = (1, 1, len(a1) + 1, 1)\n        while 3 + v2 * 2 < a2:\n            if v3 + (3 + v2) * v1 <= a2 * v1:\n                break\n            v1 += 1\n            if v1 == v4 * 10:\n                v2 += 1\n                v4 *= 10\n            v3 += v2\n        if 3 + v2 * 2 >= a2:\n            return []\n        v5 = []\n        v6 = 0\n        for v7 in range(v1):\n            v2 = a2 - (3 + len(str(v7 + 1)) + len(str(v1)))\n            v5.append('%s<%s/%s>' % (a1[v6:v6 + v2], v7 + 1, v1))\n            v6 += v2\n        return v5\n"}
{"id": "human_code\\design-skiplist.py", "text": "import random\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.num = a2\n        self.nexts = [None] * a1\n\nclass C2(object):\n    v1, v2 = (1, 2)\n    v3 = 32\n\n    def __init__(self):\n        self.__head = C1()\n        self.__len = 0\n\n    def search(self, a1):\n        \"\"\"\n        \"\"\"\n        return True if self.__find(a1, self.__find_prev_nodes(a1)) else False\n\n    def add(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = C1(self.__random_level(), a1)\n        if len(self.__head.nexts) < len(v1.nexts):\n            self.__head.nexts.extend([None] * (len(v1.nexts) - len(self.__head.nexts)))\n        v2 = self.__find_prev_nodes(a1)\n        for v3 in range(len(v1.nexts)):\n            v1.nexts[v3] = v2[v3].nexts[v3]\n            v2[v3].nexts[v3] = v1\n        self.__len += 1\n\n    def erase(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = self.__find_prev_nodes(a1)\n        v2 = self.__find(a1, v1)\n        if not v2:\n            return False\n        self.__len -= 1\n        for v3 in reversed(range(len(v2.nexts))):\n            v1[v3].nexts[v3] = v2.nexts[v3]\n            if not self.__head.nexts[v3]:\n                self.__head.nexts.pop()\n        return True\n\n    def __find(self, a1, a2):\n        if a2:\n            v1 = a2[0].nexts[0]\n            if v1 and v1.num == a1:\n                return v1\n        return None\n\n    def __find_prev_nodes(self, a1):\n        v1 = [None] * len(self.__head.nexts)\n        v2 = self.__head\n        for v3 in reversed(range(len(self.__head.nexts))):\n            while v2.nexts[v3] and v2.nexts[v3].num < a1:\n                v2 = v2.nexts[v3]\n            v1[v3] = v2\n        return v1\n\n    def __random_level(self):\n        v1 = 1\n        while random.randint(1, C2.P_DENOMINATOR) <= C2.P_NUMERATOR and v1 < C2.MAX_LEVEL:\n            v1 += 1\n        return v1\n\n    def __len__(self):\n        return self.__len\n\n    def __str__(self):\n        v1 = []\n        for v2 in reversed(range(len(self.__head.nexts))):\n            v1.append([])\n            v3 = self.__head.nexts[v2]\n            while v3:\n                v1[-1].append(str(v3.num))\n                v3 = v3.nexts[v2]\n        return '\\n'.join(['->'.join(x) for v4 in v1])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.num = a2\n        self.nexts = [None] * a1\n\nclass C2(object):\n    v1, v2 = (1, 2)\n    v3 = 32\n\n    def __init__(self):\n        self.__head = C1()\n        self.__len = 0\n\n    def search(self, a1):\n        \"\"\"\n        \"\"\"\n        return True if self.__find(a1, self.__find_prev_nodes(a1)) else False\n\n    def add(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = C1(self.__random_level(), a1)\n        if len(self.__head.nexts) < len(v1.nexts):\n            self.__head.nexts.extend([None] * (len(v1.nexts) - len(self.__head.nexts)))\n        v2 = self.__find_prev_nodes(a1)\n        for v3 in range(len(v1.nexts)):\n            v1.nexts[v3] = v2[v3].nexts[v3]\n            v2[v3].nexts[v3] = v1\n        self.__len += 1\n\n    def erase(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = self.__find_prev_nodes(a1)\n        v2 = self.__find(a1, v1)\n        if not v2:\n            return False\n        self.__len -= 1\n        for v3 in reversed(range(len(v2.nexts))):\n            v1[v3].nexts[v3] = v2.nexts[v3]\n            if not self.__head.nexts[v3]:\n                self.__head.nexts.pop()\n        return True\n\n    def __find(self, a1, a2):\n        if a2:\n            v1 = a2[0].nexts[0]\n            if v1 and v1.num == a1:\n                return v1\n        return None\n\n    def __find_prev_nodes(self, a1):\n        v1 = [None] * len(self.__head.nexts)\n        v2 = self.__head\n        for v3 in reversed(range(len(self.__head.nexts))):\n            while v2.nexts[v3] and v2.nexts[v3].num < a1:\n                v2 = v2.nexts[v3]\n            v1[v3] = v2\n        return v1\n\n    def __random_level(self):\n        v1 = 1\n        while random.randint(1, C2.P_DENOMINATOR) <= C2.P_NUMERATOR and v1 < C2.MAX_LEVEL:\n            v1 += 1\n        return v1\n\n    def __len__(self):\n        return self.__len\n\n    def __str__(self):\n        v1 = []\n        for v2 in reversed(range(len(self.__head.nexts))):\n            v1.append([])\n            v3 = self.__head.nexts[v2]\n            while v3:\n                v1[-1].append(str(v3.num))\n                v3 = v3.nexts[v2]\n        return '\\n'.join(['->'.join(x) for v4 in v1])\n"}
{"id": "llm_code\\p03039__s411344393.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    v1 = 1\n    if a1 < 2 * a2:\n        a2 = a1 - a2\n    for v3 in range(1, a2 + 1):\n        v1 = v1 * (a1 - v3 + 1) / v3 % v4\n    return v1\nif v3 == 2:\n    v5 = 0\nelse:\n    v6 = 0\n    v7 = 0\n    for v8 in range(1, v1):\n        v6 += v8 * (v1 - v8)\n    for v8 in range(1, v2):\n        v7 += v8 * (v2 - v8)\n    v6 *= v2 ** 2\n    v7 *= v1 ** 2\n    v5 = f1(v1 * v2 - 2, v3 - 2) % v4\n    v5 *= v6 + v7\nprint(int(v5 % v4))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    v1 = 1\n    if a1 < 2 * a2:\n        a2 = a1 - a2\n    for v3 in range(1, a2 + 1):\n        v1 = v1 * (a1 - v3 + 1) / v3 % v4\n    return v1\nif v3 == 2:\n    v5 = 0\nelse:\n    v6 = 0\n    v7 = 0\n    for v8 in range(1, v1):\n        v6 += v8 * (v1 - v8)\n    for v8 in range(1, v2):\n        v7 += v8 * (v2 - v8)\n    v6 *= v2 ** 2\n    v7 *= v1 ** 2\n    v5 = f1(v1 * v2 - 2, v3 - 2) % v4\n    v5 *= v6 + v7\nprint(int(v5 % v4))\n"}
{"id": "llm_code\\best-meeting-point__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minTotalDistance(self, a1):\n        v1 = []\n        v2 = []\n        v3 = len(a1)\n        v4 = len(a1[0]) if a1 else 0\n        for v5 in range(v3):\n            for v6 in range(v4):\n                if a1[v5][v6] == 1:\n                    v1.append(v5)\n                    v2.append(v6)\n        v1.sort()\n        v2.sort()\n        v7 = len(v1)\n        if v7 == 0:\n            return 0\n        v8 = v1[v7 // 2]\n        v9 = v2[v7 // 2]\n        v10 = 0\n        for v11 in v1:\n            v10 += abs(v11 - v8)\n        for v12 in v2:\n            v10 += abs(v12 - v9)\n        return v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minTotalDistance(self, a1):\n        v1 = []\n        v2 = []\n        v3 = len(a1)\n        v4 = len(a1[0]) if a1 else 0\n        for v5 in range(v3):\n            for v6 in range(v4):\n                if a1[v5][v6] == 1:\n                    v1.append(v5)\n                    v2.append(v6)\n        v1.sort()\n        v2.sort()\n        v7 = len(v1)\n        if v7 == 0:\n            return 0\n        v8 = v1[v7 // 2]\n        v9 = v2[v7 // 2]\n        v10 = 0\n        for v11 in v1:\n            v10 += abs(v11 - v8)\n        for v12 in v2:\n            v10 += abs(v12 - v9)\n        return v10\n"}
{"id": "human_code\\01-matrix__part2.py", "text": "class C1(object):\n\n    def updateMatrix(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [[float('inf')] * len(a1[0]) for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            for v4 in range(len(a1[v3])):\n                if a1[v3][v4] == 0:\n                    v1[v3][v4] = 0\n                else:\n                    if v3 > 0:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3 - 1][v4] + 1)\n                    if v4 > 0:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3][v4 - 1] + 1)\n        for v3 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[v3]))):\n                if a1[v3][v4] == 0:\n                    v1[v3][v4] = 0\n                else:\n                    if v3 < len(a1) - 1:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3 + 1][v4] + 1)\n                    if v4 < len(a1[v3]) - 1:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3][v4 + 1] + 1)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def updateMatrix(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [[float('inf')] * len(a1[0]) for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            for v4 in range(len(a1[v3])):\n                if a1[v3][v4] == 0:\n                    v1[v3][v4] = 0\n                else:\n                    if v3 > 0:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3 - 1][v4] + 1)\n                    if v4 > 0:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3][v4 - 1] + 1)\n        for v3 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[v3]))):\n                if a1[v3][v4] == 0:\n                    v1[v3][v4] = 0\n                else:\n                    if v3 < len(a1) - 1:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3 + 1][v4] + 1)\n                    if v4 < len(a1[v3]) - 1:\n                        v1[v3][v4] = min(v1[v3][v4], v1[v3][v4 + 1] + 1)\n        return v1\n"}
{"id": "human_code\\p03026__s751532845.py", "text": "import sys\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = [set() for v3 in range(v1)]\nv4 = [[int(v3) - 1 for v3 in input().split()] for v5 in range(v1 - 1)]\nv6 = ['' for v3 in range(v1)]\nv7 = [int(v3) for v3 in input().split()]\nv7.sort()\nv8 = sum(v7[:-1])\nv9 = []\nfor v3, v10 in v4:\n    v2[v3].add(v10)\n    v2[v10].add(v3)\nfor v3, v11 in enumerate(v2):\n    if len(list(v11)) == 1:\n        v9.append(v3)\nfor v5 in range(v1 - 1):\n    v3 = v9.pop(0)\n    v10 = list(v2[v3])[0]\n    v6[v3] = str(v7.pop(0))\n    v2[v10].remove(v3)\n    if len(list(v2[v10])) == 1:\n        v9.append(v10)\nv3 = v9.pop(0)\nv6[v3] = str(v7.pop(0))\nprint(v8)\nprint(' '.join(v6))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = [set() for v3 in range(v1)]\nv4 = [[int(v3) - 1 for v3 in input().split()] for v5 in range(v1 - 1)]\nv6 = ['' for v3 in range(v1)]\nv7 = [int(v3) for v3 in input().split()]\nv7.sort()\nv8 = sum(v7[:-1])\nv9 = []\nfor v3, v10 in v4:\n    v2[v3].add(v10)\n    v2[v10].add(v3)\nfor v3, v11 in enumerate(v2):\n    if len(list(v11)) == 1:\n        v9.append(v3)\nfor v5 in range(v1 - 1):\n    v3 = v9.pop(0)\n    v10 = list(v2[v3])[0]\n    v6[v3] = str(v7.pop(0))\n    v2[v10].remove(v3)\n    if len(list(v2[v10])) == 1:\n        v9.append(v10)\nv3 = v9.pop(0)\nv6[v3] = str(v7.pop(0))\nprint(v8)\nprint(' '.join(v6))\n"}
{"id": "human_code\\remove-k-balanced-substrings.py", "text": "class C1(object):\n\n    def removeSubstring(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def count(a1):\n            if a1 == '(':\n                if cnt[0] < a2:\n                    cnt[0] += 1\n                elif cnt[0] > a2:\n                    cnt[0] = 1\n            elif cnt[0] >= a2:\n                cnt[0] += 1\n            else:\n                cnt[0] = 0\n        v1 = []\n        v2 = [0]\n        for v3 in a1:\n            v1.append(v3)\n            count(v3)\n            if v2[0] != 2 * a2:\n                continue\n            for v4 in range(2 * a2):\n                v1.pop()\n            v2[0] = 0\n            for v5 in range(max(len(v1) - (2 * a2 - 1), 0), len(v1)):\n                count(v1[v5])\n        return ''.join(v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def removeSubstring(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def count(a1):\n            if a1 == '(':\n                if cnt[0] < a2:\n                    cnt[0] += 1\n                elif cnt[0] > a2:\n                    cnt[0] = 1\n            elif cnt[0] >= a2:\n                cnt[0] += 1\n            else:\n                cnt[0] = 0\n        v1 = []\n        v2 = [0]\n        for v3 in a1:\n            v1.append(v3)\n            count(v3)\n            if v2[0] != 2 * a2:\n                continue\n            for v4 in range(2 * a2):\n                v1.pop()\n            v2[0] = 0\n            for v5 in range(max(len(v1) - (2 * a2 - 1), 0), len(v1)):\n                count(v1[v5])\n        return ''.join(v1)\n"}
{"id": "llm_code\\out-of-boundary-paths__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def findPaths(self, a1, a2, a3, a4, a5):\n        v1 = 10 ** 9 + 7\n        v2 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        v3 = [[0] * a2 for v4 in range(a1)]\n        v3[a4][a5] = 1\n        v5 = 0\n        for v4 in range(a3):\n            v6 = [[0] * a2 for v4 in range(a1)]\n            for v7 in range(a1):\n                for v8 in range(a2):\n                    v9 = v3[v7][v8]\n                    for v10, v11 in v2:\n                        v12, v13 = (v7 + v10, v8 + v11)\n                        if 0 <= v12 < a1 and 0 <= v13 < a2:\n                            v6[v12][v13] = (v6[v12][v13] + v9) % v1\n                        else:\n                            v5 = (v5 + v9) % v1\n            v3 = v6\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findPaths(self, a1, a2, a3, a4, a5):\n        v1 = 10 ** 9 + 7\n        v2 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        v3 = [[0] * a2 for v4 in range(a1)]\n        v3[a4][a5] = 1\n        v5 = 0\n        for v4 in range(a3):\n            v6 = [[0] * a2 for v4 in range(a1)]\n            for v7 in range(a1):\n                for v8 in range(a2):\n                    v9 = v3[v7][v8]\n                    for v10, v11 in v2:\n                        v12, v13 = (v7 + v10, v8 + v11)\n                        if 0 <= v12 < a1 and 0 <= v13 < a2:\n                            v6[v12][v13] = (v6[v12][v13] + v9) % v1\n                        else:\n                            v5 = (v5 + v9) % v1\n            v3 = v6\n        return v5\n"}
{"id": "llm_code\\graph-connectivity-with-threshold__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n        self.rank = [0] * a1\n\n    def find(self, a1):\n        v1 = a1\n        while self.parent[v1] != v1:\n            v1 = self.parent[v1]\n        v2 = a1\n        while v2 != v1:\n            v3 = self.parent[v2]\n            self.parent[v2] = v1\n            v2 = v3\n        return v1\n\n    def merge(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return\n        if self.rank[v1] < self.rank[v2]:\n            self.parent[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.parent[v2] = v1\n        else:\n            self.parent[v2] = v1\n            self.rank[v1] += 1\n\nclass C2:\n\n    def areConnected(self, a1, a2, a3):\n        v1 = C1(a1)\n        for v2 in range(a2 + 1, a1 + 1):\n            v3 = v2 * 2\n            while v3 <= a1:\n                v1.merge(v2 - 1, v3 - 1)\n                v3 += v2\n        v4 = []\n        for v5 in a3:\n            v6, v7 = v5\n            v4.append(v1.find(v6 - 1) == v1.find(v7 - 1))\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n        self.rank = [0] * a1\n\n    def find(self, a1):\n        v1 = a1\n        while self.parent[v1] != v1:\n            v1 = self.parent[v1]\n        v2 = a1\n        while v2 != v1:\n            v3 = self.parent[v2]\n            self.parent[v2] = v1\n            v2 = v3\n        return v1\n\n    def merge(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return\n        if self.rank[v1] < self.rank[v2]:\n            self.parent[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.parent[v2] = v1\n        else:\n            self.parent[v2] = v1\n            self.rank[v1] += 1\n\nclass C2:\n\n    def areConnected(self, a1, a2, a3):\n        v1 = C1(a1)\n        for v2 in range(a2 + 1, a1 + 1):\n            v3 = v2 * 2\n            while v3 <= a1:\n                v1.merge(v2 - 1, v3 - 1)\n                v3 += v2\n        v4 = []\n        for v5 in a3:\n            v6, v7 = v5\n            v4.append(v1.find(v6 - 1) == v1.find(v7 - 1))\n        return v4\n"}
{"id": "human_code\\p03838__s252368456.py", "text": "import math\nimport queue\nfrom collections import deque, defaultdict\nimport heapq as hpq\nfrom sys import stdin, setrecursionlimit\nv1 = stdin.readline\nsetrecursionlimit(10 ** 7)\n\ndef f1():\n    v1, v2 = map(int, v1().split())\n    if v1 < v2:\n        v3 = v2 - v1\n    else:\n        v3 = v1 - v2 + 2\n    if v1 * v2 < 0:\n        v3 = min(v3, abs(abs(v1) - abs(v2)) + 1)\n    elif v1 == 0:\n        if v2 < 0:\n            v3 = abs(v2) + 1\n    elif v2 == 0:\n        if v1 > 0:\n            v3 = v1 + 1\n    print(v3)\n    return\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math\nimport queue\nfrom collections import deque, defaultdict\nimport heapq as hpq\nfrom sys import stdin, setrecursionlimit\nv1 = stdin.readline\nsetrecursionlimit(10 ** 7)\n\ndef f1():\n    v1, v2 = map(int, v1().split())\n    if v1 < v2:\n        v3 = v2 - v1\n    else:\n        v3 = v1 - v2 + 2\n    if v1 * v2 < 0:\n        v3 = min(v3, abs(abs(v1) - abs(v2)) + 1)\n    elif v1 == 0:\n        if v2 < 0:\n            v3 = abs(v2) + 1\n    elif v2 == 0:\n        if v1 > 0:\n            v3 = v1 + 1\n    print(v3)\n    return\nif __name__ == '__main__':\n    f1()\n"}
{"id": "llm_code\\count-unhappy-friends__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def unhappyFriends(self, a1, a2, a3):\n        v1 = [[0] * a1 for v2 in range(a1)]\n        for v3 in range(a1):\n            for v4, v5 in enumerate(a2[v3]):\n                v1[v3][v5] = v4\n        v6 = [-1] * a1\n        for v7, v8 in a3:\n            v6[v7] = v8\n            v6[v8] = v7\n        v9 = 0\n        for v10 in range(a1):\n            v11 = v6[v10]\n            v12 = False\n            for v13 in range(a1):\n                if v13 == v10 or v13 == v11:\n                    continue\n                v14 = v1[v10][v13] < v1[v10][v11]\n                v15 = v1[v13][v10] < v1[v13][v6[v13]]\n                if v14 and v15:\n                    v12 = True\n                    break\n            if v12:\n                v9 += 1\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def unhappyFriends(self, a1, a2, a3):\n        v1 = [[0] * a1 for v2 in range(a1)]\n        for v3 in range(a1):\n            for v4, v5 in enumerate(a2[v3]):\n                v1[v3][v5] = v4\n        v6 = [-1] * a1\n        for v7, v8 in a3:\n            v6[v7] = v8\n            v6[v8] = v7\n        v9 = 0\n        for v10 in range(a1):\n            v11 = v6[v10]\n            v12 = False\n            for v13 in range(a1):\n                if v13 == v10 or v13 == v11:\n                    continue\n                v14 = v1[v10][v13] < v1[v10][v11]\n                v15 = v1[v13][v10] < v1[v13][v6[v13]]\n                if v14 and v15:\n                    v12 = True\n                    break\n            if v12:\n                v9 += 1\n        return v9\n"}
{"id": "human_code\\p02990__s991284000.py", "text": "\"\"\"\nD - Blue and Red Balls\nhttps://atcoder.jp/contests/abc132/tasks/abc132_d\n\n\"\"\"\nimport sys\nv1 = [1]\nfor v2 in range(1, 2001):\n    v1.append(v1[-1] * v2)\n\ndef f1(a1, a2):\n    v1 = 10 ** 9 + 7\n    v2 = []\n    for v3 in range(1, a2 + 1):\n        v4 = v1[a2 - 1] // (v1[v3 - 1] * v1[a2 - 1 - v3 + 1])\n        v5 = v1[a1 - a2 + 1] // (v1[v3] * v1[a1 - a2 + 1 - v3])\n        v2.append(v4 * v5 % v1)\n    return v2\n\ndef f2(a1):\n    v1, v2 = map(int, input().split())\n    v3 = f1(v1, v2)\n    print(*v3, sep='\\n')\nif __name__ == '__main__':\n    f2(sys.argv[1:])\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "\"\"\"\nD - Blue and Red Balls\nhttps://atcoder.jp/contests/abc132/tasks/abc132_d\n\n\"\"\"\nimport sys\nv1 = [1]\nfor v2 in range(1, 2001):\n    v1.append(v1[-1] * v2)\n\ndef f1(a1, a2):\n    v1 = 10 ** 9 + 7\n    v2 = []\n    for v3 in range(1, a2 + 1):\n        v4 = v1[a2 - 1] // (v1[v3 - 1] * v1[a2 - 1 - v3 + 1])\n        v5 = v1[a1 - a2 + 1] // (v1[v3] * v1[a1 - a2 + 1 - v3])\n        v2.append(v4 * v5 % v1)\n    return v2\n\ndef f2(a1):\n    v1, v2 = map(int, input().split())\n    v3 = f1(v1, v2)\n    print(*v3, sep='\\n')\nif __name__ == '__main__':\n    f2(sys.argv[1:])\n"}
{"id": "human_code\\p03073__s111127061.py", "text": "import sys\ninput = sys.stdin.readline\nv1 = list(map(int, input().rstrip('\\n')))\nv2 = []\nv3 = []\nfor v4 in range(len(v1)):\n    if v4 % 2 == 0:\n        v2.append(0)\n        v3.append(1)\n    else:\n        v2.append(1)\n        v3.append(0)\nv5 = 0\nv6 = 0\nfor v4 in range(len(v1)):\n    if v2[v4] != v1[v4]:\n        v5 += 1\n    if v3[v4] != v1[v4]:\n        v6 += 1\nprint(min(v5, v6))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nv1 = list(map(int, input().rstrip('\\n')))\nv2 = []\nv3 = []\nfor v4 in range(len(v1)):\n    if v4 % 2 == 0:\n        v2.append(0)\n        v3.append(1)\n    else:\n        v2.append(1)\n        v3.append(0)\nv5 = 0\nv6 = 0\nfor v4 in range(len(v1)):\n    if v2[v4] != v1[v4]:\n        v5 += 1\n    if v3[v4] != v1[v4]:\n        v6 += 1\nprint(min(v5, v6))\n"}
{"id": "llm_code\\maximize-the-minimum-powered-city__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxPower(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n        v4 = min((v2[min(v1, v3 + a2 + 1)] - v2[max(0, v3 - a2)] for v3 in range(v1)))\n\n        def feasible(a1):\n            v1 = list(a1)\n            v2 = a3\n            v3 = min(v1 - 1, a2)\n            v4 = sum(v1[:v3 + 1])\n            for v5 in range(v1):\n                if v4 < a1:\n                    v6 = a1 - v4\n                    if v6 > v2:\n                        return False\n                    v2 -= v6\n                    v4 += v6\n                    v7 = min(v1 - 1, v5 + a2)\n                    v1[v7] += v6\n                if v5 == v1 - 1:\n                    break\n                v8 = max(0, v5 - a2)\n                v9 = max(0, v5 + 1 - a2)\n                v10 = min(v1 - 1, v5 + a2)\n                v11 = min(v1 - 1, v5 + 1 + a2)\n                if v9 > v8:\n                    v4 -= v1[v8]\n                if v11 > v10:\n                    v4 += v1[v11]\n            return True\n        v5, v6 = (v4, v4 + a3)\n        while v5 < v6:\n            v7 = (v5 + v6 + 1) // 2\n            if feasible(v7):\n                v5 = v7\n            else:\n                v6 = v7 - 1\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxPower(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n        v4 = min((v2[min(v1, v3 + a2 + 1)] - v2[max(0, v3 - a2)] for v3 in range(v1)))\n\n        def feasible(a1):\n            v1 = list(a1)\n            v2 = a3\n            v3 = min(v1 - 1, a2)\n            v4 = sum(v1[:v3 + 1])\n            for v5 in range(v1):\n                if v4 < a1:\n                    v6 = a1 - v4\n                    if v6 > v2:\n                        return False\n                    v2 -= v6\n                    v4 += v6\n                    v7 = min(v1 - 1, v5 + a2)\n                    v1[v7] += v6\n                if v5 == v1 - 1:\n                    break\n                v8 = max(0, v5 - a2)\n                v9 = max(0, v5 + 1 - a2)\n                v10 = min(v1 - 1, v5 + a2)\n                v11 = min(v1 - 1, v5 + 1 + a2)\n                if v9 > v8:\n                    v4 -= v1[v8]\n                if v11 > v10:\n                    v4 += v1[v11]\n            return True\n        v5, v6 = (v4, v4 + a3)\n        while v5 < v6:\n            v7 = (v5 + v6 + 1) // 2\n            if feasible(v7):\n                v5 = v7\n            else:\n                v6 = v7 - 1\n        return v5\n"}
{"id": "llm_code\\special-permutations__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def specialPerm(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = 1 << v2\n        v4 = [[0] * v2 for v5 in range(v3)]\n        for v6 in range(v2):\n            v4[1 << v6][v6] = 1\n        for v7 in range(v3):\n            for v8 in range(v2):\n                if v4[v7][v8] == 0:\n                    continue\n                for v9 in range(v2):\n                    if v7 & 1 << v9:\n                        continue\n                    v10, v11 = (a1[v8], a1[v9])\n                    if v10 % v11 == 0 or v11 % v10 == 0:\n                        v4[v7 | 1 << v9][v9] = (v4[v7 | 1 << v9][v9] + v4[v7][v8]) % v1\n        v12 = (1 << v2) - 1\n        return sum(v4[v12]) % v1 if v2 else 1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def specialPerm(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = 1 << v2\n        v4 = [[0] * v2 for v5 in range(v3)]\n        for v6 in range(v2):\n            v4[1 << v6][v6] = 1\n        for v7 in range(v3):\n            for v8 in range(v2):\n                if v4[v7][v8] == 0:\n                    continue\n                for v9 in range(v2):\n                    if v7 & 1 << v9:\n                        continue\n                    v10, v11 = (a1[v8], a1[v9])\n                    if v10 % v11 == 0 or v11 % v10 == 0:\n                        v4[v7 | 1 << v9][v9] = (v4[v7 | 1 << v9][v9] + v4[v7][v8]) % v1\n        v12 = (1 << v2) - 1\n        return sum(v4[v12]) % v1 if v2 else 1\n"}
{"id": "human_code\\p03326__s551187546.py", "text": "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nfrom math import floor, sqrt, factorial, hypot, log\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter, defaultdict, deque\nfrom itertools import accumulate, permutations, combinations, product, combinations_with_replacement\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom fractions import gcd\nfrom random import randint\n\ndef f1(a1, a2):\n    return (a1 + a2 - 1) // a2\nv1 = float('inf')\nv2 = 10 ** 9 + 7\n\ndef f2(*a1):\n    for v1 in a1:\n        print(*v1, sep='\\n')\n\ndef f3(a1):\n    return int(a1) - 1\n\ndef f4():\n    return map(int, input().split())\n\ndef f5():\n    return map(float, input().split())\n\ndef f6():\n    return map(f3, input().split())\n\ndef f7():\n    return list(f4())\n\ndef f8():\n    return [int(x) - 1 for v1 in input().split()]\n\ndef f9():\n    return list(f5())\n\ndef f10(a1: int):\n    return [f14() for v1 in range(a1)]\n\ndef f11(a1: int):\n    return [f7() for v1 in range(a1)]\n\ndef f12(a1: int):\n    return [f8() for v1 in range(a1)]\n\ndef f13():\n    return [list(map(int, l.split())) for v1 in input()]\n\ndef f14():\n    return int(input())\n\ndef f15():\n    return float(input())\n\ndef f16():\n    return input().replace('\\n', '')\n\ndef f17():\n    v1, v2 = f4()\n    v3 = f11(v1)\n    v4, v5, v6 = [1 << i for v7 in range(3)]\n\n    def f(a1):\n        a1, v2, v3 = a1\n        return abs(a1) + abs(v2) + abs(v3)\n    v8 = 0\n    for v9 in range(1 << 3):\n        v10 = bool(v4 & v9)\n        v11 = bool(v5 & v9)\n        v12 = bool(v6 & v9)\n        v3.sort(reverse=True, key=lambda x: (-1) ** v10 * x[0] + (-1) ** v11 * x[1] + (-1) ** v12 * x[2])\n        v13, v14, v15 = (0, 0, 0)\n        for v16, v17, v18 in v3[:v2]:\n            v13 += v16\n            v14 += v17\n            v15 += v18\n        v8 = max(v8, f((v13, v14, v15)))\n    print(v8)\nif __name__ == '__main__':\n    f17()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nfrom math import floor, sqrt, factorial, hypot, log\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter, defaultdict, deque\nfrom itertools import accumulate, permutations, combinations, product, combinations_with_replacement\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom fractions import gcd\nfrom random import randint\n\ndef f1(a1, a2):\n    return (a1 + a2 - 1) // a2\nv1 = float('inf')\nv2 = 10 ** 9 + 7\n\ndef f2(*a1):\n    for v1 in a1:\n        print(*v1, sep='\\n')\n\ndef f3(a1):\n    return int(a1) - 1\n\ndef f4():\n    return map(int, input().split())\n\ndef f5():\n    return map(float, input().split())\n\ndef f6():\n    return map(f3, input().split())\n\ndef f7():\n    return list(f4())\n\ndef f8():\n    return [int(x) - 1 for v1 in input().split()]\n\ndef f9():\n    return list(f5())\n\ndef f10(a1: int):\n    return [f14() for v1 in range(a1)]\n\ndef f11(a1: int):\n    return [f7() for v1 in range(a1)]\n\ndef f12(a1: int):\n    return [f8() for v1 in range(a1)]\n\ndef f13():\n    return [list(map(int, l.split())) for v1 in input()]\n\ndef f14():\n    return int(input())\n\ndef f15():\n    return float(input())\n\ndef f16():\n    return input().replace('\\n', '')\n\ndef f17():\n    v1, v2 = f4()\n    v3 = f11(v1)\n    v4, v5, v6 = [1 << i for v7 in range(3)]\n\n    def f(a1):\n        a1, v2, v3 = a1\n        return abs(a1) + abs(v2) + abs(v3)\n    v8 = 0\n    for v9 in range(1 << 3):\n        v10 = bool(v4 & v9)\n        v11 = bool(v5 & v9)\n        v12 = bool(v6 & v9)\n        v3.sort(reverse=True, key=lambda x: (-1) ** v10 * x[0] + (-1) ** v11 * x[1] + (-1) ** v12 * x[2])\n        v13, v14, v15 = (0, 0, 0)\n        for v16, v17, v18 in v3[:v2]:\n            v13 += v16\n            v14 += v17\n            v15 += v18\n        v8 = max(v8, f((v13, v14, v15)))\n    print(v8)\nif __name__ == '__main__':\n    f17()\n"}
{"id": "human_code\\number-of-islands-ii.py", "text": "class C1(object):\n\n    def numIslands2(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def node_id(a1, a2):\n            return a1[0] * a2 + a1[1]\n\n        def find_set(a1):\n            if set[a1] != a1:\n                set[a1] = find_set(set[a1])\n            return set[a1]\n\n        def union_set(a1, a2):\n            v1, v2 = (find_set(a1), find_set(a2))\n            set[min(v1, v2)] = max(v1, v2)\n        v1 = []\n        v2 = 0\n        v3 = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        set = {}\n        for v4 in a3:\n            v5 = (v4[0], v4[1])\n            set[node_id(v5, a2)] = node_id(v5, a2)\n            v2 += 1\n            for v6 in v3:\n                v7 = (v4[0] + v6[0], v4[1] + v6[1])\n                if 0 <= v7[0] < a1 and 0 <= v7[1] < a2 and (node_id(v7, a2) in set):\n                    if find_set(node_id(v5, a2)) != find_set(node_id(v7, a2)):\n                        union_set(node_id(v5, a2), node_id(v7, a2))\n                        v2 -= 1\n            v1.append(v2)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numIslands2(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def node_id(a1, a2):\n            return a1[0] * a2 + a1[1]\n\n        def find_set(a1):\n            if set[a1] != a1:\n                set[a1] = find_set(set[a1])\n            return set[a1]\n\n        def union_set(a1, a2):\n            v1, v2 = (find_set(a1), find_set(a2))\n            set[min(v1, v2)] = max(v1, v2)\n        v1 = []\n        v2 = 0\n        v3 = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n        set = {}\n        for v4 in a3:\n            v5 = (v4[0], v4[1])\n            set[node_id(v5, a2)] = node_id(v5, a2)\n            v2 += 1\n            for v6 in v3:\n                v7 = (v4[0] + v6[0], v4[1] + v6[1])\n                if 0 <= v7[0] < a1 and 0 <= v7[1] < a2 and (node_id(v7, a2) in set):\n                    if find_set(node_id(v5, a2)) != find_set(node_id(v7, a2)):\n                        union_set(node_id(v5, a2), node_id(v7, a2))\n                        v2 -= 1\n            v1.append(v2)\n        return v1\n"}
{"id": "llm_code\\sum-of-subarray-minimums__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def sumSubarrayMins(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = [-1] * v2\n        v4 = []\n        for v5 in range(v2):\n            while v4 and a1[v4[-1]] >= a1[v5]:\n                v4.pop()\n            v3[v5] = v4[-1] if v4 else -1\n            v4.append(v5)\n        v6 = [v2] * v2\n        v4 = []\n        for v5 in range(v2 - 1, -1, -1):\n            while v4 and a1[v4[-1]] > a1[v5]:\n                v4.pop()\n            v6[v5] = v4[-1] if v4 else v2\n            v4.append(v5)\n        v7 = 0\n        for v5 in range(v2):\n            v8 = v5 - v3[v5]\n            v9 = v6[v5] - v5\n            v7 = (v7 + a1[v5] * v8 * v9) % v1\n        return v7\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def sumSubarrayMins(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = [-1] * v2\n        v4 = []\n        for v5 in range(v2):\n            while v4 and a1[v4[-1]] >= a1[v5]:\n                v4.pop()\n            v3[v5] = v4[-1] if v4 else -1\n            v4.append(v5)\n        v6 = [v2] * v2\n        v4 = []\n        for v5 in range(v2 - 1, -1, -1):\n            while v4 and a1[v4[-1]] > a1[v5]:\n                v4.pop()\n            v6[v5] = v4[-1] if v4 else v2\n            v4.append(v5)\n        v7 = 0\n        for v5 in range(v2):\n            v8 = v5 - v3[v5]\n            v9 = v6[v5] - v5\n            v7 = (v7 + a1[v5] * v8 * v9) % v1\n        return v7\n"}
{"id": "human_code\\sum-of-subarray-minimums.py", "text": "import itertools\n\nclass C1(object):\n\n    def sumSubarrayMins(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2, v3 = ([0] * len(a1), [])\n        for v4 in range(len(a1)):\n            v5 = 1\n            while v3 and v3[-1][0] > a1[v4]:\n                v5 += v3.pop()[1]\n            v2[v4] = v5\n            v3.append([a1[v4], v5])\n        v6, v7 = ([0] * len(a1), [])\n        for v4 in reversed(range(len(a1))):\n            v5 = 1\n            while v7 and v7[-1][0] >= a1[v4]:\n                v5 += v7.pop()[1]\n            v6[v4] = v5\n            v7.append([a1[v4], v5])\n        return sum((a * l * r for v8, v9, v10 in zip(a1, v2, v6))) % v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\n\nclass C1(object):\n\n    def sumSubarrayMins(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2, v3 = ([0] * len(a1), [])\n        for v4 in range(len(a1)):\n            v5 = 1\n            while v3 and v3[-1][0] > a1[v4]:\n                v5 += v3.pop()[1]\n            v2[v4] = v5\n            v3.append([a1[v4], v5])\n        v6, v7 = ([0] * len(a1), [])\n        for v4 in reversed(range(len(a1))):\n            v5 = 1\n            while v7 and v7[-1][0] >= a1[v4]:\n                v5 += v7.pop()[1]\n            v6[v4] = v5\n            v7.append([a1[v4], v5])\n        return sum((a * l * r for v8, v9, v10 in zip(a1, v2, v6))) % v1\n"}
{"id": "llm_code\\split-array-into-fibonacci-sequence__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def splitIntoFibonacci(self, a1):\n        v1 = len(a1)\n        v2 = (1 << 31) - 1\n\n        def helper(a1, a2, a3, a4):\n            if a1 == v1:\n                return len(a4) >= 3\n            v1 = a2 + a3\n            if v1 > v2:\n                return False\n            v2 = str(v1)\n            v3 = len(v2)\n            if a1 + v3 > v1 or a1[a1:a1 + v3] != v2:\n                return False\n            a4.append(v1)\n            if helper(a1 + v3, a3, v1, a4):\n                return True\n            a4.pop()\n            return False\n        for v3 in range(1, min(v1, 11)):\n            if a1[0] == '0' and v3 > 1:\n                continue\n            v4 = int(a1[:v3])\n            if v4 > v2:\n                break\n            for v5 in range(v3 + 1, min(v1 + 1, v3 + 11)):\n                if a1[v3] == '0' and v5 - v3 > 1:\n                    continue\n                v6 = int(a1[v3:v5])\n                if v6 > v2:\n                    break\n                v7 = [v4, v6]\n                if helper(v5, v4, v6, v7):\n                    return v7\n        return []\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def splitIntoFibonacci(self, a1):\n        v1 = len(a1)\n        v2 = (1 << 31) - 1\n\n        def helper(a1, a2, a3, a4):\n            if a1 == v1:\n                return len(a4) >= 3\n            v1 = a2 + a3\n            if v1 > v2:\n                return False\n            v2 = str(v1)\n            v3 = len(v2)\n            if a1 + v3 > v1 or a1[a1:a1 + v3] != v2:\n                return False\n            a4.append(v1)\n            if helper(a1 + v3, a3, v1, a4):\n                return True\n            a4.pop()\n            return False\n        for v3 in range(1, min(v1, 11)):\n            if a1[0] == '0' and v3 > 1:\n                continue\n            v4 = int(a1[:v3])\n            if v4 > v2:\n                break\n            for v5 in range(v3 + 1, min(v1 + 1, v3 + 11)):\n                if a1[v3] == '0' and v5 - v3 > 1:\n                    continue\n                v6 = int(a1[v3:v5])\n                if v6 > v2:\n                    break\n                v7 = [v4, v6]\n                if helper(v5, v4, v6, v7):\n                    return v7\n        return []\n"}
{"id": "human_code\\groups-of-strings.py", "text": "from functools import reduce\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n        self.size = [1] * a1\n        self.total = a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        self.size[a2] += self.size[a1]\n        self.total -= 1\n        return True\n\nclass C2(object):\n\n    def groupStrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = C1(len(a1))\n        v2 = {}\n        for v3, v4 in enumerate(a1):\n            v5 = reduce(lambda x, y: v4 | 1 << ord(y) - ord('a'), v4, 0)\n            if v5 not in v2:\n                v2[v5] = v3\n            v1.union_set(v3, v2[v5])\n            v6 = 1\n            while v6 <= v5:\n                if v5 & v6:\n                    if v5 ^ v6 not in v2:\n                        v2[v5 ^ v6] = v3\n                    v1.union_set(v3, v2[v5 ^ v6])\n                v6 <<= 1\n        return [v1.total, max(v1.size)]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from functools import reduce\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n        self.size = [1] * a1\n        self.total = a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        self.size[a2] += self.size[a1]\n        self.total -= 1\n        return True\n\nclass C2(object):\n\n    def groupStrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = C1(len(a1))\n        v2 = {}\n        for v3, v4 in enumerate(a1):\n            v5 = reduce(lambda x, y: v4 | 1 << ord(y) - ord('a'), v4, 0)\n            if v5 not in v2:\n                v2[v5] = v3\n            v1.union_set(v3, v2[v5])\n            v6 = 1\n            while v6 <= v5:\n                if v5 & v6:\n                    if v5 ^ v6 not in v2:\n                        v2[v5 ^ v6] = v3\n                    v1.union_set(v3, v2[v5 ^ v6])\n                v6 <<= 1\n        return [v1.total, max(v1.size)]\n"}
{"id": "llm_code\\maximum-fruits-harvested-after-at-most-k-steps__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxTotalFruits(self, a1, a2, a3):\n        v1 = max(a2, max((p for v2, v3 in a1), default=a2))\n        v4 = [0] * (v1 + 1)\n        for v5, v6 in a1:\n            v4[v5] = v6\n        v7 = [0] * (v1 + 2)\n        for v8 in range(1, v1 + 2):\n            v7[v8] = v7[v8 - 1] + v4[v8 - 1]\n        v9 = 0\n        for v10 in range(a2 + 1):\n            v11 = a2 - v10\n            if v11 < 0:\n                break\n            v12 = a3 - 2 * v10\n            v13 = (a3 - v10) // 2\n            v14 = max(0, v12, v13)\n            v15 = min(v1, a2 + v14)\n            v16 = v7[v15 + 1] - v7[v11]\n            if v16 > v9:\n                v9 = v16\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxTotalFruits(self, a1, a2, a3):\n        v1 = max(a2, max((p for v2, v3 in a1), default=a2))\n        v4 = [0] * (v1 + 1)\n        for v5, v6 in a1:\n            v4[v5] = v6\n        v7 = [0] * (v1 + 2)\n        for v8 in range(1, v1 + 2):\n            v7[v8] = v7[v8 - 1] + v4[v8 - 1]\n        v9 = 0\n        for v10 in range(a2 + 1):\n            v11 = a2 - v10\n            if v11 < 0:\n                break\n            v12 = a3 - 2 * v10\n            v13 = (a3 - v10) // 2\n            v14 = max(0, v12, v13)\n            v15 = min(v1, a2 + v14)\n            v16 = v7[v15 + 1] - v7[v11]\n            if v16 > v9:\n                v9 = v16\n        return v9\n"}
{"id": "human_code\\max-sum-of-sub-matrix-no-larger-than-k__part2.py", "text": "class C1(object):\n\n    def maxSumSubmatrix(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class BST(object):\n\n            def __init__(self, a1):\n                self.val = a1\n                self.left = None\n                self.right = None\n\n            def insert(self, a1):\n                v1 = self\n                while v1:\n                    if v1.val >= a1:\n                        if v1.left:\n                            v1 = v1.left\n                        else:\n                            v1.left = BST(a1)\n                            return\n                    elif v1.right:\n                        v1 = v1.right\n                    else:\n                        v1.right = BST(a1)\n                        return\n\n            def lower_bound(self, a1):\n                v1, v2 = (None, self)\n                while v2:\n                    if v2.val >= a1:\n                        v1, v2 = (v2, v2.left)\n                    else:\n                        v2 = v2.right\n                return v1\n        if not a1:\n            return 0\n        v1 = min(len(a1), len(a1[0]))\n        v2 = max(len(a1), len(a1[0]))\n        v3 = float('-inf')\n        for v4 in range(v1):\n            v5 = [0] * v2\n            for v6 in range(v4, v1):\n                for v7 in range(v2):\n                    v5[v7] += a1[v6][v7] if v1 == len(a1) else a1[v7][v6]\n                v8 = BST(0)\n                v9 = 0\n                for sum in v5:\n                    v9 += sum\n                    v10 = v8.lower_bound(v9 - a2)\n                    if v10:\n                        v3 = max(v3, v9 - v10.val)\n                    v8.insert(v9)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxSumSubmatrix(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class BST(object):\n\n            def __init__(self, a1):\n                self.val = a1\n                self.left = None\n                self.right = None\n\n            def insert(self, a1):\n                v1 = self\n                while v1:\n                    if v1.val >= a1:\n                        if v1.left:\n                            v1 = v1.left\n                        else:\n                            v1.left = BST(a1)\n                            return\n                    elif v1.right:\n                        v1 = v1.right\n                    else:\n                        v1.right = BST(a1)\n                        return\n\n            def lower_bound(self, a1):\n                v1, v2 = (None, self)\n                while v2:\n                    if v2.val >= a1:\n                        v1, v2 = (v2, v2.left)\n                    else:\n                        v2 = v2.right\n                return v1\n        if not a1:\n            return 0\n        v1 = min(len(a1), len(a1[0]))\n        v2 = max(len(a1), len(a1[0]))\n        v3 = float('-inf')\n        for v4 in range(v1):\n            v5 = [0] * v2\n            for v6 in range(v4, v1):\n                for v7 in range(v2):\n                    v5[v7] += a1[v6][v7] if v1 == len(a1) else a1[v7][v6]\n                v8 = BST(0)\n                v9 = 0\n                for sum in v5:\n                    v9 += sum\n                    v10 = v8.lower_bound(v9 - a2)\n                    if v10:\n                        v3 = max(v3, v9 - v10.val)\n                    v8.insert(v9)\n        return v3\n"}
{"id": "llm_code\\p02954__s089706030.py", "text": "v1 = input()\nv2 = len(v1)\n\ndef f1(a1):\n    v1 = a1[0]\n    v2 = 1\n    v3 = ''\n    for v4 in range(1, len(a1)):\n        if v1 == a1[v4]:\n            v2 += 1\n        else:\n            v3 += v1 + str(v2)\n            v1 = a1[v4]\n            v2 = 1\n    v3 += v1 + str(v2)\n    return v3\nv3 = list(f1(v1))\nv4 = [0] * v2\nv5 = 0\nfor v6 in range(0, len(v3), 4):\n    v7 = int(v3[v6 + 1])\n    v8 = int(v3[v6 + 3])\n    v9 = v7 // 2 + (v8 + 1) // 2\n    v10 = v7 + v8 - v9\n    v4[v5 + v7 - 1] = v10\n    v4[v5 + v7] = v9\n    v5 += v7 + v8\nprint(*v4)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = input()\nv2 = len(v1)\n\ndef f1(a1):\n    v1 = a1[0]\n    v2 = 1\n    v3 = ''\n    for v4 in range(1, len(a1)):\n        if v1 == a1[v4]:\n            v2 += 1\n        else:\n            v3 += v1 + str(v2)\n            v1 = a1[v4]\n            v2 = 1\n    v3 += v1 + str(v2)\n    return v3\nv3 = list(f1(v1))\nv4 = [0] * v2\nv5 = 0\nfor v6 in range(0, len(v3), 4):\n    v7 = int(v3[v6 + 1])\n    v8 = int(v3[v6 + 3])\n    v9 = v7 // 2 + (v8 + 1) // 2\n    v10 = v7 + v8 - v9\n    v4[v5 + v7 - 1] = v10\n    v4[v5 + v7] = v9\n    v5 += v7 + v8\nprint(*v4)\n"}
{"id": "llm_code\\longest-increasing-path-in-a-matrix__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def longestIncreasingPath(self, a1):\n        if not a1:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = {}\n\n        def compute_length(a1, a2):\n            v1 = (a1, a2)\n            if v1 in v3:\n                return v3[v1]\n            v2 = 1\n            for v3, v4 in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                v5 = a1 + v3\n                v6 = a2 + v4\n                if 0 <= v5 < v1 and 0 <= v6 < v2 and (a1[v5][v6] > a1[a1][a2]):\n                    v2 = max(v2, 1 + compute_length(v5, v6))\n            v3[v1] = v2\n            return v2\n        v4 = 0\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v4 = max(v4, compute_length(v5, v6))\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestIncreasingPath(self, a1):\n        if not a1:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = {}\n\n        def compute_length(a1, a2):\n            v1 = (a1, a2)\n            if v1 in v3:\n                return v3[v1]\n            v2 = 1\n            for v3, v4 in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                v5 = a1 + v3\n                v6 = a2 + v4\n                if 0 <= v5 < v1 and 0 <= v6 < v2 and (a1[v5][v6] > a1[a1][a2]):\n                    v2 = max(v2, 1 + compute_length(v5, v6))\n            v3[v1] = v2\n            return v2\n        v4 = 0\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v4 = max(v4, compute_length(v5, v6))\n        return v4\n"}
{"id": "llm_code\\form-largest-integer-with-digits-that-add-up-to-target__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def largestNumber(self, a1, a2):\n        v1 = [-1] * (a2 + 1)\n        v1[0] = 0\n        for v2 in range(a2):\n            if v1[v2] == -1:\n                continue\n            for v3 in range(9):\n                v4 = v2 + a1[v3]\n                if v4 > a2:\n                    continue\n                v1[v4] = max(v1[v4], v1[v2] + 1)\n        if v1[a2] == -1:\n            return '0'\n        v5 = []\n        v6 = a2\n        for v7 in range(9, 0, -1):\n            v8 = a1[v7 - 1]\n            while v6 >= v8 and v1[v6] == v1[v6 - v8] + 1:\n                v5.append(str(v7))\n                v6 -= v8\n        return ''.join(v5)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def largestNumber(self, a1, a2):\n        v1 = [-1] * (a2 + 1)\n        v1[0] = 0\n        for v2 in range(a2):\n            if v1[v2] == -1:\n                continue\n            for v3 in range(9):\n                v4 = v2 + a1[v3]\n                if v4 > a2:\n                    continue\n                v1[v4] = max(v1[v4], v1[v2] + 1)\n        if v1[a2] == -1:\n            return '0'\n        v5 = []\n        v6 = a2\n        for v7 in range(9, 0, -1):\n            v8 = a1[v7 - 1]\n            while v6 >= v8 and v1[v6] == v1[v6 - v8] + 1:\n                v5.append(str(v7))\n                v6 -= v8\n        return ''.join(v5)\n"}
{"id": "llm_code\\maximum-non-negative-product-in-a-matrix__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxProductPath(self, a1):\n        v1 = 10 ** 9 + 7\n        if not a1 or not a1[0]:\n            return 0\n        v2, v3 = (len(a1), len(a1[0]))\n        v4 = [[0] * v3 for v5 in range(v2)]\n        v6 = [[0] * v3 for v5 in range(v2)]\n        v4[0][0] = v6[0][0] = a1[0][0]\n        for v7 in range(1, v3):\n            v8 = a1[0][v7]\n            v9 = v4[0][v7 - 1] * v8\n            v10 = v6[0][v7 - 1] * v8\n            v4[0][v7] = max(v9, v10)\n            v6[0][v7] = min(v9, v10)\n        for v11 in range(1, v2):\n            v8 = a1[v11][0]\n            v9 = v4[v11 - 1][0] * v8\n            v10 = v6[v11 - 1][0] * v8\n            v4[v11][0] = max(v9, v10)\n            v6[v11][0] = min(v9, v10)\n        for v11 in range(1, v2):\n            for v7 in range(1, v3):\n                v8 = a1[v11][v7]\n                v12 = v4[v11 - 1][v7] * v8\n                v13 = v6[v11 - 1][v7] * v8\n                v14 = v4[v11][v7 - 1] * v8\n                v15 = v6[v11][v7 - 1] * v8\n                v16 = [v12, v13, v14, v15]\n                v4[v11][v7] = max(v16)\n                v6[v11][v7] = min(v16)\n        v17 = v4[v2 - 1][v3 - 1]\n        return v17 % v1 if v17 >= 0 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxProductPath(self, a1):\n        v1 = 10 ** 9 + 7\n        if not a1 or not a1[0]:\n            return 0\n        v2, v3 = (len(a1), len(a1[0]))\n        v4 = [[0] * v3 for v5 in range(v2)]\n        v6 = [[0] * v3 for v5 in range(v2)]\n        v4[0][0] = v6[0][0] = a1[0][0]\n        for v7 in range(1, v3):\n            v8 = a1[0][v7]\n            v9 = v4[0][v7 - 1] * v8\n            v10 = v6[0][v7 - 1] * v8\n            v4[0][v7] = max(v9, v10)\n            v6[0][v7] = min(v9, v10)\n        for v11 in range(1, v2):\n            v8 = a1[v11][0]\n            v9 = v4[v11 - 1][0] * v8\n            v10 = v6[v11 - 1][0] * v8\n            v4[v11][0] = max(v9, v10)\n            v6[v11][0] = min(v9, v10)\n        for v11 in range(1, v2):\n            for v7 in range(1, v3):\n                v8 = a1[v11][v7]\n                v12 = v4[v11 - 1][v7] * v8\n                v13 = v6[v11 - 1][v7] * v8\n                v14 = v4[v11][v7 - 1] * v8\n                v15 = v6[v11][v7 - 1] * v8\n                v16 = [v12, v13, v14, v15]\n                v4[v11][v7] = max(v16)\n                v6[v11][v7] = min(v16)\n        v17 = v4[v2 - 1][v3 - 1]\n        return v17 % v1 if v17 >= 0 else -1\n"}
{"id": "human_code\\p02600__s275330495.py", "text": "import sys\n\ndef f1():\n    return sys.stdin.readline().rstrip()\n\ndef f2():\n    return int(sys.stdin.readline().rstrip())\n\ndef f3():\n    return list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef f4():\n    return list(sys.stdin.readline().rstrip().split())\nv1 = 1000000000000\nv2 = f2()\nif v2 >= 400 and v2 < 600:\n    v3 = 8\nelif v2 < 800:\n    v3 = 7\nelif v2 < 1000:\n    v3 = 6\nelif v2 < 1200:\n    v3 = 5\nelif v2 < 1400:\n    v3 = 4\nelif v2 < 1600:\n    v3 = 3\nelif v2 < 1800:\n    v3 = 2\nelse:\n    v3 = 1\nprint(v3)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\n\ndef f1():\n    return sys.stdin.readline().rstrip()\n\ndef f2():\n    return int(sys.stdin.readline().rstrip())\n\ndef f3():\n    return list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef f4():\n    return list(sys.stdin.readline().rstrip().split())\nv1 = 1000000000000\nv2 = f2()\nif v2 >= 400 and v2 < 600:\n    v3 = 8\nelif v2 < 800:\n    v3 = 7\nelif v2 < 1000:\n    v3 = 6\nelif v2 < 1200:\n    v3 = 5\nelif v2 < 1400:\n    v3 = 4\nelif v2 < 1600:\n    v3 = 3\nelif v2 < 1800:\n    v3 = 2\nelse:\n    v3 = 1\nprint(v3)\n"}
{"id": "llm_code\\p02901__s185710035.py", "text": "v1, v2 = map(int, input().split())\nv3 = []\nfor v4 in range(v2):\n    v5 = list(map(int, input().split()))\n    v6 = list(map(int, input().split()))\n    v3.append([v5, v6])\nv7 = []\nfrom collections import defaultdict\nv8 = defaultdict(int)\nfor v9 in range(1, v1 + 1):\n    v10 = 10 ** 5\n    for v4 in range(len(v3)):\n        if v9 in v3[v4][1]:\n            v7.append(v9)\n            if v9 in v7 and v7.count(v9) == 1:\n                v10 = min(v10, int(v3[v4][0][0]))\n                v8[v9] = v10\nsum = 0\nfor v11 in v8.values():\n    sum += v11\nprint(sum)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = []\nfor v4 in range(v2):\n    v5 = list(map(int, input().split()))\n    v6 = list(map(int, input().split()))\n    v3.append([v5, v6])\nv7 = []\nfrom collections import defaultdict\nv8 = defaultdict(int)\nfor v9 in range(1, v1 + 1):\n    v10 = 10 ** 5\n    for v4 in range(len(v3)):\n        if v9 in v3[v4][1]:\n            v7.append(v9)\n            if v9 in v7 and v7.count(v9) == 1:\n                v10 = min(v10, int(v3[v4][0][0]))\n                v8[v9] = v10\nsum = 0\nfor v11 in v8.values():\n    sum += v11\nprint(sum)\n"}
{"id": "human_code\\count-almost-equal-pairs-ii__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def countPairs(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 7\n        v2 = 2\n        v3 = [0] * v1\n        v3[0] = 1\n        for v4 in range(v1 - 1):\n            v3[v4 + 1] = v3[v4] * 10\n\n        def at_most(a1, a2):\n            v1 = {a2}\n            v2 = [a2]\n            v3 = 0\n            for v4 in range(a1):\n                for v3 in range(v3, len(v2)):\n                    a2 = v2[v3]\n                    for v6 in range(v1):\n                        v7 = a2 // v3[v6] % 10\n                        for v8 in range(v6 + 1, v1):\n                            v9 = a2 // v3[v8] % 10\n                            if v7 == v9:\n                                continue\n                            v10 = a2 - v7 * (v3[v6] - v3[v8]) + v9 * (v3[v6] - v3[v8])\n                            if v10 in v1:\n                                continue\n                            v1.add(v10)\n                            v2.append(v10)\n            return v2\n        v5 = 0\n        v6 = collections.Counter(a1)\n        v7 = collections.Counter()\n        for v8, v9 in v6.items():\n            v5 += v7[v8] * v9 + v9 * (v9 - 1) // 2\n            for v8 in at_most(v2, v8):\n                if v8 not in v6:\n                    continue\n                v7[v8] += v9\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def countPairs(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 7\n        v2 = 2\n        v3 = [0] * v1\n        v3[0] = 1\n        for v4 in range(v1 - 1):\n            v3[v4 + 1] = v3[v4] * 10\n\n        def at_most(a1, a2):\n            v1 = {a2}\n            v2 = [a2]\n            v3 = 0\n            for v4 in range(a1):\n                for v3 in range(v3, len(v2)):\n                    a2 = v2[v3]\n                    for v6 in range(v1):\n                        v7 = a2 // v3[v6] % 10\n                        for v8 in range(v6 + 1, v1):\n                            v9 = a2 // v3[v8] % 10\n                            if v7 == v9:\n                                continue\n                            v10 = a2 - v7 * (v3[v6] - v3[v8]) + v9 * (v3[v6] - v3[v8])\n                            if v10 in v1:\n                                continue\n                            v1.add(v10)\n                            v2.append(v10)\n            return v2\n        v5 = 0\n        v6 = collections.Counter(a1)\n        v7 = collections.Counter()\n        for v8, v9 in v6.items():\n            v5 += v7[v8] * v9 + v9 * (v9 - 1) // 2\n            for v8 in at_most(v2, v8):\n                if v8 not in v6:\n                    continue\n                v7[v8] += v9\n        return v5\n"}
{"id": "human_code\\number-of-ways-to-wear-different-hats-to-each-other.py", "text": "class C1(object):\n\n    def numberWays(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = 40\n        v3 = [[] for v4 in range(v2)]\n        for v5 in range(len(a1)):\n            for v6 in a1[v5]:\n                v3[v6 - 1].append(v5)\n        v7 = [0] * (1 << len(a1))\n        v7[0] = 1\n        for v8 in v3:\n            for v9 in reversed(range(len(v7))):\n                for v10 in v8:\n                    if v9 & 1 << v10:\n                        continue\n                    v7[v9 | 1 << v10] += v7[v9]\n                    v7[v9 | 1 << v10] %= v1\n        return v7[-1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numberWays(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = 40\n        v3 = [[] for v4 in range(v2)]\n        for v5 in range(len(a1)):\n            for v6 in a1[v5]:\n                v3[v6 - 1].append(v5)\n        v7 = [0] * (1 << len(a1))\n        v7[0] = 1\n        for v8 in v3:\n            for v9 in reversed(range(len(v7))):\n                for v10 in v8:\n                    if v9 & 1 << v10:\n                        continue\n                    v7[v9 | 1 << v10] += v7[v9]\n                    v7[v9 | 1 << v10] %= v1\n        return v7[-1]\n"}
{"id": "human_code\\minimum-time-for-k-virus-variants-to-spread__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def minDayskVariants(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def add_rec(a1, a2):\n            v1, v2, v3, v4 = a1\n            a2[v1][v2] += 1\n            a2[v1][v4 + 1] -= 1\n            a2[v3 + 1][v2] -= 1\n            a2[v3 + 1][v4 + 1] += 1\n\n        def check(a1, a2, a3):\n            v1 = collections.defaultdict(lambda: collections.defaultdict(int))\n            v2 = set()\n            for v3, v4 in a1:\n                add_rec([v3 - a3, v4 - a3, v3 + a3, v4 + a3], v1)\n                v2.add(v4 - a3)\n                v2.add(v4 + a3 + 1)\n            v5 = sorted(v2)\n            v6 = sorted(v1.keys())\n            v7 = collections.Counter()\n            for v3 in v6:\n                for v4, v8 in v1[v3].items():\n                    v7[v4] += v8\n                v9 = 0\n                for v4 in v5:\n                    v9 += v7[v4]\n                    if v9 >= a2:\n                        return True\n            return False\n        a1 = [[x + y, x - y] for v2, v3 in a1]\n        v4 = min(a1)[0]\n        v5 = max(a1)[0]\n        v6 = min(a1, key=lambda x: v2[1])[1]\n        v7 = max(a1, key=lambda x: v2[1])[1]\n        v8, v9 = (0, (v5 - v4 + (v7 - v6) + 1) // 2)\n        while v8 <= v9:\n            v10 = v8 + (v9 - v8) // 2\n            if check(a1, a2, v10):\n                v9 = v10 - 1\n            else:\n                v8 = v10 + 1\n        return v8\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def minDayskVariants(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def add_rec(a1, a2):\n            v1, v2, v3, v4 = a1\n            a2[v1][v2] += 1\n            a2[v1][v4 + 1] -= 1\n            a2[v3 + 1][v2] -= 1\n            a2[v3 + 1][v4 + 1] += 1\n\n        def check(a1, a2, a3):\n            v1 = collections.defaultdict(lambda: collections.defaultdict(int))\n            v2 = set()\n            for v3, v4 in a1:\n                add_rec([v3 - a3, v4 - a3, v3 + a3, v4 + a3], v1)\n                v2.add(v4 - a3)\n                v2.add(v4 + a3 + 1)\n            v5 = sorted(v2)\n            v6 = sorted(v1.keys())\n            v7 = collections.Counter()\n            for v3 in v6:\n                for v4, v8 in v1[v3].items():\n                    v7[v4] += v8\n                v9 = 0\n                for v4 in v5:\n                    v9 += v7[v4]\n                    if v9 >= a2:\n                        return True\n            return False\n        a1 = [[x + y, x - y] for v2, v3 in a1]\n        v4 = min(a1)[0]\n        v5 = max(a1)[0]\n        v6 = min(a1, key=lambda x: v2[1])[1]\n        v7 = max(a1, key=lambda x: v2[1])[1]\n        v8, v9 = (0, (v5 - v4 + (v7 - v6) + 1) // 2)\n        while v8 <= v9:\n            v10 = v8 + (v9 - v8) // 2\n            if check(a1, a2, v10):\n                v9 = v10 - 1\n            else:\n                v8 = v10 + 1\n        return v8\n"}
{"id": "llm_code\\minimize-malware-spread__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.p = list(range(a1))\n        self.rnk = [0] * a1\n\n    def get(self, a1):\n        if self.p[a1] != a1:\n            self.p[a1] = self.get(self.p[a1])\n        return self.p[a1]\n\n    def merge(self, a1, a2):\n        v1 = self.get(a1)\n        v2 = self.get(a2)\n        if v1 == v2:\n            return\n        if self.rnk[v1] > self.rnk[v2]:\n            self.p[v2] = v1\n        elif self.rnk[v1] < self.rnk[v2]:\n            self.p[v1] = v2\n        else:\n            self.p[v2] = v1\n            self.rnk[v1] += 1\n\nclass C2:\n\n    def minMalwareSpread(self, a1, a2):\n        v1 = len(a1)\n        v2 = C1(v1)\n        for v3 in range(v1):\n            for v4 in range(v3 + 1, v1):\n                if a1[v3][v4]:\n                    v2.merge(v3, v4)\n        v5 = {}\n        for v3 in range(v1):\n            v6 = v2.get(v3)\n            v5[v6] = v5.get(v6, 0) + 1\n        v7 = {}\n        for v8 in a2:\n            v6 = v2.get(v8)\n            v7[v6] = v7.get(v6, 0) + 1\n        v9 = -1\n        v10 = float('inf')\n        for v8 in a2:\n            v6 = v2.get(v8)\n            v11 = v7[v6]\n            v12 = v5[v6] if v11 == 1 else 0\n            if v12 > v9 or (v12 == v9 and v8 < v10):\n                v9 = v12\n                v10 = v8\n        return v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.p = list(range(a1))\n        self.rnk = [0] * a1\n\n    def get(self, a1):\n        if self.p[a1] != a1:\n            self.p[a1] = self.get(self.p[a1])\n        return self.p[a1]\n\n    def merge(self, a1, a2):\n        v1 = self.get(a1)\n        v2 = self.get(a2)\n        if v1 == v2:\n            return\n        if self.rnk[v1] > self.rnk[v2]:\n            self.p[v2] = v1\n        elif self.rnk[v1] < self.rnk[v2]:\n            self.p[v1] = v2\n        else:\n            self.p[v2] = v1\n            self.rnk[v1] += 1\n\nclass C2:\n\n    def minMalwareSpread(self, a1, a2):\n        v1 = len(a1)\n        v2 = C1(v1)\n        for v3 in range(v1):\n            for v4 in range(v3 + 1, v1):\n                if a1[v3][v4]:\n                    v2.merge(v3, v4)\n        v5 = {}\n        for v3 in range(v1):\n            v6 = v2.get(v3)\n            v5[v6] = v5.get(v6, 0) + 1\n        v7 = {}\n        for v8 in a2:\n            v6 = v2.get(v8)\n            v7[v6] = v7.get(v6, 0) + 1\n        v9 = -1\n        v10 = float('inf')\n        for v8 in a2:\n            v6 = v2.get(v8)\n            v11 = v7[v6]\n            v12 = v5[v6] if v11 == 1 else 0\n            if v12 > v9 or (v12 == v9 and v8 < v10):\n                v9 = v12\n                v10 = v8\n        return v10\n"}
{"id": "human_code\\coordinate-with-maximum-network-quality.py", "text": "class C1(object):\n\n    def bestCoordinate(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = min(a1, key=lambda x: x[0])[0]\n        v2 = max(a1, key=lambda x: x[0])[0]\n        v3 = min(a1, key=lambda x: x[1])[1]\n        v4 = max(a1, key=lambda x: x[1])[1]\n        v5 = 0\n        for v6 in range(v1, v2 + 1):\n            for v7 in range(v3, v4 + 1):\n                v8 = 0\n                for v9, v10, v11 in a1:\n                    v12 = ((v9 - v6) ** 2 + (v10 - v7) ** 2) ** 0.5\n                    if v12 <= a2:\n                        v8 += int(v11 / (1 + v12))\n                if v8 > v5:\n                    v5 = v8\n                    v13 = (v6, v7)\n        return v13\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def bestCoordinate(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = min(a1, key=lambda x: x[0])[0]\n        v2 = max(a1, key=lambda x: x[0])[0]\n        v3 = min(a1, key=lambda x: x[1])[1]\n        v4 = max(a1, key=lambda x: x[1])[1]\n        v5 = 0\n        for v6 in range(v1, v2 + 1):\n            for v7 in range(v3, v4 + 1):\n                v8 = 0\n                for v9, v10, v11 in a1:\n                    v12 = ((v9 - v6) ** 2 + (v10 - v7) ** 2) ** 0.5\n                    if v12 <= a2:\n                        v8 += int(v11 / (1 + v12))\n                if v8 > v5:\n                    v5 = v8\n                    v13 = (v6, v7)\n        return v13\n"}
{"id": "human_code\\p02685__s294229494.py", "text": "import sys, bisect, math, itertools, heapq, collections\nfrom operator import itemgetter\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 8)\ninput = sys.stdin.readline\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3 = 10 ** (-7)\n\ndef f1():\n    \"\"\"\n    一つの整数\n    \"\"\"\n    return int(input())\n\ndef f2():\n    \"\"\"\n    一行に複数の整数\n    \"\"\"\n    return list(map(int, input().split()))\n\nclass C1:\n\n    def __init__(self, a1):\n        \"\"\"\n        modを指定して初期化\n        \"\"\"\n        self.mod = a1\n        self.fac = [1, 1]\n        self.ifac = [1, 1]\n        self.inv = [0, 1]\n\n    def calc(self, a1, a2):\n        \"\"\"\n        nCk%modを計算する\n        \"\"\"\n        if a2 < 0 or a1 < a2:\n            return 0\n        self.make_tables(a1)\n        a2 = min(a2, a1 - a2)\n        return self.fac[a1] * (self.ifac[a2] * self.ifac[a1 - a2] % self.mod) % self.mod\n\n    def make_tables(self, a1):\n        \"\"\"\n        階乗テーブル・階乗の逆元テーブルを作成\n        \"\"\"\n        for v1 in range(len(self.fac), a1 + 1):\n            self.fac.append(self.fac[-1] * v1 % self.mod)\n            self.inv.append(-self.inv[self.mod % v1] * (self.mod // v1) % self.mod)\n            self.ifac.append(self.ifac[-1] * self.inv[-1] % self.mod)\nv2 = 998244353\nv4 = C1(v2)\nv5, v6, v7 = f2()\nv8 = 0\nfor v9 in range(min(v5, v7 + 1)):\n    v8 += v6 * pow(v6 - 1, v5 - 1 - v9, v2) * v4.calc(v5 - 1, v9) % v2\n    v8 %= v2\nprint(v8)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys, bisect, math, itertools, heapq, collections\nfrom operator import itemgetter\nfrom functools import lru_cache\nsys.setrecursionlimit(10 ** 8)\ninput = sys.stdin.readline\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3 = 10 ** (-7)\n\ndef f1():\n    \"\"\"\n    一つの整数\n    \"\"\"\n    return int(input())\n\ndef f2():\n    \"\"\"\n    一行に複数の整数\n    \"\"\"\n    return list(map(int, input().split()))\n\nclass C1:\n\n    def __init__(self, a1):\n        \"\"\"\n        modを指定して初期化\n        \"\"\"\n        self.mod = a1\n        self.fac = [1, 1]\n        self.ifac = [1, 1]\n        self.inv = [0, 1]\n\n    def calc(self, a1, a2):\n        \"\"\"\n        nCk%modを計算する\n        \"\"\"\n        if a2 < 0 or a1 < a2:\n            return 0\n        self.make_tables(a1)\n        a2 = min(a2, a1 - a2)\n        return self.fac[a1] * (self.ifac[a2] * self.ifac[a1 - a2] % self.mod) % self.mod\n\n    def make_tables(self, a1):\n        \"\"\"\n        階乗テーブル・階乗の逆元テーブルを作成\n        \"\"\"\n        for v1 in range(len(self.fac), a1 + 1):\n            self.fac.append(self.fac[-1] * v1 % self.mod)\n            self.inv.append(-self.inv[self.mod % v1] * (self.mod // v1) % self.mod)\n            self.ifac.append(self.ifac[-1] * self.inv[-1] % self.mod)\nv2 = 998244353\nv4 = C1(v2)\nv5, v6, v7 = f2()\nv8 = 0\nfor v9 in range(min(v5, v7 + 1)):\n    v8 += v6 * pow(v6 - 1, v5 - 1 - v9, v2) * v4.calc(v5 - 1, v9) % v2\n    v8 %= v2\nprint(v8)\n"}
{"id": "llm_code\\index-pairs-of-a-string__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def __init__(self):\n        self.children = {}\n        self.failure = None\n        self.word_ids = []\n        self.match_ids = []\n\nclass C2:\n\n    def __init__(self, a1):\n        self.root = C1()\n        self.populate_trie(a1)\n        self.setup_failures()\n\n    def populate_trie(self, a1):\n        for v1, v2 in enumerate(a1):\n            v3 = self.root\n            for v4 in v2:\n                if v4 not in v3.children:\n                    v3.children[v4] = C1()\n                v3 = v3.children[v4]\n            v3.word_ids.append(v1)\n\n    def setup_failures(self):\n        v1 = collections.deque()\n        self.root.failure = self.root\n        self.root.match_ids = []\n        for v2 in list(self.root.children.values()):\n            v2.failure = self.root\n            v1.append(v2)\n        while v1:\n            v3 = v1.popleft()\n            v3.match_ids = v3.word_ids[:] + v3.failure.match_ids\n            for v4, v2 in v3.children.items():\n                v5 = v3.failure\n                while v5 != self.root and v4 not in v5.children:\n                    v5 = v5.failure\n                v2.failure = v5.children.get(v4, self.root)\n                v1.append(v2)\n\nclass C3:\n\n    def indexPairs(self, a1, a2):\n        if not a2:\n            return []\n        v1 = C2(a2)\n        v2 = []\n        v3 = v1.root\n        for v4 in range(len(a1)):\n            v5 = a1[v4]\n            while v3 != v1.root and v5 not in v3.children:\n                v3 = v3.failure\n            v3 = v3.children.get(v5, v1.root)\n            for v6 in v3.match_ids:\n                v7 = len(a2[v6])\n                v8 = v4 - v7 + 1\n                v2.append([v8, v4])\n        return sorted(v2)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def __init__(self):\n        self.children = {}\n        self.failure = None\n        self.word_ids = []\n        self.match_ids = []\n\nclass C2:\n\n    def __init__(self, a1):\n        self.root = C1()\n        self.populate_trie(a1)\n        self.setup_failures()\n\n    def populate_trie(self, a1):\n        for v1, v2 in enumerate(a1):\n            v3 = self.root\n            for v4 in v2:\n                if v4 not in v3.children:\n                    v3.children[v4] = C1()\n                v3 = v3.children[v4]\n            v3.word_ids.append(v1)\n\n    def setup_failures(self):\n        v1 = collections.deque()\n        self.root.failure = self.root\n        self.root.match_ids = []\n        for v2 in list(self.root.children.values()):\n            v2.failure = self.root\n            v1.append(v2)\n        while v1:\n            v3 = v1.popleft()\n            v3.match_ids = v3.word_ids[:] + v3.failure.match_ids\n            for v4, v2 in v3.children.items():\n                v5 = v3.failure\n                while v5 != self.root and v4 not in v5.children:\n                    v5 = v5.failure\n                v2.failure = v5.children.get(v4, self.root)\n                v1.append(v2)\n\nclass C3:\n\n    def indexPairs(self, a1, a2):\n        if not a2:\n            return []\n        v1 = C2(a2)\n        v2 = []\n        v3 = v1.root\n        for v4 in range(len(a1)):\n            v5 = a1[v4]\n            while v3 != v1.root and v5 not in v3.children:\n                v3 = v3.failure\n            v3 = v3.children.get(v5, v1.root)\n            for v6 in v3.match_ids:\n                v7 = len(a2[v6])\n                v8 = v4 - v7 + 1\n                v2.append([v8, v4])\n        return sorted(v2)\n"}
{"id": "human_code\\sum-of-weighted-modes-in-subarrays__part1.py", "text": "import collections\nfrom sortedcontainers import SortedList\n\nclass C1(object):\n\n    def modeWeight(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def add(a1, a2):\n            if cnt[a1]:\n                sl.remove((-cnt[a1], a1))\n            cnt[a1] += a2\n            if cnt[a1]:\n                sl.add((-cnt[a1], a1))\n            else:\n                del cnt[a1]\n        v1 = collections.defaultdict(int)\n        v2 = SortedList()\n        v3 = 0\n        for v4 in range(len(a1)):\n            add(a1[v4], +1)\n            if v4 >= a2 - 1:\n                v3 += -v2[0][0] * v2[0][1]\n                add(a1[v4 - a2 + 1], -1)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom sortedcontainers import SortedList\n\nclass C1(object):\n\n    def modeWeight(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def add(a1, a2):\n            if cnt[a1]:\n                sl.remove((-cnt[a1], a1))\n            cnt[a1] += a2\n            if cnt[a1]:\n                sl.add((-cnt[a1], a1))\n            else:\n                del cnt[a1]\n        v1 = collections.defaultdict(int)\n        v2 = SortedList()\n        v3 = 0\n        for v4 in range(len(a1)):\n            add(a1[v4], +1)\n            if v4 >= a2 - 1:\n                v3 += -v2[0][0] * v2[0][1]\n                add(a1[v4 - a2 + 1], -1)\n        return v3\n"}
{"id": "human_code\\smallest-substring-with-identical-characters-i__part1.py", "text": "class C1(object):\n\n    def minLength(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def lengths():\n            v1 = 0\n            for v2 in range(len(a1)):\n                v1 += 1\n                if v2 + 1 == len(a1) or a1[v2 + 1] != a1[v2]:\n                    yield v1\n                    v1 = 0\n\n        def check(a1):\n            if a1 == 1:\n                v1 = sum((int(a1) != i % 2 for v2, a1 in enumerate(a1)))\n                return min(v1, len(a1) - v1) <= a2\n            return sum((l // (a1 + 1) for v3 in lengths())) <= a2\n        return binary_search(1, len(a1), check)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minLength(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def lengths():\n            v1 = 0\n            for v2 in range(len(a1)):\n                v1 += 1\n                if v2 + 1 == len(a1) or a1[v2 + 1] != a1[v2]:\n                    yield v1\n                    v1 = 0\n\n        def check(a1):\n            if a1 == 1:\n                v1 = sum((int(a1) != i % 2 for v2, a1 in enumerate(a1)))\n                return min(v1, len(a1) - v1) <= a2\n            return sum((l // (a1 + 1) for v3 in lengths())) <= a2\n        return binary_search(1, len(a1), check)\n"}
{"id": "human_code\\p02763__s515523024.py", "text": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, copy, functools\nimport time, random\nsys.setrecursionlimit(10 ** 7)\nv1 = 10 ** 20\nv2 = 1.0 / 10 ** 10\nv3 = 10 ** 9 + 7\nv4 = 998244353\nv5 = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nv6 = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    return [list(map(int, l.split())) for v1 in sys.stdin.readlines()]\n\ndef f3():\n    return [int(x) - 1 for v1 in sys.stdin.readline().split()]\n\ndef f4():\n    return [float(x) for v1 in sys.stdin.readline().split()]\n\ndef f5():\n    return sys.stdin.readline().split()\n\ndef f6():\n    return int(sys.stdin.readline())\n\ndef f7():\n    return float(sys.stdin.readline())\n\ndef f8():\n    return input()\n\ndef f9(a1):\n    return print(a1, flush=True)\n\ndef f10(a1):\n    return print(str(a1), file=sys.stderr)\n\ndef f11(a1, a2):\n    return a2.join(map(str, a1))\n\ndef f12(a1, a2, a3):\n    return a2.join((a3.join(map(str, b)) for v1 in a1))\n\nclass C1:\n\n    def __init__(self, a1, a2, a3):\n        if isinstance(a1, list):\n            v1 = len(a1)\n        else:\n            v1 = a1\n        v2 = 1\n        while 2 ** v2 <= v1:\n            v2 += 1\n        self.D = a2\n        self.H = v2\n        self.N = 2 ** v2\n        if isinstance(a1, list):\n            self.A = [a2] * self.N + a1 + [a2] * (self.N - v1)\n            for v2 in range(self.N - 1, 0, -1):\n                self.A[v2] = a3(self.A[v2 * 2], self.A[v2 * 2 + 1])\n        else:\n            self.A = [a2] * (self.N * 2)\n        self.F = a3\n\n    def find(self, a1):\n        return self.A[a1 + self.N]\n\n    def update(self, a1, a2):\n        a1 += self.N\n        self.A[a1] = a2\n        while a1 > 1:\n            a1 = a1 // 2\n            self.A[a1] = self.merge(self.A[a1 * 2], self.A[a1 * 2 + 1])\n\n    def merge(self, a1, a2):\n        return self.F(a1, a2)\n\n    def total(self):\n        return self.A[1]\n\n    def query(self, a1, a2):\n        v1 = self.A\n        v2 = a1 + self.N\n        v3 = a2 + self.N\n        v4 = self.D\n        while v2 < v3:\n            if v2 % 2 == 1:\n                v4 = self.merge(v4, v1[v2])\n                v2 += 1\n            if v3 % 2 == 1:\n                v3 -= 1\n                v4 = self.merge(v4, v1[v3])\n            v2 >>= 1\n            v3 >>= 1\n        return v4\n\ndef f18():\n    v1 = f6()\n    v2 = f8()\n    v3 = f6()\n    v4 = [f5() for v5 in range(v3)]\n    v6 = [[0] * 26]\n    v7 = ord('a')\n    for v8 in v2:\n        v9 = [0] * 26\n        v9[ord(v8) - v7] = 1\n        v6.append(v9)\n\n    def f(a1, a2):\n        return [a1[i] + a2[i] for v1 in range(26)]\n    v10 = C1(v6, [0] * 26, f)\n    v11 = []\n    for v9, v12, v13 in v4:\n        if v9 == '1':\n            v14 = [0] * 26\n            v14[ord(v13) - v7] = 1\n            v10.update(int(v12), v14)\n        else:\n            v8 = v10.query(0, int(v12))\n            v15 = v10.query(0, int(v13) + 1)\n            v11.append(len([1 for v16 in range(26) if v8[v16] != v15[v16]]))\n    return f11(v11, '\\n')\nprint(f18())\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, copy, functools\nimport time, random\nsys.setrecursionlimit(10 ** 7)\nv1 = 10 ** 20\nv2 = 1.0 / 10 ** 10\nv3 = 10 ** 9 + 7\nv4 = 998244353\nv5 = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nv6 = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    return [list(map(int, l.split())) for v1 in sys.stdin.readlines()]\n\ndef f3():\n    return [int(x) - 1 for v1 in sys.stdin.readline().split()]\n\ndef f4():\n    return [float(x) for v1 in sys.stdin.readline().split()]\n\ndef f5():\n    return sys.stdin.readline().split()\n\ndef f6():\n    return int(sys.stdin.readline())\n\ndef f7():\n    return float(sys.stdin.readline())\n\ndef f8():\n    return input()\n\ndef f9(a1):\n    return print(a1, flush=True)\n\ndef f10(a1):\n    return print(str(a1), file=sys.stderr)\n\ndef f11(a1, a2):\n    return a2.join(map(str, a1))\n\ndef f12(a1, a2, a3):\n    return a2.join((a3.join(map(str, b)) for v1 in a1))\n\nclass C1:\n\n    def __init__(self, a1, a2, a3):\n        if isinstance(a1, list):\n            v1 = len(a1)\n        else:\n            v1 = a1\n        v2 = 1\n        while 2 ** v2 <= v1:\n            v2 += 1\n        self.D = a2\n        self.H = v2\n        self.N = 2 ** v2\n        if isinstance(a1, list):\n            self.A = [a2] * self.N + a1 + [a2] * (self.N - v1)\n            for v2 in range(self.N - 1, 0, -1):\n                self.A[v2] = a3(self.A[v2 * 2], self.A[v2 * 2 + 1])\n        else:\n            self.A = [a2] * (self.N * 2)\n        self.F = a3\n\n    def find(self, a1):\n        return self.A[a1 + self.N]\n\n    def update(self, a1, a2):\n        a1 += self.N\n        self.A[a1] = a2\n        while a1 > 1:\n            a1 = a1 // 2\n            self.A[a1] = self.merge(self.A[a1 * 2], self.A[a1 * 2 + 1])\n\n    def merge(self, a1, a2):\n        return self.F(a1, a2)\n\n    def total(self):\n        return self.A[1]\n\n    def query(self, a1, a2):\n        v1 = self.A\n        v2 = a1 + self.N\n        v3 = a2 + self.N\n        v4 = self.D\n        while v2 < v3:\n            if v2 % 2 == 1:\n                v4 = self.merge(v4, v1[v2])\n                v2 += 1\n            if v3 % 2 == 1:\n                v3 -= 1\n                v4 = self.merge(v4, v1[v3])\n            v2 >>= 1\n            v3 >>= 1\n        return v4\n\ndef f18():\n    v1 = f6()\n    v2 = f8()\n    v3 = f6()\n    v4 = [f5() for v5 in range(v3)]\n    v6 = [[0] * 26]\n    v7 = ord('a')\n    for v8 in v2:\n        v9 = [0] * 26\n        v9[ord(v8) - v7] = 1\n        v6.append(v9)\n\n    def f(a1, a2):\n        return [a1[i] + a2[i] for v1 in range(26)]\n    v10 = C1(v6, [0] * 26, f)\n    v11 = []\n    for v9, v12, v13 in v4:\n        if v9 == '1':\n            v14 = [0] * 26\n            v14[ord(v13) - v7] = 1\n            v10.update(int(v12), v14)\n        else:\n            v8 = v10.query(0, int(v12))\n            v15 = v10.query(0, int(v13) + 1)\n            v11.append(len([1 for v16 in range(26) if v8[v16] != v15[v16]]))\n    return f11(v11, '\\n')\nprint(f18())\n"}
{"id": "human_code\\find-number-of-coins-to-place-in-tree-nodes__part1.py", "text": "class C1(object):\n\n    def placedCoins(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = [0] * len(a2)\n            v2 = [(1, (0, -1, [a2[0]]))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6, v7 = v4\n                    v2.append((4, (v5, v7)))\n                    v2.append((2, (v5, v6, 0, v7)))\n                elif v3 == 2:\n                    v5, v6, v8, v7 = v4\n                    if v8 == len(adj[v5]):\n                        continue\n                    v9 = adj[v5][v8]\n                    v2.append((2, (v5, v6, v8 + 1, v7)))\n                    if v9 == v6:\n                        continue\n                    v10 = [a2[v9]]\n                    v2.append((3, (v10, v7)))\n                    v2.append((1, (v9, v5, v10)))\n                elif v3 == 3:\n                    v10, v7 = v4\n                    v7.extend(v10)\n                    v7.sort()\n                    if len(v7) > 5:\n                        v7 = v7[:2] + v7[-3:]\n                elif v3 == 4:\n                    v5, v7 = v4\n                    v1[v5] = 1 if len(v7) < 3 else max(v7[0] * v7[1] * v7[-1], v7[-3] * v7[-2] * v7[-1], 0)\n            return v1\n        v1 = [[] for v2 in range(len(a2))]\n        for v3, v4 in a1:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        return iter_dfs()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def placedCoins(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = [0] * len(a2)\n            v2 = [(1, (0, -1, [a2[0]]))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6, v7 = v4\n                    v2.append((4, (v5, v7)))\n                    v2.append((2, (v5, v6, 0, v7)))\n                elif v3 == 2:\n                    v5, v6, v8, v7 = v4\n                    if v8 == len(adj[v5]):\n                        continue\n                    v9 = adj[v5][v8]\n                    v2.append((2, (v5, v6, v8 + 1, v7)))\n                    if v9 == v6:\n                        continue\n                    v10 = [a2[v9]]\n                    v2.append((3, (v10, v7)))\n                    v2.append((1, (v9, v5, v10)))\n                elif v3 == 3:\n                    v10, v7 = v4\n                    v7.extend(v10)\n                    v7.sort()\n                    if len(v7) > 5:\n                        v7 = v7[:2] + v7[-3:]\n                elif v3 == 4:\n                    v5, v7 = v4\n                    v1[v5] = 1 if len(v7) < 3 else max(v7[0] * v7[1] * v7[-1], v7[-3] * v7[-2] * v7[-1], 0)\n            return v1\n        v1 = [[] for v2 in range(len(a2))]\n        for v3, v4 in a1:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        return iter_dfs()\n"}
{"id": "llm_code\\sliding-puzzle__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def slidingPuzzle(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = v1 * v2\n        v4 = tuple(range(1, v3)) + (0,)\n        v5 = tuple((b for v6 in a1 for v7 in v6))\n        if v5 == v4:\n            return 0\n        v8 = {v5}\n        v9 = collections.deque([(v5, 0)])\n        v10 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while v9:\n            v11, v12 = v9.popleft()\n            v13 = v11.index(0)\n            v14, v15 = divmod(v13, v2)\n            for v16, v17 in v10:\n                v18, v19 = (v14 + v16, v15 + v17)\n                if 0 <= v18 < v1 and 0 <= v19 < v2:\n                    v20 = v18 * v2 + v19\n                    v21 = list(v11)\n                    v21[v13], v21[v20] = (v21[v20], v21[v13])\n                    v22 = tuple(v21)\n                    if v22 not in v8:\n                        if v22 == v4:\n                            return v12 + 1\n                        v8.add(v22)\n                        v9.append((v22, v12 + 1))\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def slidingPuzzle(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = v1 * v2\n        v4 = tuple(range(1, v3)) + (0,)\n        v5 = tuple((b for v6 in a1 for v7 in v6))\n        if v5 == v4:\n            return 0\n        v8 = {v5}\n        v9 = collections.deque([(v5, 0)])\n        v10 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while v9:\n            v11, v12 = v9.popleft()\n            v13 = v11.index(0)\n            v14, v15 = divmod(v13, v2)\n            for v16, v17 in v10:\n                v18, v19 = (v14 + v16, v15 + v17)\n                if 0 <= v18 < v1 and 0 <= v19 < v2:\n                    v20 = v18 * v2 + v19\n                    v21 = list(v11)\n                    v21[v13], v21[v20] = (v21[v20], v21[v13])\n                    v22 = tuple(v21)\n                    if v22 not in v8:\n                        if v22 == v4:\n                            return v12 + 1\n                        v8.add(v22)\n                        v9.append((v22, v12 + 1))\n        return -1\n"}
{"id": "llm_code\\largest-magic-square__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def largestMagicSquare(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        for v4 in a1:\n            v5 = [0]\n            for v6 in v4:\n                v5.append(v5[-1] + v6)\n            v3.append(v5)\n        v7 = []\n        for v8 in range(v2):\n            v5 = [0]\n            for v9 in range(v1):\n                v5.append(v5[-1] + a1[v9][v8])\n            v7.append(v5)\n\n        def verify_magic(a1, a2, a3):\n            v1 = sum((a1[a1 + k][a2 + k] for v2 in range(a3)))\n            if sum((a1[a1 + v2][a2 + a3 - 1 - v2] for v2 in range(a3))) != v1:\n                return False\n            for v3 in range(a1, a1 + a3):\n                if v3[v3][a2 + a3] - v3[v3][a2] != v1:\n                    return False\n            for v4 in range(a2, a2 + a3):\n                if v7[v4][a1 + a3] - v7[v4][a1] != v1:\n                    return False\n            return True\n        v10 = min(v1, v2)\n        for v11 in range(v10, 0, -1):\n            for v12 in range(v1 - v11 + 1):\n                for v13 in range(v2 - v11 + 1):\n                    if verify_magic(v12, v13, v11):\n                        return v11\n        return 1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def largestMagicSquare(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        for v4 in a1:\n            v5 = [0]\n            for v6 in v4:\n                v5.append(v5[-1] + v6)\n            v3.append(v5)\n        v7 = []\n        for v8 in range(v2):\n            v5 = [0]\n            for v9 in range(v1):\n                v5.append(v5[-1] + a1[v9][v8])\n            v7.append(v5)\n\n        def verify_magic(a1, a2, a3):\n            v1 = sum((a1[a1 + k][a2 + k] for v2 in range(a3)))\n            if sum((a1[a1 + v2][a2 + a3 - 1 - v2] for v2 in range(a3))) != v1:\n                return False\n            for v3 in range(a1, a1 + a3):\n                if v3[v3][a2 + a3] - v3[v3][a2] != v1:\n                    return False\n            for v4 in range(a2, a2 + a3):\n                if v7[v4][a1 + a3] - v7[v4][a1] != v1:\n                    return False\n            return True\n        v10 = min(v1, v2)\n        for v11 in range(v10, 0, -1):\n            for v12 in range(v1 - v11 + 1):\n                for v13 in range(v2 - v11 + 1):\n                    if verify_magic(v12, v13, v11):\n                        return v11\n        return 1\n"}
{"id": "llm_code\\design-graph-with-shortest-path-calculator__grok-4.1-fast__v1.py", "text": "import heapq\nfrom collections import defaultdict\n\nclass C1:\n\n    def __init__(self, a1, a2):\n        self.neighbors = defaultdict(list)\n        for v1, v2, v3 in a2:\n            self.neighbors[v1].append((v2, v3))\n\n    def addEdge(self, a1):\n        v1, v2, v3 = a1\n        self.neighbors[v1].append((v2, v3))\n\n    def shortestPath(self, a1, a2):\n        v1 = {node: float('inf') for v2 in self.neighbors}\n        v1[a1] = 0\n        v3 = [(0, a1)]\n        while v3:\n            v4, v2 = heapq.heappop(v3)\n            if v4 > v1[v2]:\n                continue\n            for v5, v6 in self.neighbors[v2]:\n                v7 = v4 + v6\n                if v7 < v1.get(v5, float('inf')):\n                    v1[v5] = v7\n                    heapq.heappush(v3, (v7, v5))\n        return v1.get(a2, -1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\nfrom collections import defaultdict\n\nclass C1:\n\n    def __init__(self, a1, a2):\n        self.neighbors = defaultdict(list)\n        for v1, v2, v3 in a2:\n            self.neighbors[v1].append((v2, v3))\n\n    def addEdge(self, a1):\n        v1, v2, v3 = a1\n        self.neighbors[v1].append((v2, v3))\n\n    def shortestPath(self, a1, a2):\n        v1 = {node: float('inf') for v2 in self.neighbors}\n        v1[a1] = 0\n        v3 = [(0, a1)]\n        while v3:\n            v4, v2 = heapq.heappop(v3)\n            if v4 > v1[v2]:\n                continue\n            for v5, v6 in self.neighbors[v2]:\n                v7 = v4 + v6\n                if v7 < v1.get(v5, float('inf')):\n                    v1[v5] = v7\n                    heapq.heappush(v3, (v7, v5))\n        return v1.get(a2, -1)\n"}
{"id": "llm_code\\construct-string-with-minimum-cost-easy__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minimumCost(self, a1, a2, a3):\n        v1 = float('inf')\n        v2 = len(a1)\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.minc = v1\n        v3 = TrieNode()\n        v4 = len(a2)\n        for v5 in range(v4):\n            v6 = v3\n            v7 = a2[v5]\n            v8 = a3[v5]\n            for v9 in v7:\n                if v9 not in v6.children:\n                    v6.children[v9] = TrieNode()\n                v6 = v6.children[v9]\n            v6.minc = min(v6.minc, v8)\n        v10 = [v1] * (v2 + 1)\n        v10[0] = 0\n        for v11 in range(v2):\n            if v10[v11] == v1:\n                continue\n            v6 = v3\n            for v5 in range(v11, v2):\n                v9 = a1[v5]\n                if v9 not in v6.children:\n                    break\n                v6 = v6.children[v9]\n                if v6.minc != v1:\n                    v10[v5 + 1] = min(v10[v5 + 1], v10[v11] + v6.minc)\n        return v10[v2] if v10[v2] != v1 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minimumCost(self, a1, a2, a3):\n        v1 = float('inf')\n        v2 = len(a1)\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.minc = v1\n        v3 = TrieNode()\n        v4 = len(a2)\n        for v5 in range(v4):\n            v6 = v3\n            v7 = a2[v5]\n            v8 = a3[v5]\n            for v9 in v7:\n                if v9 not in v6.children:\n                    v6.children[v9] = TrieNode()\n                v6 = v6.children[v9]\n            v6.minc = min(v6.minc, v8)\n        v10 = [v1] * (v2 + 1)\n        v10[0] = 0\n        for v11 in range(v2):\n            if v10[v11] == v1:\n                continue\n            v6 = v3\n            for v5 in range(v11, v2):\n                v9 = a1[v5]\n                if v9 not in v6.children:\n                    break\n                v6 = v6.children[v9]\n                if v6.minc != v1:\n                    v10[v5 + 1] = min(v10[v5 + 1], v10[v11] + v6.minc)\n        return v10[v2] if v10[v2] != v1 else -1\n"}
{"id": "human_code\\p03593__s589320694.py", "text": "v1, v2 = map(int, input().split())\nv3 = [input() for v4 in range(v1)]\n\ndef f1(a1):\n    return ord(a1) - ord('a')\nif v1 % 2 == 0:\n    if v2 % 2 == 0:\n        v5 = 1\n    else:\n        v5 = 2\nelif v2 % 2 == 0:\n    v5 = 3\nelse:\n    v5 = 4\nv6 = [0] * 26\nfor v4 in range(v1):\n    for v7 in range(v2):\n        v6[f1(v3[v4][v7])] += 1\nv8 = 0\nv9 = 0\nfor v4 in range(26):\n    if v6[v4] % 2 == 1:\n        v10 = v6[v4]\n        if v10 % 4 == 3:\n            v9 += 1\n        v8 += 1\n    elif v6[v4] % 2 == 0 and v6[v4] % 4 != 0:\n        v9 += 1\nif v8 > 1:\n    print('No')\n    exit()\nelif v5 == 1:\n    if v9 > 0:\n        print('No')\n        exit()\nelif v5 == 2:\n    if v9 > v1 // 2:\n        print('No')\n        exit()\nelif v5 == 3:\n    if v9 > v2 // 2:\n        print('No')\n        exit()\nelif v5 == 4:\n    if v9 > (v1 + v2 - 2) // 2:\n        print('No')\n        exit()\nprint('Yes')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = [input() for v4 in range(v1)]\n\ndef f1(a1):\n    return ord(a1) - ord('a')\nif v1 % 2 == 0:\n    if v2 % 2 == 0:\n        v5 = 1\n    else:\n        v5 = 2\nelif v2 % 2 == 0:\n    v5 = 3\nelse:\n    v5 = 4\nv6 = [0] * 26\nfor v4 in range(v1):\n    for v7 in range(v2):\n        v6[f1(v3[v4][v7])] += 1\nv8 = 0\nv9 = 0\nfor v4 in range(26):\n    if v6[v4] % 2 == 1:\n        v10 = v6[v4]\n        if v10 % 4 == 3:\n            v9 += 1\n        v8 += 1\n    elif v6[v4] % 2 == 0 and v6[v4] % 4 != 0:\n        v9 += 1\nif v8 > 1:\n    print('No')\n    exit()\nelif v5 == 1:\n    if v9 > 0:\n        print('No')\n        exit()\nelif v5 == 2:\n    if v9 > v1 // 2:\n        print('No')\n        exit()\nelif v5 == 3:\n    if v9 > v2 // 2:\n        print('No')\n        exit()\nelif v5 == 4:\n    if v9 > (v1 + v2 - 2) // 2:\n        print('No')\n        exit()\nprint('Yes')\n"}
{"id": "human_code\\find-all-people-with-secret__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def findAllPeople(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        a2.sort(key=lambda x: x[2])\n        v1 = {0, a3}\n        v2 = collections.defaultdict(list)\n        for v3, (v4, v5, v6) in enumerate(a2):\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n            if v3 + 1 != len(a2) and a2[v3 + 1][2] == a2[v3][2]:\n                continue\n            v7 = [v3 for v3 in v2.keys() if v3 in v1]\n            while v7:\n                v8 = v7.pop()\n                for v9 in v2[v8]:\n                    if v9 in v1:\n                        continue\n                    v1.add(v9)\n                    v7.append(v9)\n            v2 = collections.defaultdict(list)\n        return list(v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def findAllPeople(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        a2.sort(key=lambda x: x[2])\n        v1 = {0, a3}\n        v2 = collections.defaultdict(list)\n        for v3, (v4, v5, v6) in enumerate(a2):\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n            if v3 + 1 != len(a2) and a2[v3 + 1][2] == a2[v3][2]:\n                continue\n            v7 = [v3 for v3 in v2.keys() if v3 in v1]\n            while v7:\n                v8 = v7.pop()\n                for v9 in v2[v8]:\n                    if v9 in v1:\n                        continue\n                    v1.add(v9)\n                    v7.append(v9)\n            v2 = collections.defaultdict(list)\n        return list(v1)\n"}
{"id": "llm_code\\maximum-frequency-score-of-a-subarray__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def maxFrequencyScore(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        if a2 > v2:\n            return 0\n        v3 = collections.defaultdict(int)\n        v4 = 0\n        for v5 in range(a2):\n            v6 = a1[v5]\n            if v3[v6] > 0:\n                v4 = (v4 - pow(v6, v3[v6], v1) + v1) % v1\n            v3[v6] += 1\n            v4 = (v4 + pow(v6, v3[v6], v1)) % v1\n        v7 = v4\n        for v5 in range(a2, v2):\n            v8 = a1[v5 - a2]\n            v4 = (v4 - pow(v8, v3[v8], v1) + v1) % v1\n            v3[v8] -= 1\n            if v3[v8] > 0:\n                v4 = (v4 + pow(v8, v3[v8], v1)) % v1\n            v9 = a1[v5]\n            if v3[v9] > 0:\n                v4 = (v4 - pow(v9, v3[v9], v1) + v1) % v1\n            v3[v9] += 1\n            v4 = (v4 + pow(v9, v3[v9], v1)) % v1\n            v7 = max(v7, v4)\n        return v7\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def maxFrequencyScore(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        if a2 > v2:\n            return 0\n        v3 = collections.defaultdict(int)\n        v4 = 0\n        for v5 in range(a2):\n            v6 = a1[v5]\n            if v3[v6] > 0:\n                v4 = (v4 - pow(v6, v3[v6], v1) + v1) % v1\n            v3[v6] += 1\n            v4 = (v4 + pow(v6, v3[v6], v1)) % v1\n        v7 = v4\n        for v5 in range(a2, v2):\n            v8 = a1[v5 - a2]\n            v4 = (v4 - pow(v8, v3[v8], v1) + v1) % v1\n            v3[v8] -= 1\n            if v3[v8] > 0:\n                v4 = (v4 + pow(v8, v3[v8], v1)) % v1\n            v9 = a1[v5]\n            if v3[v9] > 0:\n                v4 = (v4 - pow(v9, v3[v9], v1) + v1) % v1\n            v3[v9] += 1\n            v4 = (v4 + pow(v9, v3[v9], v1)) % v1\n            v7 = max(v7, v4)\n        return v7\n"}
{"id": "human_code\\find-weighted-median-node-in-tree__part2.py", "text": "class C1(object):\n\n    def findMedian(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1):\n            for v1 in lookup2[a1]:\n                if a3[v1][0] == a3[v1][1]:\n                    lca[v1] = a1\n                    continue\n                result[v1] += dist[a1]\n                for v2 in a3[v1]:\n                    if lookup[v2]:\n                        lca[v1] = ancestor[uf.find_set(v2)]\n                        result[v1] -= 2 * dist[lca[v1]]\n            lookup[a1] = True\n            for v3, v4 in adj[a1]:\n                if lookup[v3]:\n                    continue\n                dist[v3] = dist[a1] + v4\n                depth[v3] = depth[a1] + 1\n                dfs(v3)\n                uf.union_set(v3, a1)\n                ancestor[uf.find_set(a1)] = a1\n\n        def dfs2(a1):\n            path.append(a1)\n            for v1, v2 in lookup3[a1]:\n                v3 = depth[a1] - depth[lca[v1]]\n                if v2 == 0:\n                    v4 = binary_search(0, v3, lambda x: 2 * (dist[a1] - dist[path[-(x + 1)]]) >= result[v1])\n                    result2[v1] = path[-(v4 + 1)]\n                else:\n                    v5 = dist[a3[v1][0]] - dist[lca[v1]]\n                    v4 = binary_search(0, v3 - 1, lambda x: 2 * (v5 + (dist[path[-(v3 - 1 + 1) + x]] - dist[lca[v1]])) >= result[v1])\n                    result2[v1] = path[-(v3 - 1 + 1) + v4]\n            for v6, v7 in adj[a1]:\n                if len(path) >= 2 and path[-2] == v6:\n                    continue\n                dfs2(v6)\n            path.pop()\n        v1 = [[] for v2 in range(len(a2) + 1)]\n        for v3, v4, v5 in a2:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = [False] * len(v1)\n        v7 = [[] for v2 in range(len(v1))]\n        for v8, v9 in enumerate(a3):\n            for v10 in v9:\n                v7[v10].append(v8)\n        v11 = UnionFind(len(v1))\n        v12 = list(range(len(v1)))\n        v13 = [0] * len(v1)\n        v14 = [0] * len(v1)\n        v15 = [0] * len(a3)\n        v16 = [-1] * len(a3)\n        dfs(0)\n        v17 = [0] * len(a3)\n        v18 = [[] for v2 in range(len(v1))]\n        for v8, (v3, v4) in enumerate(a3):\n            if 2 * (v13[v3] - v13[v16[v8]]) >= v15[v8]:\n                v18[v3].append((v8, 0))\n            else:\n                v18[v4].append((v8, 1))\n        v19 = []\n        dfs2(0)\n        return v17\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findMedian(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1):\n            for v1 in lookup2[a1]:\n                if a3[v1][0] == a3[v1][1]:\n                    lca[v1] = a1\n                    continue\n                result[v1] += dist[a1]\n                for v2 in a3[v1]:\n                    if lookup[v2]:\n                        lca[v1] = ancestor[uf.find_set(v2)]\n                        result[v1] -= 2 * dist[lca[v1]]\n            lookup[a1] = True\n            for v3, v4 in adj[a1]:\n                if lookup[v3]:\n                    continue\n                dist[v3] = dist[a1] + v4\n                depth[v3] = depth[a1] + 1\n                dfs(v3)\n                uf.union_set(v3, a1)\n                ancestor[uf.find_set(a1)] = a1\n\n        def dfs2(a1):\n            path.append(a1)\n            for v1, v2 in lookup3[a1]:\n                v3 = depth[a1] - depth[lca[v1]]\n                if v2 == 0:\n                    v4 = binary_search(0, v3, lambda x: 2 * (dist[a1] - dist[path[-(x + 1)]]) >= result[v1])\n                    result2[v1] = path[-(v4 + 1)]\n                else:\n                    v5 = dist[a3[v1][0]] - dist[lca[v1]]\n                    v4 = binary_search(0, v3 - 1, lambda x: 2 * (v5 + (dist[path[-(v3 - 1 + 1) + x]] - dist[lca[v1]])) >= result[v1])\n                    result2[v1] = path[-(v3 - 1 + 1) + v4]\n            for v6, v7 in adj[a1]:\n                if len(path) >= 2 and path[-2] == v6:\n                    continue\n                dfs2(v6)\n            path.pop()\n        v1 = [[] for v2 in range(len(a2) + 1)]\n        for v3, v4, v5 in a2:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = [False] * len(v1)\n        v7 = [[] for v2 in range(len(v1))]\n        for v8, v9 in enumerate(a3):\n            for v10 in v9:\n                v7[v10].append(v8)\n        v11 = UnionFind(len(v1))\n        v12 = list(range(len(v1)))\n        v13 = [0] * len(v1)\n        v14 = [0] * len(v1)\n        v15 = [0] * len(a3)\n        v16 = [-1] * len(a3)\n        dfs(0)\n        v17 = [0] * len(a3)\n        v18 = [[] for v2 in range(len(v1))]\n        for v8, (v3, v4) in enumerate(a3):\n            if 2 * (v13[v3] - v13[v16[v8]]) >= v15[v8]:\n                v18[v3].append((v8, 0))\n            else:\n                v18[v4].append((v8, 1))\n        v19 = []\n        dfs2(0)\n        return v17\n"}
{"id": "human_code\\maximum-tastiness-of-candy-basket.py", "text": "class C1(object):\n\n    def maximumTastiness(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = v2 = 0\n            for v3 in range(len(a1)):\n                if v2 and a1[v3] - v2 < a1:\n                    continue\n                v1 += 1\n                if v1 == a2:\n                    break\n                v2 = a1[v3]\n            return v1 >= a2\n        a1.sort()\n        v1, v2 = (1, a1[-1] - a1[0])\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if not check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumTastiness(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = v2 = 0\n            for v3 in range(len(a1)):\n                if v2 and a1[v3] - v2 < a1:\n                    continue\n                v1 += 1\n                if v1 == a2:\n                    break\n                v2 = a1[v3]\n            return v1 >= a2\n        a1.sort()\n        v1, v2 = (1, a1[-1] - a1[0])\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if not check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v2\n"}
{"id": "llm_code\\minimum-cost-of-a-path-with-special-roads__grok-4.1-fast__v1.py", "text": "import collections\nimport heapq\nfrom math import inf\n\nclass C1:\n\n    def minimumCost(self, a1, a2, a3):\n        v1 = tuple(a1)\n        v2 = tuple(a2)\n        v3 = collections.defaultdict(list)\n        v3[v2] = []\n        for v4, v5, v6, v7, v8 in a3:\n            v3[v4, v5].append(((v6, v7), v8))\n        v9 = list(v3.keys())\n        v10 = {}\n        v11 = []\n        heapq.heappush(v11, (0, v1))\n        v10[v1] = 0\n        while v11:\n            v12, v13 = heapq.heappop(v11)\n            if v12 > v10.get(v13, inf):\n                continue\n            if v13 == v2:\n                return v12\n            for v14, v8 in v3[v13]:\n                v15 = v12 + v8\n                if v15 < v10.get(v14, inf):\n                    v10[v14] = v15\n                    heapq.heappush(v11, (v15, v14))\n            for v16 in v9:\n                v17 = abs(v13[0] - v16[0]) + abs(v13[1] - v16[1])\n                v15 = v12 + v17\n                if v15 < v10.get(v16, inf):\n                    v10[v16] = v15\n                    heapq.heappush(v11, (v15, v16))\n        return v10.get(v2, inf)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\nimport heapq\nfrom math import inf\n\nclass C1:\n\n    def minimumCost(self, a1, a2, a3):\n        v1 = tuple(a1)\n        v2 = tuple(a2)\n        v3 = collections.defaultdict(list)\n        v3[v2] = []\n        for v4, v5, v6, v7, v8 in a3:\n            v3[v4, v5].append(((v6, v7), v8))\n        v9 = list(v3.keys())\n        v10 = {}\n        v11 = []\n        heapq.heappush(v11, (0, v1))\n        v10[v1] = 0\n        while v11:\n            v12, v13 = heapq.heappop(v11)\n            if v12 > v10.get(v13, inf):\n                continue\n            if v13 == v2:\n                return v12\n            for v14, v8 in v3[v13]:\n                v15 = v12 + v8\n                if v15 < v10.get(v14, inf):\n                    v10[v14] = v15\n                    heapq.heappush(v11, (v15, v14))\n            for v16 in v9:\n                v17 = abs(v13[0] - v16[0]) + abs(v13[1] - v16[1])\n                v15 = v12 + v17\n                if v15 < v10.get(v16, inf):\n                    v10[v16] = v15\n                    heapq.heappush(v11, (v15, v16))\n        return v10.get(v2, inf)\n"}
{"id": "llm_code\\find-the-original-typed-string-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def possibleStringCount(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = []\n        v3 = 0\n        v4 = len(a1)\n        while v3 < v4:\n            v5 = v3\n            while v3 < v4 and a1[v3] == a1[v5]:\n                v3 += 1\n            v2.append(v3 - v5)\n        v6 = len(v2)\n        v7 = 1\n        for v8 in v2:\n            v7 = v7 * v8 % v1\n        if a2 <= v6:\n            return v7\n        v9 = a2 - v6\n        v10 = [0] * v9\n        v10[0] = 1\n        for v8 in v2:\n            v11 = [0] * (v9 + 1)\n            for v12 in range(v9):\n                v11[v12 + 1] = (v11[v12] + v10[v12]) % v1\n            for v12 in range(v9):\n                v13 = max(0, v12 - v8 + 1)\n                v10[v12] = (v11[v12 + 1] - v11[v13] + v1) % v1\n        v14 = sum(v10) % v1\n        return (v7 - v14 + v1) % v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def possibleStringCount(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = []\n        v3 = 0\n        v4 = len(a1)\n        while v3 < v4:\n            v5 = v3\n            while v3 < v4 and a1[v3] == a1[v5]:\n                v3 += 1\n            v2.append(v3 - v5)\n        v6 = len(v2)\n        v7 = 1\n        for v8 in v2:\n            v7 = v7 * v8 % v1\n        if a2 <= v6:\n            return v7\n        v9 = a2 - v6\n        v10 = [0] * v9\n        v10[0] = 1\n        for v8 in v2:\n            v11 = [0] * (v9 + 1)\n            for v12 in range(v9):\n                v11[v12 + 1] = (v11[v12] + v10[v12]) % v1\n            for v12 in range(v9):\n                v13 = max(0, v12 - v8 + 1)\n                v10[v12] = (v11[v12 + 1] - v11[v13] + v1) % v1\n        v14 = sum(v10) % v1\n        return (v7 - v14 + v1) % v1\n"}
{"id": "human_code\\p03722__s182900061.py", "text": "v1, v2 = [int(_) for v3 in input().split()]\nv4 = {}\nfor v5 in range(v1):\n    v4[v5] = {}\nfor v3 in range(v2):\n    v6, v7, v8 = [int(v3) for v3 in input().split()]\n    v6 -= 1\n    v7 -= 1\n    v4[v6][v7] = -v8\nv9 = float('inf')\nv10 = [v9] * v1\nv10[0] = 0\nv11 = 0\nwhile True:\n    v11 += 1\n    v12 = False\n    v13 = False\n    for v6 in v4.keys():\n        for v7 in v4[v6].keys():\n            if v10[v6] != v9 and v10[v7] > v10[v6] + v4[v6][v7]:\n                v10[v7] = v10[v6] + v4[v6][v7]\n                v12 = True\n                if v7 == v1 - 1:\n                    v13 = True\n    if not v12 or v11 == v1:\n        break\nif v13:\n    print('inf')\nelse:\n    print(-v10[-1])\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = [int(_) for v3 in input().split()]\nv4 = {}\nfor v5 in range(v1):\n    v4[v5] = {}\nfor v3 in range(v2):\n    v6, v7, v8 = [int(v3) for v3 in input().split()]\n    v6 -= 1\n    v7 -= 1\n    v4[v6][v7] = -v8\nv9 = float('inf')\nv10 = [v9] * v1\nv10[0] = 0\nv11 = 0\nwhile True:\n    v11 += 1\n    v12 = False\n    v13 = False\n    for v6 in v4.keys():\n        for v7 in v4[v6].keys():\n            if v10[v6] != v9 and v10[v7] > v10[v6] + v4[v6][v7]:\n                v10[v7] = v10[v6] + v4[v6][v7]\n                v12 = True\n                if v7 == v1 - 1:\n                    v13 = True\n    if not v12 or v11 == v1:\n        break\nif v13:\n    print('inf')\nelse:\n    print(-v10[-1])\n"}
{"id": "llm_code\\number-of-paths-with-max-score__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def pathsWithMaxScore(self, a1):\n        v1 = 10 ** 9 + 7\n        v2, v3 = (len(a1), len(a1[0]))\n        v4 = [[[0, 0] for v5 in range(v3)] for v5 in range(v2)]\n        if a1[0][0] not in 'XS':\n            v6 = 0 if a1[0][0] == 'E' else int(a1[0][0])\n            v4[0][0] = [v6, 1]\n        for v7 in range(v2):\n            for v8 in range(v3):\n                if a1[v7][v8] in 'XS':\n                    continue\n                v9 = -1\n                v10 = 0\n                for v11, v12 in [(0, -1), (-1, 0), (-1, -1)]:\n                    v13, v14 = (v7 + v11, v8 + v12)\n                    if 0 <= v13 < v2 and 0 <= v14 < v3 and (v4[v13][v14][1] > 0):\n                        v15 = v4[v13][v14][0]\n                        if v15 > v9:\n                            v9 = v15\n                            v10 = v4[v13][v14][1]\n                        elif v15 == v9:\n                            v10 = (v10 + v4[v13][v14][1]) % v1\n                if v9 != -1:\n                    v16 = 0 if a1[v7][v8] == 'E' else int(a1[v7][v8])\n                    v4[v7][v8] = [v9 + v16, v10]\n        return v4[v2 - 1][v3 - 1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def pathsWithMaxScore(self, a1):\n        v1 = 10 ** 9 + 7\n        v2, v3 = (len(a1), len(a1[0]))\n        v4 = [[[0, 0] for v5 in range(v3)] for v5 in range(v2)]\n        if a1[0][0] not in 'XS':\n            v6 = 0 if a1[0][0] == 'E' else int(a1[0][0])\n            v4[0][0] = [v6, 1]\n        for v7 in range(v2):\n            for v8 in range(v3):\n                if a1[v7][v8] in 'XS':\n                    continue\n                v9 = -1\n                v10 = 0\n                for v11, v12 in [(0, -1), (-1, 0), (-1, -1)]:\n                    v13, v14 = (v7 + v11, v8 + v12)\n                    if 0 <= v13 < v2 and 0 <= v14 < v3 and (v4[v13][v14][1] > 0):\n                        v15 = v4[v13][v14][0]\n                        if v15 > v9:\n                            v9 = v15\n                            v10 = v4[v13][v14][1]\n                        elif v15 == v9:\n                            v10 = (v10 + v4[v13][v14][1]) % v1\n                if v9 != -1:\n                    v16 = 0 if a1[v7][v8] == 'E' else int(a1[v7][v8])\n                    v4[v7][v8] = [v9 + v16, v10]\n        return v4[v2 - 1][v3 - 1]\n"}
{"id": "human_code\\maximum-elegance-of-a-k-length-subsequence__part1.py", "text": "import heapq\nfrom sortedcontainers import SortedList\n\nclass C1(object):\n\n    def findMaximumElegance(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = set()\n        v3 = []\n        for v4, v5 in heapq.nlargest(a2, a1):\n            if v5 in v2:\n                v3.append(v4)\n            v1 += v4\n            v2.add(v5)\n        v6 = SortedList()\n        v7 = {}\n        for v4, v5 in a1:\n            if v5 in v2:\n                continue\n            if v5 in v7:\n                if v7[v5] >= v4:\n                    continue\n                v6.remove((v7[v5], v5))\n            v6.add((v4, v5))\n            v7[v5] = v4\n            if len(v6) > len(v3):\n                del v7[v6[0][1]]\n                del v6[0]\n        v8 = v1 + len(v2) ** 2\n        for v4, v5 in reversed(v6):\n            v1 += v4 - v3.pop()\n            v2.add(v5)\n            v8 = max(v8, v1 + len(v2) ** 2)\n        return v8\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\nfrom sortedcontainers import SortedList\n\nclass C1(object):\n\n    def findMaximumElegance(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = set()\n        v3 = []\n        for v4, v5 in heapq.nlargest(a2, a1):\n            if v5 in v2:\n                v3.append(v4)\n            v1 += v4\n            v2.add(v5)\n        v6 = SortedList()\n        v7 = {}\n        for v4, v5 in a1:\n            if v5 in v2:\n                continue\n            if v5 in v7:\n                if v7[v5] >= v4:\n                    continue\n                v6.remove((v7[v5], v5))\n            v6.add((v4, v5))\n            v7[v5] = v4\n            if len(v6) > len(v3):\n                del v7[v6[0][1]]\n                del v6[0]\n        v8 = v1 + len(v2) ** 2\n        for v4, v5 in reversed(v6):\n            v1 += v4 - v3.pop()\n            v2.add(v5)\n            v8 = max(v8, v1 + len(v2) ** 2)\n        return v8\n"}
{"id": "human_code\\minimum-score-after-removals-on-a-tree__part3.py", "text": "from functools import reduce\n\nclass C1(object):\n\n    def minimumScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            v1 = a1[a1]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 ^= dfs(v2, a1, a3)\n            a3.append(v1)\n            return v1\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = reduce(lambda x, y: x ^ y, a1)\n        v6 = float('inf')\n        for v3, v4 in a2:\n            v7 = []\n            dfs(v3, v4, v7)\n            v8 = []\n            dfs(v4, v3, v8)\n            for v9 in (v7, v8):\n                v10 = v9.pop()\n                for v11 in v9:\n                    v12, v13, v14 = (v5 ^ v10, v11, v10 ^ v11)\n                    v6 = min(v6, max(v12, v13, v14) - min(v12, v13, v14))\n        return v6\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from functools import reduce\n\nclass C1(object):\n\n    def minimumScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            v1 = a1[a1]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 ^= dfs(v2, a1, a3)\n            a3.append(v1)\n            return v1\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = reduce(lambda x, y: x ^ y, a1)\n        v6 = float('inf')\n        for v3, v4 in a2:\n            v7 = []\n            dfs(v3, v4, v7)\n            v8 = []\n            dfs(v4, v3, v8)\n            for v9 in (v7, v8):\n                v10 = v9.pop()\n                for v11 in v9:\n                    v12, v13, v14 = (v5 ^ v10, v11, v10 ^ v11)\n                    v6 = min(v6, max(v12, v13, v14) - min(v12, v13, v14))\n        return v6\n"}
{"id": "llm_code\\find-longest-special-substring-that-occurs-thrice-i__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maximumLength(self, a1):\n        v1 = [[] for v2 in range(26)]\n        v3 = len(a1)\n        v4 = 0\n        while v4 < v3:\n            v5 = a1[v4]\n            v6 = v4\n            while v4 < v3 and a1[v4] == v5:\n                v4 += 1\n            v1[ord(v5) - ord('a')].append(v4 - v6)\n        v7 = 0\n        for v8 in v1:\n            if not v8:\n                continue\n            v8.sort(reverse=True)\n            v7 = max(v7, v8[0] - 2)\n            v9 = len(v8)\n            if v9 >= 2:\n                v7 = max(v7, min(v8[0] - 1, v8[1]))\n            if v9 >= 3:\n                v7 = max(v7, v8[2])\n        return v7 if v7 > 0 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumLength(self, a1):\n        v1 = [[] for v2 in range(26)]\n        v3 = len(a1)\n        v4 = 0\n        while v4 < v3:\n            v5 = a1[v4]\n            v6 = v4\n            while v4 < v3 and a1[v4] == v5:\n                v4 += 1\n            v1[ord(v5) - ord('a')].append(v4 - v6)\n        v7 = 0\n        for v8 in v1:\n            if not v8:\n                continue\n            v8.sort(reverse=True)\n            v7 = max(v7, v8[0] - 2)\n            v9 = len(v8)\n            if v9 >= 2:\n                v7 = max(v7, min(v8[0] - 1, v8[1]))\n            if v9 >= 3:\n                v7 = max(v7, v8[2])\n        return v7 if v7 > 0 else -1\n"}
{"id": "llm_code\\partition-array-into-two-arrays-to-minimize-sum-difference__grok-4.1-fast__v1.py", "text": "import bisect\n\nclass C1:\n\n    def minimumDifference(self, a1):\n        v1 = len(a1)\n        v2 = v1 // 2\n        v3 = a1[:v2]\n        v4 = a1[v2:]\n\n        def get_sums(a1):\n            v1 = len(a1)\n            v2 = [[] for v3 in range(v1 + 1)]\n\n            def search(a1, a2, a3):\n                if a1 == v1:\n                    v2[a3].append(a2)\n                    return\n                search(a1 + 1, a2, a3)\n                search(a1 + 1, a2 + a1[a1], a3 + 1)\n            search(0, 0, 0)\n            for v4 in range(v1 + 1):\n                v2[v4].sort()\n            return v2\n        v5 = get_sums(v3)\n        v6 = get_sums(v4)\n        v7 = sum(a1)\n        v8 = float('inf')\n        for v9 in range(v2 + 1):\n            v10 = v2 - v9\n            v11 = v5[v9]\n            v12 = v6[v10]\n            for v13 in v11:\n                v14 = v7 / 2 - v13\n                v15 = bisect.bisect_left(v12, v14)\n                for v16 in (v15 - 1, v15):\n                    if 0 <= v16 < len(v12):\n                        v17 = v12[v16]\n                        v18 = abs(2 * (v13 + v17) - v7)\n                        if v18 < v8:\n                            v8 = v18\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1:\n\n    def minimumDifference(self, a1):\n        v1 = len(a1)\n        v2 = v1 // 2\n        v3 = a1[:v2]\n        v4 = a1[v2:]\n\n        def get_sums(a1):\n            v1 = len(a1)\n            v2 = [[] for v3 in range(v1 + 1)]\n\n            def search(a1, a2, a3):\n                if a1 == v1:\n                    v2[a3].append(a2)\n                    return\n                search(a1 + 1, a2, a3)\n                search(a1 + 1, a2 + a1[a1], a3 + 1)\n            search(0, 0, 0)\n            for v4 in range(v1 + 1):\n                v2[v4].sort()\n            return v2\n        v5 = get_sums(v3)\n        v6 = get_sums(v4)\n        v7 = sum(a1)\n        v8 = float('inf')\n        for v9 in range(v2 + 1):\n            v10 = v2 - v9\n            v11 = v5[v9]\n            v12 = v6[v10]\n            for v13 in v11:\n                v14 = v7 / 2 - v13\n                v15 = bisect.bisect_left(v12, v14)\n                for v16 in (v15 - 1, v15):\n                    if 0 <= v16 < len(v12):\n                        v17 = v12[v16]\n                        v18 = abs(2 * (v13 + v17) - v7)\n                        if v18 < v8:\n                            v8 = v18\n        return v8\n"}
{"id": "human_code\\p03340__s503770890.py", "text": "from collections import defaultdict, deque\nimport sys, heapq, bisect, math, itertools, string, queue, datetime\nsys.setrecursionlimit(10 ** 8)\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3 = 10 ** (-7)\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return list(map(int, input().split()))\n\ndef f3():\n    return list(input().split())\nv4 = [chr(i) for v5 in range(97, 97 + 26)]\nv6 = f1()\nv7 = f2()\nv8 = v9 = 0\nv10 = 0\nv11 = 0\nfor v12 in range(v6):\n    while v8 == v9:\n        v11 += v10 - v12\n        v10 += 1\n        if v10 > v6:\n            break\n        v8 ^= v7[v10 - 1]\n        v9 += v7[v10 - 1]\n    else:\n        v9 -= v7[v12]\n        v8 ^= v7[v12]\n        continue\n    break\nprint(v11)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from collections import defaultdict, deque\nimport sys, heapq, bisect, math, itertools, string, queue, datetime\nsys.setrecursionlimit(10 ** 8)\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3 = 10 ** (-7)\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return list(map(int, input().split()))\n\ndef f3():\n    return list(input().split())\nv4 = [chr(i) for v5 in range(97, 97 + 26)]\nv6 = f1()\nv7 = f2()\nv8 = v9 = 0\nv10 = 0\nv11 = 0\nfor v12 in range(v6):\n    while v8 == v9:\n        v11 += v10 - v12\n        v10 += 1\n        if v10 > v6:\n            break\n        v8 ^= v7[v10 - 1]\n        v9 += v7[v10 - 1]\n    else:\n        v9 -= v7[v12]\n        v8 ^= v7[v12]\n        continue\n    break\nprint(v11)\n"}
{"id": "llm_code\\p03439__s780214256.py", "text": "v1 = int(input())\nfor v2 in range(20):\n    if v2 == 0:\n        v3 = 0\n        v4 = v1 - 1\n        v5 = 0\n        print(v5)\n    else:\n        v5 = (v3 + v4) // 2\n        print(v5)\n    v6 = input()\n    v7 = v6[0]\n    if v7 == 'V':\n        exit()\n    elif v2 == 0:\n        v8 = v7\n    elif v8 == v7:\n        v3 = v5\n    elif v5 % 2 == 1:\n        print(v5 - 1)\n        v6 = input()\n        v7 = v6[0]\n        if v7 == 'V':\n            exit()\n        else:\n            print('E')\n            exit()\n    else:\n        v8 = v7\n        v4 = v5\nprint('End')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nfor v2 in range(20):\n    if v2 == 0:\n        v3 = 0\n        v4 = v1 - 1\n        v5 = 0\n        print(v5)\n    else:\n        v5 = (v3 + v4) // 2\n        print(v5)\n    v6 = input()\n    v7 = v6[0]\n    if v7 == 'V':\n        exit()\n    elif v2 == 0:\n        v8 = v7\n    elif v8 == v7:\n        v3 = v5\n    elif v5 % 2 == 1:\n        print(v5 - 1)\n        v6 = input()\n        v7 = v6[0]\n        if v7 == 'V':\n            exit()\n        else:\n            print('E')\n            exit()\n    else:\n        v8 = v7\n        v4 = v5\nprint('End')\n"}
{"id": "human_code\\amount-of-new-area-painted-each-day__part2.py", "text": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def amountPainted(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        for v2, (v3, v4) in enumerate(a1):\n            v1[v3].append((True, v2))\n            v1[v4].append((False, v2))\n        v5 = SortedList()\n        v6 = [0] * len(a1)\n        v7 = -1\n        for v8 in sorted(v1.keys()):\n            if v5:\n                v6[v5[0]] += v8 - v7\n            v7 = v8\n            for v9, v2 in v1[v8]:\n                if v9:\n                    v5.add(v2)\n                else:\n                    v5.remove(v2)\n        return v6\n\nclass C2(object):\n\n    def __init__(self, a1, a2=lambda x: 0, a3=lambda x, y: y if x is None else x + y, a4=lambda x, y: y):\n        self.tree = [None] * (2 * a1)\n        self.lazy = [None] * len(self.tree)\n        self.base = len(self.tree) // 2\n        self.H = (self.base - 1).bit_length()\n        self.query_fn = a3\n        self.update_fn = a4\n        for v1 in range(self.base, self.base + a1):\n            self.tree[v1] = a2(v1 - self.base)\n        for v1 in reversed(range(1, self.base)):\n            self.tree[v1] = a3(self.tree[2 * v1], self.tree[2 * v1 + 1])\n        self.count = [1] * (2 * a1)\n        for v1 in reversed(range(1, a1)):\n            self.count[v1] = self.count[2 * v1] + self.count[2 * v1 + 1]\n\n    def __apply(self, a1, a2):\n        self.tree[a1] = self.update_fn(self.tree[a1], a2 * self.count[a1])\n        if a1 < self.base:\n            self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n    def __push(self, a1):\n        v1 = 2 ** self.H\n        while v1 != 1:\n            v2 = a1 // v1\n            if self.lazy[v2] is not None:\n                self.__apply(v2 * 2, self.lazy[v2])\n                self.__apply(v2 * 2 + 1, self.lazy[v2])\n                self.lazy[v2] = None\n            v1 //= 2\n\n    def update(self, a1, a2, a3):\n\n        def pull(a1):\n            while a1 > 1:\n                a1 //= 2\n                self.tree[a1] = self.query_fn(self.tree[a1 * 2], self.tree[a1 * 2 + 1])\n                if self.lazy[a1] is not None:\n                    self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1] * self.count[a1])\n        if a1 > a2:\n            return\n        a1 += self.base\n        a2 += self.base\n        self.__push(a1)\n        self.__push(a2)\n        v3, v4 = (a1, a2)\n        while a1 <= a2:\n            if a1 & 1:\n                self.__apply(a1, a3)\n                a1 += 1\n            if a2 & 1 == 0:\n                self.__apply(a2, a3)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        pull(v3)\n        pull(v4)\n\n    def query(self, a1, a2):\n        v1 = None\n        if a1 > a2:\n            return v1\n        a1 += self.base\n        a2 += self.base\n        self.__push(a1)\n        self.__push(a2)\n        while a1 <= a2:\n            if a1 & 1:\n                v1 = self.query_fn(v1, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v1 = self.query_fn(v1, self.tree[a2])\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def amountPainted(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        for v2, (v3, v4) in enumerate(a1):\n            v1[v3].append((True, v2))\n            v1[v4].append((False, v2))\n        v5 = SortedList()\n        v6 = [0] * len(a1)\n        v7 = -1\n        for v8 in sorted(v1.keys()):\n            if v5:\n                v6[v5[0]] += v8 - v7\n            v7 = v8\n            for v9, v2 in v1[v8]:\n                if v9:\n                    v5.add(v2)\n                else:\n                    v5.remove(v2)\n        return v6\n\nclass C2(object):\n\n    def __init__(self, a1, a2=lambda x: 0, a3=lambda x, y: y if x is None else x + y, a4=lambda x, y: y):\n        self.tree = [None] * (2 * a1)\n        self.lazy = [None] * len(self.tree)\n        self.base = len(self.tree) // 2\n        self.H = (self.base - 1).bit_length()\n        self.query_fn = a3\n        self.update_fn = a4\n        for v1 in range(self.base, self.base + a1):\n            self.tree[v1] = a2(v1 - self.base)\n        for v1 in reversed(range(1, self.base)):\n            self.tree[v1] = a3(self.tree[2 * v1], self.tree[2 * v1 + 1])\n        self.count = [1] * (2 * a1)\n        for v1 in reversed(range(1, a1)):\n            self.count[v1] = self.count[2 * v1] + self.count[2 * v1 + 1]\n\n    def __apply(self, a1, a2):\n        self.tree[a1] = self.update_fn(self.tree[a1], a2 * self.count[a1])\n        if a1 < self.base:\n            self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n    def __push(self, a1):\n        v1 = 2 ** self.H\n        while v1 != 1:\n            v2 = a1 // v1\n            if self.lazy[v2] is not None:\n                self.__apply(v2 * 2, self.lazy[v2])\n                self.__apply(v2 * 2 + 1, self.lazy[v2])\n                self.lazy[v2] = None\n            v1 //= 2\n\n    def update(self, a1, a2, a3):\n\n        def pull(a1):\n            while a1 > 1:\n                a1 //= 2\n                self.tree[a1] = self.query_fn(self.tree[a1 * 2], self.tree[a1 * 2 + 1])\n                if self.lazy[a1] is not None:\n                    self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1] * self.count[a1])\n        if a1 > a2:\n            return\n        a1 += self.base\n        a2 += self.base\n        self.__push(a1)\n        self.__push(a2)\n        v3, v4 = (a1, a2)\n        while a1 <= a2:\n            if a1 & 1:\n                self.__apply(a1, a3)\n                a1 += 1\n            if a2 & 1 == 0:\n                self.__apply(a2, a3)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        pull(v3)\n        pull(v4)\n\n    def query(self, a1, a2):\n        v1 = None\n        if a1 > a2:\n            return v1\n        a1 += self.base\n        a2 += self.base\n        self.__push(a1)\n        self.__push(a2)\n        while a1 <= a2:\n            if a1 & 1:\n                v1 = self.query_fn(v1, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v1 = self.query_fn(v1, self.tree[a2])\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return v1\n"}
{"id": "llm_code\\copy-list-with-random-pointer__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n        self.random = None\n\nclass C2:\n\n    def copyRandomList(self, a1):\n        if not a1:\n            return None\n        v1 = {}\n        v2 = a1\n        while v2:\n            v1[v2] = C1(v2.val)\n            v2 = v2.next\n        v3 = v1[a1]\n        v2 = a1\n        while v2:\n            v4 = v1[v2]\n            v4.next = v1.get(v2.next, None)\n            v4.random = v1.get(v2.random, None)\n            v2 = v2.next\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n        self.random = None\n\nclass C2:\n\n    def copyRandomList(self, a1):\n        if not a1:\n            return None\n        v1 = {}\n        v2 = a1\n        while v2:\n            v1[v2] = C1(v2.val)\n            v2 = v2.next\n        v3 = v1[a1]\n        v2 = a1\n        while v2:\n            v4 = v1[v2]\n            v4.next = v1.get(v2.next, None)\n            v4.random = v1.get(v2.random, None)\n            v2 = v2.next\n        return v3\n"}
{"id": "human_code\\delete-duplicate-folders-in-system__part1.py", "text": "import collections\nfrom functools import reduce\n\nclass C1(object):\n\n    def deleteDuplicateFolder(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def mark(a1, a2, a3):\n            v1 = []\n            for v2, v3 in a1.items():\n                if v3 == '_del':\n                    continue\n                v1.append((v2, mark(v3, a2, a3)))\n            v1.sort()\n            v4 = a3[tuple(v1)]\n            if v4:\n                if v4 in a2:\n                    a2[v4]['_del']\n                    a1['_del']\n                else:\n                    a2[v4] = a1\n            return v4\n\n        def sweep(a1, a2, a3, a4):\n            if a3:\n                a4.append([a2[i] for v1 in a3])\n            for v2, v3 in a1.items():\n                if '_del' in v3:\n                    continue\n                a3.append(v2)\n                sweep(v3, a2, a3, a4)\n                a3.pop()\n        v1 = lambda: collections.defaultdict(v1)\n        v2 = v1()\n        v3 = collections.defaultdict()\n        v3.default_factory = v3.__len__\n        v4 = {}\n        for v5 in a1:\n            v6 = v2\n            for v7 in v5:\n                if v3[v7] not in v4:\n                    v4[v3[v7]] = v7\n                v6 = v6[v3[v7]]\n        v8 = collections.defaultdict()\n        v8.default_factory = v8.__len__\n        mark(v2, {}, v8)\n        v9 = []\n        sweep(v2, v4, [], v9)\n        return v9\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom functools import reduce\n\nclass C1(object):\n\n    def deleteDuplicateFolder(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def mark(a1, a2, a3):\n            v1 = []\n            for v2, v3 in a1.items():\n                if v3 == '_del':\n                    continue\n                v1.append((v2, mark(v3, a2, a3)))\n            v1.sort()\n            v4 = a3[tuple(v1)]\n            if v4:\n                if v4 in a2:\n                    a2[v4]['_del']\n                    a1['_del']\n                else:\n                    a2[v4] = a1\n            return v4\n\n        def sweep(a1, a2, a3, a4):\n            if a3:\n                a4.append([a2[i] for v1 in a3])\n            for v2, v3 in a1.items():\n                if '_del' in v3:\n                    continue\n                a3.append(v2)\n                sweep(v3, a2, a3, a4)\n                a3.pop()\n        v1 = lambda: collections.defaultdict(v1)\n        v2 = v1()\n        v3 = collections.defaultdict()\n        v3.default_factory = v3.__len__\n        v4 = {}\n        for v5 in a1:\n            v6 = v2\n            for v7 in v5:\n                if v3[v7] not in v4:\n                    v4[v3[v7]] = v7\n                v6 = v6[v3[v7]]\n        v8 = collections.defaultdict()\n        v8.default_factory = v8.__len__\n        mark(v2, {}, v8)\n        v9 = []\n        sweep(v2, v4, [], v9)\n        return v9\n"}
{"id": "human_code\\maximum-score-of-a-node-sequence.py", "text": "import heapq\n\nclass C1(object):\n\n    def maximumScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def find_top3(a1, a2, a3):\n            heapq.heappush(a3, (a1[a2], a2))\n            if len(a3) > 3:\n                heapq.heappop(a3)\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, v4 in a2:\n            find_top3(a1, v4, v1[v3])\n            find_top3(a1, v3, v1[v4])\n        v5 = -1\n        for v3, v4 in a2:\n            for v2, v6 in v1[v3]:\n                if v6 == v4:\n                    continue\n                for v2, v7 in v1[v4]:\n                    if v7 == v3 or v7 == v6:\n                        continue\n                    v5 = max(v5, sum((a1[x] for v8 in (v3, v4, v6, v7))))\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def maximumScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def find_top3(a1, a2, a3):\n            heapq.heappush(a3, (a1[a2], a2))\n            if len(a3) > 3:\n                heapq.heappop(a3)\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, v4 in a2:\n            find_top3(a1, v4, v1[v3])\n            find_top3(a1, v3, v1[v4])\n        v5 = -1\n        for v3, v4 in a2:\n            for v2, v6 in v1[v3]:\n                if v6 == v4:\n                    continue\n                for v2, v7 in v1[v4]:\n                    if v7 == v3 or v7 == v6:\n                        continue\n                    v5 = max(v5, sum((a1[x] for v8 in (v3, v4, v6, v7))))\n        return v5\n"}
{"id": "llm_code\\p03626__s941751597.py", "text": "v1 = int(input())\nv2 = input()\nv3 = input()\nv4 = 0\nv5 = [1, 0]\nv6 = 1000000007\nwhile v4 < v1:\n    if v2[v4] == v3[v4]:\n        v4 += 1\n        if v5[1] in [0, 1]:\n            v5[0] = v5[0] * 3 % v6\n        v5[1] = 1\n    else:\n        v4 += 2\n        if v5[1] == 0:\n            v5[0] = v5[0] * 6 % v6\n        elif v5[1] == 1:\n            v5[0] = v5[0] * 2 % v6\n        elif v5[1] == 2:\n            v5[0] = v5[0] * 3 % v6\n        v5[1] = 2\nprint(v5[0])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = input()\nv3 = input()\nv4 = 0\nv5 = [1, 0]\nv6 = 1000000007\nwhile v4 < v1:\n    if v2[v4] == v3[v4]:\n        v4 += 1\n        if v5[1] in [0, 1]:\n            v5[0] = v5[0] * 3 % v6\n        v5[1] = 1\n    else:\n        v4 += 2\n        if v5[1] == 0:\n            v5[0] = v5[0] * 6 % v6\n        elif v5[1] == 1:\n            v5[0] = v5[0] * 2 % v6\n        elif v5[1] == 2:\n            v5[0] = v5[0] * 3 % v6\n        v5[1] = 2\nprint(v5[0])\n"}
{"id": "llm_code\\maximum-and-minimum-sums-of-at-most-size-k-subarrays__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def minMaxSubarraySum(self, a1, a2):\n\n        def compute_sum(a1):\n            v1 = collections.deque()\n            v2 = 0\n            v3 = 0\n            v4 = len(a1)\n            for v5 in range(v4):\n                v6 = max(v5 - a2 + 1, 0)\n                while v1 and (not (a1[v1[-1]] < a1[v5] if a1 else a1[v1[-1]] > a1[v5])):\n                    v7 = v1.pop()\n                    v8 = v1[-1] + 1 if v1 else v6\n                    v9 = v7 - v8 + 1\n                    v2 -= v9 * a1[v7]\n                v8 = v1[-1] + 1 if v1 else v6\n                v9 = v5 - v8 + 1\n                v1.append(v5)\n                v2 += v9 * a1[v5]\n                v3 += v2\n                if v5 >= a2 - 1:\n                    v10 = v5 - a2 + 1\n                    v2 -= a1[v1[0]]\n                    if v1[0] == v10:\n                        v1.popleft()\n            return v3\n        return compute_sum(True) + compute_sum(False)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def minMaxSubarraySum(self, a1, a2):\n\n        def compute_sum(a1):\n            v1 = collections.deque()\n            v2 = 0\n            v3 = 0\n            v4 = len(a1)\n            for v5 in range(v4):\n                v6 = max(v5 - a2 + 1, 0)\n                while v1 and (not (a1[v1[-1]] < a1[v5] if a1 else a1[v1[-1]] > a1[v5])):\n                    v7 = v1.pop()\n                    v8 = v1[-1] + 1 if v1 else v6\n                    v9 = v7 - v8 + 1\n                    v2 -= v9 * a1[v7]\n                v8 = v1[-1] + 1 if v1 else v6\n                v9 = v5 - v8 + 1\n                v1.append(v5)\n                v2 += v9 * a1[v5]\n                v3 += v2\n                if v5 >= a2 - 1:\n                    v10 = v5 - a2 + 1\n                    v2 -= a1[v1[0]]\n                    if v1[0] == v10:\n                        v1.popleft()\n            return v3\n        return compute_sum(True) + compute_sum(False)\n"}
{"id": "human_code\\p03646__s868866048.py", "text": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil, pi, factorial\nfrom operator import itemgetter\nimport copy\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return map(int, input().split())\n\ndef f3():\n    return list(map(int, input().split()))\n\ndef f4():\n    return [int(input()) for v1 in range(n)]\n\ndef f5():\n    return [[f3()] for v1 in range(n)]\n\ndef f6():\n    return input().rstrip()\n\ndef f7(a1):\n    print('\\n'.join(a1))\n\ndef f8(a1):\n    print('\\n'.join(list(map(str, a1))))\nv1 = 10 ** 17\nv2 = 10 ** 9 + 7\nv3 = f1()\nv4 = [50 for v5 in range(50)]\nv6 = []\nfor v5 in range(50):\n    v7 = -v1\n    for v8 in range(50):\n        if v4[v8] >= v7:\n            v7 = v4[v8]\n            v9 = v8\n    for v8 in range(50):\n        v4[v8] += 1\n    v4[v9] -= 51\n    v6.append(copy.deepcopy(v4))\nv10 = v3 % 50\nv11 = v3 // 50\nv12 = v6[50 - v10 - 1]\nfor v5 in range(50):\n    v12[v5] += v11\nprint(50)\nprint(*v12)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil, pi, factorial\nfrom operator import itemgetter\nimport copy\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return map(int, input().split())\n\ndef f3():\n    return list(map(int, input().split()))\n\ndef f4():\n    return [int(input()) for v1 in range(n)]\n\ndef f5():\n    return [[f3()] for v1 in range(n)]\n\ndef f6():\n    return input().rstrip()\n\ndef f7(a1):\n    print('\\n'.join(a1))\n\ndef f8(a1):\n    print('\\n'.join(list(map(str, a1))))\nv1 = 10 ** 17\nv2 = 10 ** 9 + 7\nv3 = f1()\nv4 = [50 for v5 in range(50)]\nv6 = []\nfor v5 in range(50):\n    v7 = -v1\n    for v8 in range(50):\n        if v4[v8] >= v7:\n            v7 = v4[v8]\n            v9 = v8\n    for v8 in range(50):\n        v4[v8] += 1\n    v4[v9] -= 51\n    v6.append(copy.deepcopy(v4))\nv10 = v3 % 50\nv11 = v3 // 50\nv12 = v6[50 - v10 - 1]\nfor v5 in range(50):\n    v12[v5] += v11\nprint(50)\nprint(*v12)\n"}
{"id": "human_code\\shuffle-an-array.py", "text": "import random\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n\n        \"\"\"\n        self.__nums = a1\n\n    def reset(self):\n        \"\"\"\n        Resets the array to its original configuration and return it.\n        \"\"\"\n        return self.__nums\n\n    def shuffle(self):\n        \"\"\"\n        Returns a random shuffling of the array.\n        \"\"\"\n        v1 = list(self.__nums)\n        for v2 in range(len(v1)):\n            v3 = random.randint(v2, len(v1) - 1)\n            v1[v2], v1[v3] = (v1[v3], v1[v2])\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n\n        \"\"\"\n        self.__nums = a1\n\n    def reset(self):\n        \"\"\"\n        Resets the array to its original configuration and return it.\n        \"\"\"\n        return self.__nums\n\n    def shuffle(self):\n        \"\"\"\n        Returns a random shuffling of the array.\n        \"\"\"\n        v1 = list(self.__nums)\n        for v2 in range(len(v1)):\n            v3 = random.randint(v2, len(v1) - 1)\n            v1[v2], v1[v3] = (v1[v3], v1[v2])\n        return v1\n"}
{"id": "llm_code\\p03438__s257256652.py", "text": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = sum(v2)\nv5 = sum(v3)\nv6 = v5 - v4\nif v6 < 0:\n    print('No')\n    exit()\nv7 = 0\nv8 = 0\nfor v9 in range(v1):\n    v10 = v3[v9] - v2[v9]\n    if v10 > 0:\n        v7 += v10 // 2\n        v8 += v10 % 2\n    elif v10 < 0:\n        v8 -= v10\nv11 = v6 - v7\nv12 = v6 - v8\nif v11 < 0 or v12 < 0:\n    print('No')\n    exit()\nif v12 / v11 == 2:\n    print('Yes')\nelse:\n    print('No')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = sum(v2)\nv5 = sum(v3)\nv6 = v5 - v4\nif v6 < 0:\n    print('No')\n    exit()\nv7 = 0\nv8 = 0\nfor v9 in range(v1):\n    v10 = v3[v9] - v2[v9]\n    if v10 > 0:\n        v7 += v10 // 2\n        v8 += v10 % 2\n    elif v10 < 0:\n        v8 -= v10\nv11 = v6 - v7\nv12 = v6 - v8\nif v11 < 0 or v12 < 0:\n    print('No')\n    exit()\nif v12 / v11 == 2:\n    print('Yes')\nelse:\n    print('No')\n"}
{"id": "human_code\\maximum-total-beauty-of-the-gardens__part4.py", "text": "import bisect\n\nclass C1(object):\n\n    def maximumBeauty(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            return (a1[a3] - a1[a3 - 1]) * a3 - a1[a3] <= a2\n\n        def binary_search_right(a1, a2, a3, a4):\n            while a3 <= a4:\n                v1 = a3 + (a4 - a3) // 2\n                if not check(a1, a2, v1):\n                    a4 = v1 - 1\n                else:\n                    a3 = v1 + 1\n            return a4\n        a1.sort()\n        v1 = bisect.bisect_left(a1, a3)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n        v4 = v5 = 0\n        v6 = v1\n        for v7 in reversed(range(v1 + 1)):\n            if v7 != v1:\n                v5 += a1[v7]\n            v8 = a2 - ((v1 - v7) * a3 - v5)\n            if v8 < 0:\n                break\n            v6 = binary_search_right(v2, v8, 1, v7)\n            v9 = min((v8 + v2[v6]) // v6 if v6 else 0, a3 - 1)\n            v4 = max(v4, v9 * a5 + (len(a1) - v7) * a4)\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def maximumBeauty(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            return (a1[a3] - a1[a3 - 1]) * a3 - a1[a3] <= a2\n\n        def binary_search_right(a1, a2, a3, a4):\n            while a3 <= a4:\n                v1 = a3 + (a4 - a3) // 2\n                if not check(a1, a2, v1):\n                    a4 = v1 - 1\n                else:\n                    a3 = v1 + 1\n            return a4\n        a1.sort()\n        v1 = bisect.bisect_left(a1, a3)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n        v4 = v5 = 0\n        v6 = v1\n        for v7 in reversed(range(v1 + 1)):\n            if v7 != v1:\n                v5 += a1[v7]\n            v8 = a2 - ((v1 - v7) * a3 - v5)\n            if v8 < 0:\n                break\n            v6 = binary_search_right(v2, v8, 1, v7)\n            v9 = min((v8 + v2[v6]) // v6 if v6 else 0, a3 - 1)\n            v4 = max(v4, v9 * a5 + (len(a1) - v7) * a4)\n        return v4\n"}
{"id": "llm_code\\multiply-two-polynomials__grok-4.1-fast__v1.py", "text": "import math\nimport cmath\n\ndef f1(a1, a2):\n    v1 = len(a1)\n    if v1 <= 1:\n        return\n    v2 = (v1 - 1).bit_length()\n    for v3 in range(v1):\n        v4 = 0\n        v5 = v3\n        for v6 in range(v2):\n            v4 = v4 << 1 | v5 & 1\n            v5 >>= 1\n        if v3 < v4:\n            a1[v3], a1[v4] = (a1[v4], a1[v3])\n    v7 = 2\n    while v7 <= v1:\n        v8 = 2 * math.pi / v7 * (-1 if a2 else 1)\n        v9 = complex(math.cos(v8), math.sin(v8))\n        for v10 in range(0, v1, v7):\n            v11 = complex(1, 0)\n            v12 = v7 // 2\n            for v13 in range(v12):\n                v14 = v10 + v13\n                v15 = v14 + v12\n                v16 = a1[v14]\n                v17 = a1[v15] * v11\n                a1[v14] = v16 + v17\n                a1[v15] = v16 - v17\n                v11 *= v9\n        v7 *= 2\n    if a2:\n        v18 = 1.0 / v1\n        for v19 in range(v1):\n            a1[v19] *= v18\n\ndef f2(a1, a2):\n    v1 = len(a1) + len(a2) - 1\n    v2 = 1\n    while v2 < v1:\n        v2 <<= 1\n    v3 = [complex(coef, 0) for v4 in a1] + [0j] * (v2 - len(a1))\n    v5 = [complex(v4, 0) for v4 in a2] + [0j] * (v2 - len(a2))\n    f1(v3, False)\n    f1(v5, False)\n    for v6 in range(v2):\n        v3[v6] *= v5[v6]\n    f1(v3, True)\n    return [int(round(c.real)) for v7 in v3[:v1]]\n\nclass C1(object):\n\n    def multiply(self, a1, a2):\n        return f2(a1, a2)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import math\nimport cmath\n\ndef f1(a1, a2):\n    v1 = len(a1)\n    if v1 <= 1:\n        return\n    v2 = (v1 - 1).bit_length()\n    for v3 in range(v1):\n        v4 = 0\n        v5 = v3\n        for v6 in range(v2):\n            v4 = v4 << 1 | v5 & 1\n            v5 >>= 1\n        if v3 < v4:\n            a1[v3], a1[v4] = (a1[v4], a1[v3])\n    v7 = 2\n    while v7 <= v1:\n        v8 = 2 * math.pi / v7 * (-1 if a2 else 1)\n        v9 = complex(math.cos(v8), math.sin(v8))\n        for v10 in range(0, v1, v7):\n            v11 = complex(1, 0)\n            v12 = v7 // 2\n            for v13 in range(v12):\n                v14 = v10 + v13\n                v15 = v14 + v12\n                v16 = a1[v14]\n                v17 = a1[v15] * v11\n                a1[v14] = v16 + v17\n                a1[v15] = v16 - v17\n                v11 *= v9\n        v7 *= 2\n    if a2:\n        v18 = 1.0 / v1\n        for v19 in range(v1):\n            a1[v19] *= v18\n\ndef f2(a1, a2):\n    v1 = len(a1) + len(a2) - 1\n    v2 = 1\n    while v2 < v1:\n        v2 <<= 1\n    v3 = [complex(coef, 0) for v4 in a1] + [0j] * (v2 - len(a1))\n    v5 = [complex(v4, 0) for v4 in a2] + [0j] * (v2 - len(a2))\n    f1(v3, False)\n    f1(v5, False)\n    for v6 in range(v2):\n        v3[v6] *= v5[v6]\n    f1(v3, True)\n    return [int(round(c.real)) for v7 in v3[:v1]]\n\nclass C1(object):\n\n    def multiply(self, a1, a2):\n        return f2(a1, a2)\n"}
{"id": "llm_code\\maximum-area-rectangle-with-point-constraints-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxRectangleArea(self, a1, a2):\n        v1 = {}\n        for v2 in range(len(a1)):\n            v3 = a1[v2]\n            if v3 not in v1:\n                v1[v3] = []\n            v1[v3].append(a2[v2])\n        v4 = sorted(v1)\n        v5 = sorted(set(a2))\n        v6 = {val: idx + 1 for v7, v8 in enumerate(v5)}\n        v9 = len(v5)\n\n        class FenwickTree(object):\n\n            def __init__(self, a1):\n                self.size = a1\n                self.data = [0] * (a1 + 2)\n\n            def modify(self, a1, a2):\n                while a1 <= self.size:\n                    self.data[a1] += a2\n                    a1 += a1 & -a1\n\n            def sum_up_to(self, a1):\n                v1 = 0\n                while a1 > 0:\n                    v1 += self.data[a1]\n                    a1 -= a1 & -a1\n                return v1\n        v10 = FenwickTree(v9)\n        v11 = {}\n        v12 = -1\n        for v13 in v4:\n            v14 = sorted(v1[v13])\n            if len(v14) >= 2:\n                for v15 in range(len(v14) - 1):\n                    v16 = v14[v15]\n                    v17 = v14[v15 + 1]\n                    v18 = v6[v16]\n                    v19 = v6[v17]\n                    v20 = v10.sum_up_to(v19) - v10.sum_up_to(v18 - 1)\n                    v21 = (v18, v19)\n                    if v21 in v11 and v11[v21][0] == v20:\n                        v22 = v13 - v11[v21][1]\n                        v23 = v17 - v16\n                        v24 = v22 * v23\n                        if v24 > v12:\n                            v12 = v24\n                    v11[v21] = (v20 + 2, v13)\n            for v25 in v14:\n                v10.modify(v6[v25], 1)\n        return v12\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxRectangleArea(self, a1, a2):\n        v1 = {}\n        for v2 in range(len(a1)):\n            v3 = a1[v2]\n            if v3 not in v1:\n                v1[v3] = []\n            v1[v3].append(a2[v2])\n        v4 = sorted(v1)\n        v5 = sorted(set(a2))\n        v6 = {val: idx + 1 for v7, v8 in enumerate(v5)}\n        v9 = len(v5)\n\n        class FenwickTree(object):\n\n            def __init__(self, a1):\n                self.size = a1\n                self.data = [0] * (a1 + 2)\n\n            def modify(self, a1, a2):\n                while a1 <= self.size:\n                    self.data[a1] += a2\n                    a1 += a1 & -a1\n\n            def sum_up_to(self, a1):\n                v1 = 0\n                while a1 > 0:\n                    v1 += self.data[a1]\n                    a1 -= a1 & -a1\n                return v1\n        v10 = FenwickTree(v9)\n        v11 = {}\n        v12 = -1\n        for v13 in v4:\n            v14 = sorted(v1[v13])\n            if len(v14) >= 2:\n                for v15 in range(len(v14) - 1):\n                    v16 = v14[v15]\n                    v17 = v14[v15 + 1]\n                    v18 = v6[v16]\n                    v19 = v6[v17]\n                    v20 = v10.sum_up_to(v19) - v10.sum_up_to(v18 - 1)\n                    v21 = (v18, v19)\n                    if v21 in v11 and v11[v21][0] == v20:\n                        v22 = v13 - v11[v21][1]\n                        v23 = v17 - v16\n                        v24 = v22 * v23\n                        if v24 > v12:\n                            v12 = v24\n                    v11[v21] = (v20 + 2, v13)\n            for v25 in v14:\n                v10.modify(v6[v25], 1)\n        return v12\n"}
{"id": "human_code\\letter-tile-possibilities__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def numTilePossibilities(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [0.0] * (len(a1) + 1)\n        v1[0] = 1.0\n        for v2 in range(1, len(a1) + 1):\n            v1[v2] = v1[v2 - 1] * v2\n        v3 = collections.Counter(a1)\n        v4 = [0.0] * (len(a1) + 1)\n        v4[0] = 1.0\n        for v2 in v3.values():\n            v5 = [0.0] * (len(a1) + 1)\n            for v6 in range(len(v4)):\n                for v7 in range(v2 + 1):\n                    if v7 + v6 >= len(v5):\n                        break\n                    v5[v6 + v7] += v4[v6] * 1.0 / v1[v7]\n            v4 = v5\n        v8 = 0\n        for v2 in range(1, len(v4)):\n            v8 += int(round(v4[v2] * v1[v2]))\n        return v8\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def numTilePossibilities(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [0.0] * (len(a1) + 1)\n        v1[0] = 1.0\n        for v2 in range(1, len(a1) + 1):\n            v1[v2] = v1[v2 - 1] * v2\n        v3 = collections.Counter(a1)\n        v4 = [0.0] * (len(a1) + 1)\n        v4[0] = 1.0\n        for v2 in v3.values():\n            v5 = [0.0] * (len(a1) + 1)\n            for v6 in range(len(v4)):\n                for v7 in range(v2 + 1):\n                    if v7 + v6 >= len(v5):\n                        break\n                    v5[v6 + v7] += v4[v6] * 1.0 / v1[v7]\n            v4 = v5\n        v8 = 0\n        for v2 in range(1, len(v4)):\n            v8 += int(round(v4[v2] * v1[v2]))\n        return v8\n"}
{"id": "human_code\\palindrome-partitioning__part2.py", "text": "class C1(object):\n\n    def partition(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        self.partitionRecu(v1, [], a1, 0)\n        return v1\n\n    def partitionRecu(self, a1, a2, a3, a4):\n        if a4 == len(a3):\n            a1.append(list(a2))\n        else:\n            for v1 in range(a4, len(a3)):\n                if self.isPalindrome(a3[a4:v1 + 1]):\n                    a2.append(a3[a4:v1 + 1])\n                    self.partitionRecu(a1, a2, a3, v1 + 1)\n                    a2.pop()\n\n    def isPalindrome(self, a1):\n        for v1 in range(len(a1) / 2):\n            if a1[v1] != a1[-(v1 + 1)]:\n                return False\n        return True\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def partition(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        self.partitionRecu(v1, [], a1, 0)\n        return v1\n\n    def partitionRecu(self, a1, a2, a3, a4):\n        if a4 == len(a3):\n            a1.append(list(a2))\n        else:\n            for v1 in range(a4, len(a3)):\n                if self.isPalindrome(a3[a4:v1 + 1]):\n                    a2.append(a3[a4:v1 + 1])\n                    self.partitionRecu(a1, a2, a3, v1 + 1)\n                    a2.pop()\n\n    def isPalindrome(self, a1):\n        for v1 in range(len(a1) / 2):\n            if a1[v1] != a1[-(v1 + 1)]:\n                return False\n        return True\n"}
{"id": "llm_code\\divide-chocolate__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maximizeSweetness(self, a1, a2):\n        v1 = len(a1)\n        v2 = sum(a1)\n        v3 = min(a1)\n        v4 = v2 // (a2 + 1)\n\n        def feasible(a1):\n            v1 = 0\n            v2 = 0\n            while v1 < v1:\n                v3 = 0\n                while v1 < v1 and v3 < a1:\n                    v3 += a1[v1]\n                    v1 += 1\n                if v3 >= a1:\n                    v2 += 1\n            return v2 >= a2 + 1\n        while v3 <= v4:\n            v5 = v3 + (v4 - v3) // 2\n            if feasible(v5):\n                v3 = v5 + 1\n            else:\n                v4 = v5 - 1\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximizeSweetness(self, a1, a2):\n        v1 = len(a1)\n        v2 = sum(a1)\n        v3 = min(a1)\n        v4 = v2 // (a2 + 1)\n\n        def feasible(a1):\n            v1 = 0\n            v2 = 0\n            while v1 < v1:\n                v3 = 0\n                while v1 < v1 and v3 < a1:\n                    v3 += a1[v1]\n                    v1 += 1\n                if v3 >= a1:\n                    v2 += 1\n            return v2 >= a2 + 1\n        while v3 <= v4:\n            v5 = v3 + (v4 - v3) // 2\n            if feasible(v5):\n                v3 = v5 + 1\n            else:\n                v4 = v5 - 1\n        return v4\n"}
{"id": "human_code\\maximum-number-of-integers-to-choose-from-a-range-i__part1.py", "text": "class C1(object):\n\n    def maxCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = min(int((-1 + (1 + 8 * a3)) ** 0.5 / 2), a2)\n        v2 = (v1 + 1) * v1 // 2\n        v3 = v1\n        v4 = set(a1)\n        for v5 in v4:\n            if v5 <= v1:\n                v2 -= v5\n                v3 -= 1\n        for v6 in range(v1 + 1, a2 + 1):\n            if v6 in v4:\n                continue\n            if v2 + v6 > a3:\n                break\n            v2 += v6\n            v3 += 1\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = min(int((-1 + (1 + 8 * a3)) ** 0.5 / 2), a2)\n        v2 = (v1 + 1) * v1 // 2\n        v3 = v1\n        v4 = set(a1)\n        for v5 in v4:\n            if v5 <= v1:\n                v2 -= v5\n                v3 -= 1\n        for v6 in range(v1 + 1, a2 + 1):\n            if v6 in v4:\n                continue\n            if v2 + v6 > a3:\n                break\n            v2 += v6\n            v3 += 1\n        return v3\n"}
{"id": "llm_code\\maximize-score-of-numbers-in-ranges__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxPossibleScore(self, a1, a2):\n        a1.sort()\n\n        def possible(a1):\n            v1 = a1[0]\n            for v2 in range(1, len(a1)):\n                v3 = max(v1 + a1, a1[v2])\n                if v3 > a1[v2] + a2:\n                    return False\n                v1 = v3\n            return True\n        v1 = 1\n        v2 = a1[-1] + a2 - a1[0]\n        while v1 <= v2:\n            v3 = (v1 + v2) // 2\n            if possible(v3):\n                v1 = v3 + 1\n            else:\n                v2 = v3 - 1\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxPossibleScore(self, a1, a2):\n        a1.sort()\n\n        def possible(a1):\n            v1 = a1[0]\n            for v2 in range(1, len(a1)):\n                v3 = max(v1 + a1, a1[v2])\n                if v3 > a1[v2] + a2:\n                    return False\n                v1 = v3\n            return True\n        v1 = 1\n        v2 = a1[-1] + a2 - a1[0]\n        while v1 <= v2:\n            v3 = (v1 + v2) // 2\n            if possible(v3):\n                v1 = v3 + 1\n            else:\n                v2 = v3 - 1\n        return v2\n"}
{"id": "human_code\\jump-game-v__part2.py", "text": "class C1(object):\n\n    def maxJumps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = ([[] for v3 in range(len(a1))], [])\n        for v4 in range(len(a1)):\n            while v2 and a1[v2[-1]] < a1[v4]:\n                if v4 - v2[-1] <= a2:\n                    if v1[v4] and a1[v1[v4][-1]] != a1[v2[-1]]:\n                        v1[v4] = []\n                    v1[v4].append(v2[-1])\n                v2.pop()\n            v2.append(v4)\n        v5, v2 = ([[] for v3 in range(len(a1))], [])\n        for v4 in reversed(range(len(a1))):\n            while v2 and a1[v2[-1]] < a1[v4]:\n                if v2[-1] - v4 <= a2:\n                    if v5[v4] and a1[v5[v4][-1]] != a1[v2[-1]]:\n                        v5[v4] = []\n                    v5[v4].append(v2[-1])\n                v2.pop()\n            v2.append(v4)\n        v6 = [0] * len(a1)\n        for v7, v4 in sorted(([v7, v4] for v4, v7 in enumerate(a1))):\n            v6[v4] = 1\n            for v8 in itertools.chain(v1[v4], v5[v4]):\n                v6[v4] = max(v6[v4], v6[v8] + 1)\n        return max(v6)\n\nclass C2(object):\n\n    def __init__(self, a1, a2=lambda x, y: [y] * (2 * x), a3=max, a4=lambda x, y: y, a5=0):\n        self.N = a1\n        self.H = (a1 - 1).bit_length()\n        self.query_fn = a3\n        self.update_fn = a4\n        self.default_val = a5\n        self.tree = a2(a1, a5)\n        self.lazy = [None] * a1\n\n    def __apply(self, a1, a2):\n        self.tree[a1] = self.update_fn(self.tree[a1], a2)\n        if a1 < self.N:\n            self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n    def update(self, a1, a2, a3):\n\n        def pull(a1):\n            while a1 > 1:\n                a1 //= 2\n                self.tree[a1] = self.query_fn(self.tree[a1 * 2], self.tree[a1 * 2 + 1])\n                if self.lazy[a1] is not None:\n                    self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1])\n        a1 += self.N\n        a2 += self.N\n        v3, v4 = (a1, a2)\n        while a1 <= a2:\n            if a1 & 1:\n                self.__apply(a1, a3)\n                a1 += 1\n            if a2 & 1 == 0:\n                self.__apply(a2, a3)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        pull(v3)\n        pull(v4)\n\n    def query(self, a1, a2):\n\n        def push(a1):\n            v1 = 2 ** self.H\n            while v1 != 1:\n                v2 = a1 // v1\n                if self.lazy[v2] is not None:\n                    self.__apply(v2 * 2, self.lazy[v2])\n                    self.__apply(v2 * 2 + 1, self.lazy[v2])\n                    self.lazy[v2] = None\n                v1 //= 2\n        v1 = self.default_val\n        if a1 > a2:\n            return v1\n        a1 += self.N\n        a2 += self.N\n        push(a1)\n        push(a2)\n        while a1 <= a2:\n            if a1 & 1:\n                v1 = self.query_fn(v1, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v1 = self.query_fn(v1, self.tree[a2])\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return v1\n\n    def __str__(self):\n        v1 = []\n        for v2 in range(self.N):\n            v1.append(self.query(v2, v2))\n        return ','.join(map(str, v1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxJumps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = ([[] for v3 in range(len(a1))], [])\n        for v4 in range(len(a1)):\n            while v2 and a1[v2[-1]] < a1[v4]:\n                if v4 - v2[-1] <= a2:\n                    if v1[v4] and a1[v1[v4][-1]] != a1[v2[-1]]:\n                        v1[v4] = []\n                    v1[v4].append(v2[-1])\n                v2.pop()\n            v2.append(v4)\n        v5, v2 = ([[] for v3 in range(len(a1))], [])\n        for v4 in reversed(range(len(a1))):\n            while v2 and a1[v2[-1]] < a1[v4]:\n                if v2[-1] - v4 <= a2:\n                    if v5[v4] and a1[v5[v4][-1]] != a1[v2[-1]]:\n                        v5[v4] = []\n                    v5[v4].append(v2[-1])\n                v2.pop()\n            v2.append(v4)\n        v6 = [0] * len(a1)\n        for v7, v4 in sorted(([v7, v4] for v4, v7 in enumerate(a1))):\n            v6[v4] = 1\n            for v8 in itertools.chain(v1[v4], v5[v4]):\n                v6[v4] = max(v6[v4], v6[v8] + 1)\n        return max(v6)\n\nclass C2(object):\n\n    def __init__(self, a1, a2=lambda x, y: [y] * (2 * x), a3=max, a4=lambda x, y: y, a5=0):\n        self.N = a1\n        self.H = (a1 - 1).bit_length()\n        self.query_fn = a3\n        self.update_fn = a4\n        self.default_val = a5\n        self.tree = a2(a1, a5)\n        self.lazy = [None] * a1\n\n    def __apply(self, a1, a2):\n        self.tree[a1] = self.update_fn(self.tree[a1], a2)\n        if a1 < self.N:\n            self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n    def update(self, a1, a2, a3):\n\n        def pull(a1):\n            while a1 > 1:\n                a1 //= 2\n                self.tree[a1] = self.query_fn(self.tree[a1 * 2], self.tree[a1 * 2 + 1])\n                if self.lazy[a1] is not None:\n                    self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1])\n        a1 += self.N\n        a2 += self.N\n        v3, v4 = (a1, a2)\n        while a1 <= a2:\n            if a1 & 1:\n                self.__apply(a1, a3)\n                a1 += 1\n            if a2 & 1 == 0:\n                self.__apply(a2, a3)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        pull(v3)\n        pull(v4)\n\n    def query(self, a1, a2):\n\n        def push(a1):\n            v1 = 2 ** self.H\n            while v1 != 1:\n                v2 = a1 // v1\n                if self.lazy[v2] is not None:\n                    self.__apply(v2 * 2, self.lazy[v2])\n                    self.__apply(v2 * 2 + 1, self.lazy[v2])\n                    self.lazy[v2] = None\n                v1 //= 2\n        v1 = self.default_val\n        if a1 > a2:\n            return v1\n        a1 += self.N\n        a2 += self.N\n        push(a1)\n        push(a2)\n        while a1 <= a2:\n            if a1 & 1:\n                v1 = self.query_fn(v1, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v1 = self.query_fn(v1, self.tree[a2])\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return v1\n\n    def __str__(self):\n        v1 = []\n        for v2 in range(self.N):\n            v1.append(self.query(v2, v2))\n        return ','.join(map(str, v1))\n"}
{"id": "human_code\\cut-off-trees-for-golf-event__part1.py", "text": "import collections\nimport heapq\n\nclass C1(object):\n\n    def cutOffTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dot(a1, a2):\n            return a1[0] * a2[0] + a1[1] * a2[1]\n\n        def minStep(a1, a2):\n            v1 = abs(a1[0] - a2[0]) + abs(a1[1] - a2[1])\n            v2, v3 = ([a1], [])\n            v4 = set()\n            while True:\n                if not v2:\n                    if not v3:\n                        return -1\n                    v1 += 2\n                    v2, v3 = (v3, v2)\n                v5, v6 = v2.pop()\n                if (v5, v6) == a2:\n                    return v1\n                if (v5, v6) not in v4:\n                    v4.add((v5, v6))\n                    for v7, v8 in ((v5 + 1, v6), (v5 - 1, v6), (v5, v6 + 1), (v5, v6 - 1)):\n                        if 0 <= v7 < m and 0 <= v8 < n and a1[v7][v8] and ((v7, v8) not in v4):\n                            v9 = dot((v7 - v5, v8 - v6), (a2[0] - v5, a2[1] - v6)) > 0\n                            (v2 if v9 else v3).append((v7, v8))\n            return v1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] > 1:\n                    heapq.heappush(v3, (a1[v4][v5], (v4, v5)))\n        v6 = (0, 0)\n        v7 = 0\n        while v3:\n            v8 = heapq.heappop(v3)\n            v9 = minStep(v6, v8[1])\n            if v9 < 0:\n                return -1\n            v7 += v9\n            v6 = v8[1]\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport heapq\n\nclass C1(object):\n\n    def cutOffTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dot(a1, a2):\n            return a1[0] * a2[0] + a1[1] * a2[1]\n\n        def minStep(a1, a2):\n            v1 = abs(a1[0] - a2[0]) + abs(a1[1] - a2[1])\n            v2, v3 = ([a1], [])\n            v4 = set()\n            while True:\n                if not v2:\n                    if not v3:\n                        return -1\n                    v1 += 2\n                    v2, v3 = (v3, v2)\n                v5, v6 = v2.pop()\n                if (v5, v6) == a2:\n                    return v1\n                if (v5, v6) not in v4:\n                    v4.add((v5, v6))\n                    for v7, v8 in ((v5 + 1, v6), (v5 - 1, v6), (v5, v6 + 1), (v5, v6 - 1)):\n                        if 0 <= v7 < m and 0 <= v8 < n and a1[v7][v8] and ((v7, v8) not in v4):\n                            v9 = dot((v7 - v5, v8 - v6), (a2[0] - v5, a2[1] - v6)) > 0\n                            (v2 if v9 else v3).append((v7, v8))\n            return v1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] > 1:\n                    heapq.heappush(v3, (a1[v4][v5], (v4, v5)))\n        v6 = (0, 0)\n        v7 = 0\n        while v3:\n            v8 = heapq.heappop(v3)\n            v9 = minStep(v6, v8[1])\n            if v9 < 0:\n                return -1\n            v7 += v9\n            v6 = v8[1]\n        return v7\n"}
{"id": "llm_code\\minimum-difficulty-of-a-job-schedule__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minDifficulty(self, a1, a2):\n        v1 = len(a1)\n        if v1 < a2:\n            return -1\n        v2 = [[0] * v1 for v3 in range(v1)]\n        for v4 in range(v1):\n            v5 = 0\n            for v6 in range(v4, v1):\n                v5 = max(v5, a1[v6])\n                v2[v4][v6] = v5\n        v7 = [[float('inf')] * v1 for v3 in range(a2)]\n        for v8 in range(v1):\n            v7[0][v8] = v2[0][v8]\n        for v9 in range(1, a2):\n            for v8 in range(v9, v1):\n                for v10 in range(v9 - 1, v8):\n                    v11 = v7[v9 - 1][v10] + v2[v10 + 1][v8]\n                    if v11 < v7[v9][v8]:\n                        v7[v9][v8] = v11\n        return v7[a2 - 1][v1 - 1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minDifficulty(self, a1, a2):\n        v1 = len(a1)\n        if v1 < a2:\n            return -1\n        v2 = [[0] * v1 for v3 in range(v1)]\n        for v4 in range(v1):\n            v5 = 0\n            for v6 in range(v4, v1):\n                v5 = max(v5, a1[v6])\n                v2[v4][v6] = v5\n        v7 = [[float('inf')] * v1 for v3 in range(a2)]\n        for v8 in range(v1):\n            v7[0][v8] = v2[0][v8]\n        for v9 in range(1, a2):\n            for v8 in range(v9, v1):\n                for v10 in range(v9 - 1, v8):\n                    v11 = v7[v9 - 1][v10] + v2[v10 + 1][v8]\n                    if v11 < v7[v9][v8]:\n                        v7[v9][v8] = v11\n        return v7[a2 - 1][v1 - 1]\n"}
{"id": "llm_code\\reschedule-meetings-for-maximum-free-time-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxFreeTime(self, a1, a2, a3):\n        v1 = a2 + [a1]\n        v2 = [0] + a3\n        v3 = len(v1)\n        v4 = [v1[j] - v2[j] for v5 in range(v3)]\n        v6 = v7 = v8 = float('-inf')\n        v9 = v10 = v11 = -1\n        for v5 in range(v3):\n            v12 = v4[v5]\n            if v12 > v6:\n                v8, v11 = (v7, v10)\n                v7, v10 = (v6, v9)\n                v6, v9 = (v12, v5)\n            elif v12 > v7:\n                v8, v11 = (v7, v10)\n                v7, v10 = (v12, v5)\n            elif v12 > v8:\n                v8, v11 = (v12, v5)\n        v13 = [(v6, v9), (v7, v10), (v8, v11)]\n        v14 = 0\n        for v15 in range(v3 - 1):\n            v16 = v4[v15]\n            v17 = v4[v15 + 1]\n            v18 = v16 + v17\n            v19 = v2[v15 + 1] - v1[v15]\n            v20 = any((idx != v15 and idx != v15 + 1 and (v19 <= tg) for v21, v22 in v13))\n            v23 = v18 + v19 if v20 else v18\n            if v23 > v14:\n                v14 = v23\n        return v14\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxFreeTime(self, a1, a2, a3):\n        v1 = a2 + [a1]\n        v2 = [0] + a3\n        v3 = len(v1)\n        v4 = [v1[j] - v2[j] for v5 in range(v3)]\n        v6 = v7 = v8 = float('-inf')\n        v9 = v10 = v11 = -1\n        for v5 in range(v3):\n            v12 = v4[v5]\n            if v12 > v6:\n                v8, v11 = (v7, v10)\n                v7, v10 = (v6, v9)\n                v6, v9 = (v12, v5)\n            elif v12 > v7:\n                v8, v11 = (v7, v10)\n                v7, v10 = (v12, v5)\n            elif v12 > v8:\n                v8, v11 = (v12, v5)\n        v13 = [(v6, v9), (v7, v10), (v8, v11)]\n        v14 = 0\n        for v15 in range(v3 - 1):\n            v16 = v4[v15]\n            v17 = v4[v15 + 1]\n            v18 = v16 + v17\n            v19 = v2[v15 + 1] - v1[v15]\n            v20 = any((idx != v15 and idx != v15 + 1 and (v19 <= tg) for v21, v22 in v13))\n            v23 = v18 + v19 if v20 else v18\n            if v23 > v14:\n                v14 = v23\n        return v14\n"}
{"id": "llm_code\\soup-servings__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def soupServings(self, a1):\n        if a1 >= 4800:\n            return 1.0\n        v1 = (a1 + 24) // 25\n        v2 = [[0.0] * (v1 + 1) for v3 in range(v1 + 1)]\n        v4 = [(4, 0), (3, 1), (2, 2), (1, 3)]\n        for v5 in range(v1 + 1):\n            for v6 in range(v1 + 1):\n                if v5 == 0 and v6 == 0:\n                    v2[0][0] = 0.5\n                elif v5 == 0:\n                    v2[0][v6] = 1.0\n                elif v6 == 0:\n                    v2[v5][0] = 0.0\n                else:\n                    v7 = 0.0\n                    for v8, v9 in v4:\n                        v10 = v5 - v8\n                        v11 = v6 - v9\n                        if v10 <= 0 and v11 <= 0:\n                            v7 += 0.5\n                        elif v10 <= 0:\n                            v7 += 1.0\n                        elif v11 <= 0:\n                            v7 += 0.0\n                        else:\n                            v7 += v2[v10][v11]\n                    v2[v5][v6] = v7 / 4\n        return v2[v1][v1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def soupServings(self, a1):\n        if a1 >= 4800:\n            return 1.0\n        v1 = (a1 + 24) // 25\n        v2 = [[0.0] * (v1 + 1) for v3 in range(v1 + 1)]\n        v4 = [(4, 0), (3, 1), (2, 2), (1, 3)]\n        for v5 in range(v1 + 1):\n            for v6 in range(v1 + 1):\n                if v5 == 0 and v6 == 0:\n                    v2[0][0] = 0.5\n                elif v5 == 0:\n                    v2[0][v6] = 1.0\n                elif v6 == 0:\n                    v2[v5][0] = 0.0\n                else:\n                    v7 = 0.0\n                    for v8, v9 in v4:\n                        v10 = v5 - v8\n                        v11 = v6 - v9\n                        if v10 <= 0 and v11 <= 0:\n                            v7 += 0.5\n                        elif v10 <= 0:\n                            v7 += 1.0\n                        elif v11 <= 0:\n                            v7 += 0.0\n                        else:\n                            v7 += v2[v10][v11]\n                    v2[v5][v6] = v7 / 4\n        return v2[v1][v1]\n"}
{"id": "llm_code\\number-of-ways-to-separate-numbers__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def numberOfCombinations(self, a1: str) -> int:\n        v1 = len(a1)\n        v2 = 10 ** 9 + 7\n        v3 = [[0] * (v1 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(v1 - 1, -1, -1):\n            for v6 in range(v1 - 1, -1, -1):\n                if a1[v5] == a1[v6]:\n                    v3[v5][v6] = v3[v5 + 1][v6 + 1] + 1\n\n        def seg_leq(a1: int, a2: int, a3: int) -> bool:\n            v1 = v3[a1][a2]\n            if v1 >= a3:\n                return True\n            return a1[a1 + v1] < a1[a2 + v1]\n        v7 = [[0] * (v1 + 2) for v4 in range(v1 + 1)]\n        v8 = [[0] * (v1 + 2) for v4 in range(v1 + 1)]\n        for v9 in range(1, v1 + 1):\n            for v10 in range(1, v9 + 1):\n                v11 = v9 - v10\n                if a1[v11] == '0':\n                    v7[v9][v10] = 0\n                elif v11 == 0:\n                    v7[v9][v10] = 1\n                else:\n                    v12 = v8[v11][v10 - 1]\n                    v13 = 0\n                    if v10 <= v11:\n                        v14 = v11 - v10\n                        if seg_leq(v14, v11, v10):\n                            v13 = v7[v11][v10]\n                    v7[v9][v10] = (v12 + v13) % v2\n                v8[v9][v10] = (v8[v9][v10 - 1] + v7[v9][v10]) % v2\n        return v8[v1][v1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def numberOfCombinations(self, a1: str) -> int:\n        v1 = len(a1)\n        v2 = 10 ** 9 + 7\n        v3 = [[0] * (v1 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(v1 - 1, -1, -1):\n            for v6 in range(v1 - 1, -1, -1):\n                if a1[v5] == a1[v6]:\n                    v3[v5][v6] = v3[v5 + 1][v6 + 1] + 1\n\n        def seg_leq(a1: int, a2: int, a3: int) -> bool:\n            v1 = v3[a1][a2]\n            if v1 >= a3:\n                return True\n            return a1[a1 + v1] < a1[a2 + v1]\n        v7 = [[0] * (v1 + 2) for v4 in range(v1 + 1)]\n        v8 = [[0] * (v1 + 2) for v4 in range(v1 + 1)]\n        for v9 in range(1, v1 + 1):\n            for v10 in range(1, v9 + 1):\n                v11 = v9 - v10\n                if a1[v11] == '0':\n                    v7[v9][v10] = 0\n                elif v11 == 0:\n                    v7[v9][v10] = 1\n                else:\n                    v12 = v8[v11][v10 - 1]\n                    v13 = 0\n                    if v10 <= v11:\n                        v14 = v11 - v10\n                        if seg_leq(v14, v11, v10):\n                            v13 = v7[v11][v10]\n                    v7[v9][v10] = (v12 + v13) % v2\n                v8[v9][v10] = (v8[v9][v10 - 1] + v7[v9][v10]) % v2\n        return v8[v1][v1]\n"}
{"id": "human_code\\convert-binary-search-tree-to-sorted-doubly-linked-list.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2, a3):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def treeToDoublyList(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1:\n            return None\n        v1, v2, v3, v4 = (a1, a1, a1, a1)\n        if a1.left:\n            v1 = self.treeToDoublyList(a1.left)\n            v2 = v1.left\n        if a1.right:\n            v3 = self.treeToDoublyList(a1.right)\n            v4 = v3.left\n        v2.right, v3.left = (a1, a1)\n        a1.left, a1.right = (v2, v3)\n        v1.left, v4.right = (v4, v1)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2, a3):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def treeToDoublyList(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1:\n            return None\n        v1, v2, v3, v4 = (a1, a1, a1, a1)\n        if a1.left:\n            v1 = self.treeToDoublyList(a1.left)\n            v2 = v1.left\n        if a1.right:\n            v3 = self.treeToDoublyList(a1.right)\n            v4 = v3.left\n        v2.right, v3.left = (a1, a1)\n        a1.left, a1.right = (v2, v3)\n        v1.left, v4.right = (v4, v1)\n        return v1\n"}
{"id": "human_code\\dinner-plate-stacks.py", "text": "import heapq\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__stks = []\n        self.__c = a1\n        self.__min_heap = []\n\n    def push(self, a1):\n        \"\"\"\n        \"\"\"\n        if self.__min_heap:\n            v1 = heapq.heappop(self.__min_heap)\n            if v1 < len(self.__stks):\n                self.__stks[v1].append(a1)\n                return\n            self.__min_heap = []\n        if not self.__stks or len(self.__stks[-1]) == self.__c:\n            self.__stks.append([])\n        self.__stks[-1].append(a1)\n\n    def pop(self):\n        \"\"\"\n        \"\"\"\n        while self.__stks and (not self.__stks[-1]):\n            self.__stks.pop()\n        if not self.__stks:\n            return -1\n        return self.__stks[-1].pop()\n\n    def popAtStack(self, a1):\n        \"\"\"\n        \"\"\"\n        if a1 >= len(self.__stks) or not self.__stks[a1]:\n            return -1\n        heapq.heappush(self.__min_heap, a1)\n        return self.__stks[a1].pop()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__stks = []\n        self.__c = a1\n        self.__min_heap = []\n\n    def push(self, a1):\n        \"\"\"\n        \"\"\"\n        if self.__min_heap:\n            v1 = heapq.heappop(self.__min_heap)\n            if v1 < len(self.__stks):\n                self.__stks[v1].append(a1)\n                return\n            self.__min_heap = []\n        if not self.__stks or len(self.__stks[-1]) == self.__c:\n            self.__stks.append([])\n        self.__stks[-1].append(a1)\n\n    def pop(self):\n        \"\"\"\n        \"\"\"\n        while self.__stks and (not self.__stks[-1]):\n            self.__stks.pop()\n        if not self.__stks:\n            return -1\n        return self.__stks[-1].pop()\n\n    def popAtStack(self, a1):\n        \"\"\"\n        \"\"\"\n        if a1 >= len(self.__stks) or not self.__stks[a1]:\n            return -1\n        heapq.heappush(self.__min_heap, a1)\n        return self.__stks[a1].pop()\n"}
{"id": "human_code\\minimum-cost-to-convert-string-ii__part3.py", "text": "import collections\nimport itertools\n\nclass C1(object):\n\n    def minimumCost(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = {}\n        for v3 in itertools.chain(a3, a4):\n            if v3 in v2:\n                continue\n            v2[v3] = len(v2)\n\n        def dijkstra(a1):\n            v1 = {a1: 0}\n            v2 = [(0, a1)]\n            while v2:\n                v3, v4 = heapq.heappop(v2)\n                if v3 > v1[v4]:\n                    continue\n                if v4 not in dist:\n                    continue\n                for v5, v6 in dist[v4].items():\n                    if v5 in v1 and v1[v5] <= v3 + v6:\n                        continue\n                    v1[v5] = v3 + v6\n                    heapq.heappush(v2, (v1[v5], v5))\n            return v1\n        v4 = {}\n\n        def memoization(a1, a2):\n            if a1 not in v2:\n                v4[a1] = dijkstra(a1)\n            return v4[a1][a2] if a2 in v4[a1] else v1\n        v5 = {}\n        for v6 in range(len(a3)):\n            v7, v8 = (v2[a3[v6]], v2[a4[v6]])\n            if v7 not in v5:\n                v5[v7] = {v8: v1}\n            if v8 not in v5[v7]:\n                v5[v7][v8] = v1\n            v5[v7][v8] = min(v5[v7][v8], a5[v6])\n        v9 = {len(v3) for v3 in a3}\n        v10 = [v1] * (max((len(v3) for v3 in a3)) + 1)\n        v10[0] = 0\n        for v6 in range(len(a1)):\n            if v10[v6 % len(v10)] == v1:\n                continue\n            if a1[v6] == a2[v6]:\n                v10[(v6 + 1) % len(v10)] = min(v10[(v6 + 1) % len(v10)], v10[v6 % len(v10)])\n            for v11 in v9:\n                if v6 + v11 > len(a1):\n                    continue\n                v7, v8 = (a1[v6:v6 + v11], a2[v6:v6 + v11])\n                if v7 in v2 and v8 in v2:\n                    v10[(v6 + v11) % len(v10)] = min(v10[(v6 + v11) % len(v10)], v10[v6 % len(v10)] + memoization(v2[v7], v2[v8]))\n            v10[v6 % len(v10)] = v1\n        return v10[len(a1) % len(v10)] if v10[len(a1) % len(v10)] != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport itertools\n\nclass C1(object):\n\n    def minimumCost(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = {}\n        for v3 in itertools.chain(a3, a4):\n            if v3 in v2:\n                continue\n            v2[v3] = len(v2)\n\n        def dijkstra(a1):\n            v1 = {a1: 0}\n            v2 = [(0, a1)]\n            while v2:\n                v3, v4 = heapq.heappop(v2)\n                if v3 > v1[v4]:\n                    continue\n                if v4 not in dist:\n                    continue\n                for v5, v6 in dist[v4].items():\n                    if v5 in v1 and v1[v5] <= v3 + v6:\n                        continue\n                    v1[v5] = v3 + v6\n                    heapq.heappush(v2, (v1[v5], v5))\n            return v1\n        v4 = {}\n\n        def memoization(a1, a2):\n            if a1 not in v2:\n                v4[a1] = dijkstra(a1)\n            return v4[a1][a2] if a2 in v4[a1] else v1\n        v5 = {}\n        for v6 in range(len(a3)):\n            v7, v8 = (v2[a3[v6]], v2[a4[v6]])\n            if v7 not in v5:\n                v5[v7] = {v8: v1}\n            if v8 not in v5[v7]:\n                v5[v7][v8] = v1\n            v5[v7][v8] = min(v5[v7][v8], a5[v6])\n        v9 = {len(v3) for v3 in a3}\n        v10 = [v1] * (max((len(v3) for v3 in a3)) + 1)\n        v10[0] = 0\n        for v6 in range(len(a1)):\n            if v10[v6 % len(v10)] == v1:\n                continue\n            if a1[v6] == a2[v6]:\n                v10[(v6 + 1) % len(v10)] = min(v10[(v6 + 1) % len(v10)], v10[v6 % len(v10)])\n            for v11 in v9:\n                if v6 + v11 > len(a1):\n                    continue\n                v7, v8 = (a1[v6:v6 + v11], a2[v6:v6 + v11])\n                if v7 in v2 and v8 in v2:\n                    v10[(v6 + v11) % len(v10)] = min(v10[(v6 + v11) % len(v10)], v10[v6 % len(v10)] + memoization(v2[v7], v2[v8]))\n            v10[v6 % len(v10)] = v1\n        return v10[len(a1) % len(v10)] if v10[len(a1) % len(v10)] != v1 else -1\n"}
{"id": "llm_code\\convert-binary-search-tree-to-sorted-doubly-linked-list__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2, a3):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def treeToDoublyList(self, a1):\n        if not a1:\n            return None\n        v1 = []\n        v2 = None\n        v3 = None\n        v4 = a1\n        while v4 or v1:\n            while v4:\n                v1.append(v4)\n                v4 = v4.left\n            v4 = v1.pop()\n            v4.left = v2\n            if v2:\n                v2.right = v4\n            else:\n                v3 = v4\n            v2 = v4\n            v4 = v4.right\n        v2.right = v3\n        v3.left = v2\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2, a3):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def treeToDoublyList(self, a1):\n        if not a1:\n            return None\n        v1 = []\n        v2 = None\n        v3 = None\n        v4 = a1\n        while v4 or v1:\n            while v4:\n                v1.append(v4)\n                v4 = v4.left\n            v4 = v1.pop()\n            v4.left = v2\n            if v2:\n                v2.right = v4\n            else:\n                v3 = v4\n            v2 = v4\n            v4 = v4.right\n        v2.right = v3\n        v3.left = v2\n        return v3\n"}
{"id": "llm_code\\p03776__s516126735.py", "text": "from collections import Counter\n\ndef f1(a1: int, a2: int) -> list:\n    v1 = [-1, 1]\n    for v2 in range(2, a1 + 1):\n        v1.append(a2 - a2 // v2 * v1[a2 % v2] % a2)\n    return v1\n\ndef f2(a1: int, a2: int) -> list:\n    v1 = [1, 1]\n    v2 = 1\n    for v3 in range(2, a1 + 1):\n        v2 = v2 * v3 % a2\n        v1.append(v2)\n    return v1\n\ndef f3(a1: int, a2: list, a3: int) -> list:\n    v1 = [1, 1]\n    for v2 in range(2, a1 + 1):\n        v1.append(v1[v2 - 1] * a2[v2] % a3)\n    return v1\n\ndef f4(a1: int, a2: int, a3: int, a4: list, a5: list) -> int:\n    if not (0 <= a2 and a2 <= a1):\n        return 0\n    return a4[a1] * a5[a2] % a3 * a5[a1 - a2] % a3\nv1, v2, v3 = map(int, input().split())\nv4 = list(map(int, input().split()))\nv4.sort(reverse=True)\nv5 = sum(v4[:v2]) / v2\nprint(v5)\nv6 = 9999999900000001\nv7 = f1(v1, v6)\nv8 = f2(v1, v6)\nv9 = f3(v1, v7, v6)\nv10 = Counter(v4)\nv11 = 0\nif len(v10) == 1:\n    for v12 in range(v2, v3 + 1):\n        v11 += f4(v1, v12, v6, v8, v9)\n    print(v11)\nelse:\n    v13 = v4[:v3].count(v4[v2 - 1])\n    v14 = v4.count(v4[v2 - 1])\n    for v12 in range(v13, v14 + 1):\n        v11 += f4(v14, v12, v6, v8, v9)\n    print(v11)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from collections import Counter\n\ndef f1(a1: int, a2: int) -> list:\n    v1 = [-1, 1]\n    for v2 in range(2, a1 + 1):\n        v1.append(a2 - a2 // v2 * v1[a2 % v2] % a2)\n    return v1\n\ndef f2(a1: int, a2: int) -> list:\n    v1 = [1, 1]\n    v2 = 1\n    for v3 in range(2, a1 + 1):\n        v2 = v2 * v3 % a2\n        v1.append(v2)\n    return v1\n\ndef f3(a1: int, a2: list, a3: int) -> list:\n    v1 = [1, 1]\n    for v2 in range(2, a1 + 1):\n        v1.append(v1[v2 - 1] * a2[v2] % a3)\n    return v1\n\ndef f4(a1: int, a2: int, a3: int, a4: list, a5: list) -> int:\n    if not (0 <= a2 and a2 <= a1):\n        return 0\n    return a4[a1] * a5[a2] % a3 * a5[a1 - a2] % a3\nv1, v2, v3 = map(int, input().split())\nv4 = list(map(int, input().split()))\nv4.sort(reverse=True)\nv5 = sum(v4[:v2]) / v2\nprint(v5)\nv6 = 9999999900000001\nv7 = f1(v1, v6)\nv8 = f2(v1, v6)\nv9 = f3(v1, v7, v6)\nv10 = Counter(v4)\nv11 = 0\nif len(v10) == 1:\n    for v12 in range(v2, v3 + 1):\n        v11 += f4(v1, v12, v6, v8, v9)\n    print(v11)\nelse:\n    v13 = v4[:v3].count(v4[v2 - 1])\n    v14 = v4.count(v4[v2 - 1])\n    for v12 in range(v13, v14 + 1):\n        v11 += f4(v14, v12, v6, v8, v9)\n    print(v11)\n"}
{"id": "llm_code\\maximum-sum-of-subsequence-with-non-adjacent-elements__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumSumSubsequence(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = [[0] * 4 for v4 in range(4 * v2)]\n\n        def merge(a1, a2):\n            v1 = [0] * 4\n            v1[0] = max(a1[2] + a2[1], a1[0] + a2[1], a1[2] + a2[0])\n            v1[1] = max(a1[3] + a2[1], a1[1] + a2[1], a1[3] + a2[0])\n            v1[2] = max(a1[2] + a2[3], a1[0] + a2[3], a1[2] + a2[2])\n            v1[3] = max(a1[3] + a2[3], a1[1] + a2[3], a1[3] + a2[2])\n            return v1\n\n        def construct(a1, a2, a3):\n            if a2 == a3:\n                v1 = max(a1[a2], 0)\n                v3[a1] = [v1, 0, 0, 0]\n                return\n            v2 = (a2 + a3) // 2\n            construct(2 * a1, a2, v2)\n            construct(2 * a1 + 1, v2 + 1, a3)\n            v3[a1] = merge(v3[2 * a1], v3[2 * a1 + 1])\n\n        def modify(a1, a2, a3, a4, a5):\n            if a2 == a3:\n                a5 = max(a5, 0)\n                v3[a1] = [a5, 0, 0, 0]\n                return\n            v2 = (a2 + a3) // 2\n            if a4 <= v2:\n                modify(2 * a1, a2, v2, a4, a5)\n            else:\n                modify(2 * a1 + 1, v2 + 1, a3, a4, a5)\n            v3[a1] = merge(v3[2 * a1], v3[2 * a1 + 1])\n        construct(1, 0, v2 - 1)\n        v5 = 0\n        for v6, v7 in a2:\n            modify(1, 0, v2 - 1, v6, v7)\n            v5 = (v5 + max(v3[1])) % v1\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumSumSubsequence(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = [[0] * 4 for v4 in range(4 * v2)]\n\n        def merge(a1, a2):\n            v1 = [0] * 4\n            v1[0] = max(a1[2] + a2[1], a1[0] + a2[1], a1[2] + a2[0])\n            v1[1] = max(a1[3] + a2[1], a1[1] + a2[1], a1[3] + a2[0])\n            v1[2] = max(a1[2] + a2[3], a1[0] + a2[3], a1[2] + a2[2])\n            v1[3] = max(a1[3] + a2[3], a1[1] + a2[3], a1[3] + a2[2])\n            return v1\n\n        def construct(a1, a2, a3):\n            if a2 == a3:\n                v1 = max(a1[a2], 0)\n                v3[a1] = [v1, 0, 0, 0]\n                return\n            v2 = (a2 + a3) // 2\n            construct(2 * a1, a2, v2)\n            construct(2 * a1 + 1, v2 + 1, a3)\n            v3[a1] = merge(v3[2 * a1], v3[2 * a1 + 1])\n\n        def modify(a1, a2, a3, a4, a5):\n            if a2 == a3:\n                a5 = max(a5, 0)\n                v3[a1] = [a5, 0, 0, 0]\n                return\n            v2 = (a2 + a3) // 2\n            if a4 <= v2:\n                modify(2 * a1, a2, v2, a4, a5)\n            else:\n                modify(2 * a1 + 1, v2 + 1, a3, a4, a5)\n            v3[a1] = merge(v3[2 * a1], v3[2 * a1 + 1])\n        construct(1, 0, v2 - 1)\n        v5 = 0\n        for v6, v7 in a2:\n            modify(1, 0, v2 - 1, v6, v7)\n            v5 = (v5 + max(v3[1])) % v1\n        return v5\n"}
{"id": "human_code\\p03244__s418045086.py", "text": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 1\nv4 = {}\nv5 = {}\nfor v6 in v2:\n    if v3 == 1:\n        if v6 in v4:\n            v4[v6] = v4[v6] + 1\n        else:\n            v4[v6] = 1\n        v3 = 0\n    else:\n        if v6 in v5:\n            v5[v6] = v5[v6] + 1\n        else:\n            v5[v6] = 1\n        v3 = 1\nv7 = max(v4, key=v4.get)\nv8 = max(v5, key=v5.get)\nif v7 == v8:\n    v9 = max(v4.values())\n    v10 = max(v5.values())\n    v4.pop(v7)\n    v5.pop(v8)\n    if v4 == {}:\n        v11 = 0\n    else:\n        v11 = max(v4.values())\n    if v5 == {}:\n        v12 = 0\n    else:\n        v12 = max(v5.values())\n    v13 = min(v1 - v9 - v12, v1 - v10 - v11)\n    print(v13)\nelse:\n    v13 = v1 - max(v4.values()) - max(v5.values())\n    print(v13)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 1\nv4 = {}\nv5 = {}\nfor v6 in v2:\n    if v3 == 1:\n        if v6 in v4:\n            v4[v6] = v4[v6] + 1\n        else:\n            v4[v6] = 1\n        v3 = 0\n    else:\n        if v6 in v5:\n            v5[v6] = v5[v6] + 1\n        else:\n            v5[v6] = 1\n        v3 = 1\nv7 = max(v4, key=v4.get)\nv8 = max(v5, key=v5.get)\nif v7 == v8:\n    v9 = max(v4.values())\n    v10 = max(v5.values())\n    v4.pop(v7)\n    v5.pop(v8)\n    if v4 == {}:\n        v11 = 0\n    else:\n        v11 = max(v4.values())\n    if v5 == {}:\n        v12 = 0\n    else:\n        v12 = max(v5.values())\n    v13 = min(v1 - v9 - v12, v1 - v10 - v11)\n    print(v13)\nelse:\n    v13 = v1 - max(v4.values()) - max(v5.values())\n    print(v13)\n"}
{"id": "llm_code\\p03660__s220431240.py", "text": "from collections import deque\nv1 = int(input())\nv2 = [[] for v3 in range(v1)]\nfor v3 in range(v1 - 1):\n    v4, v5 = map(int, input().split())\n    v2[v4 - 1] += [v5 - 1]\n    v2[v5 - 1] += [v4 - 1]\n\ndef f1(a1, a2, a3):\n    v1 = deque([a2])\n    v2 = [-1] * v1\n    while v1:\n        v3 = v1.popleft()\n        for v4 in a1[v3]:\n            if v4 == v2[v3]:\n                continue\n            v2[v4] = v3\n            if v4 == a3:\n                break\n            v1.append(v4)\n    return v2\nv6 = f1(v2, 0, v1 - 1)\nv7 = [v1 - 1]\nwhile v7[0] != 0:\n    v7 = [v6[v7[0]]] + v7\nv8 = (len(v7) - 1) // 2\nv9 = v7[v8]\nv10 = v7[v8 + 1]\nv2[v9].remove(v10)\n\ndef f2(a1, a2):\n    v1 = deque([a2])\n    v2 = [-1] * v1\n    while v1:\n        v3 = v1.popleft()\n        for v4 in a1[v3]:\n            if v2[v4] == v3:\n                continue\n            v2[v4] = v3\n            v1.append(v4)\n    v5 = sum([v3 for v3 in v2 if v3 != -1]) + 1\n    return v5\nv11 = f2(v2, 0)\nv12 = v1 - v11\nif v11 > v12:\n    print('Fennec')\nelse:\n    print('Snuke')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from collections import deque\nv1 = int(input())\nv2 = [[] for v3 in range(v1)]\nfor v3 in range(v1 - 1):\n    v4, v5 = map(int, input().split())\n    v2[v4 - 1] += [v5 - 1]\n    v2[v5 - 1] += [v4 - 1]\n\ndef f1(a1, a2, a3):\n    v1 = deque([a2])\n    v2 = [-1] * v1\n    while v1:\n        v3 = v1.popleft()\n        for v4 in a1[v3]:\n            if v4 == v2[v3]:\n                continue\n            v2[v4] = v3\n            if v4 == a3:\n                break\n            v1.append(v4)\n    return v2\nv6 = f1(v2, 0, v1 - 1)\nv7 = [v1 - 1]\nwhile v7[0] != 0:\n    v7 = [v6[v7[0]]] + v7\nv8 = (len(v7) - 1) // 2\nv9 = v7[v8]\nv10 = v7[v8 + 1]\nv2[v9].remove(v10)\n\ndef f2(a1, a2):\n    v1 = deque([a2])\n    v2 = [-1] * v1\n    while v1:\n        v3 = v1.popleft()\n        for v4 in a1[v3]:\n            if v2[v4] == v3:\n                continue\n            v2[v4] = v3\n            v1.append(v4)\n    v5 = sum([v3 for v3 in v2 if v3 != -1]) + 1\n    return v5\nv11 = f2(v2, 0)\nv12 = v1 - v11\nif v11 > v12:\n    print('Fennec')\nelse:\n    print('Snuke')\n"}
{"id": "llm_code\\digit-operations-to-make-two-integers-equal__grok-4.1-fast__v1.py", "text": "import heapq\nfrom collections import defaultdict\n\nclass C1:\n\n    def minOperations(self, a1, a2):\n        v1 = max(a1, a2)\n        v2 = 1\n        while v2 < v1:\n            v2 *= 10\n        v2 *= 2\n        v3 = list(range(v2 + 1))\n        v3[0] = v3[1] = 0\n        for v4 in range(2, int(v2 ** 0.5) + 1):\n            if v3[v4] == v4:\n                for v5 in range(v4 * v4, v2 + 1, v4):\n                    if v3[v5] == v5:\n                        v3[v5] = v4\n        if v3[a1] == a1:\n            return -1\n        v6 = defaultdict(lambda: float('inf'))\n        v6[a1] = a1\n        v7 = [(a1, a1)]\n        v8 = set()\n        while v7:\n            v9, v10 = heapq.heappop(v7)\n            if v10 in v8:\n                continue\n            v8.add(v10)\n            if v10 == a2:\n                return v9\n            v11 = 1\n            while v11 <= v10:\n                v12 = v10 // v11\n                v13 = v12 % 10\n                v14 = 1 if v12 < 10 else 0\n                for v15 in (-1, 1):\n                    v16 = v13 + v15\n                    if v14 <= v16 <= 9:\n                        v17 = v10 + v15 * v11\n                        if 0 < v17 <= v2 and v3[v17] != v17:\n                            v18 = v9 + v17\n                            if v18 < v6[v17]:\n                                v6[v17] = v18\n                                heapq.heappush(v7, (v18, v17))\n                v11 *= 10\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\nfrom collections import defaultdict\n\nclass C1:\n\n    def minOperations(self, a1, a2):\n        v1 = max(a1, a2)\n        v2 = 1\n        while v2 < v1:\n            v2 *= 10\n        v2 *= 2\n        v3 = list(range(v2 + 1))\n        v3[0] = v3[1] = 0\n        for v4 in range(2, int(v2 ** 0.5) + 1):\n            if v3[v4] == v4:\n                for v5 in range(v4 * v4, v2 + 1, v4):\n                    if v3[v5] == v5:\n                        v3[v5] = v4\n        if v3[a1] == a1:\n            return -1\n        v6 = defaultdict(lambda: float('inf'))\n        v6[a1] = a1\n        v7 = [(a1, a1)]\n        v8 = set()\n        while v7:\n            v9, v10 = heapq.heappop(v7)\n            if v10 in v8:\n                continue\n            v8.add(v10)\n            if v10 == a2:\n                return v9\n            v11 = 1\n            while v11 <= v10:\n                v12 = v10 // v11\n                v13 = v12 % 10\n                v14 = 1 if v12 < 10 else 0\n                for v15 in (-1, 1):\n                    v16 = v13 + v15\n                    if v14 <= v16 <= 9:\n                        v17 = v10 + v15 * v11\n                        if 0 < v17 <= v2 and v3[v17] != v17:\n                            v18 = v9 + v17\n                            if v18 < v6[v17]:\n                                v6[v17] = v18\n                                heapq.heappush(v7, (v18, v17))\n                v11 *= 10\n        return -1\n"}
{"id": "human_code\\most-frequent-prime__part1.py", "text": "import collections\n\ndef f1(a1):\n    v1 = []\n    v2 = [-1] * (a1 + 1)\n    for v3 in range(2, a1 + 1):\n        if v2[v3] == -1:\n            v2[v3] = v3\n            v1.append(v3)\n        for v4 in v1:\n            if v3 * v4 > a1 or v4 > v2[v3]:\n                break\n            v2[v3 * v4] = v4\n    return v2\nv1 = 6\nv2 = f1(10 ** v1 - 1)\n\nclass C1(object):\n\n    def mostFrequentPrime(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n\n        def numbers(a1, a2, a3, a4):\n            v1 = 0\n            while 0 <= a1 < len(a1) and 0 <= a2 < len(a1[0]):\n                v1 = v1 * 10 + a1[a1][a2]\n                yield v1\n                a1, a2 = (a1 + a3, a2 + a4)\n        v2 = collections.Counter((x for v3 in range(len(a1)) for v4 in range(len(a1[0])) for v5, v6 in v1 for v7 in numbers(v3, v4, v5, v6) if v7 > 10 and v2[v7] == v7))\n        v2[-1] = 0\n        return max(iter(v2.keys()), key=lambda x: (v2[v7], v7))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\ndef f1(a1):\n    v1 = []\n    v2 = [-1] * (a1 + 1)\n    for v3 in range(2, a1 + 1):\n        if v2[v3] == -1:\n            v2[v3] = v3\n            v1.append(v3)\n        for v4 in v1:\n            if v3 * v4 > a1 or v4 > v2[v3]:\n                break\n            v2[v3 * v4] = v4\n    return v2\nv1 = 6\nv2 = f1(10 ** v1 - 1)\n\nclass C1(object):\n\n    def mostFrequentPrime(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\n\n        def numbers(a1, a2, a3, a4):\n            v1 = 0\n            while 0 <= a1 < len(a1) and 0 <= a2 < len(a1[0]):\n                v1 = v1 * 10 + a1[a1][a2]\n                yield v1\n                a1, a2 = (a1 + a3, a2 + a4)\n        v2 = collections.Counter((x for v3 in range(len(a1)) for v4 in range(len(a1[0])) for v5, v6 in v1 for v7 in numbers(v3, v4, v5, v6) if v7 > 10 and v2[v7] == v7))\n        v2[-1] = 0\n        return max(iter(v2.keys()), key=lambda x: (v2[v7], v7))\n"}
{"id": "llm_code\\minimum-time-to-break-locks-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def findMinimumTime(self, a1, a2):\n        v1 = len(a1)\n        v2 = 10 ** 18 + 5\n        v3 = {}\n\n        def rec(a1):\n            if a1 in v3:\n                return v3[a1]\n            if a1 == 0:\n                v1 = 0\n            else:\n                v2 = 0\n                v3 = a1\n                while v3 > 0:\n                    v2 += v3 & 1\n                    v3 >>= 1\n                v4 = 1 + (v2 - 1) * a2\n                v1 = v2\n                v5 = a1\n                v6 = 0\n                while v5 > 0:\n                    if v5 & 1:\n                        v7 = a1 ^ 1 << v6\n                        v8 = rec(v7)\n                        v9 = (a1[v6] + v4 - 1) // v4\n                        v1 = min(v1, v8 + v9)\n                    v5 >>= 1\n                    v6 += 1\n            v3[a1] = v1\n            return v1\n        return rec((1 << v1) - 1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def findMinimumTime(self, a1, a2):\n        v1 = len(a1)\n        v2 = 10 ** 18 + 5\n        v3 = {}\n\n        def rec(a1):\n            if a1 in v3:\n                return v3[a1]\n            if a1 == 0:\n                v1 = 0\n            else:\n                v2 = 0\n                v3 = a1\n                while v3 > 0:\n                    v2 += v3 & 1\n                    v3 >>= 1\n                v4 = 1 + (v2 - 1) * a2\n                v1 = v2\n                v5 = a1\n                v6 = 0\n                while v5 > 0:\n                    if v5 & 1:\n                        v7 = a1 ^ 1 << v6\n                        v8 = rec(v7)\n                        v9 = (a1[v6] + v4 - 1) // v4\n                        v1 = min(v1, v8 + v9)\n                    v5 >>= 1\n                    v6 += 1\n            v3[a1] = v1\n            return v1\n        return rec((1 << v1) - 1)\n"}
{"id": "llm_code\\design-hashmap__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self):\n        self.size = 10007\n        self.table = [[] for v1 in range(self.size)]\n\n    def _bucket(self, a1):\n        return a1 % self.size\n\n    def put(self, a1, a2):\n        v1 = self._bucket(a1)\n        for v2 in range(len(self.table[v1])):\n            if self.table[v1][v2][0] == a1:\n                self.table[v1][v2] = (a1, a2)\n                return\n        self.table[v1].append((a1, a2))\n\n    def get(self, a1):\n        v1 = self._bucket(a1)\n        for v2 in self.table[v1]:\n            if v2[0] == a1:\n                return v2[1]\n        return -1\n\n    def remove(self, a1):\n        v1 = self._bucket(a1)\n        for v2 in range(len(self.table[v1])):\n            if self.table[v1][v2][0] == a1:\n                del self.table[v1][v2]\n                return\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self):\n        self.size = 10007\n        self.table = [[] for v1 in range(self.size)]\n\n    def _bucket(self, a1):\n        return a1 % self.size\n\n    def put(self, a1, a2):\n        v1 = self._bucket(a1)\n        for v2 in range(len(self.table[v1])):\n            if self.table[v1][v2][0] == a1:\n                self.table[v1][v2] = (a1, a2)\n                return\n        self.table[v1].append((a1, a2))\n\n    def get(self, a1):\n        v1 = self._bucket(a1)\n        for v2 in self.table[v1]:\n            if v2[0] == a1:\n                return v2[1]\n        return -1\n\n    def remove(self, a1):\n        v1 = self._bucket(a1)\n        for v2 in range(len(self.table[v1])):\n            if self.table[v1][v2][0] == a1:\n                del self.table[v1][v2]\n                return\n"}
{"id": "human_code\\p02853__s340697000.py", "text": "v1, v2 = (int(i) for v3 in input().split())\nsum = 0\nif v1 == 1:\n    sum += 300000\nelif v1 == 2:\n    sum += 200000\nelif v1 == 3:\n    sum += 100000\nelse:\n    sum += 0\nif v2 == 1:\n    sum += 300000\nelif v2 == 2:\n    sum += 200000\nelif v2 == 3:\n    sum += 100000\nelse:\n    sum += 0\nif v1 == 1 and v2 == 1:\n    sum += 400000\nprint(sum)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = (int(i) for v3 in input().split())\nsum = 0\nif v1 == 1:\n    sum += 300000\nelif v1 == 2:\n    sum += 200000\nelif v1 == 3:\n    sum += 100000\nelse:\n    sum += 0\nif v2 == 1:\n    sum += 300000\nelif v2 == 2:\n    sum += 200000\nelif v2 == 3:\n    sum += 100000\nelse:\n    sum += 0\nif v1 == 1 and v2 == 1:\n    sum += 400000\nprint(sum)\n"}
{"id": "llm_code\\p03274__s731919234.py", "text": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = 0\nv5 = 0\nv6 = []\nv7 = []\nv8 = 0\nif v3[0] < 0:\n    for v9 in range(v1):\n        if v3[v9] >= 0:\n            v8 = v9\n            break\n    v6 = v3[:v8]\n    v6 = v6[::-1]\n    for v9 in range(len(v6)):\n        v6[v9] = abs(v6[v9])\n    v7 = v3[v8:]\n    v10 = 10000000000000000\n    v11 = len(v6)\n    v12 = len(v7)\n    for v9 in range(v11):\n        if v2 - (v9 + 1) <= v12 and v2 - (v9 + 1) >= 0:\n            v10 = min(v10, v6[v9] * 2 + v7[v2 - 1 - (v9 + 1)])\n    for v9 in range(v12):\n        if v2 - (v9 + 1) <= v11 and v2 - (v9 + 1) >= 0:\n            v10 = min(v10, v7[v9] * 2 + v6[v2 - 1 - (v9 + 1)])\n    if v2 - 1 < v11:\n        v10 = min(v10, v6[v2 - 1])\n    if v2 - 1 < v12:\n        v10 = min(v10, v7[v2 - 1])\n    print(v10)\nelse:\n    print(v3[v2 - 1])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = 0\nv5 = 0\nv6 = []\nv7 = []\nv8 = 0\nif v3[0] < 0:\n    for v9 in range(v1):\n        if v3[v9] >= 0:\n            v8 = v9\n            break\n    v6 = v3[:v8]\n    v6 = v6[::-1]\n    for v9 in range(len(v6)):\n        v6[v9] = abs(v6[v9])\n    v7 = v3[v8:]\n    v10 = 10000000000000000\n    v11 = len(v6)\n    v12 = len(v7)\n    for v9 in range(v11):\n        if v2 - (v9 + 1) <= v12 and v2 - (v9 + 1) >= 0:\n            v10 = min(v10, v6[v9] * 2 + v7[v2 - 1 - (v9 + 1)])\n    for v9 in range(v12):\n        if v2 - (v9 + 1) <= v11 and v2 - (v9 + 1) >= 0:\n            v10 = min(v10, v7[v9] * 2 + v6[v2 - 1 - (v9 + 1)])\n    if v2 - 1 < v11:\n        v10 = min(v10, v6[v2 - 1])\n    if v2 - 1 < v12:\n        v10 = min(v10, v7[v2 - 1])\n    print(v10)\nelse:\n    print(v3[v2 - 1])\n"}
{"id": "llm_code\\add-bold-tag-in-string__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def addBoldTag(self, a1, a2):\n        v1 = []\n        for v2 in a2:\n            v3 = len(v2)\n            if v3 == 0:\n                continue\n            v4 = 0\n            while True:\n                v5 = a1.find(v2, v4)\n                if v5 == -1:\n                    break\n                v1.append((v5, v5 + v3))\n                v4 = v5 + 1\n        if not v1:\n            return a1\n        v1.sort()\n        v6 = [[v1[0][0], v1[0][1]]]\n        for v7, v8 in v1[1:]:\n            if v7 <= v6[-1][1]:\n                v6[-1][1] = max(v6[-1][1], v8)\n            else:\n                v6.append([v7, v8])\n        v9 = []\n        v10 = 0\n        for v11, v12 in v6:\n            v9.append(a1[v10:v11])\n            v9.append('<b>')\n            v9.append(a1[v11:v12])\n            v9.append('</b>')\n            v10 = v12\n        v9.append(a1[v10:])\n        return ''.join(v9)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def addBoldTag(self, a1, a2):\n        v1 = []\n        for v2 in a2:\n            v3 = len(v2)\n            if v3 == 0:\n                continue\n            v4 = 0\n            while True:\n                v5 = a1.find(v2, v4)\n                if v5 == -1:\n                    break\n                v1.append((v5, v5 + v3))\n                v4 = v5 + 1\n        if not v1:\n            return a1\n        v1.sort()\n        v6 = [[v1[0][0], v1[0][1]]]\n        for v7, v8 in v1[1:]:\n            if v7 <= v6[-1][1]:\n                v6[-1][1] = max(v6[-1][1], v8)\n            else:\n                v6.append([v7, v8])\n        v9 = []\n        v10 = 0\n        for v11, v12 in v6:\n            v9.append(a1[v10:v11])\n            v9.append('<b>')\n            v9.append(a1[v11:v12])\n            v9.append('</b>')\n            v10 = v12\n        v9.append(a1[v10:])\n        return ''.join(v9)\n"}
{"id": "human_code\\cinema-seat-allocation__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def maxNumberOfFamilies(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(lambda: [False] * 3)\n        for v2, v3 in a2:\n            if 2 <= v3 <= 5:\n                v1[v2][0] = True\n            if 4 <= v3 <= 7:\n                v1[v2][1] = True\n            if 6 <= v3 <= 9:\n                v1[v2][2] = True\n        v4 = 2 * a1\n        for v5, v6, v3 in v1.values():\n            if not v5 and (not v3):\n                continue\n            if not v5 or not v6 or (not v3):\n                v4 -= 1\n                continue\n            v4 -= 2\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def maxNumberOfFamilies(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(lambda: [False] * 3)\n        for v2, v3 in a2:\n            if 2 <= v3 <= 5:\n                v1[v2][0] = True\n            if 4 <= v3 <= 7:\n                v1[v2][1] = True\n            if 6 <= v3 <= 9:\n                v1[v2][2] = True\n        v4 = 2 * a1\n        for v5, v6, v3 in v1.values():\n            if not v5 and (not v3):\n                continue\n            if not v5 or not v6 or (not v3):\n                v4 -= 1\n                continue\n            v4 -= 2\n        return v4\n"}
{"id": "human_code\\alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.py", "text": "import collections\nimport itertools\n\nclass C1(object):\n\n    def alertNames(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 3\n        v2 = collections.defaultdict(list)\n        for v3, v4 in zip(a1, a2):\n            v5, v6 = list(map(int, v4.split(':')))\n            v2[v3].append(v5 * 60 + v6)\n        v7 = []\n        for v3, v8 in v2.items():\n            v8.sort()\n            v9 = 0\n            for v10, v11 in enumerate(v8):\n                while v11 - v8[v9] > 60:\n                    v9 += 1\n                if v10 - v9 + 1 >= v1:\n                    v7.append(v3)\n                    break\n        v7.sort()\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport itertools\n\nclass C1(object):\n\n    def alertNames(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 3\n        v2 = collections.defaultdict(list)\n        for v3, v4 in zip(a1, a2):\n            v5, v6 = list(map(int, v4.split(':')))\n            v2[v3].append(v5 * 60 + v6)\n        v7 = []\n        for v3, v8 in v2.items():\n            v8.sort()\n            v9 = 0\n            for v10, v11 in enumerate(v8):\n                while v11 - v8[v9] > 60:\n                    v9 += 1\n                if v10 - v9 + 1 >= v1:\n                    v7.append(v3)\n                    break\n        v7.sort()\n        return v7\n"}
{"id": "llm_code\\p02603__s972478575.py", "text": "def f1():\n    v1 = int(input())\n    v2 = list(map(int, input().split()))\n    v3 = 1000\n    for v4 in range(v1 - 1):\n        v5 = 1000\n        v6 = [0 for v7 in range(v1)]\n        v6[v4] = 1\n        v8 = v4\n        for v9 in range(v4 + 1, v1):\n            if v2[v9] > v2[v8]:\n                v6[v9] = 1\n                if v9 > 0 and v6[v9 - 1] == 1:\n                    v6[v9 - 1] = 0\n                v8 = v9\n            elif v2[v8] > v2[v9]:\n                v6[v9] = -1\n                if v9 > 0 and v6[v9 - 1] == -1:\n                    v6[v9 - 1] = 0\n                v8 = v9\n            else:\n                v6[v9] = 0\n                v8 = v9\n        v10 = v5 // v2[v4]\n        v5 = v5 - v10 * v2[v4]\n        v11 = 0\n        for v12 in range(len(v6)):\n            if v6[v12] == 1:\n                v5 = v5 + v10 * v2[v12]\n                v10 = 0\n            elif v6[v12] == -1:\n                v10 = v5 // v2[v12]\n                v5 = v5 - v10 * v2[v12]\n                v11 = v12\n        v5 = v5 + v10 * v2[v11]\n        if v5 > v3:\n            v3 = v5\n    print(v3)\nif __name__ == '__main__':\n    f1()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1():\n    v1 = int(input())\n    v2 = list(map(int, input().split()))\n    v3 = 1000\n    for v4 in range(v1 - 1):\n        v5 = 1000\n        v6 = [0 for v7 in range(v1)]\n        v6[v4] = 1\n        v8 = v4\n        for v9 in range(v4 + 1, v1):\n            if v2[v9] > v2[v8]:\n                v6[v9] = 1\n                if v9 > 0 and v6[v9 - 1] == 1:\n                    v6[v9 - 1] = 0\n                v8 = v9\n            elif v2[v8] > v2[v9]:\n                v6[v9] = -1\n                if v9 > 0 and v6[v9 - 1] == -1:\n                    v6[v9 - 1] = 0\n                v8 = v9\n            else:\n                v6[v9] = 0\n                v8 = v9\n        v10 = v5 // v2[v4]\n        v5 = v5 - v10 * v2[v4]\n        v11 = 0\n        for v12 in range(len(v6)):\n            if v6[v12] == 1:\n                v5 = v5 + v10 * v2[v12]\n                v10 = 0\n            elif v6[v12] == -1:\n                v10 = v5 // v2[v12]\n                v5 = v5 - v10 * v2[v12]\n                v11 = v12\n        v5 = v5 + v10 * v2[v11]\n        if v5 > v3:\n            v3 = v5\n    print(v3)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\reorganize-string.py", "text": "import collections\nimport heapq\n\nclass C1(object):\n\n    def reorganizeString(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = collections.Counter(a1)\n        if any((v > (len(a1) + 1) / 2 for v2, v3 in v1.items())):\n            return ''\n        v4 = []\n        v5 = []\n        for v2, v3 in v1.items():\n            heapq.heappush(v5, (-v3, v2))\n        while len(v5) > 1:\n            v6, v7 = heapq.heappop(v5)\n            v8, v9 = heapq.heappop(v5)\n            if not v4 or v7 != v4[-1]:\n                v4.extend([v7, v9])\n                if v6 + 1:\n                    heapq.heappush(v5, (v6 + 1, v7))\n                if v8 + 1:\n                    heapq.heappush(v5, (v8 + 1, v9))\n        return ''.join(v4) + (v5[0][1] if v5 else '')\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport heapq\n\nclass C1(object):\n\n    def reorganizeString(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = collections.Counter(a1)\n        if any((v > (len(a1) + 1) / 2 for v2, v3 in v1.items())):\n            return ''\n        v4 = []\n        v5 = []\n        for v2, v3 in v1.items():\n            heapq.heappush(v5, (-v3, v2))\n        while len(v5) > 1:\n            v6, v7 = heapq.heappop(v5)\n            v8, v9 = heapq.heappop(v5)\n            if not v4 or v7 != v4[-1]:\n                v4.extend([v7, v9])\n                if v6 + 1:\n                    heapq.heappush(v5, (v6 + 1, v7))\n                if v8 + 1:\n                    heapq.heappush(v5, (v8 + 1, v9))\n        return ''.join(v4) + (v5[0][1] if v5 else '')\n"}
{"id": "llm_code\\sum-of-imbalance-numbers-of-all-subarrays__grok-4.1-fast__v1.py", "text": "from collections import defaultdict\nfrom typing import List\n\nclass C1:\n\n    def sumImbalanceNumbers(self, a1: List[int]) -> int:\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = v1 * (v1 + 1) // 2\n        v3 = 0\n        v4 = {}\n        v5 = [-1] * v1\n        for v6 in range(v1):\n            v7 = a1[v6]\n            v5[v6] = v4.get(v7, -1)\n            v8 = v6 - v5[v6]\n            v3 += v8 * (v1 - v6)\n            v4[v7] = v6\n        v9 = defaultdict(list)\n        for v6 in range(v1):\n            v9[a1[v6]].append(v6)\n        v10 = 0\n        v11 = set(v9.keys())\n\n        def gaps_subs(a1: List[int], a2: int) -> int:\n            if not a1:\n                return v2\n            v1 = 0\n            v2 = -1\n            for v3 in a1:\n                v4 = v3 - v2 - 1\n                v1 += v4 * (v4 + 1) // 2\n                v2 = v3\n            v4 = a2 - v2 - 1\n            v1 += v4 * (v4 + 1) // 2\n            return v1\n\n        def merge_lists(a1: List[int], a2: List[int]) -> List[int]:\n            v1 = []\n            v2, v3 = (0, 0)\n            v4, v5 = (len(a1), len(a2))\n            while v2 < v4 and v3 < v5:\n                if a1[v2] < a2[v3]:\n                    v1.append(a1[v2])\n                    v2 += 1\n                else:\n                    v1.append(a2[v3])\n                    v3 += 1\n            v1.extend(a1[v2:])\n            v1.extend(a2[v3:])\n            return v1\n        for v12 in list(v11):\n            v13 = v12 + 1\n            if v13 in v11:\n                v14 = v9[v12]\n                v15 = v9[v13]\n                v16 = gaps_subs(v14, v1)\n                v17 = gaps_subs(v15, v1)\n                v18 = merge_lists(v14, v15)\n                v19 = gaps_subs(v18, v1)\n                v20 = v2 - v16 - v17 + v19\n                v10 += v20\n        return v3 - v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import defaultdict\nfrom typing import List\n\nclass C1:\n\n    def sumImbalanceNumbers(self, a1: List[int]) -> int:\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = v1 * (v1 + 1) // 2\n        v3 = 0\n        v4 = {}\n        v5 = [-1] * v1\n        for v6 in range(v1):\n            v7 = a1[v6]\n            v5[v6] = v4.get(v7, -1)\n            v8 = v6 - v5[v6]\n            v3 += v8 * (v1 - v6)\n            v4[v7] = v6\n        v9 = defaultdict(list)\n        for v6 in range(v1):\n            v9[a1[v6]].append(v6)\n        v10 = 0\n        v11 = set(v9.keys())\n\n        def gaps_subs(a1: List[int], a2: int) -> int:\n            if not a1:\n                return v2\n            v1 = 0\n            v2 = -1\n            for v3 in a1:\n                v4 = v3 - v2 - 1\n                v1 += v4 * (v4 + 1) // 2\n                v2 = v3\n            v4 = a2 - v2 - 1\n            v1 += v4 * (v4 + 1) // 2\n            return v1\n\n        def merge_lists(a1: List[int], a2: List[int]) -> List[int]:\n            v1 = []\n            v2, v3 = (0, 0)\n            v4, v5 = (len(a1), len(a2))\n            while v2 < v4 and v3 < v5:\n                if a1[v2] < a2[v3]:\n                    v1.append(a1[v2])\n                    v2 += 1\n                else:\n                    v1.append(a2[v3])\n                    v3 += 1\n            v1.extend(a1[v2:])\n            v1.extend(a2[v3:])\n            return v1\n        for v12 in list(v11):\n            v13 = v12 + 1\n            if v13 in v11:\n                v14 = v9[v12]\n                v15 = v9[v13]\n                v16 = gaps_subs(v14, v1)\n                v17 = gaps_subs(v15, v1)\n                v18 = merge_lists(v14, v15)\n                v19 = gaps_subs(v18, v1)\n                v20 = v2 - v16 - v17 + v19\n                v10 += v20\n        return v3 - v10\n"}
{"id": "llm_code\\p02889__unrelated.py", "text": "import heapq\nfrom collections import defaultdict\n\ndef f1(a1, a2, a3):\n    v1 = {node: float('inf') for v2 in a1}\n    v1[a2] = 0\n    v3 = [(0, a2, 0)]\n    while v3:\n        v4, v2, v5 = heapq.heappop(v3)\n        if v4 > v1[v2]:\n            continue\n        for v6, v7 in a1[v2].items():\n            v8 = v4 + v7\n            v9 = v5\n            if v8 > a3:\n                v8 = v7\n                v9 += 1\n            if v8 < v1[v6]:\n                v1[v6] = v8\n                heapq.heappush(v3, (v8, v6, v9))\n    return v1\n\ndef f2():\n    v1, v2, v3 = map(int, input().split())\n    v4 = defaultdict(dict)\n    for v5 in range(v2):\n        v6, v7, v8 = map(int, input().split())\n        v4[v6][v7] = v8\n        v4[v7][v6] = v8\n    v9 = int(input())\n    for v5 in range(v9):\n        v10, v11 = map(int, input().split())\n        v12 = f1(v4, v10, v3)\n        if v12[v11] == float('inf'):\n            print(-1)\n        else:\n            print(v12[v11])\nif __name__ == '__main__':\n    f2()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import heapq\nfrom collections import defaultdict\n\ndef f1(a1, a2, a3):\n    v1 = {node: float('inf') for v2 in a1}\n    v1[a2] = 0\n    v3 = [(0, a2, 0)]\n    while v3:\n        v4, v2, v5 = heapq.heappop(v3)\n        if v4 > v1[v2]:\n            continue\n        for v6, v7 in a1[v2].items():\n            v8 = v4 + v7\n            v9 = v5\n            if v8 > a3:\n                v8 = v7\n                v9 += 1\n            if v8 < v1[v6]:\n                v1[v6] = v8\n                heapq.heappush(v3, (v8, v6, v9))\n    return v1\n\ndef f2():\n    v1, v2, v3 = map(int, input().split())\n    v4 = defaultdict(dict)\n    for v5 in range(v2):\n        v6, v7, v8 = map(int, input().split())\n        v4[v6][v7] = v8\n        v4[v7][v6] = v8\n    v9 = int(input())\n    for v5 in range(v9):\n        v10, v11 = map(int, input().split())\n        v12 = f1(v4, v10, v3)\n        if v12[v11] == float('inf'):\n            print(-1)\n        else:\n            print(v12[v11])\nif __name__ == '__main__':\n    f2()\n"}
{"id": "human_code\\kth-smallest-element-in-a-sorted-matrix.py", "text": "from heapq import heappush, heappop\n\nclass C1(object):\n\n    def kthSmallest(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = []\n\n        def push(a1, a2):\n            if len(a1) > len(a1[0]):\n                if a1 < len(a1[0]) and a2 < len(a1):\n                    heappush(v2, [a1[a2][a1], a1, a2])\n            elif a1 < len(a1) and a2 < len(a1[0]):\n                heappush(v2, [a1[a1][a2], a1, a2])\n        push(0, 0)\n        while v2 and a2 > 0:\n            v1, v3, v4 = heappop(v2)\n            push(v3, v4 + 1)\n            if v4 == 0:\n                push(v3 + 1, 0)\n            a2 -= 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from heapq import heappush, heappop\n\nclass C1(object):\n\n    def kthSmallest(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = []\n\n        def push(a1, a2):\n            if len(a1) > len(a1[0]):\n                if a1 < len(a1[0]) and a2 < len(a1):\n                    heappush(v2, [a1[a2][a1], a1, a2])\n            elif a1 < len(a1) and a2 < len(a1[0]):\n                heappush(v2, [a1[a1][a2], a1, a2])\n        push(0, 0)\n        while v2 and a2 > 0:\n            v1, v3, v4 = heappop(v2)\n            push(v3, v4 + 1)\n            if v4 == 0:\n                push(v3 + 1, 0)\n            a2 -= 1\n        return v1\n"}
{"id": "llm_code\\rectangle-area-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def rectangleArea(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = []\n        v3 = set()\n        for v4, v5, v6, v7 in a1:\n            v2.append((v5, 1, v4, v6))\n            v2.append((v7, -1, v4, v6))\n            v3.add(v4)\n            v3.add(v6)\n        v8 = sorted(v3)\n        v9 = len(v8)\n        if v9 < 2:\n            return 0\n        v10 = {v8[i]: i for v11 in range(v9)}\n        v12 = v9 - 1\n        v13 = 4 * v9\n        v14 = [0] * v13\n        v15 = [0] * v13\n        v16 = [0] * v13\n        v17 = [v8[v11 + 1] - v8[v11] for v11 in range(v12)]\n\n        def construct(a1, a2, a3):\n            if a2 == a3:\n                v16[a1] = v17[a2]\n                return\n            v1 = (a2 + a3) // 2\n            construct(2 * a1, a2, v1)\n            construct(2 * a1 + 1, v1 + 1, a3)\n            v16[a1] = v16[2 * a1] + v16[2 * a1 + 1]\n        construct(1, 0, v12 - 1)\n\n        def modify(a1, a2, a3, a4, a5, a6):\n            if a4 > a3 or a5 < a2:\n                return\n            if a4 <= a2 and a3 <= a5:\n                v14[a1] += a6\n            else:\n                v1 = (a2 + a3) // 2\n                modify(2 * a1, a2, v1, a4, a5, a6)\n                modify(2 * a1 + 1, v1 + 1, a3, a4, a5, a6)\n            if v14[a1] > 0:\n                v15[a1] = v16[a1]\n            elif a2 == a3:\n                v15[a1] = 0\n            else:\n                v15[a1] = v15[2 * a1] + v15[2 * a1 + 1]\n        v2.sort()\n        v18 = 0\n        v19 = v2[0][0]\n        v20 = 0\n        for v21, v22, v23, v24 in v2:\n            v18 = (v18 + v20 * (v21 - v19)) % v1\n            v25 = v10[v23]\n            v26 = v10[v24] - 1\n            if v25 <= v26:\n                modify(1, 0, v12 - 1, v25, v26, v22)\n            v20 = v15[1]\n            v19 = v21\n        return v18\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def rectangleArea(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = []\n        v3 = set()\n        for v4, v5, v6, v7 in a1:\n            v2.append((v5, 1, v4, v6))\n            v2.append((v7, -1, v4, v6))\n            v3.add(v4)\n            v3.add(v6)\n        v8 = sorted(v3)\n        v9 = len(v8)\n        if v9 < 2:\n            return 0\n        v10 = {v8[i]: i for v11 in range(v9)}\n        v12 = v9 - 1\n        v13 = 4 * v9\n        v14 = [0] * v13\n        v15 = [0] * v13\n        v16 = [0] * v13\n        v17 = [v8[v11 + 1] - v8[v11] for v11 in range(v12)]\n\n        def construct(a1, a2, a3):\n            if a2 == a3:\n                v16[a1] = v17[a2]\n                return\n            v1 = (a2 + a3) // 2\n            construct(2 * a1, a2, v1)\n            construct(2 * a1 + 1, v1 + 1, a3)\n            v16[a1] = v16[2 * a1] + v16[2 * a1 + 1]\n        construct(1, 0, v12 - 1)\n\n        def modify(a1, a2, a3, a4, a5, a6):\n            if a4 > a3 or a5 < a2:\n                return\n            if a4 <= a2 and a3 <= a5:\n                v14[a1] += a6\n            else:\n                v1 = (a2 + a3) // 2\n                modify(2 * a1, a2, v1, a4, a5, a6)\n                modify(2 * a1 + 1, v1 + 1, a3, a4, a5, a6)\n            if v14[a1] > 0:\n                v15[a1] = v16[a1]\n            elif a2 == a3:\n                v15[a1] = 0\n            else:\n                v15[a1] = v15[2 * a1] + v15[2 * a1 + 1]\n        v2.sort()\n        v18 = 0\n        v19 = v2[0][0]\n        v20 = 0\n        for v21, v22, v23, v24 in v2:\n            v18 = (v18 + v20 * (v21 - v19)) % v1\n            v25 = v10[v23]\n            v26 = v10[v24] - 1\n            if v25 <= v26:\n                modify(1, 0, v12 - 1, v25, v26, v22)\n            v20 = v15[1]\n            v19 = v21\n        return v18\n"}
{"id": "llm_code\\numbers-at-most-n-given-digit-set__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def atMostNGivenDigitSet(self, a1, a2):\n        v1 = str(a2)\n        v2 = len(v1)\n        v3 = len(a1)\n        v4 = set(a1)\n        v5 = 0\n        v6 = 1\n        for v7 in range(v2 - 1):\n            v6 *= v3\n            v5 += v6\n        v8 = v5\n        v9 = v2\n        v10 = True\n        for v11 in range(v2):\n            v12 = v1[v11]\n            v13 = 0\n            for v14 in a1:\n                if v14 < v12:\n                    v13 += 1\n            v8 += v13 * v3 ** (v9 - 1)\n            if v12 not in v4:\n                v10 = False\n                break\n            v9 -= 1\n        if v10:\n            v8 += 1\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def atMostNGivenDigitSet(self, a1, a2):\n        v1 = str(a2)\n        v2 = len(v1)\n        v3 = len(a1)\n        v4 = set(a1)\n        v5 = 0\n        v6 = 1\n        for v7 in range(v2 - 1):\n            v6 *= v3\n            v5 += v6\n        v8 = v5\n        v9 = v2\n        v10 = True\n        for v11 in range(v2):\n            v12 = v1[v11]\n            v13 = 0\n            for v14 in a1:\n                if v14 < v12:\n                    v13 += 1\n            v8 += v13 * v3 ** (v9 - 1)\n            if v12 not in v4:\n                v10 = False\n                break\n            v9 -= 1\n        if v10:\n            v8 += 1\n        return v8\n"}
{"id": "human_code\\maximum-number-of-integers-to-choose-from-a-range-ii__part1.py", "text": "class C1(object):\n\n    def maxCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = min(int((-1 + (1 + 8 * a3)) ** 0.5 / 2), a2)\n        v2 = (v1 + 1) * v1 // 2\n        v3 = v1\n        v4 = set(a1)\n        for v5 in v4:\n            if v5 <= v1:\n                v2 -= v5\n                v3 -= 1\n        for v6 in range(v1 + 1, a2 + 1):\n            if v6 in v4:\n                continue\n            if v2 + v6 > a3:\n                break\n            v2 += v6\n            v3 += 1\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = min(int((-1 + (1 + 8 * a3)) ** 0.5 / 2), a2)\n        v2 = (v1 + 1) * v1 // 2\n        v3 = v1\n        v4 = set(a1)\n        for v5 in v4:\n            if v5 <= v1:\n                v2 -= v5\n                v3 -= 1\n        for v6 in range(v1 + 1, a2 + 1):\n            if v6 in v4:\n                continue\n            if v2 + v6 > a3:\n                break\n            v2 += v6\n            v3 += 1\n        return v3\n"}
{"id": "llm_code\\design-video-sharing-platform__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    class _VideoData:\n\n        def __init__(self, a1):\n            self.clip = a1\n            self.like_count = 0\n            self.dislike_count = 0\n            self.view_count = 0\n\n    def __init__(self):\n        self._free_slots = []\n        self._video_store = {}\n        self._next_id = 0\n\n    def upload(self, a1):\n        if self._free_slots:\n            v1 = heapq.heappop(self._free_slots)\n        else:\n            v1 = self._next_id\n            self._next_id += 1\n        self._video_store[v1] = self._VideoData(a1)\n        return v1\n\n    def remove(self, a1):\n        if a1 in self._video_store:\n            heapq.heappush(self._free_slots, a1)\n            del self._video_store[a1]\n\n    def watch(self, a1, a2, a3):\n        if a1 not in self._video_store:\n            return '-1'\n        v1 = self._video_store[a1]\n        v1.view_count += 1\n        return v1.clip[a2:a3 + 1]\n\n    def like(self, a1):\n        if a1 in self._video_store:\n            self._video_store[a1].like_count += 1\n\n    def dislike(self, a1):\n        if a1 in self._video_store:\n            self._video_store[a1].dislike_count += 1\n\n    def getLikesAndDislikes(self, a1):\n        if a1 not in self._video_store:\n            return [-1]\n        v1 = self._video_store[a1]\n        return [v1.like_count, v1.dislike_count]\n\n    def getViews(self, a1):\n        if a1 not in self._video_store:\n            return -1\n        return self._video_store[a1].view_count\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    class _VideoData:\n\n        def __init__(self, a1):\n            self.clip = a1\n            self.like_count = 0\n            self.dislike_count = 0\n            self.view_count = 0\n\n    def __init__(self):\n        self._free_slots = []\n        self._video_store = {}\n        self._next_id = 0\n\n    def upload(self, a1):\n        if self._free_slots:\n            v1 = heapq.heappop(self._free_slots)\n        else:\n            v1 = self._next_id\n            self._next_id += 1\n        self._video_store[v1] = self._VideoData(a1)\n        return v1\n\n    def remove(self, a1):\n        if a1 in self._video_store:\n            heapq.heappush(self._free_slots, a1)\n            del self._video_store[a1]\n\n    def watch(self, a1, a2, a3):\n        if a1 not in self._video_store:\n            return '-1'\n        v1 = self._video_store[a1]\n        v1.view_count += 1\n        return v1.clip[a2:a3 + 1]\n\n    def like(self, a1):\n        if a1 in self._video_store:\n            self._video_store[a1].like_count += 1\n\n    def dislike(self, a1):\n        if a1 in self._video_store:\n            self._video_store[a1].dislike_count += 1\n\n    def getLikesAndDislikes(self, a1):\n        if a1 not in self._video_store:\n            return [-1]\n        v1 = self._video_store[a1]\n        return [v1.like_count, v1.dislike_count]\n\n    def getViews(self, a1):\n        if a1 not in self._video_store:\n            return -1\n        return self._video_store[a1].view_count\n"}
{"id": "llm_code\\maximize-sum-of-weights-after-edge-removals__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximizeSumOfWeights(self, a1, a2):\n        v1 = len(a1) + 1\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5, v6 in a1:\n            v2[v4].append((v5, v6))\n            v2[v5].append((v4, v6))\n\n        def explore(a1, a2):\n            v1 = 0\n            v2 = []\n            for v3, v4 in v2[a1]:\n                if v3 == a2:\n                    continue\n                v5, v6 = explore(v3, a1)\n                v1 += v5\n                v7 = max(v6 + v4 - v5, 0)\n                v2.append(v7)\n            v2.sort(reverse=True)\n            v8 = min(a2, len(v2))\n            v9 = max(0, min(a2 - 1, len(v2)))\n            v10 = v1 + sum(v2[:v8])\n            v11 = v1 + sum(v2[:v9])\n            return (v10, v11)\n        return explore(0, -1)[0]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximizeSumOfWeights(self, a1, a2):\n        v1 = len(a1) + 1\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5, v6 in a1:\n            v2[v4].append((v5, v6))\n            v2[v5].append((v4, v6))\n\n        def explore(a1, a2):\n            v1 = 0\n            v2 = []\n            for v3, v4 in v2[a1]:\n                if v3 == a2:\n                    continue\n                v5, v6 = explore(v3, a1)\n                v1 += v5\n                v7 = max(v6 + v4 - v5, 0)\n                v2.append(v7)\n            v2.sort(reverse=True)\n            v8 = min(a2, len(v2))\n            v9 = max(0, min(a2 - 1, len(v2)))\n            v10 = v1 + sum(v2[:v8])\n            v11 = v1 + sum(v2[:v9])\n            return (v10, v11)\n        return explore(0, -1)[0]\n"}
{"id": "llm_code\\maximum-number-of-k-divisible-components__grok-4.1-fast__v1.py", "text": "import sys\nsys.setrecursionlimit(10 ** 5 + 10)\n\nclass C1:\n\n    def maxKDivisibleComponents(self, a1, a2, a3, a4):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n\n        def compute(a1, a2):\n            v1 = a3[a1] % a4\n            v2 = 0\n            for v3 in v1[a1]:\n                if v3 == a2:\n                    continue\n                v4, v5 = compute(v3, a1)\n                v2 += v4\n                if v5 == 0:\n                    v2 += 1\n                else:\n                    v1 = (v1 + v5) % a4\n            return (v2, v1)\n        v5, v2 = compute(0, -1)\n        return v5 + 1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 5 + 10)\n\nclass C1:\n\n    def maxKDivisibleComponents(self, a1, a2, a3, a4):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n\n        def compute(a1, a2):\n            v1 = a3[a1] % a4\n            v2 = 0\n            for v3 in v1[a1]:\n                if v3 == a2:\n                    continue\n                v4, v5 = compute(v3, a1)\n                v2 += v4\n                if v5 == 0:\n                    v2 += 1\n                else:\n                    v1 = (v1 + v5) % a4\n            return (v2, v1)\n        v5, v2 = compute(0, -1)\n        return v5 + 1\n"}
{"id": "human_code\\diagonal-traverse.py", "text": "class C1(object):\n\n    def findDiagonalOrder(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1 or not a1[0]:\n            return []\n        v1 = []\n        v2, v3, v4 = (0, 0, 0)\n        v5 = [(-1, 1), (1, -1)]\n        for v6 in range(len(a1) * len(a1[0])):\n            v1.append(a1[v2][v3])\n            v2 += v5[v4][0]\n            v3 += v5[v4][1]\n            if v2 >= len(a1):\n                v2 = len(a1) - 1\n                v3 += 2\n                v4 = 1 - v4\n            elif v3 >= len(a1[0]):\n                v3 = len(a1[0]) - 1\n                v2 += 2\n                v4 = 1 - v4\n            elif v2 < 0:\n                v2 = 0\n                v4 = 1 - v4\n            elif v3 < 0:\n                v3 = 0\n                v4 = 1 - v4\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findDiagonalOrder(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1 or not a1[0]:\n            return []\n        v1 = []\n        v2, v3, v4 = (0, 0, 0)\n        v5 = [(-1, 1), (1, -1)]\n        for v6 in range(len(a1) * len(a1[0])):\n            v1.append(a1[v2][v3])\n            v2 += v5[v4][0]\n            v3 += v5[v4][1]\n            if v2 >= len(a1):\n                v2 = len(a1) - 1\n                v3 += 2\n                v4 = 1 - v4\n            elif v3 >= len(a1[0]):\n                v3 = len(a1[0]) - 1\n                v2 += 2\n                v4 = 1 - v4\n            elif v2 < 0:\n                v2 = 0\n                v4 = 1 - v4\n            elif v3 < 0:\n                v3 = 0\n                v4 = 1 - v4\n        return v1\n"}
{"id": "human_code\\random-pick-with-blacklist__part2.py", "text": "import random\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__n = a1 - len(a2)\n        a2.sort()\n        self.__blacklist = a2\n\n    def pick(self):\n        \"\"\"\n        \"\"\"\n        v1 = random.randint(0, self.__n - 1)\n        v2, v3 = (0, len(self.__blacklist) - 1)\n        while v2 <= v3:\n            v4 = v2 + (v3 - v2) // 2\n            if v1 + v4 < self.__blacklist[v4]:\n                v3 = v4 - 1\n            else:\n                v2 = v4 + 1\n        return v1 + v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__n = a1 - len(a2)\n        a2.sort()\n        self.__blacklist = a2\n\n    def pick(self):\n        \"\"\"\n        \"\"\"\n        v1 = random.randint(0, self.__n - 1)\n        v2, v3 = (0, len(self.__blacklist) - 1)\n        while v2 <= v3:\n            v4 = v2 + (v3 - v2) // 2\n            if v1 + v4 < self.__blacklist[v4]:\n                v3 = v4 - 1\n            else:\n                v2 = v4 + 1\n        return v1 + v2\n"}
{"id": "llm_code\\expressive-words__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def expressiveWords(self, a1, a2):\n\n        def parse_groups(a1):\n            v1 = []\n            v2 = 0\n            v3 = len(a1)\n            while v2 < v3:\n                v4 = v2\n                while v2 < v3 and a1[v2] == a1[v4]:\n                    v2 += 1\n                v1.append((a1[v4], v2 - v4))\n            return v1\n        v1 = parse_groups(a1)\n        v2 = 0\n        for v3 in a2:\n            v4 = parse_groups(v3)\n            if len(v1) != len(v4):\n                continue\n            v5 = True\n            for (v6, v7), (v8, v9) in zip(v1, v4):\n                if v6 != v8 or not (v7 == v9 or (v7 >= 3 and v7 >= v9)):\n                    v5 = False\n                    break\n            if v5:\n                v2 += 1\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def expressiveWords(self, a1, a2):\n\n        def parse_groups(a1):\n            v1 = []\n            v2 = 0\n            v3 = len(a1)\n            while v2 < v3:\n                v4 = v2\n                while v2 < v3 and a1[v2] == a1[v4]:\n                    v2 += 1\n                v1.append((a1[v4], v2 - v4))\n            return v1\n        v1 = parse_groups(a1)\n        v2 = 0\n        for v3 in a2:\n            v4 = parse_groups(v3)\n            if len(v1) != len(v4):\n                continue\n            v5 = True\n            for (v6, v7), (v8, v9) in zip(v1, v4):\n                if v6 != v8 or not (v7 == v9 or (v7 >= 3 and v7 >= v9)):\n                    v5 = False\n                    break\n            if v5:\n                v2 += 1\n        return v2\n"}
{"id": "llm_code\\graph-valid-tree__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def validTree(self, a1, a2):\n        if a1 == 0:\n            return True\n        v1 = list(range(a1))\n        v2 = [0] * a1\n\n        def get_root(a1):\n            if v1[a1] != a1:\n                v1[a1] = get_root(v1[a1])\n            return v1[a1]\n\n        def merge(a1, a2):\n            v1, v2 = (get_root(a1), get_root(a2))\n            if v1 == v2:\n                return False\n            if v2[v1] < v2[v2]:\n                v1[v1] = v2\n            elif v2[v1] > v2[v2]:\n                v1[v2] = v1\n            else:\n                v1[v2] = v1\n                v2[v1] += 1\n            return True\n        v3 = a1\n        for v4, v5 in a2:\n            if v4 >= a1 or v5 >= a1 or (not merge(v4, v5)):\n                return False\n            v3 -= 1\n        return v3 == 1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def validTree(self, a1, a2):\n        if a1 == 0:\n            return True\n        v1 = list(range(a1))\n        v2 = [0] * a1\n\n        def get_root(a1):\n            if v1[a1] != a1:\n                v1[a1] = get_root(v1[a1])\n            return v1[a1]\n\n        def merge(a1, a2):\n            v1, v2 = (get_root(a1), get_root(a2))\n            if v1 == v2:\n                return False\n            if v2[v1] < v2[v2]:\n                v1[v1] = v2\n            elif v2[v1] > v2[v2]:\n                v1[v2] = v1\n            else:\n                v1[v2] = v1\n                v2[v1] += 1\n            return True\n        v3 = a1\n        for v4, v5 in a2:\n            if v4 >= a1 or v5 >= a1 or (not merge(v4, v5)):\n                return False\n            v3 -= 1\n        return v3 == 1\n"}
{"id": "human_code\\maximize-amount-after-two-days-of-conversions__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def maxAmount(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n\n        def find_adj(a1, a2):\n            v1 = collections.defaultdict(list)\n            for v2 in range(len(a1)):\n                v1[a1[v2][0]].append((a1[v2][1], a2[v2]))\n                v1[a1[v2][1]].append((a1[v2][0], 1 / a2[v2]))\n            return v1\n\n        def bfs(a1, a2):\n            v1 = list(a1.keys())\n            while v1:\n                v2 = []\n                for v3 in v1:\n                    for v4, v5 in a2[v3]:\n                        if not v5 * a1[v3] > a1[v4]:\n                            continue\n                        a1[v4] = v5 * a1[v3]\n                        v2.append(v4)\n                v1 = v2\n            return a1\n        v1 = collections.defaultdict(int)\n        v1[a1] = 1.0\n        v2 = find_adj(a2, a3)\n        bfs(v1, v2)\n        v3 = find_adj(a4, a5)\n        bfs(v1, v3)\n        return v1[a1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def maxAmount(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n\n        def find_adj(a1, a2):\n            v1 = collections.defaultdict(list)\n            for v2 in range(len(a1)):\n                v1[a1[v2][0]].append((a1[v2][1], a2[v2]))\n                v1[a1[v2][1]].append((a1[v2][0], 1 / a2[v2]))\n            return v1\n\n        def bfs(a1, a2):\n            v1 = list(a1.keys())\n            while v1:\n                v2 = []\n                for v3 in v1:\n                    for v4, v5 in a2[v3]:\n                        if not v5 * a1[v3] > a1[v4]:\n                            continue\n                        a1[v4] = v5 * a1[v3]\n                        v2.append(v4)\n                v1 = v2\n            return a1\n        v1 = collections.defaultdict(int)\n        v1[a1] = 1.0\n        v2 = find_adj(a2, a3)\n        bfs(v1, v2)\n        v3 = find_adj(a4, a5)\n        bfs(v1, v3)\n        return v1[a1]\n"}
{"id": "human_code\\minimum-time-to-eat-all-grains.py", "text": "class C1(object):\n\n    def minimumTime(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = 0\n            for v2 in a1:\n                if v2 - a2[v1] > a1:\n                    return False\n                elif v2 - a2[v1] > 0:\n                    v3 = v2 - a2[v1]\n                    v4 = max(a1 - 2 * v3, (a1 - v3) // 2)\n                else:\n                    v4 = a1\n                while v1 < len(a2) and a2[v1] <= v2 + v4:\n                    v1 += 1\n                if v1 == len(a2):\n                    return True\n            return False\n        a1.sort()\n        a2.sort()\n        v1, v2 = (0, 2 * (max(a2[-1], a1[-1]) - min(a2[0], a1[0])))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumTime(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = 0\n            for v2 in a1:\n                if v2 - a2[v1] > a1:\n                    return False\n                elif v2 - a2[v1] > 0:\n                    v3 = v2 - a2[v1]\n                    v4 = max(a1 - 2 * v3, (a1 - v3) // 2)\n                else:\n                    v4 = a1\n                while v1 < len(a2) and a2[v1] <= v2 + v4:\n                    v1 += 1\n                if v1 == len(a2):\n                    return True\n            return False\n        a1.sort()\n        a2.sort()\n        v1, v2 = (0, 2 * (max(a2[-1], a1[-1]) - min(a2[0], a1[0])))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1\n"}
{"id": "human_code\\partition-array-to-minimize-xor__part1.py", "text": "class C1(object):\n\n    def minXor(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = [0] * (len(a1) + 1)\n        for v3 in range(len(a1)):\n            v2[v3 + 1] = v2[v3] ^ a1[v3]\n        v4 = v2[:]\n        v4[0] = v1\n        for v5 in range(2, a2 + 1):\n            for v3 in reversed(range(v5 - 1, len(v4))):\n                v6 = v1\n                for v7 in range(v5 - 1, v3):\n                    v8 = v2[v3] ^ v2[v7]\n                    v9 = v4[v7] if v4[v7] > v8 else v8\n                    if v9 < v6:\n                        v6 = v9\n                v4[v3] = v6\n        return v4[-1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minXor(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = [0] * (len(a1) + 1)\n        for v3 in range(len(a1)):\n            v2[v3 + 1] = v2[v3] ^ a1[v3]\n        v4 = v2[:]\n        v4[0] = v1\n        for v5 in range(2, a2 + 1):\n            for v3 in reversed(range(v5 - 1, len(v4))):\n                v6 = v1\n                for v7 in range(v5 - 1, v3):\n                    v8 = v2[v3] ^ v2[v7]\n                    v9 = v4[v7] if v4[v7] > v8 else v8\n                    if v9 < v6:\n                        v6 = v9\n                v4[v3] = v6\n        return v4[-1]\n"}
{"id": "human_code\\count-the-number-of-k-big-indices__part1.py", "text": "import heapq\n\nclass C1(object):\n\n    def kBigIndices(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [False] * len(a1)\n        v2 = []\n        for v3 in reversed(range(len(a1))):\n            if len(v2) == a2 and a1[v3] > -v2[0]:\n                v1[v3] = True\n            heapq.heappush(v2, -a1[v3])\n            if len(v2) == a2 + 1:\n                heapq.heappop(v2)\n        v4 = 0\n        v5 = []\n        for v3 in range(len(a1)):\n            if len(v5) == a2 and a1[v3] > -v5[0] and v1[v3]:\n                v4 += 1\n            heapq.heappush(v5, -a1[v3])\n            if len(v5) == a2 + 1:\n                heapq.heappop(v5)\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def kBigIndices(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [False] * len(a1)\n        v2 = []\n        for v3 in reversed(range(len(a1))):\n            if len(v2) == a2 and a1[v3] > -v2[0]:\n                v1[v3] = True\n            heapq.heappush(v2, -a1[v3])\n            if len(v2) == a2 + 1:\n                heapq.heappop(v2)\n        v4 = 0\n        v5 = []\n        for v3 in range(len(a1)):\n            if len(v5) == a2 and a1[v3] > -v5[0] and v1[v3]:\n                v4 += 1\n            heapq.heappush(v5, -a1[v3])\n            if len(v5) == a2 + 1:\n                heapq.heappop(v5)\n        return v4\n"}
{"id": "llm_code\\p02901__s494952995.py", "text": "v1, v2 = input().split()\nv1, v2 = (int(v1), int(v2))\nv3 = [0 for v4 in range(v2)]\nv5 = [[] for v4 in range(v2)]\nfor v6 in range(v2):\n    v3[v6], v7 = input().split()\n    v3[v6], v7 = (int(v3[v6]), int(v7))\n    v5[v6] = list(map(int, input().split()))\n    v5[v6] = [j - 1 for v8 in v5[v6]]\n\ndef f1(a1, a2):\n    if a1 == v1 and 0 not in a2:\n        return 0\n    elif a1 == v1 and 0 in a2:\n        return 1e+20\n    else:\n        v1 = f1(a1 + 1, a2)\n        v2 = a2.copy()\n        for v3 in range(len(v5[a1])):\n            v2[v5[a1][v3]] += 1\n        v4 = f1(a1 + 1, v2) + v3[a1]\n        return min([v1, v4])\nv9 = [0 for v4 in range(v1)]\nv10 = f1(0, v9)\nif v10 >= 1e+20:\n    print(-1)\nelse:\n    print(v10)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = input().split()\nv1, v2 = (int(v1), int(v2))\nv3 = [0 for v4 in range(v2)]\nv5 = [[] for v4 in range(v2)]\nfor v6 in range(v2):\n    v3[v6], v7 = input().split()\n    v3[v6], v7 = (int(v3[v6]), int(v7))\n    v5[v6] = list(map(int, input().split()))\n    v5[v6] = [j - 1 for v8 in v5[v6]]\n\ndef f1(a1, a2):\n    if a1 == v1 and 0 not in a2:\n        return 0\n    elif a1 == v1 and 0 in a2:\n        return 1e+20\n    else:\n        v1 = f1(a1 + 1, a2)\n        v2 = a2.copy()\n        for v3 in range(len(v5[a1])):\n            v2[v5[a1][v3]] += 1\n        v4 = f1(a1 + 1, v2) + v3[a1]\n        return min([v1, v4])\nv9 = [0 for v4 in range(v1)]\nv10 = f1(0, v9)\nif v10 >= 1e+20:\n    print(-1)\nelse:\n    print(v10)\n"}
{"id": "human_code\\earliest-second-to-mark-indices-i.py", "text": "class C1(object):\n\n    def earliestSecondToMarkIndices(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = [-1] * len(a1)\n            for v2 in range(a1):\n                v1[a2[v2] - 1] = v2\n            if -1 in v1:\n                return False\n            v3 = 0\n            for v2 in range(a1):\n                if v2 != v1[a2[v2] - 1]:\n                    v3 += 1\n                    continue\n                v3 -= a1[a2[v2] - 1]\n                if v3 < 0:\n                    return False\n            return True\n        v1, v2 = (sum(a1) + len(a1), len(a2))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1 if v1 <= len(a2) else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def earliestSecondToMarkIndices(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = [-1] * len(a1)\n            for v2 in range(a1):\n                v1[a2[v2] - 1] = v2\n            if -1 in v1:\n                return False\n            v3 = 0\n            for v2 in range(a1):\n                if v2 != v1[a2[v2] - 1]:\n                    v3 += 1\n                    continue\n                v3 -= a1[a2[v2] - 1]\n                if v3 < 0:\n                    return False\n            return True\n        v1, v2 = (sum(a1) + len(a1), len(a2))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1 if v1 <= len(a2) else -1\n"}
{"id": "human_code\\p02768__s481943896.py", "text": "v1 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    return (a1 + a2) % v1\n\ndef f2(a1, a2):\n    return (a1 + v1 - a2) % v1\n\ndef f3(a1, a2):\n    return a1 % v1 * (a2 % v1) % v1\n\ndef f4(a1, a2):\n    if a2 == 0:\n        return 1\n    elif a2 == 1:\n        return a1 % v1\n    elif a2 % 2 == 0:\n        return f4(a1, a2 // 2) ** 2 % v1\n    else:\n        return f4(a1, a2 // 2) ** 2 * a1 % v1\n\ndef f5(a1, a2):\n    return f3(a1, f4(a2, v1 - 2))\nv2, v3, v4 = map(int, input().split())\nv5 = f4(2, v2)\nv5 = f2(v5, 1)\nv6 = 1\nv7 = 1\nfor v8 in range(v3):\n    v6 = f3(v6, v2 - v8)\n    v7 = f3(v7, v8 + 1)\nv6 = f5(v6, v7)\nv9 = 1\nv10 = 1\nfor v8 in range(v4):\n    v9 = f3(v9, v2 - v8)\n    v10 = f3(v10, v8 + 1)\nv9 = f5(v9, v10)\nv5 = f2(v5, v6)\nv5 = f2(v5, v9)\nprint(v5)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    return (a1 + a2) % v1\n\ndef f2(a1, a2):\n    return (a1 + v1 - a2) % v1\n\ndef f3(a1, a2):\n    return a1 % v1 * (a2 % v1) % v1\n\ndef f4(a1, a2):\n    if a2 == 0:\n        return 1\n    elif a2 == 1:\n        return a1 % v1\n    elif a2 % 2 == 0:\n        return f4(a1, a2 // 2) ** 2 % v1\n    else:\n        return f4(a1, a2 // 2) ** 2 * a1 % v1\n\ndef f5(a1, a2):\n    return f3(a1, f4(a2, v1 - 2))\nv2, v3, v4 = map(int, input().split())\nv5 = f4(2, v2)\nv5 = f2(v5, 1)\nv6 = 1\nv7 = 1\nfor v8 in range(v3):\n    v6 = f3(v6, v2 - v8)\n    v7 = f3(v7, v8 + 1)\nv6 = f5(v6, v7)\nv9 = 1\nv10 = 1\nfor v8 in range(v4):\n    v9 = f3(v9, v2 - v8)\n    v10 = f3(v10, v8 + 1)\nv9 = f5(v9, v10)\nv5 = f2(v5, v6)\nv5 = f2(v5, v9)\nprint(v5)\n"}
{"id": "human_code\\checking-existence-of-edge-length-limited-paths.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.set[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.set[v2] = v1\n        else:\n            self.set[v2] = v1\n            self.rank[v1] += 1\n        return True\n\nclass C2(object):\n\n    def distanceLimitedPathsExist(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        for v1, v2 in enumerate(a3):\n            v2.append(v1)\n        a2.sort(key=lambda x: x[2])\n        a3.sort(key=lambda x: x[2])\n        v3 = C1(a1)\n        v4 = [False] * len(a3)\n        v5 = 0\n        for v6, v7, v8, v1 in a3:\n            while v5 < len(a2) and a2[v5][2] < v8:\n                v3.union_set(a2[v5][0], a2[v5][1])\n                v5 += 1\n            v4[v1] = v3.find_set(v6) == v3.find_set(v7)\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.set[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.set[v2] = v1\n        else:\n            self.set[v2] = v1\n            self.rank[v1] += 1\n        return True\n\nclass C2(object):\n\n    def distanceLimitedPathsExist(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        for v1, v2 in enumerate(a3):\n            v2.append(v1)\n        a2.sort(key=lambda x: x[2])\n        a3.sort(key=lambda x: x[2])\n        v3 = C1(a1)\n        v4 = [False] * len(a3)\n        v5 = 0\n        for v6, v7, v8, v1 in a3:\n            while v5 < len(a2) and a2[v5][2] < v8:\n                v3.union_set(a2[v5][0], a2[v5][1])\n                v5 += 1\n            v4[v1] = v3.find_set(v6) == v3.find_set(v7)\n        return v4\n"}
{"id": "human_code\\parallel-courses-iii.py", "text": "class C1(object):\n\n    def minimumTime(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a1)]\n        v3 = [0] * a1\n        for v4, v5 in a2:\n            v1[v4 - 1].append(v5 - 1)\n            v3[v5 - 1] += 1\n        v6 = [u for v7 in range(a1) if not v3[v7]]\n        v8 = [a3[v7] if not v3[v7] else 0 for v7 in range(a1)]\n        while v6:\n            v9 = []\n            for v7 in v6:\n                for v10 in v1[v7]:\n                    v8[v10] = max(v8[v10], v8[v7] + a3[v10])\n                    v3[v10] -= 1\n                    if not v3[v10]:\n                        v9.append(v10)\n            v6 = v9\n        return max(v8)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumTime(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a1)]\n        v3 = [0] * a1\n        for v4, v5 in a2:\n            v1[v4 - 1].append(v5 - 1)\n            v3[v5 - 1] += 1\n        v6 = [u for v7 in range(a1) if not v3[v7]]\n        v8 = [a3[v7] if not v3[v7] else 0 for v7 in range(a1)]\n        while v6:\n            v9 = []\n            for v7 in v6:\n                for v10 in v1[v7]:\n                    v8[v10] = max(v8[v10], v8[v7] + a3[v10])\n                    v3[v10] -= 1\n                    if not v3[v10]:\n                        v9.append(v10)\n            v6 = v9\n        return max(v8)\n"}
{"id": "human_code\\copy-list-with-random-pointer__part2.py", "text": "class C1(object):\n\n    def copyRandomList(self, a1):\n        v1 = Node(0)\n        v2, v3, v4 = (a1, v1, {})\n        while v2:\n            v5 = Node(v2.val)\n            v4[v2] = v5\n            v3.next = v5\n            v3, v2 = (v3.__next__, v2.__next__)\n        v2 = a1\n        while v2:\n            if v2.random:\n                v4[v2].random = v4[v2.random]\n            v2 = v2.__next__\n        return v1.__next__\nfrom collections import defaultdict\n\nclass C2(object):\n\n    def copyRandomList(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = defaultdict(lambda: Node(0))\n        v1[None] = None\n        v2 = a1\n        while v2:\n            v1[v2].val = v2.val\n            v1[v2].next = v1[v2.__next__]\n            v1[v2].random = v1[v2.random]\n            v2 = v2.__next__\n        return v1[a1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def copyRandomList(self, a1):\n        v1 = Node(0)\n        v2, v3, v4 = (a1, v1, {})\n        while v2:\n            v5 = Node(v2.val)\n            v4[v2] = v5\n            v3.next = v5\n            v3, v2 = (v3.__next__, v2.__next__)\n        v2 = a1\n        while v2:\n            if v2.random:\n                v4[v2].random = v4[v2.random]\n            v2 = v2.__next__\n        return v1.__next__\nfrom collections import defaultdict\n\nclass C2(object):\n\n    def copyRandomList(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = defaultdict(lambda: Node(0))\n        v1[None] = None\n        v2 = a1\n        while v2:\n            v1[v2].val = v2.val\n            v1[v2].next = v1[v2.__next__]\n            v1[v2].random = v1[v2.random]\n            v2 = v2.__next__\n        return v1[a1]\n"}
{"id": "human_code\\count-substrings-divisible-by-last-digit__part2.py", "text": "class C1(object):\n\n    def countSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        for v2 in range(len(a1)):\n            if a1[v2] == '4':\n                v1 += 1\n                if v2 - 1 >= 0 and int(a1[v2 - 1:v2 + 1]) % 4 == 0:\n                    v1 += v2\n        for v2 in range(len(a1)):\n            if a1[v2] == '8':\n                v1 += 1\n                if v2 - 1 >= 0 and int(a1[v2 - 1:v2 + 1]) % 8 == 0:\n                    v1 += 1\n                if v2 - 2 >= 0 and int(a1[v2 - 2:v2 + 1]) % 8 == 0:\n                    v1 += v2 - 1\n        for v3 in range(1, 9 + 1):\n            if v3 in (4, 8):\n                continue\n            v4 = 1\n            v5 = 0\n            v6 = [0] * v3\n            v7 = 0\n            for v2 in range(len(a1)):\n                v5 = (v5 + v4 * (ord(a1[~v2]) - ord('0'))) % v3\n                v7 += v6[v5]\n                if a1[~v2] == str(v3):\n                    v7 += v3 != 8\n                    v6[v5] += 1\n                v4 = v4 * 10 % v3\n            v1 += v7\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        for v2 in range(len(a1)):\n            if a1[v2] == '4':\n                v1 += 1\n                if v2 - 1 >= 0 and int(a1[v2 - 1:v2 + 1]) % 4 == 0:\n                    v1 += v2\n        for v2 in range(len(a1)):\n            if a1[v2] == '8':\n                v1 += 1\n                if v2 - 1 >= 0 and int(a1[v2 - 1:v2 + 1]) % 8 == 0:\n                    v1 += 1\n                if v2 - 2 >= 0 and int(a1[v2 - 2:v2 + 1]) % 8 == 0:\n                    v1 += v2 - 1\n        for v3 in range(1, 9 + 1):\n            if v3 in (4, 8):\n                continue\n            v4 = 1\n            v5 = 0\n            v6 = [0] * v3\n            v7 = 0\n            for v2 in range(len(a1)):\n                v5 = (v5 + v4 * (ord(a1[~v2]) - ord('0'))) % v3\n                v7 += v6[v5]\n                if a1[~v2] == str(v3):\n                    v7 += v3 != 8\n                    v6[v5] += 1\n                v4 = v4 * 10 % v3\n            v1 += v7\n        return v1\n"}
{"id": "llm_code\\maximum-value-sum-by-placing-three-rooks-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumValueSum(self, a1):\n        v1 = 3\n        v2 = len(a1)\n        v3 = len(a1[0])\n        v4 = []\n        for v5 in range(v2):\n            v6 = [(a1[v5][col_idx], v5, col_idx) for v7 in range(v3)]\n            v6.sort(key=lambda x: x[0], reverse=True)\n            v4.append(v6[:v1])\n        v8 = [[] for v9 in range(v3)]\n        for v10 in v4:\n            for v11 in v10:\n                v7 = v11[2]\n                v8[v7].append(v11)\n        for v7 in range(v3):\n            v8[v7].sort(key=lambda x: x[0], reverse=True)\n            v8[v7] = v8[v7][:v1]\n        v12 = []\n        for v13 in v8:\n            v12.extend(v13)\n        v12.sort(key=lambda x: x[0], reverse=True)\n        v14 = (v1 - 1) * (2 * v1 - 1) + 1\n        v15 = v12[:v14]\n        v16 = 0\n        v17 = len(v15)\n        for v18 in range(v17):\n            v19, v20, v21 = v15[v18]\n            for v22 in range(v18 + 1, v17):\n                v23, v24, v25 = v15[v22]\n                if v20 == v24 or v21 == v25:\n                    continue\n                for v26 in range(v22 + 1, v17):\n                    v27, v28, v29 = v15[v26]\n                    if v28 == v20 or v28 == v24 or v29 == v21 or (v29 == v25):\n                        continue\n                    v16 = max(v16, v19 + v23 + v27)\n        return v16\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumValueSum(self, a1):\n        v1 = 3\n        v2 = len(a1)\n        v3 = len(a1[0])\n        v4 = []\n        for v5 in range(v2):\n            v6 = [(a1[v5][col_idx], v5, col_idx) for v7 in range(v3)]\n            v6.sort(key=lambda x: x[0], reverse=True)\n            v4.append(v6[:v1])\n        v8 = [[] for v9 in range(v3)]\n        for v10 in v4:\n            for v11 in v10:\n                v7 = v11[2]\n                v8[v7].append(v11)\n        for v7 in range(v3):\n            v8[v7].sort(key=lambda x: x[0], reverse=True)\n            v8[v7] = v8[v7][:v1]\n        v12 = []\n        for v13 in v8:\n            v12.extend(v13)\n        v12.sort(key=lambda x: x[0], reverse=True)\n        v14 = (v1 - 1) * (2 * v1 - 1) + 1\n        v15 = v12[:v14]\n        v16 = 0\n        v17 = len(v15)\n        for v18 in range(v17):\n            v19, v20, v21 = v15[v18]\n            for v22 in range(v18 + 1, v17):\n                v23, v24, v25 = v15[v22]\n                if v20 == v24 or v21 == v25:\n                    continue\n                for v26 in range(v22 + 1, v17):\n                    v27, v28, v29 = v15[v26]\n                    if v28 == v20 or v28 == v24 or v29 == v21 or (v29 == v25):\n                        continue\n                    v16 = max(v16, v19 + v23 + v27)\n        return v16\n"}
{"id": "llm_code\\kth-smallest-instructions__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def kthSmallestPath(self, a1, a2):\n        v1, v2 = a1\n\n        def binomial(a1, a2):\n            if a2 == 0 or a2 == a1:\n                return 1\n            a2 = min(a2, a1 - a2)\n            v2 = 1\n            for v3 in range(a2):\n                v2 = v2 * (a1 - v3) // (v3 + 1)\n            return v2\n\n        def construct_path(a1, a2, a3):\n            if a1 == 0 and a2 == 0:\n                return ''\n            v1 = 0 if a2 == 0 else binomial(a1 + a2 - 1, a1)\n            if a3 <= v1:\n                return 'H' + construct_path(a1, a2 - 1, a3)\n            else:\n                return 'V' + construct_path(a1 - 1, a2, a3 - v1)\n        return construct_path(v1, v2, a2)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def kthSmallestPath(self, a1, a2):\n        v1, v2 = a1\n\n        def binomial(a1, a2):\n            if a2 == 0 or a2 == a1:\n                return 1\n            a2 = min(a2, a1 - a2)\n            v2 = 1\n            for v3 in range(a2):\n                v2 = v2 * (a1 - v3) // (v3 + 1)\n            return v2\n\n        def construct_path(a1, a2, a3):\n            if a1 == 0 and a2 == 0:\n                return ''\n            v1 = 0 if a2 == 0 else binomial(a1 + a2 - 1, a1)\n            if a3 <= v1:\n                return 'H' + construct_path(a1, a2 - 1, a3)\n            else:\n                return 'V' + construct_path(a1 - 1, a2, a3 - v1)\n        return construct_path(v1, v2, a2)\n"}
{"id": "llm_code\\evaluate-valid-expressions__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def evaluateExpression(self, a1):\n        v1 = {'add': int.__add__, 'sub': int.__sub__, 'mul': int.__mul__, 'div': int.__floordiv__}\n\n        def evaluate(a1):\n            v1 = a1\n            while a1 < len(a1) and a1[a1].isdigit():\n                a1 += 1\n            if a1 > v1:\n                return (int(a1[v1:a1]), a1)\n            v1 = a1\n            while a1 < len(a1) and a1[a1].isalpha():\n                a1 += 1\n            v3 = v1[a1[v1:a1]]\n            a1 += 1\n            v4, a1 = evaluate(a1)\n            a1 += 1\n            v5, a1 = evaluate(a1)\n            a1 += 1\n            return (v3(v4, v5), a1)\n        return evaluate(0)[0]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def evaluateExpression(self, a1):\n        v1 = {'add': int.__add__, 'sub': int.__sub__, 'mul': int.__mul__, 'div': int.__floordiv__}\n\n        def evaluate(a1):\n            v1 = a1\n            while a1 < len(a1) and a1[a1].isdigit():\n                a1 += 1\n            if a1 > v1:\n                return (int(a1[v1:a1]), a1)\n            v1 = a1\n            while a1 < len(a1) and a1[a1].isalpha():\n                a1 += 1\n            v3 = v1[a1[v1:a1]]\n            a1 += 1\n            v4, a1 = evaluate(a1)\n            a1 += 1\n            v5, a1 = evaluate(a1)\n            a1 += 1\n            return (v3(v4, v5), a1)\n        return evaluate(0)[0]\n"}
{"id": "human_code\\missing-ranges.py", "text": "class C1(object):\n\n    def findMissingRanges(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def getRange(a1, a2):\n            if a1 == a2:\n                return '{}'.format(a1)\n            else:\n                return '{}->{}'.format(a1, a2)\n        v1 = []\n        v2 = a2 - 1\n        for v3 in range(len(a1) + 1):\n            if v3 == len(a1):\n                v4 = a3 + 1\n            else:\n                v4 = a1[v3]\n            if v4 - v2 >= 2:\n                v1.append(getRange(v2 + 1, v4 - 1))\n            v2 = v4\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findMissingRanges(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def getRange(a1, a2):\n            if a1 == a2:\n                return '{}'.format(a1)\n            else:\n                return '{}->{}'.format(a1, a2)\n        v1 = []\n        v2 = a2 - 1\n        for v3 in range(len(a1) + 1):\n            if v3 == len(a1):\n                v4 = a3 + 1\n            else:\n                v4 = a1[v3]\n            if v4 - v2 >= 2:\n                v1.append(getRange(v2 + 1, v4 - 1))\n            v2 = v4\n        return v1\n"}
{"id": "llm_code\\final-array-state-after-k-multiplication-operations-i__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1(object):\n\n    def getFinalState(self, a1, a2, a3):\n        if a3 == 1:\n            return a1\n        v1 = len(a1)\n        v2 = [(a1[i], i) for v3 in range(v1)]\n        heapq.heapify(v2)\n        v4 = max(a1)\n        v5 = 0\n        while v5 < a2:\n            v6, v7 = v2[0]\n            if v6 * a3 > v4:\n                break\n            heapq.heappop(v2)\n            heapq.heappush(v2, (v6 * a3, v7))\n            v5 += 1\n        v8 = a2 - v5\n        v9 = []\n        while v2:\n            v9.append(heapq.heappop(v2))\n        v10, v11 = divmod(v8, v1)\n        v12 = pow(a3, v10)\n        v13 = [0] * v1\n        for v14 in range(v1):\n            v15, v7 = v9[v14]\n            v16 = a3 if v14 < v11 else 1\n            v13[v7] = v15 * v12 * v16\n        return v13\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def getFinalState(self, a1, a2, a3):\n        if a3 == 1:\n            return a1\n        v1 = len(a1)\n        v2 = [(a1[i], i) for v3 in range(v1)]\n        heapq.heapify(v2)\n        v4 = max(a1)\n        v5 = 0\n        while v5 < a2:\n            v6, v7 = v2[0]\n            if v6 * a3 > v4:\n                break\n            heapq.heappop(v2)\n            heapq.heappush(v2, (v6 * a3, v7))\n            v5 += 1\n        v8 = a2 - v5\n        v9 = []\n        while v2:\n            v9.append(heapq.heappop(v2))\n        v10, v11 = divmod(v8, v1)\n        v12 = pow(a3, v10)\n        v13 = [0] * v1\n        for v14 in range(v1):\n            v15, v7 = v9[v14]\n            v16 = a3 if v14 < v11 else 1\n            v13[v7] = v15 * v12 * v16\n        return v13\n"}
{"id": "human_code\\p02632__s902963293.py", "text": "v1 = int(input())\nv2 = input()\nv3 = len(v2)\nv4 = 10 ** 9 + 7\nv5 = 10 ** 7\nv6 = [1]\nv7 = [0] * (v5 + 4)\nfor v8 in range(v5 + 3):\n    v6.append(v6[-1] * (v8 + 1) % v4)\nv7[-1] = pow(v6[-1], v4 - 2, v4)\nfor v8 in range(v5 + 2, -1, -1):\n    v7[v8] = v7[v8 + 1] * (v8 + 1) % v4\n\ndef f1(a1, a2, a3):\n    return v6[a1] * v7[a2] % a3 * v7[a1 - a2] % a3\nv9 = 0\nfor v8 in range(v1 + 1):\n    v10 = pow(26, v8, v4) * pow(25, v1 - v8, v4) * f1(v1 + v3 - v8 - 1, v3 - 1, v4)\n    v10 %= v4\n    v9 += v10\n    v9 %= v4\nprint(v9)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = input()\nv3 = len(v2)\nv4 = 10 ** 9 + 7\nv5 = 10 ** 7\nv6 = [1]\nv7 = [0] * (v5 + 4)\nfor v8 in range(v5 + 3):\n    v6.append(v6[-1] * (v8 + 1) % v4)\nv7[-1] = pow(v6[-1], v4 - 2, v4)\nfor v8 in range(v5 + 2, -1, -1):\n    v7[v8] = v7[v8 + 1] * (v8 + 1) % v4\n\ndef f1(a1, a2, a3):\n    return v6[a1] * v7[a2] % a3 * v7[a1 - a2] % a3\nv9 = 0\nfor v8 in range(v1 + 1):\n    v10 = pow(26, v8, v4) * pow(25, v1 - v8, v4) * f1(v1 + v3 - v8 - 1, v3 - 1, v4)\n    v10 %= v4\n    v9 += v10\n    v9 %= v4\nprint(v9)\n"}
{"id": "llm_code\\make-string-anti-palindrome__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def makeAntiPalindrome(self, a1):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        if max(v2) > v1 // 2:\n            return '-1'\n        v4 = [0] * v1\n\n        def pick(a1=-1):\n            for v1 in range(26):\n                if v2[v1] > 0 and v1 != a1:\n                    return v1\n            return -1\n        for v5 in range(v1 // 2):\n            v6 = pick()\n            v4[v5] = v6\n            v2[v6] -= 1\n            v7 = pick(v6)\n            v4[v1 - 1 - v5] = v7\n            v2[v7] -= 1\n        if v1 % 2:\n            v4[v1 // 2] = pick()\n        return ''.join((chr(ord('a') + x) for v8 in v4))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def makeAntiPalindrome(self, a1):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        if max(v2) > v1 // 2:\n            return '-1'\n        v4 = [0] * v1\n\n        def pick(a1=-1):\n            for v1 in range(26):\n                if v2[v1] > 0 and v1 != a1:\n                    return v1\n            return -1\n        for v5 in range(v1 // 2):\n            v6 = pick()\n            v4[v5] = v6\n            v2[v6] -= 1\n            v7 = pick(v6)\n            v4[v1 - 1 - v5] = v7\n            v2[v7] -= 1\n        if v1 % 2:\n            v4[v1 // 2] = pick()\n        return ''.join((chr(ord('a') + x) for v8 in v4))\n"}
{"id": "llm_code\\p03326__s297838782.py", "text": "v1, v2 = map(int, input().split())\nv3 = [list(map(int, input().split())) for v4 in range(v1)]\nif v2 == 0:\n    print(0)\n    exit()\nv3 = sorted(v3, key=lambda x: abs(x[0]), reverse=True)\nv5 = [[{'S': 0, 'L': [0, 0, 0]} for v6 in range(v1)] for v4 in range(v2 + 1)]\nv5[1][0]['L'] = v3[0]\nv5[1][0]['S'] = abs(v3[0][0]) + abs(v3[0][1]) + abs(v3[0][2])\nfor v7 in range(1, v1):\n    for v8 in range(1, min(v7 + 2, v2 + 1)):\n        v9 = v5[v8 - 1][v7 - 1]['L']\n        v9 = [v9[0] + v3[v7][0], v9[1] + v3[v7][1], v9[2] + v3[v7][2]]\n        v10 = abs(v9[0]) + abs(v9[1]) + abs(v9[2])\n        if v5[v8][v7 - 1]['S'] < v10:\n            v5[v8][v7]['S'] = v10\n            v5[v8][v7]['L'] = v9\n        else:\n            v5[v8][v7]['S'] = v5[v8][v7 - 1]['S']\n            v5[v8][v7]['L'] = v5[v8][v7 - 1]['L']\nv11 = v5[v2][v1 - 1]['S']\nv3 = sorted(v3, key=lambda x: abs(x[1]), reverse=True)\nv5 = [[{'S': 0, 'L': [0, 0, 0]} for v6 in range(v1)] for v4 in range(v2 + 1)]\nv5[1][0]['L'] = v3[0]\nv5[1][0]['S'] = abs(v3[0][0]) + abs(v3[0][1]) + abs(v3[0][2])\nfor v7 in range(1, v1):\n    for v8 in range(1, min(v7 + 2, v2 + 1)):\n        v9 = v5[v8 - 1][v7 - 1]['L']\n        v9 = [v9[0] + v3[v7][0], v9[1] + v3[v7][1], v9[2] + v3[v7][2]]\n        v10 = abs(v9[0]) + abs(v9[1]) + abs(v9[2])\n        if v5[v8][v7 - 1]['S'] < v10:\n            v5[v8][v7]['S'] = v10\n            v5[v8][v7]['L'] = v9\n        else:\n            v5[v8][v7]['S'] = v5[v8][v7 - 1]['S']\n            v5[v8][v7]['L'] = v5[v8][v7 - 1]['L']\nv11 = max(v5[v2][v1 - 1]['S'], v11)\nv3 = sorted(v3, key=lambda x: abs(x[2]), reverse=True)\nv5 = [[{'S': 0, 'L': [0, 0, 0]} for v6 in range(v1)] for v4 in range(v2 + 1)]\nv5[1][0]['L'] = v3[0]\nv5[1][0]['S'] = abs(v3[0][0]) + abs(v3[0][1]) + abs(v3[0][2])\nfor v7 in range(1, v1):\n    for v8 in range(1, min(v7 + 2, v2 + 1)):\n        v9 = v5[v8 - 1][v7 - 1]['L']\n        v9 = [v9[0] + v3[v7][0], v9[1] + v3[v7][1], v9[2] + v3[v7][2]]\n        v10 = abs(v9[0]) + abs(v9[1]) + abs(v9[2])\n        if v5[v8][v7 - 1]['S'] < v10:\n            v5[v8][v7]['S'] = v10\n            v5[v8][v7]['L'] = v9\n        else:\n            v5[v8][v7]['S'] = v5[v8][v7 - 1]['S']\n            v5[v8][v7]['L'] = v5[v8][v7 - 1]['L']\nv11 = max(v5[v2][v1 - 1]['S'], v11)\nprint(v11)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = [list(map(int, input().split())) for v4 in range(v1)]\nif v2 == 0:\n    print(0)\n    exit()\nv3 = sorted(v3, key=lambda x: abs(x[0]), reverse=True)\nv5 = [[{'S': 0, 'L': [0, 0, 0]} for v6 in range(v1)] for v4 in range(v2 + 1)]\nv5[1][0]['L'] = v3[0]\nv5[1][0]['S'] = abs(v3[0][0]) + abs(v3[0][1]) + abs(v3[0][2])\nfor v7 in range(1, v1):\n    for v8 in range(1, min(v7 + 2, v2 + 1)):\n        v9 = v5[v8 - 1][v7 - 1]['L']\n        v9 = [v9[0] + v3[v7][0], v9[1] + v3[v7][1], v9[2] + v3[v7][2]]\n        v10 = abs(v9[0]) + abs(v9[1]) + abs(v9[2])\n        if v5[v8][v7 - 1]['S'] < v10:\n            v5[v8][v7]['S'] = v10\n            v5[v8][v7]['L'] = v9\n        else:\n            v5[v8][v7]['S'] = v5[v8][v7 - 1]['S']\n            v5[v8][v7]['L'] = v5[v8][v7 - 1]['L']\nv11 = v5[v2][v1 - 1]['S']\nv3 = sorted(v3, key=lambda x: abs(x[1]), reverse=True)\nv5 = [[{'S': 0, 'L': [0, 0, 0]} for v6 in range(v1)] for v4 in range(v2 + 1)]\nv5[1][0]['L'] = v3[0]\nv5[1][0]['S'] = abs(v3[0][0]) + abs(v3[0][1]) + abs(v3[0][2])\nfor v7 in range(1, v1):\n    for v8 in range(1, min(v7 + 2, v2 + 1)):\n        v9 = v5[v8 - 1][v7 - 1]['L']\n        v9 = [v9[0] + v3[v7][0], v9[1] + v3[v7][1], v9[2] + v3[v7][2]]\n        v10 = abs(v9[0]) + abs(v9[1]) + abs(v9[2])\n        if v5[v8][v7 - 1]['S'] < v10:\n            v5[v8][v7]['S'] = v10\n            v5[v8][v7]['L'] = v9\n        else:\n            v5[v8][v7]['S'] = v5[v8][v7 - 1]['S']\n            v5[v8][v7]['L'] = v5[v8][v7 - 1]['L']\nv11 = max(v5[v2][v1 - 1]['S'], v11)\nv3 = sorted(v3, key=lambda x: abs(x[2]), reverse=True)\nv5 = [[{'S': 0, 'L': [0, 0, 0]} for v6 in range(v1)] for v4 in range(v2 + 1)]\nv5[1][0]['L'] = v3[0]\nv5[1][0]['S'] = abs(v3[0][0]) + abs(v3[0][1]) + abs(v3[0][2])\nfor v7 in range(1, v1):\n    for v8 in range(1, min(v7 + 2, v2 + 1)):\n        v9 = v5[v8 - 1][v7 - 1]['L']\n        v9 = [v9[0] + v3[v7][0], v9[1] + v3[v7][1], v9[2] + v3[v7][2]]\n        v10 = abs(v9[0]) + abs(v9[1]) + abs(v9[2])\n        if v5[v8][v7 - 1]['S'] < v10:\n            v5[v8][v7]['S'] = v10\n            v5[v8][v7]['L'] = v9\n        else:\n            v5[v8][v7]['S'] = v5[v8][v7 - 1]['S']\n            v5[v8][v7]['L'] = v5[v8][v7 - 1]['L']\nv11 = max(v5[v2][v1 - 1]['S'], v11)\nprint(v11)\n"}
{"id": "human_code\\k-similar-strings.py", "text": "import collections\n\nclass C1(object):\n\n    def kSimilarity(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def neighbors(a1, a2):\n            for v1, v2 in enumerate(a1):\n                if v2 != a2[v1]:\n                    break\n            v3 = list(a1)\n            for v4 in range(v1 + 1, len(a1)):\n                if v3[v4] == a2[v1]:\n                    v3[v1], v3[v4] = (v3[v4], v3[v1])\n                    yield ''.join(v3)\n                    v3[v4], v3[v1] = (v3[v1], v3[v4])\n        v1 = collections.deque([a1])\n        v2 = set()\n        v3 = 0\n        while v1:\n            for v4 in range(len(v1)):\n                v5 = v1.popleft()\n                if v5 == a2:\n                    return v3\n                for v6 in neighbors(v5, a2):\n                    if v6 not in v2:\n                        v2.add(v6)\n                        v1.append(v6)\n            v3 += 1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def kSimilarity(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def neighbors(a1, a2):\n            for v1, v2 in enumerate(a1):\n                if v2 != a2[v1]:\n                    break\n            v3 = list(a1)\n            for v4 in range(v1 + 1, len(a1)):\n                if v3[v4] == a2[v1]:\n                    v3[v1], v3[v4] = (v3[v4], v3[v1])\n                    yield ''.join(v3)\n                    v3[v4], v3[v1] = (v3[v1], v3[v4])\n        v1 = collections.deque([a1])\n        v2 = set()\n        v3 = 0\n        while v1:\n            for v4 in range(len(v1)):\n                v5 = v1.popleft()\n                if v5 == a2:\n                    return v3\n                for v6 in neighbors(v5, a2):\n                    if v6 not in v2:\n                        v2.add(v6)\n                        v1.append(v6)\n            v3 += 1\n"}
{"id": "llm_code\\maximum-coins-from-k-consecutive-bags__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumCoins(self, a1, a2):\n\n        def get_max(a1):\n            a1 = sorted(a1)\n            v2 = len(a1)\n            v3 = [0] * (v2 + 1)\n            for v4 in range(v2):\n                v5 = a1[v4][1] - a1[v4][0] + 1\n                v3[v4 + 1] = v3[v4] + v5 * a1[v4][2]\n            v6 = 0\n            v7 = 0\n            for v8 in range(v2):\n                while a1[v8][1] - a1[v7][1] + 1 > a2:\n                    v7 += 1\n                v9 = v3[v8 + 1] - v3[v7]\n                v10 = a1[v8][1] - a1[v7][0] + 1\n                v11 = max(v10 - a2, 0) * a1[v7][2]\n                v6 = max(v6, v9 - v11)\n            return v6\n        v1 = get_max(a1)\n        v2 = [[-x[1], -x[0], x[2]] for v3 in a1]\n        v1 = max(v1, get_max(v2))\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumCoins(self, a1, a2):\n\n        def get_max(a1):\n            a1 = sorted(a1)\n            v2 = len(a1)\n            v3 = [0] * (v2 + 1)\n            for v4 in range(v2):\n                v5 = a1[v4][1] - a1[v4][0] + 1\n                v3[v4 + 1] = v3[v4] + v5 * a1[v4][2]\n            v6 = 0\n            v7 = 0\n            for v8 in range(v2):\n                while a1[v8][1] - a1[v7][1] + 1 > a2:\n                    v7 += 1\n                v9 = v3[v8 + 1] - v3[v7]\n                v10 = a1[v8][1] - a1[v7][0] + 1\n                v11 = max(v10 - a2, 0) * a1[v7][2]\n                v6 = max(v6, v9 - v11)\n            return v6\n        v1 = get_max(a1)\n        v2 = [[-x[1], -x[0], x[2]] for v3 in a1]\n        v1 = max(v1, get_max(v2))\n        return v1\n"}
{"id": "human_code\\smallest-string-with-swaps__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[max(v1, v2)] = min(v1, v2)\n        return True\n\nclass C2(object):\n\n    def smallestStringWithSwaps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = C1(len(a1))\n        for v2, v3 in a2:\n            v1.union_set(v2, v3)\n        v4 = collections.defaultdict(list)\n        for v5 in range(len(a1)):\n            v4[v1.find_set(v5)].append(a1[v5])\n        for v5 in v4.keys():\n            v4[v5].sort(reverse=True)\n        v6 = []\n        for v5 in range(len(a1)):\n            v6.append(v4[v1.find_set(v5)].pop())\n        return ''.join(v6)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[max(v1, v2)] = min(v1, v2)\n        return True\n\nclass C2(object):\n\n    def smallestStringWithSwaps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = C1(len(a1))\n        for v2, v3 in a2:\n            v1.union_set(v2, v3)\n        v4 = collections.defaultdict(list)\n        for v5 in range(len(a1)):\n            v4[v1.find_set(v5)].append(a1[v5])\n        for v5 in v4.keys():\n            v4[v5].sort(reverse=True)\n        v6 = []\n        for v5 in range(len(a1)):\n            v6.append(v4[v1.find_set(v5)].pop())\n        return ''.join(v6)\n"}
{"id": "llm_code\\maximum-number-of-groups-getting-fresh-donuts__grok-4.1-fast__v1.py", "text": "from functools import lru_cache\nfrom typing import List\n\nclass C1:\n\n    def maxHappyGroups(self, a1: int, a2: List[int]) -> int:\n        v1 = [0] * a1\n        for v2 in a2:\n            v1[v2 % a1] += 1\n        v3 = v1[0]\n        v1[0] = 0\n        for v4 in range(1, a1 // 2 + 1):\n            v5 = a1 - v4\n            v6 = v1[v4] // 2 if v4 == v5 else min(v1[v4], v1[v5])\n            v3 += v6\n            v1[v4] -= v6\n            if v4 != v5:\n                v1[v5] -= v6\n        v7 = [r for v8 in range(1, a1) if v1[v8]]\n        if not v7:\n            return v3\n        v9 = tuple((v1[v8] for v8 in v7))\n\n        @lru_cache(maxsize=None)\n        def rec(a1: int, a2: tuple) -> int:\n            if not any(a2):\n                return 0\n            v1 = 0\n            for v2, v3 in enumerate(v7):\n                if a2[v2]:\n                    v4 = (a1 - v3) % a1\n                    v5 = list(a2)\n                    v5[v2] -= 1\n                    v6 = 1 if v4 == 0 else 0\n                    v1 = max(v1, v6 + rec(v4, tuple(v5)))\n            return v1\n        return v3 + rec(0, v9)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from functools import lru_cache\nfrom typing import List\n\nclass C1:\n\n    def maxHappyGroups(self, a1: int, a2: List[int]) -> int:\n        v1 = [0] * a1\n        for v2 in a2:\n            v1[v2 % a1] += 1\n        v3 = v1[0]\n        v1[0] = 0\n        for v4 in range(1, a1 // 2 + 1):\n            v5 = a1 - v4\n            v6 = v1[v4] // 2 if v4 == v5 else min(v1[v4], v1[v5])\n            v3 += v6\n            v1[v4] -= v6\n            if v4 != v5:\n                v1[v5] -= v6\n        v7 = [r for v8 in range(1, a1) if v1[v8]]\n        if not v7:\n            return v3\n        v9 = tuple((v1[v8] for v8 in v7))\n\n        @lru_cache(maxsize=None)\n        def rec(a1: int, a2: tuple) -> int:\n            if not any(a2):\n                return 0\n            v1 = 0\n            for v2, v3 in enumerate(v7):\n                if a2[v2]:\n                    v4 = (a1 - v3) % a1\n                    v5 = list(a2)\n                    v5[v2] -= 1\n                    v6 = 1 if v4 == 0 else 0\n                    v1 = max(v1, v6 + rec(v4, tuple(v5)))\n            return v1\n        return v3 + rec(0, v9)\n"}
{"id": "llm_code\\p03147__s175922160.py", "text": "v1 = [0] * n\n\ndef f1(a1, a2, a3):\n    for v1 in range(a1):\n        if a3[v1] < a2[v1]:\n            v2 = v1\n            break\n        elif v1 == a1 - 1 and a3[v1] < a2[v1]:\n            v2 = v1\n        else:\n            v2 = v1 + 1\n    for v3 in range(v2, a1):\n        if a3[v3] == a2[v3]:\n            v4 = v3 - 1\n            break\n        elif v3 == a1 - 1:\n            v4 = v3\n    for v5 in range(v2, v4 + 1):\n        a3[v5] += 1\nv2 = 0\nwhile v1 != h:\n    for v3 in range(n):\n        if v1[v3] < h[v3]:\n            v2 += 1\n            f1(n, h, v1)\n            break\nprint(v2)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = [0] * n\n\ndef f1(a1, a2, a3):\n    for v1 in range(a1):\n        if a3[v1] < a2[v1]:\n            v2 = v1\n            break\n        elif v1 == a1 - 1 and a3[v1] < a2[v1]:\n            v2 = v1\n        else:\n            v2 = v1 + 1\n    for v3 in range(v2, a1):\n        if a3[v3] == a2[v3]:\n            v4 = v3 - 1\n            break\n        elif v3 == a1 - 1:\n            v4 = v3\n    for v5 in range(v2, v4 + 1):\n        a3[v5] += 1\nv2 = 0\nwhile v1 != h:\n    for v3 in range(n):\n        if v1[v3] < h[v3]:\n            v2 += 1\n            f1(n, h, v1)\n            break\nprint(v2)\n"}
{"id": "human_code\\paint-house-ii__part2.py", "text": "from functools import reduce\n\nclass C1(object):\n\n    def minCostII(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [a1[0], [0] * v2]\n        for v4 in range(1, v1):\n            v5, v6 = (float('inf'), float('inf'))\n            for v7 in range(v2):\n                if v3[(v4 - 1) % 2][v7] < v5:\n                    v5, v6 = (v3[(v4 - 1) % 2][v7], v5)\n                elif v3[(v4 - 1) % 2][v7] < v6:\n                    v6 = v3[(v4 - 1) % 2][v7]\n            for v7 in range(v2):\n                v8 = v5 if v3[(v4 - 1) % 2][v7] != v5 else v6\n                v3[v4 % 2][v7] = a1[v4][v7] + v8\n        return min(v3[(v1 - 1) % 2])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from functools import reduce\n\nclass C1(object):\n\n    def minCostII(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [a1[0], [0] * v2]\n        for v4 in range(1, v1):\n            v5, v6 = (float('inf'), float('inf'))\n            for v7 in range(v2):\n                if v3[(v4 - 1) % 2][v7] < v5:\n                    v5, v6 = (v3[(v4 - 1) % 2][v7], v5)\n                elif v3[(v4 - 1) % 2][v7] < v6:\n                    v6 = v3[(v4 - 1) % 2][v7]\n            for v7 in range(v2):\n                v8 = v5 if v3[(v4 - 1) % 2][v7] != v5 else v6\n                v3[v4 % 2][v7] = a1[v4][v7] + v8\n        return min(v3[(v1 - 1) % 2])\n"}
{"id": "llm_code\\maximum-of-minimum-values-in-all-subarrays__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def findMaximums(self, a1):\n        v1 = len(a1)\n        v2 = [-1] * v1\n        v3 = []\n        for v4 in range(v1):\n            while v3 and a1[v3[-1]] >= a1[v4]:\n                v3.pop()\n            if v3:\n                v2[v4] = v3[-1]\n            v3.append(v4)\n        v5 = [v1] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            while v3 and a1[v3[-1]] >= a1[v4]:\n                v3.pop()\n            if v3:\n                v5[v4] = v3[-1]\n            v3.append(v4)\n        v6 = [-1] * v1\n        for v4 in range(v1):\n            v7 = v5[v4] - v2[v4] - 1\n            v8 = v7 - 1\n            v6[v8] = max(v6[v8], a1[v4])\n        for v4 in range(v1 - 2, -1, -1):\n            v6[v4] = max(v6[v4], v6[v4 + 1])\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findMaximums(self, a1):\n        v1 = len(a1)\n        v2 = [-1] * v1\n        v3 = []\n        for v4 in range(v1):\n            while v3 and a1[v3[-1]] >= a1[v4]:\n                v3.pop()\n            if v3:\n                v2[v4] = v3[-1]\n            v3.append(v4)\n        v5 = [v1] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            while v3 and a1[v3[-1]] >= a1[v4]:\n                v3.pop()\n            if v3:\n                v5[v4] = v3[-1]\n            v3.append(v4)\n        v6 = [-1] * v1\n        for v4 in range(v1):\n            v7 = v5[v4] - v2[v4] - 1\n            v8 = v7 - 1\n            v6[v8] = max(v6[v8], a1[v4])\n        for v4 in range(v1 - 2, -1, -1):\n            v6[v4] = max(v6[v4], v6[v4 + 1])\n        return v6\n"}
{"id": "llm_code\\count-ways-to-build-rooms-in-an-ant-colony__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def waysToBuildRooms(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = [[] for v4 in range(v2)]\n        for v5 in range(1, v2):\n            v3[a1[v5]].append(v5)\n        v6 = [1] * (v2 + 1)\n        for v5 in range(1, v2 + 1):\n            v6[v5] = v6[v5 - 1] * v5 % v1\n        v7 = [0] * (v2 + 1)\n        v7[v2] = pow(v6[v2], v1 - 2, v1)\n        for v5 in range(v2 - 1, -1, -1):\n            v7[v5] = v7[v5 + 1] * (v5 + 1) % v1\n\n        def comb(a1, a2):\n            if a2 < 0 or a2 > a1:\n                return 0\n            return v6[a1] * v7[a2] % v1 * v7[a1 - a2] % v1\n\n        def traverse(a1):\n            v1 = 1\n            v2 = 0\n            v3 = 1\n            for v4 in v3[a1]:\n                v5, v6 = traverse(v4)\n                v1 = v1 * v5 % v1\n                v7 = comb(v2 + v6, v6)\n                v1 = v1 * v7 % v1\n                v2 += v6\n                v3 += v6\n            return (v1, v3)\n        return traverse(0)[0]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def waysToBuildRooms(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = [[] for v4 in range(v2)]\n        for v5 in range(1, v2):\n            v3[a1[v5]].append(v5)\n        v6 = [1] * (v2 + 1)\n        for v5 in range(1, v2 + 1):\n            v6[v5] = v6[v5 - 1] * v5 % v1\n        v7 = [0] * (v2 + 1)\n        v7[v2] = pow(v6[v2], v1 - 2, v1)\n        for v5 in range(v2 - 1, -1, -1):\n            v7[v5] = v7[v5 + 1] * (v5 + 1) % v1\n\n        def comb(a1, a2):\n            if a2 < 0 or a2 > a1:\n                return 0\n            return v6[a1] * v7[a2] % v1 * v7[a1 - a2] % v1\n\n        def traverse(a1):\n            v1 = 1\n            v2 = 0\n            v3 = 1\n            for v4 in v3[a1]:\n                v5, v6 = traverse(v4)\n                v1 = v1 * v5 % v1\n                v7 = comb(v2 + v6, v6)\n                v1 = v1 * v7 % v1\n                v2 += v6\n                v3 += v6\n            return (v1, v3)\n        return traverse(0)[0]\n"}
{"id": "human_code\\zuma-game__part3.py", "text": "import collections\n\nclass C1(object):\n\n    def findMinStep(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def shrink(a1):\n            v1 = []\n            v2 = 0\n            for v3 in range(len(a1) + 1):\n                if v3 == len(a1) or a1[v3] != a1[v2]:\n                    if v1 and v1[-1][0] == a1[v2]:\n                        v1[-1][1] += v3 - v2\n                        if v1[-1][1] >= 3:\n                            v1.pop()\n                    elif a1 and v3 - v2 < 3:\n                        v1 += ([a1[v2], v3 - v2],)\n                    v2 = v3\n            v4 = []\n            for v5 in v1:\n                v4 += [v5[0]] * v5[1]\n            return v4\n\n        def findMinStepHelper2(a1, a2, a3):\n            v1 = float('inf')\n            for v2 in range(len(a2)):\n                for v3 in range(len(a1) + 1):\n                    v4 = shrink(a1[0:v3] + a2[v2:v2 + 1] + a1[v3:])\n                    v5 = a2[0:v2] + a2[v2 + 1:]\n                    v1 = min(v1, findMinStepHelper(v4, v5, a3) + 1)\n            return v1\n\n        def find(a1, a2, a3):\n            for v1 in range(a3, len(a1)):\n                if a1[v1] == a2:\n                    return v1\n            return -1\n\n        def findMinStepHelper(a1, a2, a3):\n            if not a1:\n                return 0\n            if not a2:\n                return float('inf')\n            if tuple(a2) in a3[tuple(a1)]:\n                return a3[tuple(a1)][tuple(a2)]\n            v1 = float('inf')\n            for v2 in range(len(a2)):\n                v3 = 0\n                while v3 < len(a1):\n                    v4 = find(a1, a2[v2], v3)\n                    if v4 == -1:\n                        break\n                    if v4 < len(a1) - 1 and a1[v4] == a1[v4 + 1]:\n                        v5 = shrink(a1[0:v4] + a1[v4 + 2:])\n                        v6 = a2[0:v2] + a2[v2 + 1:]\n                        v1 = min(v1, findMinStepHelper(v5, v6, a3) + 1)\n                        v4 += 1\n                    elif v2 > 0 and a2[v2] == a2[v2 - 1]:\n                        v5 = shrink(a1[0:v4] + a1[v4 + 1:])\n                        v6 = a2[0:v2 - 1] + a2[v2 + 1:]\n                        v1 = min(v1, findMinStepHelper(v5, v6, a3) + 2)\n                    v3 = v4 + 1\n            a3[tuple(a1)][tuple(a2)] = v1\n            return v1\n        a1, a2 = (list(a1), list(a2))\n        a2.sort()\n        v3 = findMinStepHelper(a1, a2, collections.defaultdict(dict))\n        if v3 == float('inf'):\n            v3 = findMinStepHelper2(a1, a2, collections.defaultdict(dict))\n        return -1 if v3 == float('inf') else v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def findMinStep(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def shrink(a1):\n            v1 = []\n            v2 = 0\n            for v3 in range(len(a1) + 1):\n                if v3 == len(a1) or a1[v3] != a1[v2]:\n                    if v1 and v1[-1][0] == a1[v2]:\n                        v1[-1][1] += v3 - v2\n                        if v1[-1][1] >= 3:\n                            v1.pop()\n                    elif a1 and v3 - v2 < 3:\n                        v1 += ([a1[v2], v3 - v2],)\n                    v2 = v3\n            v4 = []\n            for v5 in v1:\n                v4 += [v5[0]] * v5[1]\n            return v4\n\n        def findMinStepHelper2(a1, a2, a3):\n            v1 = float('inf')\n            for v2 in range(len(a2)):\n                for v3 in range(len(a1) + 1):\n                    v4 = shrink(a1[0:v3] + a2[v2:v2 + 1] + a1[v3:])\n                    v5 = a2[0:v2] + a2[v2 + 1:]\n                    v1 = min(v1, findMinStepHelper(v4, v5, a3) + 1)\n            return v1\n\n        def find(a1, a2, a3):\n            for v1 in range(a3, len(a1)):\n                if a1[v1] == a2:\n                    return v1\n            return -1\n\n        def findMinStepHelper(a1, a2, a3):\n            if not a1:\n                return 0\n            if not a2:\n                return float('inf')\n            if tuple(a2) in a3[tuple(a1)]:\n                return a3[tuple(a1)][tuple(a2)]\n            v1 = float('inf')\n            for v2 in range(len(a2)):\n                v3 = 0\n                while v3 < len(a1):\n                    v4 = find(a1, a2[v2], v3)\n                    if v4 == -1:\n                        break\n                    if v4 < len(a1) - 1 and a1[v4] == a1[v4 + 1]:\n                        v5 = shrink(a1[0:v4] + a1[v4 + 2:])\n                        v6 = a2[0:v2] + a2[v2 + 1:]\n                        v1 = min(v1, findMinStepHelper(v5, v6, a3) + 1)\n                        v4 += 1\n                    elif v2 > 0 and a2[v2] == a2[v2 - 1]:\n                        v5 = shrink(a1[0:v4] + a1[v4 + 1:])\n                        v6 = a2[0:v2 - 1] + a2[v2 + 1:]\n                        v1 = min(v1, findMinStepHelper(v5, v6, a3) + 2)\n                    v3 = v4 + 1\n            a3[tuple(a1)][tuple(a2)] = v1\n            return v1\n        a1, a2 = (list(a1), list(a2))\n        a2.sort()\n        v3 = findMinStepHelper(a1, a2, collections.defaultdict(dict))\n        if v3 == float('inf'):\n            v3 = findMinStepHelper2(a1, a2, collections.defaultdict(dict))\n        return -1 if v3 == float('inf') else v3\n"}
{"id": "human_code\\word-pattern__part1.py", "text": "class C1(object):\n\n    def wordPattern(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if len(a1) != self.wordCount(a2):\n            return False\n        v1, v2 = ({}, {})\n        for v3, v4 in zip(a1, self.wordGenerator(a2)):\n            if v4 not in v1 and v3 not in v2:\n                v1[v4] = v3\n                v2[v3] = v4\n            elif v4 not in v1 or v1[v4] != v3:\n                return False\n        return True\n\n    def wordCount(self, a1):\n        v1 = 1 if a1 else 0\n        for v2 in a1:\n            if v2 == ' ':\n                v1 += 1\n        return v1\n\n    def wordGenerator(self, a1):\n        v1 = ''\n        for v2 in a1:\n            if v2 == ' ':\n                yield v1\n                v1 = ''\n            else:\n                v1 += v2\n        yield v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def wordPattern(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if len(a1) != self.wordCount(a2):\n            return False\n        v1, v2 = ({}, {})\n        for v3, v4 in zip(a1, self.wordGenerator(a2)):\n            if v4 not in v1 and v3 not in v2:\n                v1[v4] = v3\n                v2[v3] = v4\n            elif v4 not in v1 or v1[v4] != v3:\n                return False\n        return True\n\n    def wordCount(self, a1):\n        v1 = 1 if a1 else 0\n        for v2 in a1:\n            if v2 == ' ':\n                v1 += 1\n        return v1\n\n    def wordGenerator(self, a1):\n        v1 = ''\n        for v2 in a1:\n            if v2 == ' ':\n                yield v1\n                v1 = ''\n            else:\n                v1 += v2\n        yield v1\n"}
{"id": "human_code\\closest-node-to-path-in-tree__part3.py", "text": "from functools import partial\n\nclass C1(object):\n\n    def __init__(self, a1):\n\n        def preprocess(a1, a2):\n            D[a1] = 1 if a2 == -1 else D[a2] + 1\n            P[a1] = a2\n\n        def divide(a1, a2):\n            for v1 in reversed(range(len(a1[a1]))):\n                v2 = a1[a1][v1]\n                if v2 == a2:\n                    continue\n                stk.append(partial(divide, v2, a1))\n            stk.append(partial(preprocess, a1, a2))\n        v1 = len(a1)\n        v2, v3 = ([0] * v1, [0] * v1)\n        v4 = []\n        v4.append(partial(divide, 0, -1))\n        while v4:\n            v4.pop()()\n        self.D, self.P = (v2, v3)\n\n    def lca(self, a1, a2):\n        while self.D[a1] > self.D[a2]:\n            a1 = self.P[a1]\n        while self.D[a1] < self.D[a2]:\n            a2 = self.P[a2]\n        while a1 != a2:\n            a1, a2 = (self.P[a1], self.P[a2])\n        return a1\n\nclass C2(object):\n\n    def closestNode(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            (v1[v3].append(v4), v1[v4].append(v3))\n        v5 = C1(v1)\n        return [max((v5.lca(x, y) for v6, v7 in ((start, end), (start, node), (end, node))), key=lambda x: v5.D[v6]) for v8, v9, v10 in a3]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from functools import partial\n\nclass C1(object):\n\n    def __init__(self, a1):\n\n        def preprocess(a1, a2):\n            D[a1] = 1 if a2 == -1 else D[a2] + 1\n            P[a1] = a2\n\n        def divide(a1, a2):\n            for v1 in reversed(range(len(a1[a1]))):\n                v2 = a1[a1][v1]\n                if v2 == a2:\n                    continue\n                stk.append(partial(divide, v2, a1))\n            stk.append(partial(preprocess, a1, a2))\n        v1 = len(a1)\n        v2, v3 = ([0] * v1, [0] * v1)\n        v4 = []\n        v4.append(partial(divide, 0, -1))\n        while v4:\n            v4.pop()()\n        self.D, self.P = (v2, v3)\n\n    def lca(self, a1, a2):\n        while self.D[a1] > self.D[a2]:\n            a1 = self.P[a1]\n        while self.D[a1] < self.D[a2]:\n            a2 = self.P[a2]\n        while a1 != a2:\n            a1, a2 = (self.P[a1], self.P[a2])\n        return a1\n\nclass C2(object):\n\n    def closestNode(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            (v1[v3].append(v4), v1[v4].append(v3))\n        v5 = C1(v1)\n        return [max((v5.lca(x, y) for v6, v7 in ((start, end), (start, node), (end, node))), key=lambda x: v5.D[v6]) for v8, v9, v10 in a3]\n"}
{"id": "llm_code\\maximum-xor-with-an-element-from-array__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.bits = a1\n        self.nodes = [[-1, -1]]\n        self.next_node = 1\n\n    def add(self, a1):\n        v1 = 0\n        for v2 in range(self.bits - 1, -1, -1):\n            v3 = a1 >> v2 & 1\n            if self.nodes[v1][v3] == -1:\n                self.nodes[v1][v3] = self.next_node\n                self.nodes.append([-1, -1])\n                self.next_node += 1\n            v1 = self.nodes[v1][v3]\n\n    def find_max_xor(self, a1):\n        if self.nodes[0][0] == -1 and self.nodes[0][1] == -1:\n            return -1\n        v1 = 0\n        v2 = 0\n        for v3 in range(self.bits - 1, -1, -1):\n            v4 = a1 >> v3 & 1\n            v5 = 1 - v4\n            if self.nodes[v1][v5] != -1:\n                v2 |= 1 << v3\n                v1 = self.nodes[v1][v5]\n            else:\n                v1 = self.nodes[v1][v4]\n        return v2\n\nclass C2:\n\n    def maximizeXor(self, a1, a2):\n        a1.sort()\n        if not a1:\n            return [-1] * len(a2)\n        v1 = max(a1[-1], max((q[0] for v2 in a2)))\n        v3 = v1.bit_length()\n        v4 = sorted(enumerate(a2), key=lambda e: e[1][1])\n        v5 = C1(v3)\n        v6 = [-1] * len(a2)\n        v7 = 0\n        for v8, (v9, v10) in v4:\n            while v7 < len(a1) and a1[v7] <= v10:\n                v5.add(a1[v7])\n                v7 += 1\n            v6[v8] = v5.find_max_xor(v9)\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.bits = a1\n        self.nodes = [[-1, -1]]\n        self.next_node = 1\n\n    def add(self, a1):\n        v1 = 0\n        for v2 in range(self.bits - 1, -1, -1):\n            v3 = a1 >> v2 & 1\n            if self.nodes[v1][v3] == -1:\n                self.nodes[v1][v3] = self.next_node\n                self.nodes.append([-1, -1])\n                self.next_node += 1\n            v1 = self.nodes[v1][v3]\n\n    def find_max_xor(self, a1):\n        if self.nodes[0][0] == -1 and self.nodes[0][1] == -1:\n            return -1\n        v1 = 0\n        v2 = 0\n        for v3 in range(self.bits - 1, -1, -1):\n            v4 = a1 >> v3 & 1\n            v5 = 1 - v4\n            if self.nodes[v1][v5] != -1:\n                v2 |= 1 << v3\n                v1 = self.nodes[v1][v5]\n            else:\n                v1 = self.nodes[v1][v4]\n        return v2\n\nclass C2:\n\n    def maximizeXor(self, a1, a2):\n        a1.sort()\n        if not a1:\n            return [-1] * len(a2)\n        v1 = max(a1[-1], max((q[0] for v2 in a2)))\n        v3 = v1.bit_length()\n        v4 = sorted(enumerate(a2), key=lambda e: e[1][1])\n        v5 = C1(v3)\n        v6 = [-1] * len(a2)\n        v7 = 0\n        for v8, (v9, v10) in v4:\n            while v7 < len(a1) and a1[v7] <= v10:\n                v5.add(a1[v7])\n                v7 += 1\n            v6[v8] = v5.find_max_xor(v9)\n        return v6\n"}
{"id": "human_code\\maximum-xor-of-two-non-overlapping-subtrees__part2.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.__root = {}\n        self.__bit_length = a1\n\n    def insert(self, a1):\n        v1 = self.__root\n        for v2 in reversed(range(self.__bit_length)):\n            v3 = a1 >> v2 & 1\n            if v3 not in v1:\n                v1[v3] = {}\n            v1 = v1[v3]\n\n    def query(self, a1):\n        if not self.__root:\n            return -1\n        v1, v2 = (self.__root, 0)\n        for v3 in reversed(range(self.__bit_length)):\n            v4 = a1 >> v3 & 1\n            if 1 ^ v4 in v1:\n                v1 = v1[1 ^ v4]\n                v2 |= 1 << v3\n            else:\n                v1 = v1[v4]\n        return v2\n\nclass C2(object):\n\n    def maxXor(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            lookup[a1] = a3[a1] + sum((dfs(v, a1) for v1 in adj[a1] if v1 != a2))\n            return lookup[a1]\n\n        def dfs2(a1, a2):\n            v1 = max(trie.query(lookup[a1]), 0)\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 = max(v1, dfs2(v2, a1))\n            trie.insert(lookup[a1])\n            return v1\n        v1 = [[] for v2 in range(len(a3))]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * len(a3)\n        dfs(0, -1)\n        v6 = C1(v5[0].bit_length())\n        return dfs2(0, -1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.__root = {}\n        self.__bit_length = a1\n\n    def insert(self, a1):\n        v1 = self.__root\n        for v2 in reversed(range(self.__bit_length)):\n            v3 = a1 >> v2 & 1\n            if v3 not in v1:\n                v1[v3] = {}\n            v1 = v1[v3]\n\n    def query(self, a1):\n        if not self.__root:\n            return -1\n        v1, v2 = (self.__root, 0)\n        for v3 in reversed(range(self.__bit_length)):\n            v4 = a1 >> v3 & 1\n            if 1 ^ v4 in v1:\n                v1 = v1[1 ^ v4]\n                v2 |= 1 << v3\n            else:\n                v1 = v1[v4]\n        return v2\n\nclass C2(object):\n\n    def maxXor(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            lookup[a1] = a3[a1] + sum((dfs(v, a1) for v1 in adj[a1] if v1 != a2))\n            return lookup[a1]\n\n        def dfs2(a1, a2):\n            v1 = max(trie.query(lookup[a1]), 0)\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 = max(v1, dfs2(v2, a1))\n            trie.insert(lookup[a1])\n            return v1\n        v1 = [[] for v2 in range(len(a3))]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * len(a3)\n        dfs(0, -1)\n        v6 = C1(v5[0].bit_length())\n        return dfs2(0, -1)\n"}
{"id": "human_code\\path-with-minimum-effort__part5.py", "text": "class C1(object):\n\n    def minimumEffortPath(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def check(a1, a2):\n            v1 = [[False] * len(a1[0]) for v2 in range(len(a1))]\n            v3 = [(0, 0)]\n            while v3:\n                v4, v5 = v3.pop()\n                if (v4, v5) == (len(a1) - 1, len(a1[0]) - 1):\n                    return True\n                for v6, v7 in v1:\n                    v8, v9 = (v4 + v6, v5 + v7)\n                    if not (0 <= v8 < len(a1) and 0 <= v9 < len(a1[0]) and (abs(a1[v8][v9] - a1[v4][v5]) <= a2) and (not v1[v8][v9])):\n                        continue\n                    v1[v8][v9] = True\n                    v3.append((v8, v9))\n            return False\n        v2, v3 = (0, 10 ** 6)\n        while v2 <= v3:\n            v4 = v2 + (v3 - v2) // 2\n            if check(a1, v4):\n                v3 = v4 - 1\n            else:\n                v2 = v4 + 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumEffortPath(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def check(a1, a2):\n            v1 = [[False] * len(a1[0]) for v2 in range(len(a1))]\n            v3 = [(0, 0)]\n            while v3:\n                v4, v5 = v3.pop()\n                if (v4, v5) == (len(a1) - 1, len(a1[0]) - 1):\n                    return True\n                for v6, v7 in v1:\n                    v8, v9 = (v4 + v6, v5 + v7)\n                    if not (0 <= v8 < len(a1) and 0 <= v9 < len(a1[0]) and (abs(a1[v8][v9] - a1[v4][v5]) <= a2) and (not v1[v8][v9])):\n                        continue\n                    v1[v8][v9] = True\n                    v3.append((v8, v9))\n            return False\n        v2, v3 = (0, 10 ** 6)\n        while v2 <= v3:\n            v4 = v2 + (v3 - v2) // 2\n            if check(a1, v4):\n                v3 = v4 - 1\n            else:\n                v2 = v4 + 1\n        return v2\n"}
{"id": "human_code\\design-snake-game.py", "text": "from collections import deque\n\nclass C1(object):\n\n    def __init__(self, a1, a2, a3):\n        \"\"\"\n        Initialize your data structure here.\n        @param width - screen width\n        @param height - screen height\n        @param food - A list of food positions\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\n        \"\"\"\n        self.__width = a1\n        self.__height = a2\n        self.__score = 0\n        self.__f = 0\n        self.__food = a3\n        self.__snake = deque([(0, 0)])\n        self.__direction = {'U': (-1, 0), 'L': (0, -1), 'R': (0, 1), 'D': (1, 0)}\n        self.__lookup = {(0, 0)}\n\n    def move(self, a1):\n        \"\"\"\n        Moves the snake.\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n        @return The game's score after the move. Return -1 if game over.\n        Game over when snake crosses the screen boundary or bites its body.\n        \"\"\"\n\n        def valid(a1, a2):\n            return 0 <= a1 < self.__height and 0 <= a2 < self.__width and ((a1, a2) not in self.__lookup)\n        v1 = self.__direction[a1]\n        v2, v3 = (self.__snake[-1][0] + v1[0], self.__snake[-1][1] + v1[1])\n        self.__lookup.remove(self.__snake[0])\n        v4 = self.__snake.popleft()\n        if not valid(v2, v3):\n            return -1\n        elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (v2, v3):\n            self.__score += 1\n            self.__f += 1\n            self.__snake.appendleft(v4)\n            self.__lookup.add(v4)\n        self.__snake.append((v2, v3))\n        self.__lookup.add((v2, v3))\n        return self.__score\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1(object):\n\n    def __init__(self, a1, a2, a3):\n        \"\"\"\n        Initialize your data structure here.\n        @param width - screen width\n        @param height - screen height\n        @param food - A list of food positions\n        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0].\n        \"\"\"\n        self.__width = a1\n        self.__height = a2\n        self.__score = 0\n        self.__f = 0\n        self.__food = a3\n        self.__snake = deque([(0, 0)])\n        self.__direction = {'U': (-1, 0), 'L': (0, -1), 'R': (0, 1), 'D': (1, 0)}\n        self.__lookup = {(0, 0)}\n\n    def move(self, a1):\n        \"\"\"\n        Moves the snake.\n        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down\n        @return The game's score after the move. Return -1 if game over.\n        Game over when snake crosses the screen boundary or bites its body.\n        \"\"\"\n\n        def valid(a1, a2):\n            return 0 <= a1 < self.__height and 0 <= a2 < self.__width and ((a1, a2) not in self.__lookup)\n        v1 = self.__direction[a1]\n        v2, v3 = (self.__snake[-1][0] + v1[0], self.__snake[-1][1] + v1[1])\n        self.__lookup.remove(self.__snake[0])\n        v4 = self.__snake.popleft()\n        if not valid(v2, v3):\n            return -1\n        elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (v2, v3):\n            self.__score += 1\n            self.__f += 1\n            self.__snake.appendleft(v4)\n            self.__lookup.add(v4)\n        self.__snake.append((v2, v3))\n        self.__lookup.add((v2, v3))\n        return self.__score\n"}
{"id": "human_code\\smallest-string-with-swaps__part2.py", "text": "import itertools\n\nclass C1(object):\n\n    def smallestStringWithSwaps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3, a4):\n            a3.add(a1)\n            a4.append(a1)\n            for v1 in a2[a1]:\n                if v1 in a3:\n                    continue\n                dfs(v1, a2, a3, a4)\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = set()\n        v5 = list(a1)\n        for v2 in range(len(a1)):\n            if v2 in v4:\n                continue\n            v6 = []\n            dfs(v2, v1, v4, v6)\n            v6.sort()\n            v7 = sorted((v5[k] for v8 in v6))\n            for v9, v10 in zip(v6, v7):\n                v5[v9] = v10\n        return ''.join(v5)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\n\nclass C1(object):\n\n    def smallestStringWithSwaps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3, a4):\n            a3.add(a1)\n            a4.append(a1)\n            for v1 in a2[a1]:\n                if v1 in a3:\n                    continue\n                dfs(v1, a2, a3, a4)\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = set()\n        v5 = list(a1)\n        for v2 in range(len(a1)):\n            if v2 in v4:\n                continue\n            v6 = []\n            dfs(v2, v1, v4, v6)\n            v6.sort()\n            v7 = sorted((v5[k] for v8 in v6))\n            for v9, v10 in zip(v6, v7):\n                v5[v9] = v10\n        return ''.join(v5)\n"}
{"id": "human_code\\online-majority-element-in-subarray__part3.py", "text": "import functools\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        v1 = len(a1)\n        self.__original_length = v1\n        self.__tree_length = 2 ** (v1.bit_length() + (v1 & v1 - 1 != 0)) - 1\n        self.__tree = [-1 for v2 in range(self.__tree_length)]\n        self.__count = a2\n        self.__constructTree(a1, 0, self.__original_length - 1, 0)\n\n    def query(self, a1, a2):\n        return self.__queryRange(a1, a2, 0, self.__original_length - 1, 0)\n\n    def __constructTree(self, a1, a2, a3, a4):\n        if a2 > a3:\n            return\n        if a2 == a3:\n            self.__tree[a4] = a1[a2]\n            return\n        v1 = a2 + (a3 - a2) // 2\n        self.__constructTree(a1, a2, v1, a4 * 2 + 1)\n        self.__constructTree(a1, v1 + 1, a3, a4 * 2 + 2)\n        if self.__tree[a4 * 2 + 1] != -1 and self.__count(self.__tree[a4 * 2 + 1], a2, a3) * 2 > a3 - a2 + 1:\n            self.__tree[a4] = self.__tree[a4 * 2 + 1]\n        elif self.__tree[a4 * 2 + 2] != -1 and self.__count(self.__tree[a4 * 2 + 2], a2, a3) * 2 > a3 - a2 + 1:\n            self.__tree[a4] = self.__tree[a4 * 2 + 2]\n\n    def __queryRange(self, a1, a2, a3, a4, a5):\n        if a3 > a4:\n            return (-1, -1)\n        if a4 < a1 or a3 > a2:\n            return (-1, -1)\n        if a1 <= a3 and a4 <= a2:\n            if self.__tree[a5] != -1:\n                v1 = self.__count(self.__tree[a5], a1, a2)\n                if v1 * 2 > a2 - a1 + 1:\n                    return (self.__tree[a5], v1)\n        else:\n            v2 = a3 + (a4 - a3) // 2\n            v3 = self.__queryRange(a1, a2, a3, v2, a5 * 2 + 1)\n            if v3[0] != -1:\n                return v3\n            v3 = self.__queryRange(a1, a2, v2 + 1, a4, a5 * 2 + 2)\n            if v3[0] != -1:\n                return v3\n        return (-1, -1)\n\nclass C2(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def count(a1, a2, a3, a4):\n            return bisect.bisect_right(a1[a2], a4) - bisect.bisect_left(a1[a2], a3)\n        self.__arr = a1\n        self.__inv_idx = collections.defaultdict(list)\n        for v1, v2 in enumerate(self.__arr):\n            self.__inv_idx[v2].append(v1)\n        self.__segment_tree = C1(a1, functools.partial(count, self.__inv_idx))\n\n    def query(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = self.__segment_tree.query(a1, a2)\n        if v1[1] >= a3:\n            return v1[0]\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import functools\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        v1 = len(a1)\n        self.__original_length = v1\n        self.__tree_length = 2 ** (v1.bit_length() + (v1 & v1 - 1 != 0)) - 1\n        self.__tree = [-1 for v2 in range(self.__tree_length)]\n        self.__count = a2\n        self.__constructTree(a1, 0, self.__original_length - 1, 0)\n\n    def query(self, a1, a2):\n        return self.__queryRange(a1, a2, 0, self.__original_length - 1, 0)\n\n    def __constructTree(self, a1, a2, a3, a4):\n        if a2 > a3:\n            return\n        if a2 == a3:\n            self.__tree[a4] = a1[a2]\n            return\n        v1 = a2 + (a3 - a2) // 2\n        self.__constructTree(a1, a2, v1, a4 * 2 + 1)\n        self.__constructTree(a1, v1 + 1, a3, a4 * 2 + 2)\n        if self.__tree[a4 * 2 + 1] != -1 and self.__count(self.__tree[a4 * 2 + 1], a2, a3) * 2 > a3 - a2 + 1:\n            self.__tree[a4] = self.__tree[a4 * 2 + 1]\n        elif self.__tree[a4 * 2 + 2] != -1 and self.__count(self.__tree[a4 * 2 + 2], a2, a3) * 2 > a3 - a2 + 1:\n            self.__tree[a4] = self.__tree[a4 * 2 + 2]\n\n    def __queryRange(self, a1, a2, a3, a4, a5):\n        if a3 > a4:\n            return (-1, -1)\n        if a4 < a1 or a3 > a2:\n            return (-1, -1)\n        if a1 <= a3 and a4 <= a2:\n            if self.__tree[a5] != -1:\n                v1 = self.__count(self.__tree[a5], a1, a2)\n                if v1 * 2 > a2 - a1 + 1:\n                    return (self.__tree[a5], v1)\n        else:\n            v2 = a3 + (a4 - a3) // 2\n            v3 = self.__queryRange(a1, a2, a3, v2, a5 * 2 + 1)\n            if v3[0] != -1:\n                return v3\n            v3 = self.__queryRange(a1, a2, v2 + 1, a4, a5 * 2 + 2)\n            if v3[0] != -1:\n                return v3\n        return (-1, -1)\n\nclass C2(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def count(a1, a2, a3, a4):\n            return bisect.bisect_right(a1[a2], a4) - bisect.bisect_left(a1[a2], a3)\n        self.__arr = a1\n        self.__inv_idx = collections.defaultdict(list)\n        for v1, v2 in enumerate(self.__arr):\n            self.__inv_idx[v2].append(v1)\n        self.__segment_tree = C1(a1, functools.partial(count, self.__inv_idx))\n\n    def query(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = self.__segment_tree.query(a1, a2)\n        if v1[1] >= a3:\n            return v1[0]\n        return -1\n"}
{"id": "human_code\\pseudo-palindromic-paths-in-a-binary-tree__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def pseudoPalindromicPaths(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = [(a1, 0)]\n        while v2:\n            v3, v4 = v2.pop()\n            if not v3:\n                continue\n            v4 ^= 1 << v3.val - 1\n            v1 += int(v3.left == v3.right and v4 & v4 - 1 == 0)\n            v2.append((v3.right, v4))\n            v2.append((v3.left, v4))\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def pseudoPalindromicPaths(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = [(a1, 0)]\n        while v2:\n            v3, v4 = v2.pop()\n            if not v3:\n                continue\n            v4 ^= 1 << v3.val - 1\n            v1 += int(v3.left == v3.right and v4 & v4 - 1 == 0)\n            v2.append((v3.right, v4))\n            v2.append((v3.left, v4))\n        return v1\n"}
{"id": "human_code\\shortest-matching-substring__part2.py", "text": "class C1(object):\n\n    def shortestMatchingSubstring(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n\n        def getPrefix(a1):\n            v1 = [-1] * len(a1)\n            v2 = -1\n            for v3 in range(1, len(a1)):\n                while v2 + 1 > 0 and a1[v2 + 1] != a1[v3]:\n                    v2 = v1[v2]\n                if a1[v2 + 1] == a1[v3]:\n                    v2 += 1\n                v1[v3] = v2\n            return v1\n        v2, v3, v4 = a2.split('*')\n        v5 = len(a1)\n        v6, v7, v8 = (len(v2), len(v3), len(v4))\n        v9 = getPrefix(v2 + '#' + a1)\n        v10 = getPrefix(v3 + '#' + a1)\n        v11 = getPrefix(v4 + '#' + a1)\n        v12 = v1\n        v13 = v14 = v15 = 0\n        while v13 + v7 + v8 < v5:\n            while v13 < v5 and v9[v6 + 1 + v13] + 1 != v6:\n                v13 += 1\n            if v13 == v5:\n                break\n            while v14 < v5 and (not (v14 >= v13 + v7 and v10[v7 + 1 + v14] + 1 == v7)):\n                v14 += 1\n            if v14 == v5:\n                break\n            while v15 < v5 and (not (v15 >= v14 + v8 and v11[v8 + 1 + v15] + 1 == v8)):\n                v15 += 1\n            if v15 == v5:\n                break\n            v12 = min(v12, v15 - (v13 - v6))\n            v13 += 1\n        return v12 if v12 != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def shortestMatchingSubstring(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n\n        def getPrefix(a1):\n            v1 = [-1] * len(a1)\n            v2 = -1\n            for v3 in range(1, len(a1)):\n                while v2 + 1 > 0 and a1[v2 + 1] != a1[v3]:\n                    v2 = v1[v2]\n                if a1[v2 + 1] == a1[v3]:\n                    v2 += 1\n                v1[v3] = v2\n            return v1\n        v2, v3, v4 = a2.split('*')\n        v5 = len(a1)\n        v6, v7, v8 = (len(v2), len(v3), len(v4))\n        v9 = getPrefix(v2 + '#' + a1)\n        v10 = getPrefix(v3 + '#' + a1)\n        v11 = getPrefix(v4 + '#' + a1)\n        v12 = v1\n        v13 = v14 = v15 = 0\n        while v13 + v7 + v8 < v5:\n            while v13 < v5 and v9[v6 + 1 + v13] + 1 != v6:\n                v13 += 1\n            if v13 == v5:\n                break\n            while v14 < v5 and (not (v14 >= v13 + v7 and v10[v7 + 1 + v14] + 1 == v7)):\n                v14 += 1\n            if v14 == v5:\n                break\n            while v15 < v5 and (not (v15 >= v14 + v8 and v11[v8 + 1 + v15] + 1 == v8)):\n                v15 += 1\n            if v15 == v5:\n                break\n            v12 = min(v12, v15 - (v13 - v6))\n            v13 += 1\n        return v12 if v12 != v1 else -1\n"}
{"id": "human_code\\find-longest-self-contained-substring__part1.py", "text": "import bisect\n\nclass C1(object):\n\n    def maxSubstringLength(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2):\n            for v1 in idxs:\n                if not v1 or v1[-1] < a1 or v1[0] > a2 or (a1 <= v1[0] and v1[-1] <= a2):\n                    continue\n                v2 = bisect.bisect_left(v1, a1)\n                if v2 != len(v1) and v1[v2] <= a2:\n                    return False\n            return True\n        v1 = [[] for v2 in range(26)]\n        for v3, v4 in enumerate(a1):\n            v1[ord(v4) - ord('a')].append(v3)\n        v5 = -1\n        for v4 in v1:\n            if not v4:\n                continue\n            v6 = v4[0]\n            for v7 in v1:\n                if not v7:\n                    continue\n                v8 = v7[-1]\n                if v6 <= v8 and v5 < v8 - v6 + 1 != len(a1) and check(v6, v8):\n                    v5 = v8 - v6 + 1\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def maxSubstringLength(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2):\n            for v1 in idxs:\n                if not v1 or v1[-1] < a1 or v1[0] > a2 or (a1 <= v1[0] and v1[-1] <= a2):\n                    continue\n                v2 = bisect.bisect_left(v1, a1)\n                if v2 != len(v1) and v1[v2] <= a2:\n                    return False\n            return True\n        v1 = [[] for v2 in range(26)]\n        for v3, v4 in enumerate(a1):\n            v1[ord(v4) - ord('a')].append(v3)\n        v5 = -1\n        for v4 in v1:\n            if not v4:\n                continue\n            v6 = v4[0]\n            for v7 in v1:\n                if not v7:\n                    continue\n                v8 = v7[-1]\n                if v6 <= v8 and v5 < v8 - v6 + 1 != len(a1) and check(v6, v8):\n                    v5 = v8 - v6 + 1\n        return v5\n"}
{"id": "human_code\\course-schedule-ii__part4.py", "text": "import collections\n\nclass C1(object):\n\n    def findOrder(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = list(range(3))\n\n        def dfs(a1):\n            if lookup[a1] != v1:\n                return lookup[a1] == v3\n            lookup[a1] = v2\n            if any((not dfs(v) for v1 in adj[a1])):\n                return False\n            lookup[a1] = v3\n            result.append(a1)\n            return True\n        v4 = []\n        v5 = collections.defaultdict(list)\n        for v6, v7 in a2:\n            v5[v7].append(v6)\n        v8 = collections.defaultdict(lambda: v1)\n        for v6 in range(a1):\n            if not dfs(v6):\n                return []\n        v4.reverse()\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def findOrder(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = list(range(3))\n\n        def dfs(a1):\n            if lookup[a1] != v1:\n                return lookup[a1] == v3\n            lookup[a1] = v2\n            if any((not dfs(v) for v1 in adj[a1])):\n                return False\n            lookup[a1] = v3\n            result.append(a1)\n            return True\n        v4 = []\n        v5 = collections.defaultdict(list)\n        for v6, v7 in a2:\n            v5[v7].append(v6)\n        v8 = collections.defaultdict(lambda: v1)\n        for v6 in range(a1):\n            if not dfs(v6):\n                return []\n        v4.reverse()\n        return v4\n"}
{"id": "human_code\\top-k-frequent-words__part2.py", "text": "class C1(object):\n\n    def topKFrequent(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class MinHeapObj(object):\n\n            def __init__(self, a1):\n                self.val = a1\n\n            def __lt__(self, a1):\n                return self.val[1] > a1.val[1] if self.val[0] == a1.val[0] else self.val < a1.val\n\n            def __eq__(self, a1):\n                return self.val == a1.val\n\n            def __str__(self):\n                return str(self.val)\n        v1 = collections.Counter(a1)\n        v2 = []\n        for v3, v4 in v1.items():\n            heapq.heappush(v2, MinHeapObj((v4, v3)))\n            if len(v2) == a2 + 1:\n                heapq.heappop(v2)\n        v5 = []\n        while v2:\n            v5.append(heapq.heappop(v2).val[1])\n        return v5[::-1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def topKFrequent(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class MinHeapObj(object):\n\n            def __init__(self, a1):\n                self.val = a1\n\n            def __lt__(self, a1):\n                return self.val[1] > a1.val[1] if self.val[0] == a1.val[0] else self.val < a1.val\n\n            def __eq__(self, a1):\n                return self.val == a1.val\n\n            def __str__(self):\n                return str(self.val)\n        v1 = collections.Counter(a1)\n        v2 = []\n        for v3, v4 in v1.items():\n            heapq.heappush(v2, MinHeapObj((v4, v3)))\n            if len(v2) == a2 + 1:\n                heapq.heappop(v2)\n        v5 = []\n        while v2:\n            v5.append(heapq.heappop(v2).val[1])\n        return v5[::-1]\n"}
{"id": "llm_code\\maximum-area-rectangle-with-point-constraints-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxRectangleArea(self, a1):\n        a1.sort()\n        v1 = sorted({p[1] for v2 in a1})\n        v3 = {y: i + 1 for v4, v5 in enumerate(v1)}\n        v6 = len(v1)\n        v7 = [0] * (v6 + 2)\n\n        def add(a1, a2):\n            while a1 <= v6:\n                v7[a1] += a2\n                a1 += a1 & -a1\n\n        def sum_upto(a1):\n            v1 = 0\n            while a1 > 0:\n                v1 += v7[a1]\n                a1 -= a1 & -a1\n            return v1\n        v8 = {}\n        v9 = -1\n        v4 = 0\n        v10 = len(a1)\n        while v4 < v10:\n            v11 = a1[v4][0]\n            v12 = v4\n            while v12 < v10 and a1[v12][0] == v11:\n                v12 += 1\n            for v13 in range(v4, v12):\n                add(v3[a1[v13][1]], 1)\n            for v13 in range(v4, v12 - 1):\n                v14 = a1[v13][1]\n                v15 = a1[v13 + 1][1]\n                v16 = v3[v14]\n                v17 = v3[v15]\n                v18 = sum_upto(v17) - sum_upto(v16 - 1)\n                v19 = (v16, v17)\n                if v19 in v8:\n                    v20, v21 = v8[v19]\n                    if v20 + 2 == v18:\n                        v22 = (v11 - v21) * (v15 - v14)\n                        v9 = max(v9, v22)\n                v8[v19] = (v18, v11)\n            v4 = v12\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxRectangleArea(self, a1):\n        a1.sort()\n        v1 = sorted({p[1] for v2 in a1})\n        v3 = {y: i + 1 for v4, v5 in enumerate(v1)}\n        v6 = len(v1)\n        v7 = [0] * (v6 + 2)\n\n        def add(a1, a2):\n            while a1 <= v6:\n                v7[a1] += a2\n                a1 += a1 & -a1\n\n        def sum_upto(a1):\n            v1 = 0\n            while a1 > 0:\n                v1 += v7[a1]\n                a1 -= a1 & -a1\n            return v1\n        v8 = {}\n        v9 = -1\n        v4 = 0\n        v10 = len(a1)\n        while v4 < v10:\n            v11 = a1[v4][0]\n            v12 = v4\n            while v12 < v10 and a1[v12][0] == v11:\n                v12 += 1\n            for v13 in range(v4, v12):\n                add(v3[a1[v13][1]], 1)\n            for v13 in range(v4, v12 - 1):\n                v14 = a1[v13][1]\n                v15 = a1[v13 + 1][1]\n                v16 = v3[v14]\n                v17 = v3[v15]\n                v18 = sum_upto(v17) - sum_upto(v16 - 1)\n                v19 = (v16, v17)\n                if v19 in v8:\n                    v20, v21 = v8[v19]\n                    if v20 + 2 == v18:\n                        v22 = (v11 - v21) * (v15 - v14)\n                        v9 = max(v9, v22)\n                v8[v19] = (v18, v11)\n            v4 = v12\n        return v9\n"}
{"id": "llm_code\\shift-distance-between-two-strings__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def shiftDistance(self, a1, a2, a3, a4):\n\n        def build_prefix(a1):\n            v1 = [0]\n            for v2 in a1:\n                v1.append(v1[-1] + v2)\n            return v1\n        v1 = build_prefix(a3)\n        v2 = build_prefix(a4)\n        v3 = v1[-1]\n        v4 = v2[-1]\n\n        def next_shift(a1, a2):\n            if a1 <= a2:\n                return v1[a2] - v1[a1]\n            return v3 + v1[a2] - v1[a1]\n\n        def prev_shift(a1, a2):\n            if a1 >= a2:\n                return v2[a1 + 1] - v2[a2 + 1]\n            return v4 - (v2[a2 + 1] - v2[a1 + 1])\n        v5 = 0\n        for v6, v7 in zip(a1, a2):\n            if v6 == v7:\n                continue\n            v8 = ord(v6) - ord('a')\n            v9 = ord(v7) - ord('a')\n            v5 += min(next_shift(v8, v9), prev_shift(v8, v9))\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def shiftDistance(self, a1, a2, a3, a4):\n\n        def build_prefix(a1):\n            v1 = [0]\n            for v2 in a1:\n                v1.append(v1[-1] + v2)\n            return v1\n        v1 = build_prefix(a3)\n        v2 = build_prefix(a4)\n        v3 = v1[-1]\n        v4 = v2[-1]\n\n        def next_shift(a1, a2):\n            if a1 <= a2:\n                return v1[a2] - v1[a1]\n            return v3 + v1[a2] - v1[a1]\n\n        def prev_shift(a1, a2):\n            if a1 >= a2:\n                return v2[a1 + 1] - v2[a2 + 1]\n            return v4 - (v2[a2 + 1] - v2[a1 + 1])\n        v5 = 0\n        for v6, v7 in zip(a1, a2):\n            if v6 == v7:\n                continue\n            v8 = ord(v6) - ord('a')\n            v9 = ord(v7) - ord('a')\n            v5 += min(next_shift(v8, v9), prev_shift(v8, v9))\n        return v5\n"}
{"id": "human_code\\minimum-cost-to-make-array-equal__part3.py", "text": "class C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = list(range(len(a1)))\n        v1.sort(key=lambda x: a1[x])\n        v2 = [0] * (len(a2) + 1)\n        v3 = 0\n        for v4 in range(len(a2)):\n            if v4 - 1 >= 0:\n                v3 += v2[v4] * (a1[v1[v4]] - a1[v1[v4 - 1]])\n            v2[v4 + 1] = v2[v4] + a2[v1[v4]]\n        v5 = float('inf')\n        v6 = v7 = 0\n        for v4 in reversed(range(len(a2))):\n            if v4 + 1 < len(v1):\n                v7 += v6 * (a1[v1[v4 + 1]] - a1[v1[v4]])\n            v5 = min(v5, v3 + v7)\n            if v4 - 1 >= 0:\n                v3 -= v2[v4] * (a1[v1[v4]] - a1[v1[v4 - 1]])\n            v6 += a2[v1[v4]]\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = list(range(len(a1)))\n        v1.sort(key=lambda x: a1[x])\n        v2 = [0] * (len(a2) + 1)\n        v3 = 0\n        for v4 in range(len(a2)):\n            if v4 - 1 >= 0:\n                v3 += v2[v4] * (a1[v1[v4]] - a1[v1[v4 - 1]])\n            v2[v4 + 1] = v2[v4] + a2[v1[v4]]\n        v5 = float('inf')\n        v6 = v7 = 0\n        for v4 in reversed(range(len(a2))):\n            if v4 + 1 < len(v1):\n                v7 += v6 * (a1[v1[v4 + 1]] - a1[v1[v4]])\n            v5 = min(v5, v3 + v7)\n            if v4 - 1 >= 0:\n                v3 -= v2[v4] * (a1[v1[v4]] - a1[v1[v4 - 1]])\n            v6 += a2[v1[v4]]\n        return v5\n"}
{"id": "human_code\\sum-of-number-and-its-reverse__part1.py", "text": "class C1(object):\n\n    def sumOfNumberAndReverse(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def backtracking(a1, a2):\n            if a1 == 0:\n                return True\n            if a2 == 1:\n                return False\n            if a1 <= 18:\n                return a1 % 2 == 0 or (a1 == 11 and a2 == 0)\n            if a2 == 2:\n                return False\n            for v1 in (a1 % 10, 10 + a1 % 10):\n                if not 1 <= v1 <= 18:\n                    continue\n                v2 = 11\n                if a2:\n                    v2 = a2\n                else:\n                    while v1 * ((v2 - 1) * 10 + 1) <= a1:\n                        v2 = (v2 - 1) * 10 + 1\n                if a1 - v1 * v2 >= 0 and backtracking((a1 - v1 * v2) // 10, v2 // 100 + 1):\n                    return True\n            return False\n        return backtracking(a1, 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def sumOfNumberAndReverse(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def backtracking(a1, a2):\n            if a1 == 0:\n                return True\n            if a2 == 1:\n                return False\n            if a1 <= 18:\n                return a1 % 2 == 0 or (a1 == 11 and a2 == 0)\n            if a2 == 2:\n                return False\n            for v1 in (a1 % 10, 10 + a1 % 10):\n                if not 1 <= v1 <= 18:\n                    continue\n                v2 = 11\n                if a2:\n                    v2 = a2\n                else:\n                    while v1 * ((v2 - 1) * 10 + 1) <= a1:\n                        v2 = (v2 - 1) * 10 + 1\n                if a1 - v1 * v2 >= 0 and backtracking((a1 - v1 * v2) // 10, v2 // 100 + 1):\n                    return True\n            return False\n        return backtracking(a1, 0)\n"}
{"id": "llm_code\\p03062__s859306100.py", "text": "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nv1 = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nv2 = lambda: int(input())\nv3 = lambda: map(int, input().split())\nv4 = lambda: list(v3())\nv5 = lambda: input()\n\ndef f1():\n    v1 = v2()\n    v2 = v4()\n    v3 = 0\n    for v4 in range(v1):\n        v3 += abs(v2[v4])\n    for v4 in range(v1 - 1):\n        if v2[v4] * v2[v4 + 1] < 0:\n            v3 -= 2 * min(abs(v2[v4]), abs(v2[v4 + 1]))\n    print(v3)\nif __name__ == '__main__':\n    f1()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nv1 = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nv2 = lambda: int(input())\nv3 = lambda: map(int, input().split())\nv4 = lambda: list(v3())\nv5 = lambda: input()\n\ndef f1():\n    v1 = v2()\n    v2 = v4()\n    v3 = 0\n    for v4 in range(v1):\n        v3 += abs(v2[v4])\n    for v4 in range(v1 - 1):\n        if v2[v4] * v2[v4 + 1] < 0:\n            v3 -= 2 * min(abs(v2[v4]), abs(v2[v4 + 1]))\n    print(v3)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "llm_code\\minimize-the-total-price-of-the-trips__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def minimumTotalPrice(self, a1, a2, a3, a4):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * a1\n        for v6, v7 in a4:\n            if v6 == v7:\n                v5[v6] += 1\n                continue\n            v8 = [-1] * a1\n            v9 = deque([v6])\n            v8[v6] = -2\n            v10 = False\n            while v9 and (not v10):\n                v11 = v9.popleft()\n                for v12 in v1[v11]:\n                    if v8[v12] == -1:\n                        v8[v12] = v11\n                        v9.append(v12)\n                        if v12 == v7:\n                            v10 = True\n                            break\n            v11 = v7\n            while v11 != v6:\n                v5[v11] += 1\n                v11 = v8[v11]\n            v5[v6] += 1\n\n        def tree_dp(a1, a2):\n            v1 = a3[a1] * v5[a1]\n            v2 = a3[a1] // 2 * v5[a1]\n            for v3 in v1[a1]:\n                if v3 == a2:\n                    continue\n                v4, v5 = tree_dp(v3, a1)\n                v1 += min(v4, v5)\n                v2 += v4\n            return (v1, v2)\n        v13, v14 = tree_dp(0, -1)\n        return min(v13, v14)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def minimumTotalPrice(self, a1, a2, a3, a4):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * a1\n        for v6, v7 in a4:\n            if v6 == v7:\n                v5[v6] += 1\n                continue\n            v8 = [-1] * a1\n            v9 = deque([v6])\n            v8[v6] = -2\n            v10 = False\n            while v9 and (not v10):\n                v11 = v9.popleft()\n                for v12 in v1[v11]:\n                    if v8[v12] == -1:\n                        v8[v12] = v11\n                        v9.append(v12)\n                        if v12 == v7:\n                            v10 = True\n                            break\n            v11 = v7\n            while v11 != v6:\n                v5[v11] += 1\n                v11 = v8[v11]\n            v5[v6] += 1\n\n        def tree_dp(a1, a2):\n            v1 = a3[a1] * v5[a1]\n            v2 = a3[a1] // 2 * v5[a1]\n            for v3 in v1[a1]:\n                if v3 == a2:\n                    continue\n                v4, v5 = tree_dp(v3, a1)\n                v1 += min(v4, v5)\n                v2 += v4\n            return (v1, v2)\n        v13, v14 = tree_dp(0, -1)\n        return min(v13, v14)\n"}
{"id": "human_code\\valid-word-abbreviation.py", "text": "class C1(object):\n\n    def validWordAbbreviation(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (0, 0)\n        for v3 in a2:\n            if v3.isdigit():\n                if v2 == 0 and v3 == '0':\n                    return False\n                v2 *= 10\n                v2 += int(v3)\n            else:\n                if v2:\n                    v1 += v2\n                    v2 = 0\n                if v1 >= len(a1) or a1[v1] != v3:\n                    return False\n                v1 += 1\n        if v2:\n            v1 += v2\n        return v1 == len(a1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def validWordAbbreviation(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (0, 0)\n        for v3 in a2:\n            if v3.isdigit():\n                if v2 == 0 and v3 == '0':\n                    return False\n                v2 *= 10\n                v2 += int(v3)\n            else:\n                if v2:\n                    v1 += v2\n                    v2 = 0\n                if v1 >= len(a1) or a1[v1] != v3:\n                    return False\n                v1 += 1\n        if v2:\n            v1 += v2\n        return v1 == len(a1)\n"}
{"id": "llm_code\\evaluate-division__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self):\n        self.par = {}\n        self.mul = {}\n        self.rnk = {}\n\n    def get(self, a1):\n        if a1 not in self.par:\n            self.par[a1] = a1\n            self.mul[a1] = 1.0\n            self.rnk[a1] = 0\n            return a1\n        if self.par[a1] != a1:\n            v1 = self.par[a1]\n            self.par[a1] = self.get(v1)\n            self.mul[a1] *= self.mul[v1]\n        return self.par[a1]\n\n    def merge(self, a1, a2, a3):\n        v1 = self.get(a1)\n        v2 = self.get(a2)\n        if v1 == v2:\n            return False\n        v3 = self.mul[a1]\n        v4 = self.mul[a2]\n        if self.rnk[v1] < self.rnk[v2]:\n            self.par[v1] = v2\n            self.mul[v1] = a3 * v4 / v3\n        elif self.rnk[v1] > self.rnk[v2]:\n            self.par[v2] = v1\n            self.mul[v2] = v3 / (a3 * v4)\n        else:\n            self.par[v2] = v1\n            self.mul[v2] = v3 / (a3 * v4)\n            self.rnk[v1] += 1\n        return True\n\n    def get_ratio(self, a1, a2):\n        if a1 not in self.par or a2 not in self.par:\n            return -1.0\n        v1 = self.get(a1)\n        v2 = self.get(a2)\n        if v1 != v2:\n            return -1.0\n        return self.mul[a1] / self.mul[a2]\n\nclass C2:\n\n    def calcEquation(self, a1, a2, a3):\n        v1 = C1()\n        for v2, v3 in zip(a1, a2):\n            v1.merge(v2[0], v2[1], v3)\n        return [v1.get_ratio(q[0], q[1]) for v4 in a3]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self):\n        self.par = {}\n        self.mul = {}\n        self.rnk = {}\n\n    def get(self, a1):\n        if a1 not in self.par:\n            self.par[a1] = a1\n            self.mul[a1] = 1.0\n            self.rnk[a1] = 0\n            return a1\n        if self.par[a1] != a1:\n            v1 = self.par[a1]\n            self.par[a1] = self.get(v1)\n            self.mul[a1] *= self.mul[v1]\n        return self.par[a1]\n\n    def merge(self, a1, a2, a3):\n        v1 = self.get(a1)\n        v2 = self.get(a2)\n        if v1 == v2:\n            return False\n        v3 = self.mul[a1]\n        v4 = self.mul[a2]\n        if self.rnk[v1] < self.rnk[v2]:\n            self.par[v1] = v2\n            self.mul[v1] = a3 * v4 / v3\n        elif self.rnk[v1] > self.rnk[v2]:\n            self.par[v2] = v1\n            self.mul[v2] = v3 / (a3 * v4)\n        else:\n            self.par[v2] = v1\n            self.mul[v2] = v3 / (a3 * v4)\n            self.rnk[v1] += 1\n        return True\n\n    def get_ratio(self, a1, a2):\n        if a1 not in self.par or a2 not in self.par:\n            return -1.0\n        v1 = self.get(a1)\n        v2 = self.get(a2)\n        if v1 != v2:\n            return -1.0\n        return self.mul[a1] / self.mul[a2]\n\nclass C2:\n\n    def calcEquation(self, a1, a2, a3):\n        v1 = C1()\n        for v2, v3 in zip(a1, a2):\n            v1.merge(v2[0], v2[1], v3)\n        return [v1.get_ratio(q[0], q[1]) for v4 in a3]\n"}
{"id": "llm_code\\p03402__s766492986.py", "text": "v1, v2 = map(int, input().split())\nv3 = [['.' for v4 in range(3)] for v5 in range(3)]\nv6 = [['#' for v4 in range(3)] for v5 in range(3)]\nv7 = [['#' for v4 in range(3)] for v5 in range(3)]\nv8 = [['.' for v4 in range(3)] for v5 in range(3)]\nv7[1][1] = '.'\nv8[1][1] = '#'\nv9 = [['.' for v4 in range(99)] for v5 in range(96)]\nv1 -= 1\nv2 -= 1\nv10 = v1 // 33\nv11 = v1 % 33\nfor v4 in range(16):\n    for v5 in range(33):\n        if v10 > v4:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v7[v12][v13]\n        elif v10 == v4:\n            if v11 > v5:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v7[v12][v13]\n            else:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v3[v12][v13]\n        else:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v3[v12][v13]\nif v1 > 0:\n    v2 -= 1\nif v2 == -1:\n    for v4 in range(48):\n        print(*v9[v4], sep='')\n    exit()\nv14 = v2 // 33\nv15 = v2 % 33\nfor v4 in range(16, 32):\n    for v5 in range(33):\n        if v14 > v4 - 16:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v8[v12][v13]\n        elif v14 == v4 - 16:\n            if v15 > v5:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v8[v12][v13]\n            else:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v6[v12][v13]\n        else:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v6[v12][v13]\nprint(96, 99)\nfor v4 in range(96):\n    print(*v9[v4], sep='')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = [['.' for v4 in range(3)] for v5 in range(3)]\nv6 = [['#' for v4 in range(3)] for v5 in range(3)]\nv7 = [['#' for v4 in range(3)] for v5 in range(3)]\nv8 = [['.' for v4 in range(3)] for v5 in range(3)]\nv7[1][1] = '.'\nv8[1][1] = '#'\nv9 = [['.' for v4 in range(99)] for v5 in range(96)]\nv1 -= 1\nv2 -= 1\nv10 = v1 // 33\nv11 = v1 % 33\nfor v4 in range(16):\n    for v5 in range(33):\n        if v10 > v4:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v7[v12][v13]\n        elif v10 == v4:\n            if v11 > v5:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v7[v12][v13]\n            else:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v3[v12][v13]\n        else:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v3[v12][v13]\nif v1 > 0:\n    v2 -= 1\nif v2 == -1:\n    for v4 in range(48):\n        print(*v9[v4], sep='')\n    exit()\nv14 = v2 // 33\nv15 = v2 % 33\nfor v4 in range(16, 32):\n    for v5 in range(33):\n        if v14 > v4 - 16:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v8[v12][v13]\n        elif v14 == v4 - 16:\n            if v15 > v5:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v8[v12][v13]\n            else:\n                for v12 in range(3):\n                    for v13 in range(3):\n                        v9[v4 * 3 + v12][v5 * 3 + v13] = v6[v12][v13]\n        else:\n            for v12 in range(3):\n                for v13 in range(3):\n                    v9[v4 * 3 + v12][v5 * 3 + v13] = v6[v12][v13]\nprint(96, 99)\nfor v4 in range(96):\n    print(*v9[v4], sep='')\n"}
{"id": "human_code\\house-robber-iv__part2.py", "text": "class C1(object):\n\n    def minCapability(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = v2 = 0\n            while v2 < len(a1):\n                if a1[v2] <= a1:\n                    v1 += 1\n                    v2 += 2\n                else:\n                    v2 += 1\n            return v1 >= a2\n        v1, v2 = (min(a1), max(a1))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minCapability(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            v1 = v2 = 0\n            while v2 < len(a1):\n                if a1[v2] <= a1:\n                    v1 += 1\n                    v2 += 2\n                else:\n                    v2 += 1\n            return v1 >= a2\n        v1, v2 = (min(a1), max(a1))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1\n"}
{"id": "llm_code\\lemonade-change__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def lemonadeChange(self, a1):\n        v1 = {5: 0, 10: 0}\n        for v2 in a1:\n            if v2 == 5:\n                v1[5] += 1\n            elif v2 == 10:\n                if v1[5] == 0:\n                    return False\n                v1[5] -= 1\n                v1[10] += 1\n            else:\n                v3 = False\n                if v1[10] > 0 and v1[5] > 0:\n                    v1[10] -= 1\n                    v1[5] -= 1\n                    v3 = True\n                if not v3 and v1[5] >= 3:\n                    v1[5] -= 3\n                    v3 = True\n                if not v3:\n                    return False\n        return True\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def lemonadeChange(self, a1):\n        v1 = {5: 0, 10: 0}\n        for v2 in a1:\n            if v2 == 5:\n                v1[5] += 1\n            elif v2 == 10:\n                if v1[5] == 0:\n                    return False\n                v1[5] -= 1\n                v1[10] += 1\n            else:\n                v3 = False\n                if v1[10] > 0 and v1[5] > 0:\n                    v1[10] -= 1\n                    v1[5] -= 1\n                    v3 = True\n                if not v3 and v1[5] >= 3:\n                    v1[5] -= 3\n                    v3 = True\n                if not v3:\n                    return False\n        return True\n"}
{"id": "human_code\\minimum-cost-path-with-edge-reversals.py", "text": "import heapq\n\nclass C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dijkstra():\n            v1 = [float('inf')] * len(adj)\n            v1[0] = 0\n            v2 = [(v1[0], 0)]\n            while v2:\n                v3, v4 = heapq.heappop(v2)\n                if v3 != v1[v4]:\n                    continue\n                if v4 == len(adj) - 1:\n                    return v3\n                for v5, v6 in adj[v4]:\n                    if not v1[v5] > v3 + v6:\n                        continue\n                    v1[v5] = v3 + v6\n                    heapq.heappush(v2, (v1[v5], v5))\n            return -1\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, 2 * v5))\n        return dijkstra()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dijkstra():\n            v1 = [float('inf')] * len(adj)\n            v1[0] = 0\n            v2 = [(v1[0], 0)]\n            while v2:\n                v3, v4 = heapq.heappop(v2)\n                if v3 != v1[v4]:\n                    continue\n                if v4 == len(adj) - 1:\n                    return v3\n                for v5, v6 in adj[v4]:\n                    if not v1[v5] > v3 + v6:\n                        continue\n                    v1[v5] = v3 + v6\n                    heapq.heappush(v2, (v1[v5], v5))\n            return -1\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, 2 * v5))\n        return dijkstra()\n"}
{"id": "llm_code\\split-concatenated-strings__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def splitLoopedString(self, a1):\n        v1 = [max(s, s[::-1]) for v2 in a1]\n        v3 = ''.join(v1)\n        v4 = len(v3)\n        v5 = 'a'\n        v6 = [0]\n        for v2 in a1:\n            v6.append(v6[-1] + len(v2))\n        v7 = len(a1)\n        for v8 in range(v7):\n            v9 = v6[v8]\n            v10 = v6[v8 + 1]\n            v11 = v3[v10:] + v3[:v9]\n            v12 = v10 - v9\n            v13 = a1[v8]\n            for v14 in (v13, v13[::-1]):\n                for v15 in range(v12):\n                    if v14[v15] >= v5[0]:\n                        v16 = v14[v15:] + v11 + v14[:v15]\n                        v5 = max(v5, v16)\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def splitLoopedString(self, a1):\n        v1 = [max(s, s[::-1]) for v2 in a1]\n        v3 = ''.join(v1)\n        v4 = len(v3)\n        v5 = 'a'\n        v6 = [0]\n        for v2 in a1:\n            v6.append(v6[-1] + len(v2))\n        v7 = len(a1)\n        for v8 in range(v7):\n            v9 = v6[v8]\n            v10 = v6[v8 + 1]\n            v11 = v3[v10:] + v3[:v9]\n            v12 = v10 - v9\n            v13 = a1[v8]\n            for v14 in (v13, v13[::-1]):\n                for v15 in range(v12):\n                    if v14[v15] >= v5[0]:\n                        v16 = v14[v15:] + v11 + v14[:v15]\n                        v5 = max(v5, v16)\n        return v5\n"}
{"id": "human_code\\p02632__s956618393.py", "text": "import sys\nv1 = sys.stdin.readline\nv2 = int(v1())\nv3 = v1().rstrip()\nv3 = len(v3)\nv4 = v2 + v3\nv5 = 10 ** 9 + 7\nv6 = 10 ** 6 * 2\nv7 = [1] * 2 + [0] * (v6 - 2)\nv8 = [1] * 2 + [0] * (v6 - 2)\nv9 = [0, 1] + [0] * (v6 - 2)\nfor v10 in range(2, v6):\n    v7[v10] = v7[v10 - 1] * v10 % v5\n    v9[v10] = -v9[v5 % v10] * (v5 // v10) % v5\n    v8[v10] = v8[v10 - 1] * v9[v10] % v5\n\ndef f1(a1, a2, a3):\n    if a2 < 0 or a2 > a1:\n        return 0\n    a2 = min(a2, a1 - a2)\n    return v7[a1] * v8[a2] * v8[a1 - a2] % a3\nv11 = 0\nfor v12 in range(v3, v4 + 1):\n    v13 = f1(v12 - 1, v3 - 1, v5)\n    v13 *= pow(25, v12 - v3, v5)\n    v13 %= v5\n    v13 *= pow(26, v4 - v12, v5)\n    v13 %= v5\n    v11 += v13\n    v11 %= v5\nprint(v11)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1 = sys.stdin.readline\nv2 = int(v1())\nv3 = v1().rstrip()\nv3 = len(v3)\nv4 = v2 + v3\nv5 = 10 ** 9 + 7\nv6 = 10 ** 6 * 2\nv7 = [1] * 2 + [0] * (v6 - 2)\nv8 = [1] * 2 + [0] * (v6 - 2)\nv9 = [0, 1] + [0] * (v6 - 2)\nfor v10 in range(2, v6):\n    v7[v10] = v7[v10 - 1] * v10 % v5\n    v9[v10] = -v9[v5 % v10] * (v5 // v10) % v5\n    v8[v10] = v8[v10 - 1] * v9[v10] % v5\n\ndef f1(a1, a2, a3):\n    if a2 < 0 or a2 > a1:\n        return 0\n    a2 = min(a2, a1 - a2)\n    return v7[a1] * v8[a2] * v8[a1 - a2] % a3\nv11 = 0\nfor v12 in range(v3, v4 + 1):\n    v13 = f1(v12 - 1, v3 - 1, v5)\n    v13 *= pow(25, v12 - v3, v5)\n    v13 %= v5\n    v13 *= pow(26, v4 - v12, v5)\n    v13 %= v5\n    v11 += v13\n    v11 %= v5\nprint(v11)\n"}
{"id": "llm_code\\p02684__s917858867.py", "text": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = 1\nv5 = 1\nv6 = []\nv7 = 0\nv8 = 0\nv9 = 0\nif v3[0] == 1:\n    v9 = 1\nelif v1 >= v2:\n    for v10 in range(v2 - 1):\n        v11 = v3[v4 - 1]\n        v4 = v11\n    v9 = v4\nelse:\n    for v10 in range(v1):\n        v11 = v3[v4 - 1]\n        v4 = v11\n        v12 = len(v6)\n        for v13 in range(v12):\n            if v4 == v6[v13]:\n                v8 = v10 - v13 + 1\n                v7 = 1\n                v14 = v10 + 1\n                break\n        if v7 == 1:\n            break\n        else:\n            v6.append(v4)\n    if v8 == 1:\n        v9 = v3[v14]\n    else:\n        v15 = v2 % v8\n        v9 = v3[v14 + v15 - 1 - v8]\nprint(v9)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = 1\nv5 = 1\nv6 = []\nv7 = 0\nv8 = 0\nv9 = 0\nif v3[0] == 1:\n    v9 = 1\nelif v1 >= v2:\n    for v10 in range(v2 - 1):\n        v11 = v3[v4 - 1]\n        v4 = v11\n    v9 = v4\nelse:\n    for v10 in range(v1):\n        v11 = v3[v4 - 1]\n        v4 = v11\n        v12 = len(v6)\n        for v13 in range(v12):\n            if v4 == v6[v13]:\n                v8 = v10 - v13 + 1\n                v7 = 1\n                v14 = v10 + 1\n                break\n        if v7 == 1:\n            break\n        else:\n            v6.append(v4)\n    if v8 == 1:\n        v9 = v3[v14]\n    else:\n        v15 = v2 % v8\n        v9 = v3[v14 + v15 - 1 - v8]\nprint(v9)\n"}
{"id": "llm_code\\p03221__s483850552.py", "text": "def f1(a1, a2):\n    v1 = len(a1)\n    v2 = 0\n    v3 = v1\n    while v2 != v3:\n        if a2 > a1[(v2 + v3) // 2]:\n            v2 = (v2 + v3) // 2 + 1\n        else:\n            v3 = (v2 + v3) // 2\n    return v2\nv1, v2 = map(int, input().split())\nv3 = []\nv4 = []\nv5 = [[] for v6 in range(v1)]\nfor v7 in range(v2):\n    v8, v9 = map(int, input().split())\n    v3.append(v8)\n    v4.append(v9)\n    v5[v8 - 1].append(v9)\nfor v7 in range(v1):\n    v5[v7].sort()\nfor v7 in range(v2):\n    v10 = f1(v5[v3[v7] - 1], v4[v7]) + 1\n    print('%06d%06d' % (v3[v7], v10))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1, a2):\n    v1 = len(a1)\n    v2 = 0\n    v3 = v1\n    while v2 != v3:\n        if a2 > a1[(v2 + v3) // 2]:\n            v2 = (v2 + v3) // 2 + 1\n        else:\n            v3 = (v2 + v3) // 2\n    return v2\nv1, v2 = map(int, input().split())\nv3 = []\nv4 = []\nv5 = [[] for v6 in range(v1)]\nfor v7 in range(v2):\n    v8, v9 = map(int, input().split())\n    v3.append(v8)\n    v4.append(v9)\n    v5[v8 - 1].append(v9)\nfor v7 in range(v1):\n    v5[v7].sort()\nfor v7 in range(v2):\n    v10 = f1(v5[v3[v7] - 1], v4[v7]) + 1\n    print('%06d%06d' % (v3[v7], v10))\n"}
{"id": "llm_code\\number-of-ways-to-reconstruct-a-tree__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1(object):\n\n    def checkWays(self, a1):\n        v1 = collections.defaultdict(set)\n        for v2, v3 in a1:\n            v1[v2].add(v3)\n            v1[v3].add(v2)\n        v4 = len(v1)\n        if v4 == 0:\n            return 1\n        v5 = sorted(v1, key=lambda nd: len(v1[nd]), reverse=True)\n        v6 = set()\n        v7 = v5[0]\n        v6.add(v7)\n        if len(v1[v7]) != v4 - 1:\n            return 0\n        v8 = False\n        for v9 in v5[1:]:\n            v6.add(v9)\n            v10 = [nbr for v11 in v1[v9] if v11 in v6]\n            if not v10:\n                return 0\n            v12 = min(v10, key=lambda nbr: len(v1[v11]))\n            for v11 in v1[v9]:\n                if v11 != v12 and v11 not in v1[v12]:\n                    return 0\n            if len(v1[v9]) == len(v1[v12]):\n                v8 = True\n        return 2 if v8 else 1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def checkWays(self, a1):\n        v1 = collections.defaultdict(set)\n        for v2, v3 in a1:\n            v1[v2].add(v3)\n            v1[v3].add(v2)\n        v4 = len(v1)\n        if v4 == 0:\n            return 1\n        v5 = sorted(v1, key=lambda nd: len(v1[nd]), reverse=True)\n        v6 = set()\n        v7 = v5[0]\n        v6.add(v7)\n        if len(v1[v7]) != v4 - 1:\n            return 0\n        v8 = False\n        for v9 in v5[1:]:\n            v6.add(v9)\n            v10 = [nbr for v11 in v1[v9] if v11 in v6]\n            if not v10:\n                return 0\n            v12 = min(v10, key=lambda nbr: len(v1[v11]))\n            for v11 in v1[v9]:\n                if v11 != v12 and v11 not in v1[v12]:\n                    return 0\n            if len(v1[v9]) == len(v1[v12]):\n                v8 = True\n        return 2 if v8 else 1\n"}
{"id": "human_code\\word-abbreviation.py", "text": "import collections\n\nclass C1(object):\n\n    def wordsAbbreviation(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def isUnique(a1, a2):\n            return sum((word.startswith(a1) for v1 in a2)) == 1\n\n        def toAbbr(a1, a2):\n            v1 = a1 + str(len(a2) - 1 - len(a1)) + a2[-1]\n            return v1 if len(v1) < len(a2) else a2\n        v1 = collections.defaultdict(set)\n        v2 = {}\n        for v3 in a1:\n            v4 = v3[:1]\n            v1[toAbbr(v4, v3)].add(v3)\n        for v5, v6 in v1.items():\n            if len(v6) > 1:\n                for v3 in v6:\n                    for v7 in range(2, len(v3)):\n                        v4 = v3[:v7]\n                        if isUnique(v4, v6):\n                            v2[v3] = toAbbr(v4, v3)\n                            break\n            else:\n                v2[v6.pop()] = v5\n        return [v2[v3] for v3 in a1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def wordsAbbreviation(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def isUnique(a1, a2):\n            return sum((word.startswith(a1) for v1 in a2)) == 1\n\n        def toAbbr(a1, a2):\n            v1 = a1 + str(len(a2) - 1 - len(a1)) + a2[-1]\n            return v1 if len(v1) < len(a2) else a2\n        v1 = collections.defaultdict(set)\n        v2 = {}\n        for v3 in a1:\n            v4 = v3[:1]\n            v1[toAbbr(v4, v3)].add(v3)\n        for v5, v6 in v1.items():\n            if len(v6) > 1:\n                for v3 in v6:\n                    for v7 in range(2, len(v3)):\n                        v4 = v3[:v7]\n                        if isUnique(v4, v6):\n                            v2[v3] = toAbbr(v4, v3)\n                            break\n            else:\n                v2[v6.pop()] = v5\n        return [v2[v3] for v3 in a1]\n"}
{"id": "llm_code\\p03347__s218421905.py", "text": "v1 = int(input())\nv2 = [int(input()) for v3 in range(v1)]\nv4 = [0] * 200001\nv5 = [0] * 200001\nfor v6 in range(v1):\n    v7 = v6 - v2[v6]\n    if v7 < 0:\n        print(-1)\n        exit()\n    v4[v7] = max(v4[v7], v2[v6])\nv8 = 0\nv9 = 0\nfor v6 in range(200001):\n    v9 = max(v9, v4[v6] + v6)\n    v5[v6] = v9\nfor v6 in range(1, v1):\n    if v6 <= v5[v6 - v2[v6] - 1]:\n        print(-1)\n        exit()\nv8 = sum(v4)\nprint(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [int(input()) for v3 in range(v1)]\nv4 = [0] * 200001\nv5 = [0] * 200001\nfor v6 in range(v1):\n    v7 = v6 - v2[v6]\n    if v7 < 0:\n        print(-1)\n        exit()\n    v4[v7] = max(v4[v7], v2[v6])\nv8 = 0\nv9 = 0\nfor v6 in range(200001):\n    v9 = max(v9, v4[v6] + v6)\n    v5[v6] = v9\nfor v6 in range(1, v1):\n    if v6 <= v5[v6 - v2[v6] - 1]:\n        print(-1)\n        exit()\nv8 = sum(v4)\nprint(v8)\n"}
{"id": "human_code\\process-string-with-special-operations-i.py", "text": "import collections\n\nclass C1(object):\n\n    def processStr(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = collections.deque()\n        v2 = True\n        for v3 in a1:\n            if v3 == '*':\n                if not v1:\n                    continue\n                if v2:\n                    v1.pop()\n                else:\n                    v1.popleft()\n            elif v3 == '#':\n                v1.extend(v1)\n            elif v3 == '%':\n                v2 = not v2\n            elif v2:\n                v1.append(v3)\n            else:\n                v1.appendleft(v3)\n        if not v2:\n            v1.reverse()\n        return ''.join(v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def processStr(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = collections.deque()\n        v2 = True\n        for v3 in a1:\n            if v3 == '*':\n                if not v1:\n                    continue\n                if v2:\n                    v1.pop()\n                else:\n                    v1.popleft()\n            elif v3 == '#':\n                v1.extend(v1)\n            elif v3 == '%':\n                v2 = not v2\n            elif v2:\n                v1.append(v3)\n            else:\n                v1.appendleft(v3)\n        if not v2:\n            v1.reverse()\n        return ''.join(v1)\n"}
{"id": "llm_code\\p03380__s626381532.py", "text": "import sys\nsys.setrecursionlimit(10 ** 8)\n\ndef f1():\n    return int(sys.stdin.readline())\n\ndef f2():\n    return map(int, sys.stdin.readline().split())\n\ndef f3():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f4(a1):\n    return [list(map(int, sys.stdin.readline().split())) for v1 in range(a1)]\n\ndef f5(a1, a2, a3):\n    return [[a1] * a2 for v1 in range(a3)]\n\ndef f6(a1, a2, a3, a4):\n    return [[[a1] * a2 for v1 in range(a3)] for v1 in range(a4)]\nimport bisect\nv1 = f1()\nv2 = sorted(f3())\nv3 = (v2[-1], v2[0])\nfor v4 in range(v1 - 1):\n    for v5 in range(v4 + 1, v1):\n        if v3[0] * v3[1] < v2[v5] * v2[v4]:\n            v3 = (v2[v5], v2[v4])\nprint(v3[0], v3[1])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 8)\n\ndef f1():\n    return int(sys.stdin.readline())\n\ndef f2():\n    return map(int, sys.stdin.readline().split())\n\ndef f3():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f4(a1):\n    return [list(map(int, sys.stdin.readline().split())) for v1 in range(a1)]\n\ndef f5(a1, a2, a3):\n    return [[a1] * a2 for v1 in range(a3)]\n\ndef f6(a1, a2, a3, a4):\n    return [[[a1] * a2 for v1 in range(a3)] for v1 in range(a4)]\nimport bisect\nv1 = f1()\nv2 = sorted(f3())\nv3 = (v2[-1], v2[0])\nfor v4 in range(v1 - 1):\n    for v5 in range(v4 + 1, v1):\n        if v3[0] * v3[1] < v2[v5] * v2[v4]:\n            v3 = (v2[v5], v2[v4])\nprint(v3[0], v3[1])\n"}
{"id": "human_code\\max-stack.py", "text": "import collections\n\nclass C1(object):\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.__idx_to_val = collections.defaultdict(int)\n        self.__val_to_idxs = collections.defaultdict(list)\n        self.__top = None\n        self.__max = None\n\n    def push(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = self.__val_to_idxs[self.__top][-1] + 1 if self.__val_to_idxs else 0\n        self.__idx_to_val[v1] = a1\n        self.__val_to_idxs[a1].append(v1)\n        self.__top = a1\n        self.__max = max(self.__max, a1)\n\n    def pop(self):\n        \"\"\"\n        \"\"\"\n        v1 = self.__top\n        self.__remove(v1)\n        return v1\n\n    def top(self):\n        \"\"\"\n        \"\"\"\n        return self.__top\n\n    def peekMax(self):\n        \"\"\"\n        \"\"\"\n        return self.__max\n\n    def popMax(self):\n        \"\"\"\n        \"\"\"\n        v1 = self.__max\n        self.__remove(v1)\n        return v1\n\n    def __remove(self, a1):\n        v1 = self.__val_to_idxs[a1][-1]\n        self.__val_to_idxs[a1].pop()\n        if not self.__val_to_idxs[a1]:\n            del self.__val_to_idxs[a1]\n        del self.__idx_to_val[v1]\n        if a1 == self.__top:\n            self.__top = self.__idx_to_val[max(self.__idx_to_val.keys())] if self.__idx_to_val else None\n        if a1 == self.__max:\n            self.__max = max(self.__val_to_idxs.keys()) if self.__val_to_idxs else None\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.__idx_to_val = collections.defaultdict(int)\n        self.__val_to_idxs = collections.defaultdict(list)\n        self.__top = None\n        self.__max = None\n\n    def push(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = self.__val_to_idxs[self.__top][-1] + 1 if self.__val_to_idxs else 0\n        self.__idx_to_val[v1] = a1\n        self.__val_to_idxs[a1].append(v1)\n        self.__top = a1\n        self.__max = max(self.__max, a1)\n\n    def pop(self):\n        \"\"\"\n        \"\"\"\n        v1 = self.__top\n        self.__remove(v1)\n        return v1\n\n    def top(self):\n        \"\"\"\n        \"\"\"\n        return self.__top\n\n    def peekMax(self):\n        \"\"\"\n        \"\"\"\n        return self.__max\n\n    def popMax(self):\n        \"\"\"\n        \"\"\"\n        v1 = self.__max\n        self.__remove(v1)\n        return v1\n\n    def __remove(self, a1):\n        v1 = self.__val_to_idxs[a1][-1]\n        self.__val_to_idxs[a1].pop()\n        if not self.__val_to_idxs[a1]:\n            del self.__val_to_idxs[a1]\n        del self.__idx_to_val[v1]\n        if a1 == self.__top:\n            self.__top = self.__idx_to_val[max(self.__idx_to_val.keys())] if self.__idx_to_val else None\n        if a1 == self.__max:\n            self.__max = max(self.__val_to_idxs.keys()) if self.__val_to_idxs else None\n"}
{"id": "human_code\\maximum-and-minimum-sums-of-at-most-size-k-subsequences__part1.py", "text": "from functools import reduce\nv1 = 10 ** 9 + 7\nv2, v3, v4 = [[1] * 2 for v5 in range(3)]\n\ndef f1(a1, a2):\n    if a1 < a2:\n        return 0\n    while len(v3) <= a1:\n        v2.append(v2[-1] * len(v3) % v1)\n        v3.append(v3[v1 % len(v3)] * (v1 - v1 // len(v3)) % v1)\n        v4.append(v4[-1] * v3[-1] % v1)\n    return v2[a1] * v4[a1 - a2] % v1 * v4[a2] % v1\n\nclass C1(object):\n\n    def minMaxSums(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        a1.sort()\n        v2 = 0\n        v3 = 1\n        for v4 in range(len(a1)):\n            v2 = (v2 + (a1[v4] + a1[~v4]) * v3) % v1\n            v3 = (v3 * 2 - f1(v4, a2 - 1)) % v1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from functools import reduce\nv1 = 10 ** 9 + 7\nv2, v3, v4 = [[1] * 2 for v5 in range(3)]\n\ndef f1(a1, a2):\n    if a1 < a2:\n        return 0\n    while len(v3) <= a1:\n        v2.append(v2[-1] * len(v3) % v1)\n        v3.append(v3[v1 % len(v3)] * (v1 - v1 // len(v3)) % v1)\n        v4.append(v4[-1] * v3[-1] % v1)\n    return v2[a1] * v4[a1 - a2] % v1 * v4[a2] % v1\n\nclass C1(object):\n\n    def minMaxSums(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        a1.sort()\n        v2 = 0\n        v3 = 1\n        for v4 in range(len(a1)):\n            v2 = (v2 + (a1[v4] + a1[~v4]) * v3) % v1\n            v3 = (v3 * 2 - f1(v4, a2 - 1)) % v1\n        return v2\n"}
{"id": "human_code\\jump-game-v__part3.py", "text": "class C1(object):\n\n    def maxJumps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (list(range(len(a1))), [])\n        for v3 in range(len(a1)):\n            while v2 and a1[v2[-1]] < a1[v3]:\n                if v3 - v2[-1] <= a2:\n                    v1[v3] = v2[-1]\n                v2.pop()\n            v2.append(v3)\n        v4, v2 = (list(range(len(a1))), [])\n        for v3 in reversed(range(len(a1))):\n            while v2 and a1[v2[-1]] < a1[v3]:\n                if v2[-1] - v3 <= a2:\n                    v4[v3] = v2[-1]\n                v2.pop()\n            v2.append(v3)\n        v5 = SegmentTree(len(a1))\n        for v6, v3 in sorted(([x, v3] for v3, v7 in enumerate(a1))):\n            v5.update(v3, v3, v5.query(v1[v3], v4[v3]) + 1)\n        return v5.query(0, len(a1) - 1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxJumps(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (list(range(len(a1))), [])\n        for v3 in range(len(a1)):\n            while v2 and a1[v2[-1]] < a1[v3]:\n                if v3 - v2[-1] <= a2:\n                    v1[v3] = v2[-1]\n                v2.pop()\n            v2.append(v3)\n        v4, v2 = (list(range(len(a1))), [])\n        for v3 in reversed(range(len(a1))):\n            while v2 and a1[v2[-1]] < a1[v3]:\n                if v2[-1] - v3 <= a2:\n                    v4[v3] = v2[-1]\n                v2.pop()\n            v2.append(v3)\n        v5 = SegmentTree(len(a1))\n        for v6, v3 in sorted(([x, v3] for v3, v7 in enumerate(a1))):\n            v5.update(v3, v3, v5.query(v1[v3], v4[v3]) + 1)\n        return v5.query(0, len(a1) - 1)\n"}
{"id": "llm_code\\number-of-valid-words-in-a-sentence__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def countValidWords(self, a1):\n\n        def is_valid(a1):\n            if not a1:\n                return False\n            v1 = len(a1)\n            v2 = False\n            for v3 in range(v1):\n                v4 = a1[v3]\n                if v4.isdigit():\n                    return False\n                if v4 == '-':\n                    if v2 or v3 == 0 or v3 == v1 - 1 or (not (a1[v3 - 1].isalpha() and a1[v3 + 1].isalpha())):\n                        return False\n                    v2 = True\n                elif v4 in '!,.':\n                    if v3 != v1 - 1:\n                        return False\n                elif not v4.isalpha():\n                    return False\n            return True\n        return sum((1 for v1 in a1.split() if is_valid(v1)))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def countValidWords(self, a1):\n\n        def is_valid(a1):\n            if not a1:\n                return False\n            v1 = len(a1)\n            v2 = False\n            for v3 in range(v1):\n                v4 = a1[v3]\n                if v4.isdigit():\n                    return False\n                if v4 == '-':\n                    if v2 or v3 == 0 or v3 == v1 - 1 or (not (a1[v3 - 1].isalpha() and a1[v3 + 1].isalpha())):\n                        return False\n                    v2 = True\n                elif v4 in '!,.':\n                    if v3 != v1 - 1:\n                        return False\n                elif not v4.isalpha():\n                    return False\n            return True\n        return sum((1 for v1 in a1.split() if is_valid(v1)))\n"}
{"id": "human_code\\find-the-median-of-the-uniqueness-array.py", "text": "import collections\n\nclass C1(object):\n\n    def medianOfUniquenessArray(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def check(a1):\n            v1 = 0\n            v2 = collections.Counter()\n            v3 = 0\n            for v4 in range(len(a1)):\n                v2[a1[v4]] += 1\n                while len(v2) == a1 + 1:\n                    v2[a1[v3]] -= 1\n                    if v2[a1[v3]] == 0:\n                        del v2[a1[v3]]\n                    v3 += 1\n                v1 += v4 - v3 + 1\n            return v1 >= total - v1\n        v1 = (len(a1) + 1) * len(a1) // 2\n        return binary_search(1, len(set(a1)), check)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def medianOfUniquenessArray(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def check(a1):\n            v1 = 0\n            v2 = collections.Counter()\n            v3 = 0\n            for v4 in range(len(a1)):\n                v2[a1[v4]] += 1\n                while len(v2) == a1 + 1:\n                    v2[a1[v3]] -= 1\n                    if v2[a1[v3]] == 0:\n                        del v2[a1[v3]]\n                    v3 += 1\n                v1 += v4 - v3 + 1\n            return v1 >= total - v1\n        v1 = (len(a1) + 1) * len(a1) // 2\n        return binary_search(1, len(set(a1)), check)\n"}
{"id": "llm_code\\majority-element-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def majorityElement(self, a1):\n        v1 = v2 = None\n        v3 = v4 = 0\n        for v5 in a1:\n            if v1 == v5:\n                v3 += 1\n            elif v2 == v5:\n                v4 += 1\n            elif v3 == 0:\n                v1 = v5\n                v3 = 1\n            elif v4 == 0:\n                v2 = v5\n                v4 = 1\n            else:\n                v3 -= 1\n                v4 -= 1\n        v3 = v4 = 0\n        v6 = len(a1)\n        v7 = v6 // 3\n        for v5 in a1:\n            if v1 == v5:\n                v3 += 1\n            if v2 == v5:\n                v4 += 1\n        v8 = []\n        if v3 > v7:\n            v8.append(v1)\n        if v4 > v7:\n            v8.append(v2)\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def majorityElement(self, a1):\n        v1 = v2 = None\n        v3 = v4 = 0\n        for v5 in a1:\n            if v1 == v5:\n                v3 += 1\n            elif v2 == v5:\n                v4 += 1\n            elif v3 == 0:\n                v1 = v5\n                v3 = 1\n            elif v4 == 0:\n                v2 = v5\n                v4 = 1\n            else:\n                v3 -= 1\n                v4 -= 1\n        v3 = v4 = 0\n        v6 = len(a1)\n        v7 = v6 // 3\n        for v5 in a1:\n            if v1 == v5:\n                v3 += 1\n            if v2 == v5:\n                v4 += 1\n        v8 = []\n        if v3 > v7:\n            v8.append(v1)\n        if v4 > v7:\n            v8.append(v2)\n        return v8\n"}
{"id": "human_code\\p02846__s520336695.py", "text": "v1, v2 = map(int, input().split())\nv3, v4 = map(int, input().split())\nv5, v6 = map(int, input().split())\nif v3 > v5 and v4 > v6:\n    print(0)\n    exit()\nif v5 > v3 and v6 > v4:\n    print(0)\n    exit()\nif v3 < v5 and v4 > v6:\n    v3, v5 = (v5, v3)\n    v4, v6 = (v6, v4)\nv7 = abs(v3 - v5)\nv8 = abs(v4 - v6)\nv9 = v7 * v1\nv10 = v8 * v2\nv11 = v10 - v9\nif v11 < 0:\n    print(0)\n    exit()\nif v11 == 0:\n    print('infinity')\n    exit()\nif v9 % v11 != 0:\n    v12 = v9 // v11 * 2 + 1\nelse:\n    v12 = (v9 // v11 - 1) * 2 + 2\nprint(v12)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3, v4 = map(int, input().split())\nv5, v6 = map(int, input().split())\nif v3 > v5 and v4 > v6:\n    print(0)\n    exit()\nif v5 > v3 and v6 > v4:\n    print(0)\n    exit()\nif v3 < v5 and v4 > v6:\n    v3, v5 = (v5, v3)\n    v4, v6 = (v6, v4)\nv7 = abs(v3 - v5)\nv8 = abs(v4 - v6)\nv9 = v7 * v1\nv10 = v8 * v2\nv11 = v10 - v9\nif v11 < 0:\n    print(0)\n    exit()\nif v11 == 0:\n    print('infinity')\n    exit()\nif v9 % v11 != 0:\n    v12 = v9 // v11 * 2 + 1\nelse:\n    v12 = (v9 // v11 - 1) * 2 + 2\nprint(v12)\n"}
{"id": "human_code\\search-suggestions-system__part2.py", "text": "class C1(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(C1)\n        self.infos = []\n\n    def insert(self, a1, a2):\n        v1 = self\n        for v2 in a1[a2]:\n            v1 = v1.leaves[v2]\n            v1.add_info(a2)\n\n    def add_info(self, a1):\n        if len(self.infos) == self.__TOP_COUNT:\n            return\n        self.infos.append(a1)\n\nclass C2(object):\n\n    def suggestedProducts(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        a1.sort()\n        v1 = C1()\n        for v2 in range(len(a1)):\n            v1.insert(a1, v2)\n        v3 = [[] for v4 in range(len(a2))]\n        for v2, v5 in enumerate(a2):\n            if v5 not in v1.leaves:\n                break\n            v1 = v1.leaves[v5]\n            v3[v2] = [a1[x] for v6 in v1.infos]\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self):\n        self.__TOP_COUNT = 3\n        self.leaves = collections.defaultdict(C1)\n        self.infos = []\n\n    def insert(self, a1, a2):\n        v1 = self\n        for v2 in a1[a2]:\n            v1 = v1.leaves[v2]\n            v1.add_info(a2)\n\n    def add_info(self, a1):\n        if len(self.infos) == self.__TOP_COUNT:\n            return\n        self.infos.append(a1)\n\nclass C2(object):\n\n    def suggestedProducts(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        a1.sort()\n        v1 = C1()\n        for v2 in range(len(a1)):\n            v1.insert(a1, v2)\n        v3 = [[] for v4 in range(len(a2))]\n        for v2, v5 in enumerate(a2):\n            if v5 not in v1.leaves:\n                break\n            v1 = v1.leaves[v5]\n            v3[v2] = [a1[x] for v6 in v1.infos]\n        return v3\n"}
{"id": "llm_code\\palindrome-removal__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minimumMoves(self, a1):\n        v1 = len(a1)\n        v2 = {}\n\n        def compute(a1, a2):\n            if a1 > a2:\n                return 0\n            if a1 == a2:\n                return 1\n            v1 = (a1, a2)\n            if v1 in v2:\n                return v2[v1]\n            v2 = 1 + compute(a1 + 1, a2)\n            if a1 + 1 <= a2 and a1[a1] == a1[a1 + 1]:\n                v2 = min(v2, 1 + compute(a1 + 2, a2))\n            for v3 in range(a1 + 2, a2 + 1):\n                if a1[a1] == a1[v3]:\n                    v2 = min(v2, compute(a1 + 1, v3 - 1) + compute(v3 + 1, a2))\n            v2[v1] = v2\n            return v2\n        return compute(0, v1 - 1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumMoves(self, a1):\n        v1 = len(a1)\n        v2 = {}\n\n        def compute(a1, a2):\n            if a1 > a2:\n                return 0\n            if a1 == a2:\n                return 1\n            v1 = (a1, a2)\n            if v1 in v2:\n                return v2[v1]\n            v2 = 1 + compute(a1 + 1, a2)\n            if a1 + 1 <= a2 and a1[a1] == a1[a1 + 1]:\n                v2 = min(v2, 1 + compute(a1 + 2, a2))\n            for v3 in range(a1 + 2, a2 + 1):\n                if a1[a1] == a1[v3]:\n                    v2 = min(v2, compute(a1 + 1, v3 - 1) + compute(v3 + 1, a2))\n            v2[v1] = v2\n            return v2\n        return compute(0, v1 - 1)\n"}
{"id": "llm_code\\find-the-maximum-sequence-value-of-array__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxValue(self, a1, a2):\n        v1 = len(a1)\n        v2 = 128\n        v3 = 10 ** 9\n        v4 = [v3] * v2\n        v5 = [0] * v2\n        v6 = [v1] * v2\n        for v7 in range(v1):\n            v8 = a1[v7]\n            v4[v8] = 1\n            for v9 in range(v2):\n                if v8 & v9 == v8:\n                    v5[v9] += 1\n                v4[v9 | v8] = min(v4[v9 | v8], v4[v9] + 1)\n            for v9 in range(v2):\n                if v5[v9] >= a2 and v4[v9] <= a2 and (v6[v9] == v1):\n                    v6[v9] = v7\n        v10 = [v3] * v2\n        v11 = [0] * v2\n        v12 = [-1] * v2\n        for v7 in range(v1 - 1, -1, -1):\n            v8 = a1[v7]\n            v10[v8] = 1\n            for v9 in range(v2):\n                if v8 & v9 == v8:\n                    v11[v9] += 1\n                v10[v9 | v8] = min(v10[v9 | v8], v10[v9] + 1)\n            for v9 in range(v2):\n                if v11[v9] >= a2 and v10[v9] <= a2 and (v12[v9] == -1):\n                    v12[v9] = v7\n        for v13 in range(v2 - 1, -1, -1):\n            for v14 in range(1, v2):\n                v15 = v13 ^ v14\n                if v6[v14] < v12[v15]:\n                    return v13\n        return 0\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxValue(self, a1, a2):\n        v1 = len(a1)\n        v2 = 128\n        v3 = 10 ** 9\n        v4 = [v3] * v2\n        v5 = [0] * v2\n        v6 = [v1] * v2\n        for v7 in range(v1):\n            v8 = a1[v7]\n            v4[v8] = 1\n            for v9 in range(v2):\n                if v8 & v9 == v8:\n                    v5[v9] += 1\n                v4[v9 | v8] = min(v4[v9 | v8], v4[v9] + 1)\n            for v9 in range(v2):\n                if v5[v9] >= a2 and v4[v9] <= a2 and (v6[v9] == v1):\n                    v6[v9] = v7\n        v10 = [v3] * v2\n        v11 = [0] * v2\n        v12 = [-1] * v2\n        for v7 in range(v1 - 1, -1, -1):\n            v8 = a1[v7]\n            v10[v8] = 1\n            for v9 in range(v2):\n                if v8 & v9 == v8:\n                    v11[v9] += 1\n                v10[v9 | v8] = min(v10[v9 | v8], v10[v9] + 1)\n            for v9 in range(v2):\n                if v11[v9] >= a2 and v10[v9] <= a2 and (v12[v9] == -1):\n                    v12[v9] = v7\n        for v13 in range(v2 - 1, -1, -1):\n            for v14 in range(1, v2):\n                v15 = v13 ^ v14\n                if v6[v14] < v12[v15]:\n                    return v13\n        return 0\n"}
{"id": "human_code\\sliding-window-median__part2.py", "text": "import collections\nimport heapq\n\nclass C1(object):\n\n    def medianSlidingWindow(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def lazy_delete(a1, a2, a3):\n            while a1 and a3 * a1[0] in a2:\n                a2[a3 * a1[0]] -= 1\n                if not a2[a3 * a1[0]]:\n                    del a2[a3 * a1[0]]\n                heapq.heappop(a1)\n\n        def full_delete(a1, a2, a3):\n            v1 = []\n            for v2 in a1:\n                if a3 * v2 not in a2:\n                    v1.append(v2)\n                    continue\n                a2[a3 * v2] -= 1\n                if not a2[a3 * v2]:\n                    del a2[a3 * v2]\n            a1[:] = v1\n            heapq.heapify(a1)\n        v1, v2 = ([], [])\n        for v3 in range(a2):\n            if v3 % 2 == 0:\n                heapq.heappush(v1, -heapq.heappushpop(v2, -a1[v3]))\n            else:\n                heapq.heappush(v2, -heapq.heappushpop(v1, a1[v3]))\n        v4 = [float(v1[0])] if a2 % 2 else [(v1[0] - v2[0]) / 2.0]\n        v5 = collections.defaultdict(int)\n        for v3 in range(a2, len(a1)):\n            heapq.heappush(v2, -heapq.heappushpop(v1, a1[v3]))\n            if a1[v3 - a2] > -v2[0]:\n                heapq.heappush(v1, -heapq.heappop(v2))\n            v5[a1[v3 - a2]] += 1\n            lazy_delete(v2, v5, -1)\n            lazy_delete(v1, v5, 1)\n            if len(v1) + len(v2) > 2 * a2:\n                full_delete(v2, v5, -1)\n                full_delete(v1, v5, 1)\n            v4.append(float(v1[0]) if a2 % 2 else (v1[0] - v2[0]) / 2.0)\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport heapq\n\nclass C1(object):\n\n    def medianSlidingWindow(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def lazy_delete(a1, a2, a3):\n            while a1 and a3 * a1[0] in a2:\n                a2[a3 * a1[0]] -= 1\n                if not a2[a3 * a1[0]]:\n                    del a2[a3 * a1[0]]\n                heapq.heappop(a1)\n\n        def full_delete(a1, a2, a3):\n            v1 = []\n            for v2 in a1:\n                if a3 * v2 not in a2:\n                    v1.append(v2)\n                    continue\n                a2[a3 * v2] -= 1\n                if not a2[a3 * v2]:\n                    del a2[a3 * v2]\n            a1[:] = v1\n            heapq.heapify(a1)\n        v1, v2 = ([], [])\n        for v3 in range(a2):\n            if v3 % 2 == 0:\n                heapq.heappush(v1, -heapq.heappushpop(v2, -a1[v3]))\n            else:\n                heapq.heappush(v2, -heapq.heappushpop(v1, a1[v3]))\n        v4 = [float(v1[0])] if a2 % 2 else [(v1[0] - v2[0]) / 2.0]\n        v5 = collections.defaultdict(int)\n        for v3 in range(a2, len(a1)):\n            heapq.heappush(v2, -heapq.heappushpop(v1, a1[v3]))\n            if a1[v3 - a2] > -v2[0]:\n                heapq.heappush(v1, -heapq.heappop(v2))\n            v5[a1[v3 - a2]] += 1\n            lazy_delete(v2, v5, -1)\n            lazy_delete(v1, v5, 1)\n            if len(v1) + len(v2) > 2 * a2:\n                full_delete(v2, v5, -1)\n                full_delete(v1, v5, 1)\n            v4.append(float(v1[0]) if a2 % 2 else (v1[0] - v2[0]) / 2.0)\n        return v4\n"}
{"id": "llm_code\\find-leaves-of-binary-tree__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def findLeaves(self, a1):\n        if not a1:\n            return []\n        v1 = {}\n\n        def get_height(a1):\n            if a1 is None:\n                return -1\n            if a1 in v1:\n                return v1[a1]\n            v1 = get_height(a1.left)\n            v2 = get_height(a1.right)\n            v1[a1] = 1 + max(v1, v2)\n            return v1[a1]\n        get_height(a1)\n        v2 = v1[a1]\n        v3 = [[] for v4 in range(v2 + 1)]\n\n        def assign(a1):\n            if a1 is None:\n                return\n            assign(a1.left)\n            assign(a1.right)\n            v3[v1[a1]].append(a1.val)\n        assign(a1)\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def findLeaves(self, a1):\n        if not a1:\n            return []\n        v1 = {}\n\n        def get_height(a1):\n            if a1 is None:\n                return -1\n            if a1 in v1:\n                return v1[a1]\n            v1 = get_height(a1.left)\n            v2 = get_height(a1.right)\n            v1[a1] = 1 + max(v1, v2)\n            return v1[a1]\n        get_height(a1)\n        v2 = v1[a1]\n        v3 = [[] for v4 in range(v2 + 1)]\n\n        def assign(a1):\n            if a1 is None:\n                return\n            assign(a1.left)\n            assign(a1.right)\n            v3[v1[a1]].append(a1.val)\n        assign(a1)\n        return v3\n"}
{"id": "llm_code\\flatten-a-multilevel-doubly-linked-list__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4):\n        self.val = a1\n        self.prev = a2\n        self.next = a3\n        self.child = a4\n\nclass C2(object):\n\n    def flatten(self, a1):\n        v1 = a1\n        while v1:\n            if v1.child:\n                v2 = v1.child\n                v3 = v2\n                while v3.next:\n                    v3 = v3.next\n                v3.next = v1.next\n                if v1.next:\n                    v1.next.prev = v3\n                v1.next = v2\n                v2.prev = v1\n                v1.child = None\n            v1 = v1.next\n        return a1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4):\n        self.val = a1\n        self.prev = a2\n        self.next = a3\n        self.child = a4\n\nclass C2(object):\n\n    def flatten(self, a1):\n        v1 = a1\n        while v1:\n            if v1.child:\n                v2 = v1.child\n                v3 = v2\n                while v3.next:\n                    v3 = v3.next\n                v3.next = v1.next\n                if v1.next:\n                    v1.next.prev = v3\n                v1.next = v2\n                v2.prev = v1\n                v1.child = None\n            v1 = v1.next\n        return a1\n"}
{"id": "llm_code\\generalized-abbreviation__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def generateAbbreviations(self, a1):\n        v1 = len(a1)\n        v2 = []\n        for v3 in range(1 << v1):\n            v4 = [-1]\n            for v5 in range(v1):\n                if v3 & 1 << v5:\n                    v4.append(v5)\n            v4.append(v1)\n            v6 = []\n            for v7 in range(1, len(v4)):\n                v8 = v4[v7 - 1]\n                v9 = v4[v7]\n                v10 = v9 - v8 - 1\n                if v10 > 0:\n                    v6.append(str(v10))\n                if v9 < v1:\n                    v6.append(a1[v9])\n            v2.append(''.join(v6))\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def generateAbbreviations(self, a1):\n        v1 = len(a1)\n        v2 = []\n        for v3 in range(1 << v1):\n            v4 = [-1]\n            for v5 in range(v1):\n                if v3 & 1 << v5:\n                    v4.append(v5)\n            v4.append(v1)\n            v6 = []\n            for v7 in range(1, len(v4)):\n                v8 = v4[v7 - 1]\n                v9 = v4[v7]\n                v10 = v9 - v8 - 1\n                if v10 > 0:\n                    v6.append(str(v10))\n                if v9 < v1:\n                    v6.append(a1[v9])\n            v2.append(''.join(v6))\n        return v2\n"}
{"id": "human_code\\longest-common-prefix-of-k-strings-after-removal__part3.py", "text": "class C1(object):\n\n    def longestCommonPrefix(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self):\n                self.__nodes = []\n                self.__cnt = []\n                self.__mx = []\n                self.__new_node()\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 26)\n                self.__cnt.append(0)\n                self.__mx.append(0)\n                return len(self.__nodes) - 1\n\n            def update(self, a1, a2, a3):\n                v1 = [-1] * (len(a1) + 1)\n                v1[0] = v2 = 0\n                for v3, v4 in enumerate(a1, 1):\n                    v5 = ord(v4) - ord('a')\n                    if self.__nodes[v2][v5] == -1:\n                        self.__nodes[v2][v5] = self.__new_node()\n                    v1[v3] = v2 = self.__nodes[v2][v5]\n                for v3 in reversed(range(len(v1))):\n                    v2 = v1[v3]\n                    self.__cnt[v2] += a2\n                    self.__mx[v2] = v3 if self.__cnt[v2] >= a3 else 0\n                    for v5 in range(len(self.__nodes[v2])):\n                        if self.__nodes[v2][v5] != -1:\n                            self.__mx[v2] = max(self.__mx[v2], self.__mx[self.__nodes[v2][v5]])\n\n            def query(self):\n                return self.__mx[0]\n        v1 = [0] * len(a1)\n        v2 = Trie()\n        for v3 in a1:\n            v2.update(v3, +1, a2)\n        for v4 in range(len(a1)):\n            v2.update(a1[v4], -1, a2)\n            v1[v4] = v2.query()\n            v2.update(a1[v4], +1, a2)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestCommonPrefix(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self):\n                self.__nodes = []\n                self.__cnt = []\n                self.__mx = []\n                self.__new_node()\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 26)\n                self.__cnt.append(0)\n                self.__mx.append(0)\n                return len(self.__nodes) - 1\n\n            def update(self, a1, a2, a3):\n                v1 = [-1] * (len(a1) + 1)\n                v1[0] = v2 = 0\n                for v3, v4 in enumerate(a1, 1):\n                    v5 = ord(v4) - ord('a')\n                    if self.__nodes[v2][v5] == -1:\n                        self.__nodes[v2][v5] = self.__new_node()\n                    v1[v3] = v2 = self.__nodes[v2][v5]\n                for v3 in reversed(range(len(v1))):\n                    v2 = v1[v3]\n                    self.__cnt[v2] += a2\n                    self.__mx[v2] = v3 if self.__cnt[v2] >= a3 else 0\n                    for v5 in range(len(self.__nodes[v2])):\n                        if self.__nodes[v2][v5] != -1:\n                            self.__mx[v2] = max(self.__mx[v2], self.__mx[self.__nodes[v2][v5]])\n\n            def query(self):\n                return self.__mx[0]\n        v1 = [0] * len(a1)\n        v2 = Trie()\n        for v3 in a1:\n            v2.update(v3, +1, a2)\n        for v4 in range(len(a1)):\n            v2.update(a1[v4], -1, a2)\n            v1[v4] = v2.query()\n            v2.update(a1[v4], +1, a2)\n        return v1\n"}
{"id": "llm_code\\remove-k-balanced-substrings__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def removeSubstring(self, a1, a2):\n        v1 = []\n        v2 = [0]\n        v3 = 2 * a2\n        for v4 in a1:\n            v1.append(v4)\n            if v4 == '(':\n                if v2[0] < a2:\n                    v2[0] += 1\n                elif v2[0] > a2:\n                    v2[0] = 1\n            elif v2[0] >= a2:\n                v2[0] += 1\n            else:\n                v2[0] = 0\n            if v2[0] == v3:\n                for v5 in range(v3):\n                    v1.pop()\n                v2[0] = 0\n                v6 = max(0, len(v1) - v3 + 1)\n                for v7 in range(v6, len(v1)):\n                    v8 = v1[v7]\n                    if v8 == '(':\n                        if v2[0] < a2:\n                            v2[0] += 1\n                        elif v2[0] > a2:\n                            v2[0] = 1\n                    elif v2[0] >= a2:\n                        v2[0] += 1\n                    else:\n                        v2[0] = 0\n        return ''.join(v1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def removeSubstring(self, a1, a2):\n        v1 = []\n        v2 = [0]\n        v3 = 2 * a2\n        for v4 in a1:\n            v1.append(v4)\n            if v4 == '(':\n                if v2[0] < a2:\n                    v2[0] += 1\n                elif v2[0] > a2:\n                    v2[0] = 1\n            elif v2[0] >= a2:\n                v2[0] += 1\n            else:\n                v2[0] = 0\n            if v2[0] == v3:\n                for v5 in range(v3):\n                    v1.pop()\n                v2[0] = 0\n                v6 = max(0, len(v1) - v3 + 1)\n                for v7 in range(v6, len(v1)):\n                    v8 = v1[v7]\n                    if v8 == '(':\n                        if v2[0] < a2:\n                            v2[0] += 1\n                        elif v2[0] > a2:\n                            v2[0] = 1\n                    elif v2[0] >= a2:\n                        v2[0] += 1\n                    else:\n                        v2[0] = 0\n        return ''.join(v1)\n"}
{"id": "llm_code\\online-election__grok-4.1-fast__v1.py", "text": "from collections import Counter\nimport bisect\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        self.vote_times = a2\n        self.leader_at = []\n        v1 = Counter()\n        v2 = -1\n        v3 = 0\n        for v4 in a1:\n            v1[v4] += 1\n            if v1[v4] > v3:\n                v3 = v1[v4]\n                v2 = v4\n            elif v1[v4] == v3:\n                v2 = v4\n            self.leader_at.append(v2)\n\n    def q(self, a1):\n        v1 = bisect.bisect_right(self.vote_times, a1) - 1\n        return self.leader_at[v1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import Counter\nimport bisect\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        self.vote_times = a2\n        self.leader_at = []\n        v1 = Counter()\n        v2 = -1\n        v3 = 0\n        for v4 in a1:\n            v1[v4] += 1\n            if v1[v4] > v3:\n                v3 = v1[v4]\n                v2 = v4\n            elif v1[v4] == v3:\n                v2 = v4\n            self.leader_at.append(v2)\n\n    def q(self, a1):\n        v1 = bisect.bisect_right(self.vote_times, a1) - 1\n        return self.leader_at[v1]\n"}
{"id": "llm_code\\minimum-addition-to-make-integer-beautiful__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def makeIntegerBeautiful(self, a1, a2):\n        v1 = 0\n        v2 = a1\n        while v2 > 0:\n            v1 += v2 % 10\n            v2 //= 10\n        if v1 <= a2:\n            return 0\n        v3 = 0\n        v4 = a1\n        while v1 > a2:\n            v5 = 10\n            while v4 // v5 % 10 == 9:\n                v5 *= 10\n            v6 = v4 % v5\n            v7 = 0\n            v8 = v6\n            while v8 > 0:\n                v7 += v8 % 10\n                v8 //= 10\n            v1 += 1 - v7\n            v9 = v5 - v6\n            v3 += v9\n            v4 += v9\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def makeIntegerBeautiful(self, a1, a2):\n        v1 = 0\n        v2 = a1\n        while v2 > 0:\n            v1 += v2 % 10\n            v2 //= 10\n        if v1 <= a2:\n            return 0\n        v3 = 0\n        v4 = a1\n        while v1 > a2:\n            v5 = 10\n            while v4 // v5 % 10 == 9:\n                v5 *= 10\n            v6 = v4 % v5\n            v7 = 0\n            v8 = v6\n            while v8 > 0:\n                v7 += v8 % 10\n                v8 //= 10\n            v1 += 1 - v7\n            v9 = v5 - v6\n            v3 += v9\n            v4 += v9\n        return v3\n"}
{"id": "human_code\\find-building-where-alice-and-bob-can-meet__part3.py", "text": "class C1(object):\n\n    def leftmostBuildingQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binary_search_right(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if not a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a2\n        v1 = [-1] * len(a2)\n        v2 = [[] for v3 in range(len(a1))]\n        for v4, (v5, v6) in enumerate(a2):\n            if v5 > v6:\n                v5, v6 = (v6, v5)\n            if v5 == v6 or a1[v5] < a1[v6]:\n                v1[v4] = v6\n            else:\n                v2[v6].append((a1[v5], v4))\n        v7 = []\n        for v6 in reversed(range(len(a1))):\n            while v7 and v7[-1][0] <= a1[v6]:\n                v7.pop()\n            v7.append((a1[v6], v6))\n            for v8, v4 in v2[v6]:\n                v9 = binary_search_right(0, len(v7) - 1, lambda x: v7[x][0] > v8)\n                if v9 >= 0:\n                    v1[v4] = v7[v9][1]\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def leftmostBuildingQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binary_search_right(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if not a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a2\n        v1 = [-1] * len(a2)\n        v2 = [[] for v3 in range(len(a1))]\n        for v4, (v5, v6) in enumerate(a2):\n            if v5 > v6:\n                v5, v6 = (v6, v5)\n            if v5 == v6 or a1[v5] < a1[v6]:\n                v1[v4] = v6\n            else:\n                v2[v6].append((a1[v5], v4))\n        v7 = []\n        for v6 in reversed(range(len(a1))):\n            while v7 and v7[-1][0] <= a1[v6]:\n                v7.pop()\n            v7.append((a1[v6], v6))\n            for v8, v4 in v2[v6]:\n                v9 = binary_search_right(0, len(v7) - 1, lambda x: v7[x][0] > v8)\n                if v9 >= 0:\n                    v1[v4] = v7[v9][1]\n        return v1\n"}
{"id": "llm_code\\merge-in-between-linked-lists__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.next = a2\n\nclass C2(object):\n\n    def mergeInBetween(self, a1, a2, a3, a4):\n        v1 = C1(0)\n        v1.next = a1\n        v2 = v1\n        for v3 in range(a2):\n            v2 = v2.next\n        v4 = v2.next\n        for v3 in range(a3 - a2 + 1):\n            v4 = v4.next\n        v2.next = a4\n        v5 = a4\n        while v5.next:\n            v5 = v5.next\n        v5.next = v4\n        return v1.next\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.next = a2\n\nclass C2(object):\n\n    def mergeInBetween(self, a1, a2, a3, a4):\n        v1 = C1(0)\n        v1.next = a1\n        v2 = v1\n        for v3 in range(a2):\n            v2 = v2.next\n        v4 = v2.next\n        for v3 in range(a3 - a2 + 1):\n            v4 = v4.next\n        v2.next = a4\n        v5 = a4\n        while v5.next:\n            v5 = v5.next\n        v5.next = v4\n        return v1.next\n"}
{"id": "human_code\\minimum-unique-word-abbreviation__part1.py", "text": "class C1(object):\n\n    def minAbbreviation(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def bits_to_abbr_len(a1, a2):\n            v1 = 0\n            v2 = 0\n            for v3 in range(len(a1)):\n                if a2 & 1:\n                    if v3 - v2 > 0:\n                        v1 += len(str(v3 - v2))\n                    v2 = v3 + 1\n                    v1 += 1\n                elif v3 == len(a1) - 1:\n                    v1 += len(str(v3 - v2 + 1))\n                a2 >>= 1\n            return v1\n\n        def bits_to_abbr(a1, a2):\n            v1 = []\n            v2 = 0\n            for v3 in range(len(a1)):\n                if a2 & 1:\n                    if v3 - v2 > 0:\n                        v1.append(str(v3 - v2))\n                    v2 = v3 + 1\n                    v1.append(a1[v3])\n                elif v3 == len(a1) - 1:\n                    v1.append(str(v3 - v2 + 1))\n                a2 >>= 1\n            return ''.join(v1)\n        v1 = []\n        for v2 in a2:\n            if len(v2) != len(a1):\n                continue\n            v1.append(sum((2 ** i for v3, v4 in enumerate(v2) if a1[v3] != v4)))\n        if not v1:\n            return str(len(a1))\n        v5 = 2 ** len(a1) - 1\n        for v6 in range(2 ** len(a1)):\n            if all((d & v6 for v7 in v1)) and bits_to_abbr_len(a1, v6) < bits_to_abbr_len(a1, v5):\n                v5 = v6\n        return bits_to_abbr(a1, v5)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minAbbreviation(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def bits_to_abbr_len(a1, a2):\n            v1 = 0\n            v2 = 0\n            for v3 in range(len(a1)):\n                if a2 & 1:\n                    if v3 - v2 > 0:\n                        v1 += len(str(v3 - v2))\n                    v2 = v3 + 1\n                    v1 += 1\n                elif v3 == len(a1) - 1:\n                    v1 += len(str(v3 - v2 + 1))\n                a2 >>= 1\n            return v1\n\n        def bits_to_abbr(a1, a2):\n            v1 = []\n            v2 = 0\n            for v3 in range(len(a1)):\n                if a2 & 1:\n                    if v3 - v2 > 0:\n                        v1.append(str(v3 - v2))\n                    v2 = v3 + 1\n                    v1.append(a1[v3])\n                elif v3 == len(a1) - 1:\n                    v1.append(str(v3 - v2 + 1))\n                a2 >>= 1\n            return ''.join(v1)\n        v1 = []\n        for v2 in a2:\n            if len(v2) != len(a1):\n                continue\n            v1.append(sum((2 ** i for v3, v4 in enumerate(v2) if a1[v3] != v4)))\n        if not v1:\n            return str(len(a1))\n        v5 = 2 ** len(a1) - 1\n        for v6 in range(2 ** len(a1)):\n            if all((d & v6 for v7 in v1)) and bits_to_abbr_len(a1, v6) < bits_to_abbr_len(a1, v5):\n                v5 = v6\n        return bits_to_abbr(a1, v5)\n"}
{"id": "human_code\\maximum-length-of-a-concatenated-string-with-unique-characters__part1.py", "text": "v1 = [1]\nv2 = {1: 0}\nfor v3 in range(1, 26):\n    v1.append(v1[-1] << 1)\n    v2[v1[v3]] = v3\n\nclass C1(object):\n\n    def maxLength(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def bitset(a1):\n            v1 = 0\n            for v2 in a1:\n                if v1 & v1[ord(v2) - ord('a')]:\n                    return 0\n                v1 |= v1[ord(v2) - ord('a')]\n            return v1\n\n        def number_of_one(a1):\n            v1 = 0\n            while a1:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n        v1 = [0]\n        for v2 in a1:\n            v3 = bitset(v2)\n            if not v3:\n                continue\n            v4 = len(v1)\n            for v5 in range(v4):\n                if v1[v5] & v3:\n                    continue\n                v1.append(v1[v5] | v3)\n        return max((number_of_one(s_set) for v6 in v1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "v1 = [1]\nv2 = {1: 0}\nfor v3 in range(1, 26):\n    v1.append(v1[-1] << 1)\n    v2[v1[v3]] = v3\n\nclass C1(object):\n\n    def maxLength(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def bitset(a1):\n            v1 = 0\n            for v2 in a1:\n                if v1 & v1[ord(v2) - ord('a')]:\n                    return 0\n                v1 |= v1[ord(v2) - ord('a')]\n            return v1\n\n        def number_of_one(a1):\n            v1 = 0\n            while a1:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n        v1 = [0]\n        for v2 in a1:\n            v3 = bitset(v2)\n            if not v3:\n                continue\n            v4 = len(v1)\n            for v5 in range(v4):\n                if v1[v5] & v3:\n                    continue\n                v1.append(v1[v5] | v3)\n        return max((number_of_one(s_set) for v6 in v1))\n"}
{"id": "llm_code\\longest-palindromic-path-in-graph__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxLen(self, a1, a2, a3):\n        v1 = a1 * (a1 - 1) // 2\n        if len(a2) == v1:\n            v2 = [0] * 26\n            for v3 in a3:\n                v2[ord(v3) - ord('a')] += 1\n            v4 = sum((2 * (f // 2) for v5 in v2))\n            return v4 + (1 if any((v5 % 2 != 0 for v5 in v2)) else 0)\n        v6 = [[] for v7 in range(a1)]\n        for v8, v9 in a2:\n            v6[v8].append(v9)\n            v6[v9].append(v8)\n        v10 = [set() for v7 in range(1 << a1)]\n        for v11 in range(a1):\n            v12 = 1 << v11\n            v10[v12].add((v11, v11))\n        for v8, v9 in a2:\n            if a3[v8] == a3[v9]:\n                v12 = 1 << v8 | 1 << v9\n                v13, v14 = (min(v8, v9), max(v8, v9))\n                v10[v12].add((v13, v14))\n        v15 = [bin(k).count('1') for v16 in range(1 << a1)]\n        v17 = 0\n        for v12 in range(1, 1 << a1):\n            if v10[v12]:\n                v17 = max(v17, v15[v12])\n            for v18 in v10[v12]:\n                v19, v20 = v18\n                for v21 in v6[v19]:\n                    if v12 & 1 << v21:\n                        continue\n                    for v22 in v6[v20]:\n                        if v12 & 1 << v22 or v21 == v22:\n                            continue\n                        if a3[v21] == a3[v22]:\n                            v23 = v12 | 1 << v21 | 1 << v22\n                            v13, v14 = (min(v21, v22), max(v21, v22))\n                            v10[v23].add((v13, v14))\n        return v17\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxLen(self, a1, a2, a3):\n        v1 = a1 * (a1 - 1) // 2\n        if len(a2) == v1:\n            v2 = [0] * 26\n            for v3 in a3:\n                v2[ord(v3) - ord('a')] += 1\n            v4 = sum((2 * (f // 2) for v5 in v2))\n            return v4 + (1 if any((v5 % 2 != 0 for v5 in v2)) else 0)\n        v6 = [[] for v7 in range(a1)]\n        for v8, v9 in a2:\n            v6[v8].append(v9)\n            v6[v9].append(v8)\n        v10 = [set() for v7 in range(1 << a1)]\n        for v11 in range(a1):\n            v12 = 1 << v11\n            v10[v12].add((v11, v11))\n        for v8, v9 in a2:\n            if a3[v8] == a3[v9]:\n                v12 = 1 << v8 | 1 << v9\n                v13, v14 = (min(v8, v9), max(v8, v9))\n                v10[v12].add((v13, v14))\n        v15 = [bin(k).count('1') for v16 in range(1 << a1)]\n        v17 = 0\n        for v12 in range(1, 1 << a1):\n            if v10[v12]:\n                v17 = max(v17, v15[v12])\n            for v18 in v10[v12]:\n                v19, v20 = v18\n                for v21 in v6[v19]:\n                    if v12 & 1 << v21:\n                        continue\n                    for v22 in v6[v20]:\n                        if v12 & 1 << v22 or v21 == v22:\n                            continue\n                        if a3[v21] == a3[v22]:\n                            v23 = v12 | 1 << v21 | 1 << v22\n                            v13, v14 = (min(v21, v22), max(v21, v22))\n                            v10[v23].add((v13, v14))\n        return v17\n"}
{"id": "llm_code\\minimum-cost-to-split-an-array__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minCost(self, a1, a2):\n        v1 = len(a1)\n        v2 = float('inf')\n        v3 = [v2] * (v1 + 1)\n        v3[0] = 0\n        for v4 in range(1, v1 + 1):\n            v5 = [0] * v1\n            v6 = 0\n            for v7 in range(v4 - 1, -1, -1):\n                v8 = a1[v7]\n                v5[v8] += 1\n                if v5[v8] == 1:\n                    v6 += 1\n                elif v5[v8] == 2:\n                    v6 -= 1\n                v9 = v4 - v7\n                v10 = a2 + v9 - v6\n                v3[v4] = min(v3[v4], v3[v7] + v10)\n        return v3[v1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minCost(self, a1, a2):\n        v1 = len(a1)\n        v2 = float('inf')\n        v3 = [v2] * (v1 + 1)\n        v3[0] = 0\n        for v4 in range(1, v1 + 1):\n            v5 = [0] * v1\n            v6 = 0\n            for v7 in range(v4 - 1, -1, -1):\n                v8 = a1[v7]\n                v5[v8] += 1\n                if v5[v8] == 1:\n                    v6 += 1\n                elif v5[v8] == 2:\n                    v6 -= 1\n                v9 = v4 - v7\n                v10 = a2 + v9 - v6\n                v3[v4] = min(v3[v4], v3[v7] + v10)\n        return v3[v1]\n"}
{"id": "human_code\\trapping-rain-water-ii.py", "text": "from heapq import heappush, heappop\n\nclass C1(object):\n\n    def trapRainWater(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = len(a1)\n        if not v1:\n            return 0\n        v2 = len(a1[0])\n        if not v2:\n            return 0\n        v3 = [[False for v4 in range(v2)] for v5 in range(v1)]\n        v6 = []\n        for v4 in range(v1):\n            heappush(v6, [a1[v4][0], v4, 0])\n            v3[v4][0] = True\n            heappush(v6, [a1[v4][v2 - 1], v4, v2 - 1])\n            v3[v4][v2 - 1] = True\n        for v5 in range(1, v2 - 1):\n            heappush(v6, [a1[0][v5], 0, v5])\n            v3[0][v5] = True\n            heappush(v6, [a1[v1 - 1][v5], v1 - 1, v5])\n            v3[v1 - 1][v5] = True\n        v7 = 0\n        while v6:\n            v8, v4, v5 = heappop(v6)\n            for v9, v10 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                v11, v12 = (v4 + v9, v5 + v10)\n                if 0 <= v11 < v1 and 0 <= v12 < v2 and (not v3[v11][v12]):\n                    v7 += max(0, v8 - a1[v11][v12])\n                    heappush(v6, [max(v8, a1[v11][v12]), v11, v12])\n                    v3[v11][v12] = True\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from heapq import heappush, heappop\n\nclass C1(object):\n\n    def trapRainWater(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = len(a1)\n        if not v1:\n            return 0\n        v2 = len(a1[0])\n        if not v2:\n            return 0\n        v3 = [[False for v4 in range(v2)] for v5 in range(v1)]\n        v6 = []\n        for v4 in range(v1):\n            heappush(v6, [a1[v4][0], v4, 0])\n            v3[v4][0] = True\n            heappush(v6, [a1[v4][v2 - 1], v4, v2 - 1])\n            v3[v4][v2 - 1] = True\n        for v5 in range(1, v2 - 1):\n            heappush(v6, [a1[0][v5], 0, v5])\n            v3[0][v5] = True\n            heappush(v6, [a1[v1 - 1][v5], v1 - 1, v5])\n            v3[v1 - 1][v5] = True\n        v7 = 0\n        while v6:\n            v8, v4, v5 = heappop(v6)\n            for v9, v10 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                v11, v12 = (v4 + v9, v5 + v10)\n                if 0 <= v11 < v1 and 0 <= v12 < v2 and (not v3[v11][v12]):\n                    v7 += max(0, v8 - a1[v11][v12])\n                    heappush(v6, [max(v8, a1[v11][v12]), v11, v12])\n                    v3[v11][v12] = True\n        return v7\n"}
{"id": "human_code\\reachable-nodes-in-subdivided-graph.py", "text": "import collections\nimport heapq\n\nclass C1(object):\n\n    def reachableNodes(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a3)]\n        for v3, v4, v5 in a1:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = [(0, 0)]\n        v7 = collections.defaultdict(lambda: float('inf'))\n        v7[0] = 0\n        v8 = collections.defaultdict(lambda: collections.defaultdict(int))\n        v9 = 0\n        while v6:\n            v10, v3 = heapq.heappop(v6)\n            if v7[v3] < v10:\n                continue\n            v9 += 1\n            for v4, v5 in v1[v3]:\n                v8[v3][v4] = min(v5, a2 - v10)\n                v11 = v10 + v5 + 1\n                if v11 <= a2 and v11 < v7[v4]:\n                    v7[v4] = v11\n                    heapq.heappush(v6, (v11, v4))\n        for v3, v4, v5 in a1:\n            v9 += min(v5, v8[v3][v4] + v8[v4][v3])\n        return v9\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport heapq\n\nclass C1(object):\n\n    def reachableNodes(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a3)]\n        for v3, v4, v5 in a1:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = [(0, 0)]\n        v7 = collections.defaultdict(lambda: float('inf'))\n        v7[0] = 0\n        v8 = collections.defaultdict(lambda: collections.defaultdict(int))\n        v9 = 0\n        while v6:\n            v10, v3 = heapq.heappop(v6)\n            if v7[v3] < v10:\n                continue\n            v9 += 1\n            for v4, v5 in v1[v3]:\n                v8[v3][v4] = min(v5, a2 - v10)\n                v11 = v10 + v5 + 1\n                if v11 <= a2 and v11 < v7[v4]:\n                    v7[v4] = v11\n                    heapq.heappush(v6, (v11, v4))\n        for v3, v4, v5 in a1:\n            v9 += min(v5, v8[v3][v4] + v8[v4][v3])\n        return v9\n"}
{"id": "human_code\\lowest-common-ancestor-of-deepest-leaves.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def lcaDeepestLeaves(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def lcaDeepestLeavesHelper(a1):\n            if not a1:\n                return (0, None)\n            v1, v2 = lcaDeepestLeavesHelper(a1.left)\n            v3, v4 = lcaDeepestLeavesHelper(a1.right)\n            if v1 > v3:\n                return (v1 + 1, v2)\n            if v1 < v3:\n                return (v3 + 1, v4)\n            return (v1 + 1, a1)\n        return lcaDeepestLeavesHelper(a1)[1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def lcaDeepestLeaves(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def lcaDeepestLeavesHelper(a1):\n            if not a1:\n                return (0, None)\n            v1, v2 = lcaDeepestLeavesHelper(a1.left)\n            v3, v4 = lcaDeepestLeavesHelper(a1.right)\n            if v1 > v3:\n                return (v1 + 1, v2)\n            if v1 < v3:\n                return (v3 + 1, v4)\n            return (v1 + 1, a1)\n        return lcaDeepestLeavesHelper(a1)[1]\n"}
{"id": "llm_code\\p03032__s594556440.py", "text": "import sys\ninput = sys.stdin.readline\nv1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = []\nv5 = 0\nfor v6 in range(v2 + 1):\n    for v7 in range(v2 - v6 + 1):\n        if v6 + v7 > v1:\n            break\n        v4.append(v3[:v6] + v3[v1 - v7:])\nfor v8 in v4:\n    for v9 in range(v2 - len(v8)):\n        if v8 == []:\n            break\n        elif min(v8) < 0:\n            v8.pop(v8.index(min(v8)))\n        elif min(v8) > 0:\n            break\n        if v8 != []:\n            v10 = sum(v8)\n            if v10 > 0 and v10 > v5:\n                v5 = v10\nprint(v5)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nv1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = []\nv5 = 0\nfor v6 in range(v2 + 1):\n    for v7 in range(v2 - v6 + 1):\n        if v6 + v7 > v1:\n            break\n        v4.append(v3[:v6] + v3[v1 - v7:])\nfor v8 in v4:\n    for v9 in range(v2 - len(v8)):\n        if v8 == []:\n            break\n        elif min(v8) < 0:\n            v8.pop(v8.index(min(v8)))\n        elif min(v8) > 0:\n            break\n        if v8 != []:\n            v10 = sum(v8)\n            if v10 > 0 and v10 > v5:\n                v5 = v10\nprint(v5)\n"}
{"id": "llm_code\\p03147__s169287769.py", "text": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 0\nv4, v5 = (0, 0)\nwhile True:\n    if v4 > v1 - 1 or v5 > v1 - 1:\n        break\n    while v4 < v1 and v2[v4] == 0:\n        v4 += 1\n    if v4 >= v1:\n        break\n    v5 = v4\n    while v5 < v1 and v2[v5] != 0:\n        v5 += 1\n    v6 = min(v2[v4:min(v5, v1)])\n    for v7 in range(v4, min(v5, v1)):\n        v2[v7] -= v6\n    v3 += v6\n    v4 = v5\nprint(v3)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 0\nv4, v5 = (0, 0)\nwhile True:\n    if v4 > v1 - 1 or v5 > v1 - 1:\n        break\n    while v4 < v1 and v2[v4] == 0:\n        v4 += 1\n    if v4 >= v1:\n        break\n    v5 = v4\n    while v5 < v1 and v2[v5] != 0:\n        v5 += 1\n    v6 = min(v2[v4:min(v5, v1)])\n    for v7 in range(v4, min(v5, v1)):\n        v2[v7] -= v6\n    v3 += v6\n    v4 = v5\nprint(v3)\n"}
{"id": "human_code\\p02985__s058342975.py", "text": "v1 = 10 ** 9 + 7\nv2, v3 = map(int, input().split())\nv4 = [[] for v5 in range(v2)]\nfor v5 in range(v2 - 1):\n    v6, v7 = map(int, input().split())\n    v4[v6 - 1] += [v7 - 1]\n    v4[v7 - 1] += [v6 - 1]\nv8 = [0] * v2\nv9 = [0]\nv8[0] = 1\nv10 = v3\nwhile v9:\n    v11 = v9.pop()\n    for v12 in v4[v11]:\n        if v8[v12] > 0:\n            continue\n        else:\n            v10 = v10 * max(v3 - v8[v11], 0) % v1\n            v8[v11] += 1\n            v8[v12] = 2\n            v9.append(v12)\nprint(v10 % v1)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = 10 ** 9 + 7\nv2, v3 = map(int, input().split())\nv4 = [[] for v5 in range(v2)]\nfor v5 in range(v2 - 1):\n    v6, v7 = map(int, input().split())\n    v4[v6 - 1] += [v7 - 1]\n    v4[v7 - 1] += [v6 - 1]\nv8 = [0] * v2\nv9 = [0]\nv8[0] = 1\nv10 = v3\nwhile v9:\n    v11 = v9.pop()\n    for v12 in v4[v11]:\n        if v8[v12] > 0:\n            continue\n        else:\n            v10 = v10 * max(v3 - v8[v11], 0) % v1\n            v8[v11] += 1\n            v8[v12] = 2\n            v9.append(v12)\nprint(v10 % v1)\n"}
{"id": "human_code\\count-nodes-with-the-highest-score__part1.py", "text": "from functools import reduce\n\nclass C1(object):\n\n    def countHighestScoreNodes(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1):\n            v1 = [0] * 2\n            v2 = [(1, (0, [0]))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6 = v4\n                    v7 = [[0] for v8 in range(len(a1[v5]))]\n                    v2.append((2, (v7, v6)))\n                    for v9, v10 in enumerate(a1[v5]):\n                        v2.append((1, (v10, v7[v9])))\n                elif v3 == 2:\n                    v7, v6 = v4\n                    v6[0] = sum((cnt[0] for v11 in v7)) + 1\n                    v12 = max(len(a1) - v6[0], 1) * reduce(lambda x, y: x * y[0], v7, 1)\n                    if v12 > v1[0]:\n                        v1[:] = [v12, 1]\n                    elif v12 == v1[0]:\n                        v1[1] += 1\n            return v1[1]\n        v1 = [[] for v2 in range(len(a1))]\n        for v3 in range(1, len(a1)):\n            v1[a1[v3]].append(v3)\n        return iter_dfs(v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from functools import reduce\n\nclass C1(object):\n\n    def countHighestScoreNodes(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1):\n            v1 = [0] * 2\n            v2 = [(1, (0, [0]))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6 = v4\n                    v7 = [[0] for v8 in range(len(a1[v5]))]\n                    v2.append((2, (v7, v6)))\n                    for v9, v10 in enumerate(a1[v5]):\n                        v2.append((1, (v10, v7[v9])))\n                elif v3 == 2:\n                    v7, v6 = v4\n                    v6[0] = sum((cnt[0] for v11 in v7)) + 1\n                    v12 = max(len(a1) - v6[0], 1) * reduce(lambda x, y: x * y[0], v7, 1)\n                    if v12 > v1[0]:\n                        v1[:] = [v12, 1]\n                    elif v12 == v1[0]:\n                        v1[1] += 1\n            return v1[1]\n        v1 = [[] for v2 in range(len(a1))]\n        for v3 in range(1, len(a1)):\n            v1[a1[v3]].append(v3)\n        return iter_dfs(v1)\n"}
{"id": "human_code\\boundary-of-binary-tree.py", "text": "class C1(object):\n\n    def boundaryOfBinaryTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def leftBoundary(a1, a2):\n            if not a1 or (not a1.left and (not a1.right)):\n                return\n            a2.append(a1.val)\n            if not a1.left:\n                leftBoundary(a1.right, a2)\n            else:\n                leftBoundary(a1.left, a2)\n\n        def rightBoundary(a1, a2):\n            if not a1 or (not a1.left and (not a1.right)):\n                return\n            if not a1.right:\n                rightBoundary(a1.left, a2)\n            else:\n                rightBoundary(a1.right, a2)\n            a2.append(a1.val)\n\n        def leaves(a1, a2):\n            if not a1:\n                return\n            if not a1.left and (not a1.right):\n                a2.append(a1.val)\n                return\n            leaves(a1.left, a2)\n            leaves(a1.right, a2)\n        if not a1:\n            return []\n        v1 = [a1.val]\n        leftBoundary(a1.left, v1)\n        leaves(a1.left, v1)\n        leaves(a1.right, v1)\n        rightBoundary(a1.right, v1)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def boundaryOfBinaryTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def leftBoundary(a1, a2):\n            if not a1 or (not a1.left and (not a1.right)):\n                return\n            a2.append(a1.val)\n            if not a1.left:\n                leftBoundary(a1.right, a2)\n            else:\n                leftBoundary(a1.left, a2)\n\n        def rightBoundary(a1, a2):\n            if not a1 or (not a1.left and (not a1.right)):\n                return\n            if not a1.right:\n                rightBoundary(a1.left, a2)\n            else:\n                rightBoundary(a1.right, a2)\n            a2.append(a1.val)\n\n        def leaves(a1, a2):\n            if not a1:\n                return\n            if not a1.left and (not a1.right):\n                a2.append(a1.val)\n                return\n            leaves(a1.left, a2)\n            leaves(a1.right, a2)\n        if not a1:\n            return []\n        v1 = [a1.val]\n        leftBoundary(a1.left, v1)\n        leaves(a1.left, v1)\n        leaves(a1.right, v1)\n        rightBoundary(a1.right, v1)\n        return v1\n"}
{"id": "human_code\\p03660__s540239406.py", "text": "import sys\nsys.setrecursionlimit(600000)\nv1 = int(input())\nv2 = [[] for v3 in range(v1)]\nfor v3 in range(v1 - 1):\n    v4, v5 = map(int, input().split())\n    v2[v4 - 1].append(v5 - 1)\n    v2[v5 - 1].append(v4 - 1)\n\ndef f1(a1, a2, a3):\n    if a1 == v1 - 1:\n        return (a3, True)\n    v1 = False\n    for v2 in v2[a1]:\n        if not a2[v2]:\n            a3.append(v2)\n            a2[v2] = True\n            v3, v4 = f1(v2, a2, a3)\n            if v4:\n                v5 = v3\n                v1 = True\n    if not v1:\n        a3.pop()\n        return (a3, False)\n    return (v5, True)\nv6 = [False for v3 in range(v1)]\nv6[0] = True\nv7, v8 = f1(0, v6, [0])\nv9 = [0 for v3 in range(v1)]\nv10 = len(v7)\nif v10 % 2 == 0:\n    v11 = v7[v10 // 2 - 1]\n    v12 = v7[v10 // 2]\nelse:\n    v11 = v7[v10 // 2]\n    v12 = v7[v10 // 2 + 1]\nv9[v11] = True\nv9[v12] = True\n\ndef f2(a1, a2, a3):\n    a3 += 1\n    for v2 in v2[a1]:\n        if not a2[v2]:\n            a2[v2] = True\n            a3 = f2(v2, a2, a3)\n    return a3\nv13 = f2(v11, v9, 0)\nv14 = f2(v12, v9, 0)\nif v14 < v13:\n    print('Fennec')\nelse:\n    print('Snuke')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(600000)\nv1 = int(input())\nv2 = [[] for v3 in range(v1)]\nfor v3 in range(v1 - 1):\n    v4, v5 = map(int, input().split())\n    v2[v4 - 1].append(v5 - 1)\n    v2[v5 - 1].append(v4 - 1)\n\ndef f1(a1, a2, a3):\n    if a1 == v1 - 1:\n        return (a3, True)\n    v1 = False\n    for v2 in v2[a1]:\n        if not a2[v2]:\n            a3.append(v2)\n            a2[v2] = True\n            v3, v4 = f1(v2, a2, a3)\n            if v4:\n                v5 = v3\n                v1 = True\n    if not v1:\n        a3.pop()\n        return (a3, False)\n    return (v5, True)\nv6 = [False for v3 in range(v1)]\nv6[0] = True\nv7, v8 = f1(0, v6, [0])\nv9 = [0 for v3 in range(v1)]\nv10 = len(v7)\nif v10 % 2 == 0:\n    v11 = v7[v10 // 2 - 1]\n    v12 = v7[v10 // 2]\nelse:\n    v11 = v7[v10 // 2]\n    v12 = v7[v10 // 2 + 1]\nv9[v11] = True\nv9[v12] = True\n\ndef f2(a1, a2, a3):\n    a3 += 1\n    for v2 in v2[a1]:\n        if not a2[v2]:\n            a2[v2] = True\n            a3 = f2(v2, a2, a3)\n    return a3\nv13 = f2(v11, v9, 0)\nv14 = f2(v12, v9, 0)\nif v14 < v13:\n    print('Fennec')\nelse:\n    print('Snuke')\n"}
{"id": "human_code\\minimum-remove-to-make-valid-parentheses.py", "text": "class C1(object):\n\n    def minRemoveToMakeValid(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = list(a1)\n        v2 = 0\n        for v3, v4 in enumerate(v1):\n            if v4 == '(':\n                v2 += 1\n            elif v4 == ')':\n                if v2:\n                    v2 -= 1\n                else:\n                    v1[v3] = ''\n        if v2:\n            for v3 in reversed(range(len(v1))):\n                if v1[v3] == '(':\n                    v1[v3] = ''\n                    v2 -= 1\n                    if not v2:\n                        break\n        return ''.join(v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minRemoveToMakeValid(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = list(a1)\n        v2 = 0\n        for v3, v4 in enumerate(v1):\n            if v4 == '(':\n                v2 += 1\n            elif v4 == ')':\n                if v2:\n                    v2 -= 1\n                else:\n                    v1[v3] = ''\n        if v2:\n            for v3 in reversed(range(len(v1))):\n                if v1[v3] == '(':\n                    v1[v3] = ''\n                    v2 -= 1\n                    if not v2:\n                        break\n        return ''.join(v1)\n"}
{"id": "human_code\\p03046__s108584422.py", "text": "v1, v2 = map(int, input().split())\nif v2 >= pow(2, v1):\n    print(-1)\nelif v2 == 0:\n    v3 = []\n    for v4 in range(pow(2, v1)):\n        v3.append(v4)\n        v3.append(v4)\n    print(*v3)\nelse:\n    v5 = 0\n    v6 = []\n    for v4 in range(pow(2, v1)):\n        if v4 == v2:\n            continue\n        v5 ^= v4\n        v6.append(v4)\n    if v5 == v2:\n        v7 = list(reversed(v6))\n        v3 = v6 + [v2] + v7 + [v2]\n        print(*v3)\n    else:\n        print(-1)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nif v2 >= pow(2, v1):\n    print(-1)\nelif v2 == 0:\n    v3 = []\n    for v4 in range(pow(2, v1)):\n        v3.append(v4)\n        v3.append(v4)\n    print(*v3)\nelse:\n    v5 = 0\n    v6 = []\n    for v4 in range(pow(2, v1)):\n        if v4 == v2:\n            continue\n        v5 ^= v4\n        v6.append(v4)\n    if v5 == v2:\n        v7 = list(reversed(v6))\n        v3 = v6 + [v2] + v7 + [v2]\n        print(*v3)\n    else:\n        print(-1)\n"}
{"id": "llm_code\\p02556__s445923576.py", "text": "v1 = int(input())\nv2 = [0, 10 ** 9]\nv3 = [0, 0]\nv4 = [10 ** 9, 10 ** 9]\nv5 = [10 ** 9, 0]\nfor v6 in range(0, v1):\n    v7, v8 = list(map(int, input().split()))\n    if v3[0] < v7 and v3[1] < v8:\n        v3 = [v7, v8]\n    if v2[0] < v7 and v2[1] > v8:\n        v2 = [v7, v8]\n    if v5[0] > v7 and v5[1] < v8:\n        v5 = [v7, v8]\n    if v4[0] > v7 and v4[1] > v8:\n        v4 = [v7, v8]\nv9 = abs(v3[0] - v4[0]) + abs(v3[1] - v4[1])\nv10 = abs(v5[0] - v2[0]) + abs(v5[1] - v4[1])\nv11 = abs(v3[0] - v3[1]) + abs(v2[0] - v4[1])\nv12 = abs(v5[0] - v5[1]) + abs(v2[0] - v4[1])\nprint(max(v9, v10, v11, v12))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [0, 10 ** 9]\nv3 = [0, 0]\nv4 = [10 ** 9, 10 ** 9]\nv5 = [10 ** 9, 0]\nfor v6 in range(0, v1):\n    v7, v8 = list(map(int, input().split()))\n    if v3[0] < v7 and v3[1] < v8:\n        v3 = [v7, v8]\n    if v2[0] < v7 and v2[1] > v8:\n        v2 = [v7, v8]\n    if v5[0] > v7 and v5[1] < v8:\n        v5 = [v7, v8]\n    if v4[0] > v7 and v4[1] > v8:\n        v4 = [v7, v8]\nv9 = abs(v3[0] - v4[0]) + abs(v3[1] - v4[1])\nv10 = abs(v5[0] - v2[0]) + abs(v5[1] - v4[1])\nv11 = abs(v3[0] - v3[1]) + abs(v2[0] - v4[1])\nv12 = abs(v5[0] - v5[1]) + abs(v2[0] - v4[1])\nprint(max(v9, v10, v11, v12))\n"}
{"id": "human_code\\minimum-sum-of-values-by-dividing-array__part4.py", "text": "import collections\n\nclass C1(object):\n\n    def minimumValueSum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = (1 << max(a1).bit_length()) - 1\n\n        def memoization(a1, a2, a3):\n            if a1 == len(a1) and a2 == len(a2):\n                return 0\n            if a1 == len(a1) or a2 == len(a2) or a3 < a2[a2]:\n                return v1\n            if a3 not in lookup[a1][a2]:\n                v1 = memoization(a1 + 1, a2, a3 & a1[a1])\n                if a3 & a1[a1] == a2[a2]:\n                    v1 = min(v1, a1[a1] + memoization(a1 + 1, a2 + 1, v2))\n                lookup[a1][a2][a3] = v1\n            return lookup[a1][a2][a3]\n        v3 = [[collections.defaultdict(int) for v4 in range(len(a2))] for v4 in range(len(a1))]\n        v5 = memoization(0, 0, v2)\n        return v5 if v5 != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def minimumValueSum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = (1 << max(a1).bit_length()) - 1\n\n        def memoization(a1, a2, a3):\n            if a1 == len(a1) and a2 == len(a2):\n                return 0\n            if a1 == len(a1) or a2 == len(a2) or a3 < a2[a2]:\n                return v1\n            if a3 not in lookup[a1][a2]:\n                v1 = memoization(a1 + 1, a2, a3 & a1[a1])\n                if a3 & a1[a1] == a2[a2]:\n                    v1 = min(v1, a1[a1] + memoization(a1 + 1, a2 + 1, v2))\n                lookup[a1][a2][a3] = v1\n            return lookup[a1][a2][a3]\n        v3 = [[collections.defaultdict(int) for v4 in range(len(a2))] for v4 in range(len(a1))]\n        v5 = memoization(0, 0, v2)\n        return v5 if v5 != v1 else -1\n"}
{"id": "human_code\\minimum-relative-loss-after-buying-chocolates.py", "text": "class C1(object):\n\n    def minimumRelativeLosses(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n        a1.sort()\n        v1 = [0] * (len(a1) + 1)\n        for v2 in range(len(a1)):\n            v1[v2 + 1] = v1[v2] + a1[v2]\n        v3 = []\n        for v4, v5 in a2:\n            v6 = binary_search(0, v5 - 1, lambda x: v4 - (a1[-(v5 - x)] - v4) <= a1[x + 1 - 1] - 0)\n            v7 = v1[-1] - v1[-1 - (v5 - v6)] - (v5 - v6) * v4\n            v8 = v1[v6] + (v5 - v6) * v4\n            v3.append(v8 - v7)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumRelativeLosses(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n        a1.sort()\n        v1 = [0] * (len(a1) + 1)\n        for v2 in range(len(a1)):\n            v1[v2 + 1] = v1[v2] + a1[v2]\n        v3 = []\n        for v4, v5 in a2:\n            v6 = binary_search(0, v5 - 1, lambda x: v4 - (a1[-(v5 - x)] - v4) <= a1[x + 1 - 1] - 0)\n            v7 = v1[-1] - v1[-1 - (v5 - v6)] - (v5 - v6) * v4\n            v8 = v1[v6] + (v5 - v6) * v4\n            v3.append(v8 - v7)\n        return v3\n"}
{"id": "human_code\\p03476__s492103745.py", "text": "v1 = 10 ** 5 + 1\nv2 = [True] * (v1 + 1)\nv2[0] = False\nv2[1] = False\nfor v3 in range(2, v1 + 1):\n    if v2[v3]:\n        for v4 in range(v3 * 2, v1 + 1, v3):\n            v2[v4] = False\nv5 = [0] * (v1 + 1)\nfor v3 in range(0, v1 + 1):\n    if v3 % 2 == 0:\n        continue\n    if v2[v3] and v2[(v3 + 1) // 2]:\n        v5[v3] = 1\nv6 = [0] * (v1 + 1)\nfor v3 in range(v1):\n    v6[v3 + 1] = v6[v3] + v5[v3]\nv7 = int(input())\nv8 = [list(map(int, input().split())) for v9 in range(v7)]\nfor v3 in range(v7):\n    print(v6[v8[v3][1] + 1] - v6[v8[v3][0]])\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = 10 ** 5 + 1\nv2 = [True] * (v1 + 1)\nv2[0] = False\nv2[1] = False\nfor v3 in range(2, v1 + 1):\n    if v2[v3]:\n        for v4 in range(v3 * 2, v1 + 1, v3):\n            v2[v4] = False\nv5 = [0] * (v1 + 1)\nfor v3 in range(0, v1 + 1):\n    if v3 % 2 == 0:\n        continue\n    if v2[v3] and v2[(v3 + 1) // 2]:\n        v5[v3] = 1\nv6 = [0] * (v1 + 1)\nfor v3 in range(v1):\n    v6[v3 + 1] = v6[v3] + v5[v3]\nv7 = int(input())\nv8 = [list(map(int, input().split())) for v9 in range(v7)]\nfor v3 in range(v7):\n    print(v6[v8[v3][1] + 1] - v6[v8[v3][0]])\n"}
{"id": "human_code\\step-by-step-directions-from-a-binary-tree-node-to-another__part2.py", "text": "class C1(object):\n\n    def getDirections(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            if a1.val == a2:\n                return True\n            if a1.left and dfs(a1.left, a2, a3):\n                a3.append('L')\n            elif a1.right and dfs(a1.right, a2, a3):\n                a3.append('R')\n            return a3\n        v1, v2 = ([], [])\n        dfs(a1, a2, v1)\n        dfs(a1, a3, v2)\n        while len(v1) and len(v2) and (v1[-1] == v2[-1]):\n            v1.pop()\n            v2.pop()\n        v2.reverse()\n        return ''.join(['U'] * len(v1) + v2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def getDirections(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            if a1.val == a2:\n                return True\n            if a1.left and dfs(a1.left, a2, a3):\n                a3.append('L')\n            elif a1.right and dfs(a1.right, a2, a3):\n                a3.append('R')\n            return a3\n        v1, v2 = ([], [])\n        dfs(a1, a2, v1)\n        dfs(a1, a3, v2)\n        while len(v1) and len(v2) and (v1[-1] == v2[-1]):\n            v1.pop()\n            v2.pop()\n        v2.reverse()\n        return ''.join(['U'] * len(v1) + v2)\n"}
{"id": "human_code\\select-cells-in-grid-with-maximum-score__part2.py", "text": "class C1(object):\n\n    def maxScore(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = max((x for v2 in a1 for v3 in v2))\n        v4 = [set() for v5 in range(v1)]\n        for v6, v2 in enumerate(a1):\n            for v3 in v2:\n                v4[v3 - 1].add(v6)\n        v7 = [float('-inf')] * (1 << len(a1))\n        v7[0] = 0\n        for v3 in range(len(v4)):\n            if not v4[v3]:\n                continue\n            for v8 in reversed(range(len(v7))):\n                for v6 in v4[v3]:\n                    if v8 & 1 << v6:\n                        continue\n                    v7[v8 | 1 << v6] = max(v7[v8 | 1 << v6], v7[v8] + (v3 + 1))\n        return max(v7)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxScore(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = max((x for v2 in a1 for v3 in v2))\n        v4 = [set() for v5 in range(v1)]\n        for v6, v2 in enumerate(a1):\n            for v3 in v2:\n                v4[v3 - 1].add(v6)\n        v7 = [float('-inf')] * (1 << len(a1))\n        v7[0] = 0\n        for v3 in range(len(v4)):\n            if not v4[v3]:\n                continue\n            for v8 in reversed(range(len(v7))):\n                for v6 in v4[v3]:\n                    if v8 & 1 << v6:\n                        continue\n                    v7[v8 | 1 << v6] = max(v7[v8 | 1 << v6], v7[v8] + (v3 + 1))\n        return max(v7)\n"}
{"id": "human_code\\maximum-number-of-darts-inside-of-a-circular-dartboard.py", "text": "import math\n\nclass C1(object):\n\n    def numPoints(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def count_points(a1, a2, a3):\n            v1 = []\n            for v2 in range(len(a1)):\n                if a3 == v2:\n                    continue\n                v3, v4 = (a1[a3][0] - a1[v2][0], a1[a3][1] - a1[v2][1])\n                v5 = math.sqrt(v3 ** 2 + v4 ** 2)\n                if v5 > 2 * a2:\n                    continue\n                v6, v7 = (math.acos(v5 / (2 * a2)), math.atan2(v4, v3))\n                (v1.append((v7 - v6, 0)), v1.append((v7 + v6, 1)))\n            v1.sort()\n            v8, v9 = (1, 1)\n            for v10, v11 in v1:\n                if not v11:\n                    v9 += 1\n                else:\n                    v9 -= 1\n                v8 = max(v8, v9)\n            return v8\n        return max((count_points(a1, a2, i) for v1 in range(len(a1))))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import math\n\nclass C1(object):\n\n    def numPoints(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def count_points(a1, a2, a3):\n            v1 = []\n            for v2 in range(len(a1)):\n                if a3 == v2:\n                    continue\n                v3, v4 = (a1[a3][0] - a1[v2][0], a1[a3][1] - a1[v2][1])\n                v5 = math.sqrt(v3 ** 2 + v4 ** 2)\n                if v5 > 2 * a2:\n                    continue\n                v6, v7 = (math.acos(v5 / (2 * a2)), math.atan2(v4, v3))\n                (v1.append((v7 - v6, 0)), v1.append((v7 + v6, 1)))\n            v1.sort()\n            v8, v9 = (1, 1)\n            for v10, v11 in v1:\n                if not v11:\n                    v9 += 1\n                else:\n                    v9 -= 1\n                v8 = max(v8, v9)\n            return v8\n        return max((count_points(a1, a2, i) for v1 in range(len(a1))))\n"}
{"id": "llm_code\\tag-validator__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def isValid(self, a1):\n        v1 = len(a1)\n        v2 = []\n\n        def get_tag(a1):\n            if a1 >= v1 or a1[a1] != '<':\n                return (None, a1)\n            v1 = a1.find('>', a1 + 1)\n            if v1 == -1 or v1 - a1 - 1 < 1 or v1 - a1 - 1 > 9:\n                return (None, a1)\n            v2 = a1[a1 + 1:v1]\n            if not all(('A' <= c <= 'Z' for v3 in v2)):\n                return (None, a1)\n            return (v2, v1 + 1)\n\n        def chk_close(a1, a2):\n            v1 = len(a2)\n            v2 = a1 + v1 + 3\n            if v2 > v1 or a1[a1:a1 + 2] != '</' or a1[a1 + 2:a1 + 2 + v1] != a2 or (a1[a1 + 2 + v1] != '>'):\n                return (False, a1)\n            return (True, v2)\n        v3 = 0\n        v4, v3 = get_tag(v3)\n        if v4 is None:\n            return False\n        v2.append(v4)\n        while v3 < v1:\n            if a1[v3] == '<':\n                if v3 + 9 <= v1 and a1[v3:v3 + 9] == '<![CDATA[':\n                    v5 = a1.find(']]>', v3 + 9)\n                    if v5 == -1:\n                        return False\n                    v3 = v5 + 3\n                    continue\n                if v3 + 1 < v1 and a1[v3 + 1] == '/':\n                    v6, v7 = chk_close(v3, v2[-1])\n                    if not v6:\n                        return False\n                    v3 = v7\n                    v2.pop()\n                    if not v2:\n                        return v3 == v1\n                else:\n                    v4, v7 = get_tag(v3)\n                    if v4 is None:\n                        return False\n                    v3 = v7\n                    v2.append(v4)\n            else:\n                v8 = a1.find('<', v3)\n                v3 = v1 if v8 == -1 else v8\n        return False\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def isValid(self, a1):\n        v1 = len(a1)\n        v2 = []\n\n        def get_tag(a1):\n            if a1 >= v1 or a1[a1] != '<':\n                return (None, a1)\n            v1 = a1.find('>', a1 + 1)\n            if v1 == -1 or v1 - a1 - 1 < 1 or v1 - a1 - 1 > 9:\n                return (None, a1)\n            v2 = a1[a1 + 1:v1]\n            if not all(('A' <= c <= 'Z' for v3 in v2)):\n                return (None, a1)\n            return (v2, v1 + 1)\n\n        def chk_close(a1, a2):\n            v1 = len(a2)\n            v2 = a1 + v1 + 3\n            if v2 > v1 or a1[a1:a1 + 2] != '</' or a1[a1 + 2:a1 + 2 + v1] != a2 or (a1[a1 + 2 + v1] != '>'):\n                return (False, a1)\n            return (True, v2)\n        v3 = 0\n        v4, v3 = get_tag(v3)\n        if v4 is None:\n            return False\n        v2.append(v4)\n        while v3 < v1:\n            if a1[v3] == '<':\n                if v3 + 9 <= v1 and a1[v3:v3 + 9] == '<![CDATA[':\n                    v5 = a1.find(']]>', v3 + 9)\n                    if v5 == -1:\n                        return False\n                    v3 = v5 + 3\n                    continue\n                if v3 + 1 < v1 and a1[v3 + 1] == '/':\n                    v6, v7 = chk_close(v3, v2[-1])\n                    if not v6:\n                        return False\n                    v3 = v7\n                    v2.pop()\n                    if not v2:\n                        return v3 == v1\n                else:\n                    v4, v7 = get_tag(v3)\n                    if v4 is None:\n                        return False\n                    v3 = v7\n                    v2.append(v4)\n            else:\n                v8 = a1.find('<', v3)\n                v3 = v1 if v8 == -1 else v8\n        return False\n"}
{"id": "llm_code\\partition-labels__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def partitionLabels(self, a1):\n        v1 = len(a1)\n        v2 = [-1] * 26\n        v3 = v1 - 1\n        while v3 >= 0:\n            v4 = ord(a1[v3]) - ord('a')\n            if v2[v4] == -1:\n                v2[v4] = v3\n            v3 -= 1\n        v5 = []\n        v6 = 0\n        v7 = 0\n        v3 = 0\n        while v3 < v1:\n            v7 = max(v7, v2[ord(a1[v3]) - ord('a')])\n            if v3 == v7:\n                v5.append(v3 - v6 + 1)\n                v6 = v3 + 1\n            v3 += 1\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def partitionLabels(self, a1):\n        v1 = len(a1)\n        v2 = [-1] * 26\n        v3 = v1 - 1\n        while v3 >= 0:\n            v4 = ord(a1[v3]) - ord('a')\n            if v2[v4] == -1:\n                v2[v4] = v3\n            v3 -= 1\n        v5 = []\n        v6 = 0\n        v7 = 0\n        v3 = 0\n        while v3 < v1:\n            v7 = max(v7, v2[ord(a1[v3]) - ord('a')])\n            if v3 == v7:\n                v5.append(v3 - v6 + 1)\n                v6 = v3 + 1\n            v3 += 1\n        return v5\n"}
{"id": "human_code\\p03593__s617216978.py", "text": "from sys import stdin\nimport string\nimport heapq\nv1, v2 = map(int, stdin.readline().rstrip().split())\nv3 = ''\nfor v4 in range(v1):\n    v3 += stdin.readline().rstrip()\nv5 = v1 // 2 * (v2 // 2)\nv6 = v1 % 2 * (v2 // 2) + v2 % 2 * (v1 // 2)\nv7 = v1 % 2 * (v2 % 2)\nv8 = string.ascii_lowercase\nv9 = [-v3.count(v4) for v4 in v8 if v3.count(v4) != 0]\nheapq.heapify(v9)\nfor v4 in range(v5):\n    if v9[0] <= -4:\n        v10 = heapq.heappop(v9)\n        if v10 + 4 == 0:\n            continue\n        else:\n            heapq.heappush(v9, v10 + 4)\n    else:\n        print('No')\n        exit()\nfor v4 in range(v6):\n    if v9[0] <= -2:\n        v10 = heapq.heappop(v9)\n        if v10 + 2 == 0:\n            continue\n        else:\n            heapq.heappush(v9, v10 + 2)\n    else:\n        print('No')\n        exit()\nfor v4 in range(v7):\n    if v9[0] <= -1:\n        v10 = heapq.heappop(v9)\n        if v10 + 1 == 0:\n            continue\n        else:\n            heapq.heappush(v9, v10 + 1)\n    else:\n        print('No')\n        exit()\nprint('Yes')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from sys import stdin\nimport string\nimport heapq\nv1, v2 = map(int, stdin.readline().rstrip().split())\nv3 = ''\nfor v4 in range(v1):\n    v3 += stdin.readline().rstrip()\nv5 = v1 // 2 * (v2 // 2)\nv6 = v1 % 2 * (v2 // 2) + v2 % 2 * (v1 // 2)\nv7 = v1 % 2 * (v2 % 2)\nv8 = string.ascii_lowercase\nv9 = [-v3.count(v4) for v4 in v8 if v3.count(v4) != 0]\nheapq.heapify(v9)\nfor v4 in range(v5):\n    if v9[0] <= -4:\n        v10 = heapq.heappop(v9)\n        if v10 + 4 == 0:\n            continue\n        else:\n            heapq.heappush(v9, v10 + 4)\n    else:\n        print('No')\n        exit()\nfor v4 in range(v6):\n    if v9[0] <= -2:\n        v10 = heapq.heappop(v9)\n        if v10 + 2 == 0:\n            continue\n        else:\n            heapq.heappush(v9, v10 + 2)\n    else:\n        print('No')\n        exit()\nfor v4 in range(v7):\n    if v9[0] <= -1:\n        v10 = heapq.heappop(v9)\n        if v10 + 1 == 0:\n            continue\n        else:\n            heapq.heappush(v9, v10 + 1)\n    else:\n        print('No')\n        exit()\nprint('Yes')\n"}
{"id": "human_code\\p03354__s244115504.py", "text": "import sys\ninput = sys.stdin.readline\nv1, v2 = map(int, input().split())\nv3 = list(map(lambda x: int(x) - 1, input().split()))\n\nclass C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n\n    def get_root(self, a1):\n        v1 = self.parent[a1]\n        if v1 == a1:\n            return v1\n        else:\n            v1 = self.get_root(v1)\n            self.parent[a1] = v1\n            return v1\n\n    def are_in_same_union(self, a1, a2):\n        v1 = self.get_root(a1)\n        v2 = self.get_root(a2)\n        if v1 == v2:\n            return True\n        else:\n            return False\n\n    def unite(self, a1, a2):\n        v1 = self.get_root(a1)\n        v2 = self.get_root(a2)\n        if v1 == v2:\n            return\n        self.parent[v2] = v1\nv4 = C1(v1)\nfor v5 in range(v2):\n    v6, v7 = map(int, input().split())\n    v6 -= 1\n    v7 -= 1\n    v4.unite(v6, v7)\nv8 = 0\nfor v9 in range(v1):\n    v10 = v3[v9]\n    if v10 == v9:\n        v8 += 1\n    elif v4.are_in_same_union(v9, v10):\n        v8 += 1\nprint(v8)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nv1, v2 = map(int, input().split())\nv3 = list(map(lambda x: int(x) - 1, input().split()))\n\nclass C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n\n    def get_root(self, a1):\n        v1 = self.parent[a1]\n        if v1 == a1:\n            return v1\n        else:\n            v1 = self.get_root(v1)\n            self.parent[a1] = v1\n            return v1\n\n    def are_in_same_union(self, a1, a2):\n        v1 = self.get_root(a1)\n        v2 = self.get_root(a2)\n        if v1 == v2:\n            return True\n        else:\n            return False\n\n    def unite(self, a1, a2):\n        v1 = self.get_root(a1)\n        v2 = self.get_root(a2)\n        if v1 == v2:\n            return\n        self.parent[v2] = v1\nv4 = C1(v1)\nfor v5 in range(v2):\n    v6, v7 = map(int, input().split())\n    v6 -= 1\n    v7 -= 1\n    v4.unite(v6, v7)\nv8 = 0\nfor v9 in range(v1):\n    v10 = v3[v9]\n    if v10 == v9:\n        v8 += 1\n    elif v4.are_in_same_union(v9, v10):\n        v8 += 1\nprint(v8)\n"}
{"id": "human_code\\majority-element-ii.py", "text": "import collections\n\nclass C1(object):\n\n    def majorityElement(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = (3, len(a1), collections.defaultdict(int))\n        for v4 in a1:\n            v3[v4] += 1\n            if len(v3) == v1:\n                for v5 in list(v3.keys()):\n                    v3[v5] -= 1\n                    if v3[v5] == 0:\n                        del v3[v5]\n        for v4 in list(v3.keys()):\n            v3[v4] = 0\n        for v4 in a1:\n            if v4 in v3:\n                v3[v4] += 1\n        v6 = []\n        for v4 in list(v3.keys()):\n            if v3[v4] > v2 / v1:\n                v6.append(v4)\n        return v6\n\n    def majorityElement2(self, a1):\n        \"\"\"\n        \"\"\"\n        return [i[0] for v1 in list(collections.Counter(a1).items()) if v1[1] > len(a1) / 3]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def majorityElement(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = (3, len(a1), collections.defaultdict(int))\n        for v4 in a1:\n            v3[v4] += 1\n            if len(v3) == v1:\n                for v5 in list(v3.keys()):\n                    v3[v5] -= 1\n                    if v3[v5] == 0:\n                        del v3[v5]\n        for v4 in list(v3.keys()):\n            v3[v4] = 0\n        for v4 in a1:\n            if v4 in v3:\n                v3[v4] += 1\n        v6 = []\n        for v4 in list(v3.keys()):\n            if v3[v4] > v2 / v1:\n                v6.append(v4)\n        return v6\n\n    def majorityElement2(self, a1):\n        \"\"\"\n        \"\"\"\n        return [i[0] for v1 in list(collections.Counter(a1).items()) if v1[1] > len(a1) / 3]\n"}
{"id": "human_code\\p03618__s438750493.py", "text": "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\nv1 = 10 ** 9 + 7\nv2 = float('inf')\nv3 = 'abcdefghijklmnopqrstuvwxyz'\n\ndef f1():\n    return int(input().strip())\n\ndef f2():\n    return input().strip()\n\ndef f3():\n    return list(map(int, input().split()))\n\ndef f4():\n    return list(map(str, input().split()))\n\ndef f5(a1):\n    return list((int(input()) for v1 in range(a1)))\n\ndef f6(a1):\n    return list((input().strip() for v1 in range(a1)))\n\ndef f7(a1):\n    return [list(map(int, input().split())) for v1 in range(a1)]\n\ndef f8(a1):\n    return [list(map(str, input().split())) for v1 in range(a1)]\n\ndef f9(a1):\n    print(a1)\n    return\n\ndef f10():\n    print('Yes')\n    return\n\ndef f11():\n    print('No')\n    return\n\ndef f12():\n    exit()\n\ndef f13(a1):\n    print(a1)\n    exit()\n\ndef f14():\n    print('Yes')\n    exit()\n\ndef f15():\n    print('No')\n    exit()\n\ndef f16(a1):\n    return defaultdict(a1)\n\ndef f17(a1):\n    return pow(a1, v1 - 2, v1)\nv4 = []\n\ndef f18(a1):\n    if len(v4) > a1:\n        return v4[a1]\n    if len(v4) == 0:\n        v4.append(1)\n    while len(v4) <= a1:\n        v4.append(v4[-1] * len(v4) % v1)\n    return v4[a1]\nv5 = []\n\ndef f19(a1):\n    if len(v5) > a1:\n        return v5[a1]\n    if len(v5) == 0:\n        v5.append(1)\n    while len(v5) <= a1:\n        v5.append(v5[-1] * pow(len(v5), v1 - 2, v1) % v1)\n    return v5[a1]\n\ndef f20(a1, a2):\n    if a1 == a2:\n        return 1\n    if a1 < a2 or a2 < 0:\n        return 0\n    v1 = 1\n    v1 = v1 * f18(a1) % v1\n    v1 = v1 * f19(a2) % v1\n    v1 = v1 * f19(a1 - a2) % v1\n    return v1\n\ndef f21(a1):\n    v1 = []\n    v2 = a1\n    for v3 in range(2, int(-(-a1 ** 0.5 // 1)) + 1):\n        if v2 % v3 == 0:\n            v4 = 0\n            while v2 % v3 == 0:\n                v4 += 1\n                v2 //= v3\n            v1.append([v3, v4])\n    if v2 != 1:\n        v1.append([v2, 1])\n    if v1 == []:\n        v1.append([a1, 1])\n    return v1\n\ndef f22(a1):\n    v1 = []\n    for v2 in range(1, int(a1 ** 0.5) + 1):\n        if a1 % v2 == 0:\n            v1.append(v2)\n            if v2 != a1 // v2:\n                v1.append(a1 // v2)\n    return v1\n\ndef f23(a1):\n    max = int(math.sqrt(a1))\n    v1 = [i for v2 in range(2, a1 + 1)]\n    v3 = []\n    while v1[0] <= max:\n        v3.append(v1[0])\n        v4 = v1[0]\n        v1 = [v2 for v2 in v1 if v2 % v4 != 0]\n    v3.extend(v1)\n    return v3\n\ndef f24(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f25(a1, a2):\n    return a1 * a2 // f24(a1, a2)\n\ndef f26(a1):\n    v1 = 0\n    while a1:\n        a1 &= a1 - 1\n        v1 += 1\n    return v1\n\ndef f27(a1, a2):\n    if a1 // a2:\n        return f27(a1 // a2, a2) + [a1 % a2]\n    return [a1 % a2]\n\ndef f28(a1, a2):\n    return sum((int(str(a1)[-i - 1]) * a2 ** i for v1 in range(len(str(a1)))))\n\ndef f29(a1, a2):\n    a1 -= 1\n    if a1 // a2:\n        return f29(a1 // a2, a2) + [a1 % a2]\n    return [a1 % a2]\n\ndef f30(a1, a2):\n    v1 = 0\n    while a1 >= a2:\n        a1 //= a2\n        v1 += 1\n    return v1\nv6 = v6()\nv7 = len(v6)\nv8 = f16(int)\nfor v9 in v6:\n    v8[v9] += 1\nv10 = v7 * (v7 - 1) // 2\nfor v11 in v8:\n    v12 = v8[v11]\n    v10 -= v12 * (v12 - 1) // 2\nprint(v10 + 1)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nimport math\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\nv1 = 10 ** 9 + 7\nv2 = float('inf')\nv3 = 'abcdefghijklmnopqrstuvwxyz'\n\ndef f1():\n    return int(input().strip())\n\ndef f2():\n    return input().strip()\n\ndef f3():\n    return list(map(int, input().split()))\n\ndef f4():\n    return list(map(str, input().split()))\n\ndef f5(a1):\n    return list((int(input()) for v1 in range(a1)))\n\ndef f6(a1):\n    return list((input().strip() for v1 in range(a1)))\n\ndef f7(a1):\n    return [list(map(int, input().split())) for v1 in range(a1)]\n\ndef f8(a1):\n    return [list(map(str, input().split())) for v1 in range(a1)]\n\ndef f9(a1):\n    print(a1)\n    return\n\ndef f10():\n    print('Yes')\n    return\n\ndef f11():\n    print('No')\n    return\n\ndef f12():\n    exit()\n\ndef f13(a1):\n    print(a1)\n    exit()\n\ndef f14():\n    print('Yes')\n    exit()\n\ndef f15():\n    print('No')\n    exit()\n\ndef f16(a1):\n    return defaultdict(a1)\n\ndef f17(a1):\n    return pow(a1, v1 - 2, v1)\nv4 = []\n\ndef f18(a1):\n    if len(v4) > a1:\n        return v4[a1]\n    if len(v4) == 0:\n        v4.append(1)\n    while len(v4) <= a1:\n        v4.append(v4[-1] * len(v4) % v1)\n    return v4[a1]\nv5 = []\n\ndef f19(a1):\n    if len(v5) > a1:\n        return v5[a1]\n    if len(v5) == 0:\n        v5.append(1)\n    while len(v5) <= a1:\n        v5.append(v5[-1] * pow(len(v5), v1 - 2, v1) % v1)\n    return v5[a1]\n\ndef f20(a1, a2):\n    if a1 == a2:\n        return 1\n    if a1 < a2 or a2 < 0:\n        return 0\n    v1 = 1\n    v1 = v1 * f18(a1) % v1\n    v1 = v1 * f19(a2) % v1\n    v1 = v1 * f19(a1 - a2) % v1\n    return v1\n\ndef f21(a1):\n    v1 = []\n    v2 = a1\n    for v3 in range(2, int(-(-a1 ** 0.5 // 1)) + 1):\n        if v2 % v3 == 0:\n            v4 = 0\n            while v2 % v3 == 0:\n                v4 += 1\n                v2 //= v3\n            v1.append([v3, v4])\n    if v2 != 1:\n        v1.append([v2, 1])\n    if v1 == []:\n        v1.append([a1, 1])\n    return v1\n\ndef f22(a1):\n    v1 = []\n    for v2 in range(1, int(a1 ** 0.5) + 1):\n        if a1 % v2 == 0:\n            v1.append(v2)\n            if v2 != a1 // v2:\n                v1.append(a1 // v2)\n    return v1\n\ndef f23(a1):\n    max = int(math.sqrt(a1))\n    v1 = [i for v2 in range(2, a1 + 1)]\n    v3 = []\n    while v1[0] <= max:\n        v3.append(v1[0])\n        v4 = v1[0]\n        v1 = [v2 for v2 in v1 if v2 % v4 != 0]\n    v3.extend(v1)\n    return v3\n\ndef f24(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f25(a1, a2):\n    return a1 * a2 // f24(a1, a2)\n\ndef f26(a1):\n    v1 = 0\n    while a1:\n        a1 &= a1 - 1\n        v1 += 1\n    return v1\n\ndef f27(a1, a2):\n    if a1 // a2:\n        return f27(a1 // a2, a2) + [a1 % a2]\n    return [a1 % a2]\n\ndef f28(a1, a2):\n    return sum((int(str(a1)[-i - 1]) * a2 ** i for v1 in range(len(str(a1)))))\n\ndef f29(a1, a2):\n    a1 -= 1\n    if a1 // a2:\n        return f29(a1 // a2, a2) + [a1 % a2]\n    return [a1 % a2]\n\ndef f30(a1, a2):\n    v1 = 0\n    while a1 >= a2:\n        a1 //= a2\n        v1 += 1\n    return v1\nv6 = v6()\nv7 = len(v6)\nv8 = f16(int)\nfor v9 in v6:\n    v8[v9] += 1\nv10 = v7 * (v7 - 1) // 2\nfor v11 in v8:\n    v12 = v8[v11]\n    v10 -= v12 * (v12 - 1) // 2\nprint(v10 + 1)\n"}
{"id": "human_code\\kth-smallest-product-of-two-sorted-arrays.py", "text": "class C1(object):\n\n    def kthSmallestProduct(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4, a5):\n            v1 = 0\n            v2, v3 = (0, len(a2) - 1)\n            v4 = reversed if a5 >= 0 else lambda x: x\n            for v5 in v4(range(a4)):\n                while v2 < len(a2) and a1[v5] * a2[v2] > a5:\n                    v2 += 1\n                v1 += len(a2) - 1 - v2 + 1\n            v4 = (lambda x: x) if a5 >= 0 else reversed\n            for v5 in v4(range(a4, len(a1))):\n                if a1[v5] == 0:\n                    if a5 >= 0:\n                        v1 += len(a2)\n                    continue\n                while v3 >= 0 and a1[v5] * a2[v3] > a5:\n                    v3 -= 1\n                v1 += v3 - 0 + 1\n            return v1 >= a3\n        v1 = sum((x < 0 for v2 in a1))\n        v3 = min((a1[i] * a2[j] for v4 in (0, -1) for v5 in (0, -1)))\n        v6 = max((a1[v4] * a2[v5] for v4 in (0, -1) for v5 in (0, -1)))\n        while v3 <= v6:\n            v7 = v3 + (v6 - v3) // 2\n            if check(a1, a2, a3, v1, v7):\n                v6 = v7 - 1\n            else:\n                v3 = v7 + 1\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def kthSmallestProduct(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4, a5):\n            v1 = 0\n            v2, v3 = (0, len(a2) - 1)\n            v4 = reversed if a5 >= 0 else lambda x: x\n            for v5 in v4(range(a4)):\n                while v2 < len(a2) and a1[v5] * a2[v2] > a5:\n                    v2 += 1\n                v1 += len(a2) - 1 - v2 + 1\n            v4 = (lambda x: x) if a5 >= 0 else reversed\n            for v5 in v4(range(a4, len(a1))):\n                if a1[v5] == 0:\n                    if a5 >= 0:\n                        v1 += len(a2)\n                    continue\n                while v3 >= 0 and a1[v5] * a2[v3] > a5:\n                    v3 -= 1\n                v1 += v3 - 0 + 1\n            return v1 >= a3\n        v1 = sum((x < 0 for v2 in a1))\n        v3 = min((a1[i] * a2[j] for v4 in (0, -1) for v5 in (0, -1)))\n        v6 = max((a1[v4] * a2[v5] for v4 in (0, -1) for v5 in (0, -1)))\n        while v3 <= v6:\n            v7 = v3 + (v6 - v3) // 2\n            if check(a1, a2, a3, v1, v7):\n                v6 = v7 - 1\n            else:\n                v3 = v7 + 1\n        return v3\n"}
{"id": "human_code\\p03213__s242376391.py", "text": "\"\"\"\n22:17:30\n\n\"\"\"\nfrom collections import defaultdict\nv1 = int(input())\n\ndef f1(a1):\n    if not isinstance(a1, int):\n        raise TypeError('Input int')\n    if a1 < 2:\n        raise ValueError('N >= 2')\n    v1 = []\n    v2 = [i + 1 for v3 in range(1, a1)]\n    while True:\n        v4 = v2[0]\n        if v4 >= int(a1 ** 0.5):\n            return v1 + v2\n        v1.append(v4)\n        v2 = [d for v5 in v2 if v5 % v4 != 0]\n\ndef f2(a1):\n    v1 = defaultdict(int)\n    for v2 in range(1, a1 + 1):\n        if v2 <= 3:\n            v1[v2] += 1\n            continue\n        v3 = f1(int(v2 ** 0.5))\n        for v4 in v3:\n            while v2 % v4 == 0:\n                v1[v4] += 1\n                v2 //= v4\n        if v2 != 1:\n            v1[v2] += 1\n    return v1\nv2 = f2(v1)\nv3 = 0\nv4 = 0\nv5 = 0\nv6 = 0\nv7 = 0\nfor v8 in v2.keys():\n    v9 = v2[v8]\n    if v9 >= 2:\n        v7 += 1\n    if v9 >= 4:\n        v6 += 1\n    if v9 >= 14:\n        v5 += 1\n    if v9 >= 24:\n        v4 += 1\n    if v9 >= 74:\n        v3 += 1\nv10 = 0\nv10 += v3\nv10 += (v7 - 1) * v4\nv10 += (v6 - 1) * v5\nv10 += (v7 - 2) * v6 * (v6 - 1) // 2\nprint(v10)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "\"\"\"\n22:17:30\n\n\"\"\"\nfrom collections import defaultdict\nv1 = int(input())\n\ndef f1(a1):\n    if not isinstance(a1, int):\n        raise TypeError('Input int')\n    if a1 < 2:\n        raise ValueError('N >= 2')\n    v1 = []\n    v2 = [i + 1 for v3 in range(1, a1)]\n    while True:\n        v4 = v2[0]\n        if v4 >= int(a1 ** 0.5):\n            return v1 + v2\n        v1.append(v4)\n        v2 = [d for v5 in v2 if v5 % v4 != 0]\n\ndef f2(a1):\n    v1 = defaultdict(int)\n    for v2 in range(1, a1 + 1):\n        if v2 <= 3:\n            v1[v2] += 1\n            continue\n        v3 = f1(int(v2 ** 0.5))\n        for v4 in v3:\n            while v2 % v4 == 0:\n                v1[v4] += 1\n                v2 //= v4\n        if v2 != 1:\n            v1[v2] += 1\n    return v1\nv2 = f2(v1)\nv3 = 0\nv4 = 0\nv5 = 0\nv6 = 0\nv7 = 0\nfor v8 in v2.keys():\n    v9 = v2[v8]\n    if v9 >= 2:\n        v7 += 1\n    if v9 >= 4:\n        v6 += 1\n    if v9 >= 14:\n        v5 += 1\n    if v9 >= 24:\n        v4 += 1\n    if v9 >= 74:\n        v3 += 1\nv10 = 0\nv10 += v3\nv10 += (v7 - 1) * v4\nv10 += (v6 - 1) * v5\nv10 += (v7 - 2) * v6 * (v6 - 1) // 2\nprint(v10)\n"}
{"id": "human_code\\tree-diameter__part2.py", "text": "class C1(object):\n\n    def treeDiameter(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            v1 = 0\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v3 = dfs(v2, a1)\n                result[0] = max(result[0], v1 + (v3 + 1))\n                v1 = max(v1, v3 + 1)\n            return v1\n        v1 = [[] for v2 in range(len(a1) + 1)]\n        for v3, v4 in a1:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0]\n        dfs(0, -1)\n        return v5[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def treeDiameter(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            v1 = 0\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v3 = dfs(v2, a1)\n                result[0] = max(result[0], v1 + (v3 + 1))\n                v1 = max(v1, v3 + 1)\n            return v1\n        v1 = [[] for v2 in range(len(a1) + 1)]\n        for v3, v4 in a1:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0]\n        dfs(0, -1)\n        return v5[0]\n"}
{"id": "llm_code\\cinema-seat-allocation__grok-4.1-fast__v1.py", "text": "from collections import defaultdict\n\nclass C1:\n\n    def maxNumberOfFamilies(self, a1, a2):\n        v1 = defaultdict(int)\n        for v2, v3 in a2:\n            if 2 <= v3 <= 5:\n                v1[v2] |= 1\n            if 4 <= v3 <= 7:\n                v1[v2] |= 2\n            if 6 <= v3 <= 9:\n                v1[v2] |= 4\n        v4 = 2 * a1\n        for v5 in v1.values():\n            if v5 & 1 == 0 and v5 & 4 == 0:\n                continue\n            if v5 != 7:\n                v4 -= 1\n            else:\n                v4 -= 2\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import defaultdict\n\nclass C1:\n\n    def maxNumberOfFamilies(self, a1, a2):\n        v1 = defaultdict(int)\n        for v2, v3 in a2:\n            if 2 <= v3 <= 5:\n                v1[v2] |= 1\n            if 4 <= v3 <= 7:\n                v1[v2] |= 2\n            if 6 <= v3 <= 9:\n                v1[v2] |= 4\n        v4 = 2 * a1\n        for v5 in v1.values():\n            if v5 & 1 == 0 and v5 & 4 == 0:\n                continue\n            if v5 != 7:\n                v4 -= 1\n            else:\n                v4 -= 2\n        return v4\n"}
{"id": "human_code\\maximize-sum-of-weights-after-edge-removals__part2.py", "text": "import random\n\nclass C1(object):\n\n    def maximizeSumOfWeights(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4):\n                v1 = a2\n                while v1 <= a3:\n                    if a3(a1[v1], a4):\n                        a1[v1], a1[a2] = (a1[a2], a1[v1])\n                        a2 += 1\n                        v1 += 1\n                    elif a3(a4, a1[v1]):\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                    else:\n                        v1 += 1\n                return (a2, a3)\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = random.randint(v1, v2)\n                v4, v5 = tri_partition(a1, v1, v2, a1[v3])\n                if v4 <= a2 <= v5:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v5 + 1\n\n        def dfs(a1, a2):\n            v1 = 0\n            v2 = []\n            for v3, v4 in adj[a1]:\n                if v3 == a2:\n                    continue\n                v5 = dfs(v3, a1)\n                v1 += v5[0]\n                v2.append(max(v5[1] + v4 - v5[0], 0))\n            if a2 - 1 < len(v2):\n                nth_element(v2, a2 - 1, lambda a, b: a > b)\n            return (v1 + sum((v2[i] for v6 in range(min(a2, len(v2))))), v1 + sum((v2[v6] for v6 in range(min(a2 - 1, len(v2))))))\n        v1 = [[] for v2 in range(len(a1) + 1)]\n        for v3, v4, v5 in a1:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        return dfs(0, -1)[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def maximizeSumOfWeights(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4):\n                v1 = a2\n                while v1 <= a3:\n                    if a3(a1[v1], a4):\n                        a1[v1], a1[a2] = (a1[a2], a1[v1])\n                        a2 += 1\n                        v1 += 1\n                    elif a3(a4, a1[v1]):\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                    else:\n                        v1 += 1\n                return (a2, a3)\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = random.randint(v1, v2)\n                v4, v5 = tri_partition(a1, v1, v2, a1[v3])\n                if v4 <= a2 <= v5:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v5 + 1\n\n        def dfs(a1, a2):\n            v1 = 0\n            v2 = []\n            for v3, v4 in adj[a1]:\n                if v3 == a2:\n                    continue\n                v5 = dfs(v3, a1)\n                v1 += v5[0]\n                v2.append(max(v5[1] + v4 - v5[0], 0))\n            if a2 - 1 < len(v2):\n                nth_element(v2, a2 - 1, lambda a, b: a > b)\n            return (v1 + sum((v2[i] for v6 in range(min(a2, len(v2))))), v1 + sum((v2[v6] for v6 in range(min(a2 - 1, len(v2))))))\n        v1 = [[] for v2 in range(len(a1) + 1)]\n        for v3, v4, v5 in a1:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        return dfs(0, -1)[0]\n"}
{"id": "human_code\\p03213__s037547332.py", "text": "from functools import reduce\nfrom operator import mul\n\ndef f1(a1):\n    v1 = []\n    v2 = 2\n    v3 = 0\n    while v2 <= a1:\n        v3 += a1 // v2\n        v2 *= 2\n    if v3 > 0:\n        v1.append((2, v3))\n    v4 = [1] * (a1 + 1)\n    v5 = int(a1 ** 0.5) + 1\n    for v6 in range(3, v5 + 1, 2):\n        if v4[v6]:\n            for v7 in range(v6 + v6, a1 + 1, v6):\n                v4[v7] = 0\n    for v6 in range(3, a1 + 1, 2):\n        if v4[v6]:\n            v2 = v6\n            v3 = 0\n            while v2 <= a1:\n                v3 += a1 // v2\n                v2 *= v6\n            v1.append((v6, v3))\n    return v1\nimport sys\n\ndef f2(*a1, **a2):\n    print(*a1, file=sys.stderr, **a2)\nv1 = [[74], [24, 2], [14, 4], [4, 4, 2]]\nv2 = [1, 1, 1, 2]\nv3 = int(input())\nv4 = f1(v3)\nv5 = [0] * (v3 + 1)\nv6 = [0] * (v3 + 1)\nfor v4 in f1(v3):\n    v5[v4[1]] += 1\nfor v7 in range(v3, -1, -1):\n    v6[v7] = v5[v7] if v7 == v3 else v5[v7] + v6[v7 + 1]\nv8 = 0\nfor v7, v9 in enumerate(v1):\n    v10 = []\n    for v11, v12 in enumerate(v9):\n        if v12 > v3:\n            break\n        v10.append(v6[v12] - v11)\n    if len(v10):\n        v8 += reduce(mul, v10) // v2[v7]\nprint(v8)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from functools import reduce\nfrom operator import mul\n\ndef f1(a1):\n    v1 = []\n    v2 = 2\n    v3 = 0\n    while v2 <= a1:\n        v3 += a1 // v2\n        v2 *= 2\n    if v3 > 0:\n        v1.append((2, v3))\n    v4 = [1] * (a1 + 1)\n    v5 = int(a1 ** 0.5) + 1\n    for v6 in range(3, v5 + 1, 2):\n        if v4[v6]:\n            for v7 in range(v6 + v6, a1 + 1, v6):\n                v4[v7] = 0\n    for v6 in range(3, a1 + 1, 2):\n        if v4[v6]:\n            v2 = v6\n            v3 = 0\n            while v2 <= a1:\n                v3 += a1 // v2\n                v2 *= v6\n            v1.append((v6, v3))\n    return v1\nimport sys\n\ndef f2(*a1, **a2):\n    print(*a1, file=sys.stderr, **a2)\nv1 = [[74], [24, 2], [14, 4], [4, 4, 2]]\nv2 = [1, 1, 1, 2]\nv3 = int(input())\nv4 = f1(v3)\nv5 = [0] * (v3 + 1)\nv6 = [0] * (v3 + 1)\nfor v4 in f1(v3):\n    v5[v4[1]] += 1\nfor v7 in range(v3, -1, -1):\n    v6[v7] = v5[v7] if v7 == v3 else v5[v7] + v6[v7 + 1]\nv8 = 0\nfor v7, v9 in enumerate(v1):\n    v10 = []\n    for v11, v12 in enumerate(v9):\n        if v12 > v3:\n            break\n        v10.append(v6[v12] - v11)\n    if len(v10):\n        v8 += reduce(mul, v10) // v2[v7]\nprint(v8)\n"}
{"id": "human_code\\longest-balanced-subarray-ii.py", "text": "class C1(object):\n\n    def longestBalanced(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class SegmentTree(object):\n\n            def __init__(self, a1):\n                self.min = [0] * (1 << (a1 - 1).bit_length() + 1)\n                self.max = [0] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.min) >> 1\n                self.lazy = [0] * self.base\n\n            def __apply(self, a1, a2):\n                self.min[a1] += a2\n                self.max[a1] += a2\n                if a1 < self.base:\n                    self.lazy[a1] += a2\n\n            def __push(self, a1):\n                for v1 in reversed(range(1, a1.bit_length())):\n                    v2 = a1 >> v1\n                    if self.lazy[v2]:\n                        self.__apply(v2 << 1, self.lazy[v2])\n                        self.__apply(v2 << 1 | 1, self.lazy[v2])\n                        self.lazy[v2] = 0\n\n            def update(self, a1, a2, a3):\n\n                def pull(a1):\n                    while a1 > 1:\n                        a1 >>= 1\n                        self.min[a1] = self.min[a1 << 1] if self.min[a1 << 1] < self.min[a1 << 1 | 1] else self.min[a1 << 1 | 1]\n                        self.max[a1] = self.max[a1 << 1] if self.max[a1 << 1] > self.max[a1 << 1 | 1] else self.max[a1 << 1 | 1]\n                        if self.lazy[a1]:\n                            self.min[a1] += self.lazy[a1]\n                            self.max[a1] += self.lazy[a1]\n                a1 += self.base\n                a2 += self.base\n                v3, v4 = (a1, a2)\n                while a1 <= a2:\n                    if a1 & 1:\n                        self.__apply(a1, a3)\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        self.__apply(a2, a3)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                pull(v3)\n                pull(v4)\n\n            def binary_search(self, a1):\n                v1 = 1\n                while not v1 >= self.base:\n                    if self.lazy[v1]:\n                        self.__apply(v1 << 1, self.lazy[v1])\n                        self.__apply(v1 << 1 | 1, self.lazy[v1])\n                        self.lazy[v1] = 0\n                    v1 <<= 1\n                    if not self.min[v1] <= a1 <= self.max[v1]:\n                        v1 |= 1\n                return v1 - self.base\n        v1 = len(a1) + 1\n        v2 = SegmentTree(v1)\n        v3 = v4 = 0\n        v5 = {}\n        for v6, v7 in enumerate(a1, 1):\n            v8 = +1 if v7 & 1 else -1\n            if v7 in v5:\n                v2.update(v5[v7], v1 - 1, -v8)\n                v4 -= v8\n            v4 += v8\n            v5[v7] = v6\n            v2.update(v5[v7], v1 - 1, +v8)\n            v9 = v6 - v2.binary_search(v4)\n            if v9 > v3:\n                v3 = v9\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestBalanced(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class SegmentTree(object):\n\n            def __init__(self, a1):\n                self.min = [0] * (1 << (a1 - 1).bit_length() + 1)\n                self.max = [0] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.min) >> 1\n                self.lazy = [0] * self.base\n\n            def __apply(self, a1, a2):\n                self.min[a1] += a2\n                self.max[a1] += a2\n                if a1 < self.base:\n                    self.lazy[a1] += a2\n\n            def __push(self, a1):\n                for v1 in reversed(range(1, a1.bit_length())):\n                    v2 = a1 >> v1\n                    if self.lazy[v2]:\n                        self.__apply(v2 << 1, self.lazy[v2])\n                        self.__apply(v2 << 1 | 1, self.lazy[v2])\n                        self.lazy[v2] = 0\n\n            def update(self, a1, a2, a3):\n\n                def pull(a1):\n                    while a1 > 1:\n                        a1 >>= 1\n                        self.min[a1] = self.min[a1 << 1] if self.min[a1 << 1] < self.min[a1 << 1 | 1] else self.min[a1 << 1 | 1]\n                        self.max[a1] = self.max[a1 << 1] if self.max[a1 << 1] > self.max[a1 << 1 | 1] else self.max[a1 << 1 | 1]\n                        if self.lazy[a1]:\n                            self.min[a1] += self.lazy[a1]\n                            self.max[a1] += self.lazy[a1]\n                a1 += self.base\n                a2 += self.base\n                v3, v4 = (a1, a2)\n                while a1 <= a2:\n                    if a1 & 1:\n                        self.__apply(a1, a3)\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        self.__apply(a2, a3)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                pull(v3)\n                pull(v4)\n\n            def binary_search(self, a1):\n                v1 = 1\n                while not v1 >= self.base:\n                    if self.lazy[v1]:\n                        self.__apply(v1 << 1, self.lazy[v1])\n                        self.__apply(v1 << 1 | 1, self.lazy[v1])\n                        self.lazy[v1] = 0\n                    v1 <<= 1\n                    if not self.min[v1] <= a1 <= self.max[v1]:\n                        v1 |= 1\n                return v1 - self.base\n        v1 = len(a1) + 1\n        v2 = SegmentTree(v1)\n        v3 = v4 = 0\n        v5 = {}\n        for v6, v7 in enumerate(a1, 1):\n            v8 = +1 if v7 & 1 else -1\n            if v7 in v5:\n                v2.update(v5[v7], v1 - 1, -v8)\n                v4 -= v8\n            v4 += v8\n            v5[v7] = v6\n            v2.update(v5[v7], v1 - 1, +v8)\n            v9 = v6 - v2.binary_search(v4)\n            if v9 > v3:\n                v3 = v9\n        return v3\n"}
{"id": "human_code\\design-underground-system.py", "text": "import collections\n\nclass C1(object):\n\n    def __init__(self):\n        self.__live = {}\n        self.__statistics = collections.defaultdict(lambda: [0, 0])\n\n    def checkIn(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        self.__live[a1] = (a2, a3)\n\n    def checkOut(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1, v2 = self.__live.pop(a1)\n        self.__statistics[v1, a2][0] += a3 - v2\n        self.__statistics[v1, a2][1] += 1\n\n    def getAverageTime(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = self.__statistics[a1, a2]\n        return float(v1) / v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def __init__(self):\n        self.__live = {}\n        self.__statistics = collections.defaultdict(lambda: [0, 0])\n\n    def checkIn(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        self.__live[a1] = (a2, a3)\n\n    def checkOut(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1, v2 = self.__live.pop(a1)\n        self.__statistics[v1, a2][0] += a3 - v2\n        self.__statistics[v1, a2][1] += 1\n\n    def getAverageTime(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = self.__statistics[a1, a2]\n        return float(v1) / v2\n"}
{"id": "human_code\\regions-cut-by-slashes.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.count = a1\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 != v2:\n            self.set[min(v1, v2)] = max(v1, v2)\n            self.count -= 1\n\nclass C2(object):\n\n    def regionsBySlashes(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def index(a1, a2, a3, a4):\n            return (a2 * a1 + a3) * 4 + a4\n        v1 = C1(len(a1) ** 2 * 4)\n        v2, v3, v4, v5 = list(range(4))\n        for v6 in range(len(a1)):\n            for v7 in range(len(a1)):\n                if v6:\n                    v1.union_set(index(len(a1), v6 - 1, v7, v4), index(len(a1), v6, v7, v2))\n                if v7:\n                    v1.union_set(index(len(a1), v6, v7 - 1, v3), index(len(a1), v6, v7, v5))\n                if a1[v6][v7] != '/':\n                    v1.union_set(index(len(a1), v6, v7, v2), index(len(a1), v6, v7, v3))\n                    v1.union_set(index(len(a1), v6, v7, v4), index(len(a1), v6, v7, v5))\n                if a1[v6][v7] != '\\\\':\n                    v1.union_set(index(len(a1), v6, v7, v5), index(len(a1), v6, v7, v2))\n                    v1.union_set(index(len(a1), v6, v7, v3), index(len(a1), v6, v7, v4))\n        return v1.count\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.count = a1\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 != v2:\n            self.set[min(v1, v2)] = max(v1, v2)\n            self.count -= 1\n\nclass C2(object):\n\n    def regionsBySlashes(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def index(a1, a2, a3, a4):\n            return (a2 * a1 + a3) * 4 + a4\n        v1 = C1(len(a1) ** 2 * 4)\n        v2, v3, v4, v5 = list(range(4))\n        for v6 in range(len(a1)):\n            for v7 in range(len(a1)):\n                if v6:\n                    v1.union_set(index(len(a1), v6 - 1, v7, v4), index(len(a1), v6, v7, v2))\n                if v7:\n                    v1.union_set(index(len(a1), v6, v7 - 1, v3), index(len(a1), v6, v7, v5))\n                if a1[v6][v7] != '/':\n                    v1.union_set(index(len(a1), v6, v7, v2), index(len(a1), v6, v7, v3))\n                    v1.union_set(index(len(a1), v6, v7, v4), index(len(a1), v6, v7, v5))\n                if a1[v6][v7] != '\\\\':\n                    v1.union_set(index(len(a1), v6, v7, v5), index(len(a1), v6, v7, v2))\n                    v1.union_set(index(len(a1), v6, v7, v3), index(len(a1), v6, v7, v4))\n        return v1.count\n"}
{"id": "human_code\\p03409__s906990167.py", "text": "v1 = int(input())\nv2 = [list(map(int, input().split())) for v3 in range(v1)]\nv4 = [list(map(int, input().split())) for v3 in range(v1)]\nv5 = 0\nv2.sort(reverse=True, key=lambda x: (x[0], x[1]))\nv4.sort(key=lambda x: (x[0], x[1]))\n\ndef f1(a1, a2):\n    v1 = []\n    v2 = []\n    for v3 in a1:\n        if v3 in v1:\n            continue\n        for v4 in a2:\n            if v4 in v2:\n                continue\n            if v3[0] < v4[0] and v3[1] < v4[1]:\n                v1.append(v3)\n                v2.append(v4)\n                break\n    return len(v1)\nv5 = f1(v2, v4)\nv2.sort(reverse=True, key=lambda x: (x[1], x[0]))\nv4.sort(key=lambda x: (x[1], x[0]))\nv5 = max(v5, f1(v2, v4))\nv2.sort(reverse=True, key=lambda x: (x[1], x[0]))\nv4.sort(key=lambda x: (x[0], x[1]))\nv5 = max(v5, f1(v2, v4))\nv2.sort(reverse=True, key=lambda x: (x[0], x[1]))\nv4.sort(key=lambda x: (x[1], x[0]))\nv5 = max(v5, f1(v2, v4))\nprint(v5)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [list(map(int, input().split())) for v3 in range(v1)]\nv4 = [list(map(int, input().split())) for v3 in range(v1)]\nv5 = 0\nv2.sort(reverse=True, key=lambda x: (x[0], x[1]))\nv4.sort(key=lambda x: (x[0], x[1]))\n\ndef f1(a1, a2):\n    v1 = []\n    v2 = []\n    for v3 in a1:\n        if v3 in v1:\n            continue\n        for v4 in a2:\n            if v4 in v2:\n                continue\n            if v3[0] < v4[0] and v3[1] < v4[1]:\n                v1.append(v3)\n                v2.append(v4)\n                break\n    return len(v1)\nv5 = f1(v2, v4)\nv2.sort(reverse=True, key=lambda x: (x[1], x[0]))\nv4.sort(key=lambda x: (x[1], x[0]))\nv5 = max(v5, f1(v2, v4))\nv2.sort(reverse=True, key=lambda x: (x[1], x[0]))\nv4.sort(key=lambda x: (x[0], x[1]))\nv5 = max(v5, f1(v2, v4))\nv2.sort(reverse=True, key=lambda x: (x[0], x[1]))\nv4.sort(key=lambda x: (x[1], x[0]))\nv5 = max(v5, f1(v2, v4))\nprint(v5)\n"}
{"id": "llm_code\\shortest-bridge__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1(object):\n\n    def shortestBridge(self, a1):\n        v1 = len(a1)\n        v2 = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        v3 = set()\n        v4 = collections.deque()\n        for v5 in range(v1):\n            for v6 in range(v1):\n                if a1[v5][v6] == 1:\n                    v7 = collections.deque([(v5, v6)])\n                    v3.add((v5, v6))\n                    while v7:\n                        v8, v9 = v7.popleft()\n                        for v10, v11 in v2:\n                            v12, v13 = (v8 + v10, v9 + v11)\n                            if 0 <= v12 < v1 and 0 <= v13 < v1 and ((v12, v13) not in v3) and (a1[v12][v13] == 1):\n                                v3.add((v12, v13))\n                                v7.append((v12, v13))\n                    v4 = collections.deque(((r, c, 0) for v14, v15 in v3))\n                    break\n            else:\n                continue\n            break\n        while v4:\n            v8, v9, v16 = v4.popleft()\n            for v10, v11 in v2:\n                v12, v13 = (v8 + v10, v9 + v11)\n                if not (0 <= v12 < v1 and 0 <= v13 < v1):\n                    continue\n                if (v12, v13) in v3:\n                    continue\n                if a1[v12][v13] == 1:\n                    return v16\n                v3.add((v12, v13))\n                v4.append((v12, v13, v16 + 1))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def shortestBridge(self, a1):\n        v1 = len(a1)\n        v2 = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        v3 = set()\n        v4 = collections.deque()\n        for v5 in range(v1):\n            for v6 in range(v1):\n                if a1[v5][v6] == 1:\n                    v7 = collections.deque([(v5, v6)])\n                    v3.add((v5, v6))\n                    while v7:\n                        v8, v9 = v7.popleft()\n                        for v10, v11 in v2:\n                            v12, v13 = (v8 + v10, v9 + v11)\n                            if 0 <= v12 < v1 and 0 <= v13 < v1 and ((v12, v13) not in v3) and (a1[v12][v13] == 1):\n                                v3.add((v12, v13))\n                                v7.append((v12, v13))\n                    v4 = collections.deque(((r, c, 0) for v14, v15 in v3))\n                    break\n            else:\n                continue\n            break\n        while v4:\n            v8, v9, v16 = v4.popleft()\n            for v10, v11 in v2:\n                v12, v13 = (v8 + v10, v9 + v11)\n                if not (0 <= v12 < v1 and 0 <= v13 < v1):\n                    continue\n                if (v12, v13) in v3:\n                    continue\n                if a1[v12][v13] == 1:\n                    return v16\n                v3.add((v12, v13))\n                v4.append((v12, v13, v16 + 1))\n"}
{"id": "llm_code\\maximum-increasing-triplet-value__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumTripletValue(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v2[v1 - 1] = a1[v1 - 1]\n        for v3 in range(v1 - 2, -1, -1):\n            v2[v3] = max(v2[v3 + 1], a1[v3])\n        v4 = sorted(set(a1))\n        v5 = {v4[v3]: v3 + 1 for v3 in range(len(v4))}\n        v6 = len(v4)\n        v7 = [-1] * (v6 + 2)\n\n        def upd(a1, a2):\n            while a1 <= v6:\n                v7[a1] = max(v7[a1], a2)\n                a1 += a1 & -a1\n\n        def qmax(a1):\n            v1 = -1\n            while a1 > 0:\n                v1 = max(v1, v7[a1])\n                a1 -= a1 & -a1\n            return v1\n        v8 = 0\n        for v9 in range(v1):\n            if 1 <= v9 < v1 - 1:\n                v10 = v5[a1[v9]]\n                v11 = qmax(v10 - 1)\n                v12 = v2[v9 + 1]\n                if v11 != -1 and v12 > a1[v9]:\n                    v8 = max(v8, v11 - a1[v9] + v12)\n            upd(v5[a1[v9]], a1[v9])\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumTripletValue(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v2[v1 - 1] = a1[v1 - 1]\n        for v3 in range(v1 - 2, -1, -1):\n            v2[v3] = max(v2[v3 + 1], a1[v3])\n        v4 = sorted(set(a1))\n        v5 = {v4[v3]: v3 + 1 for v3 in range(len(v4))}\n        v6 = len(v4)\n        v7 = [-1] * (v6 + 2)\n\n        def upd(a1, a2):\n            while a1 <= v6:\n                v7[a1] = max(v7[a1], a2)\n                a1 += a1 & -a1\n\n        def qmax(a1):\n            v1 = -1\n            while a1 > 0:\n                v1 = max(v1, v7[a1])\n                a1 -= a1 & -a1\n            return v1\n        v8 = 0\n        for v9 in range(v1):\n            if 1 <= v9 < v1 - 1:\n                v10 = v5[a1[v9]]\n                v11 = qmax(v10 - 1)\n                v12 = v2[v9 + 1]\n                if v11 != -1 and v12 > a1[v9]:\n                    v8 = max(v8, v11 - a1[v9] + v12)\n            upd(v5[a1[v9]], a1[v9])\n        return v8\n"}
{"id": "llm_code\\satisfiability-of-equality-equations__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def equationsPossible(self, a1):\n        v1 = [[False] * 26 for v2 in range(26)]\n        for v3 in a1:\n            v4 = ord(v3[0]) - ord('a')\n            v5 = ord(v3[3]) - ord('a')\n            if v3[1] == '!':\n                if v4 == v5:\n                    return False\n            else:\n                v1[v4][v5] = True\n                v1[v5][v4] = True\n        for v6 in range(26):\n            for v7 in range(26):\n                for v8 in range(26):\n                    if v1[v7][v6] and v1[v6][v8]:\n                        v1[v7][v8] = True\n        for v3 in a1:\n            if v3[1] == '!':\n                v4 = ord(v3[0]) - ord('a')\n                v5 = ord(v3[3]) - ord('a')\n                if v1[v4][v5]:\n                    return False\n        return True\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def equationsPossible(self, a1):\n        v1 = [[False] * 26 for v2 in range(26)]\n        for v3 in a1:\n            v4 = ord(v3[0]) - ord('a')\n            v5 = ord(v3[3]) - ord('a')\n            if v3[1] == '!':\n                if v4 == v5:\n                    return False\n            else:\n                v1[v4][v5] = True\n                v1[v5][v4] = True\n        for v6 in range(26):\n            for v7 in range(26):\n                for v8 in range(26):\n                    if v1[v7][v6] and v1[v6][v8]:\n                        v1[v7][v8] = True\n        for v3 in a1:\n            if v3[1] == '!':\n                v4 = ord(v3[0]) - ord('a')\n                v5 = ord(v3[3]) - ord('a')\n                if v1[v4][v5]:\n                    return False\n        return True\n"}
{"id": "llm_code\\p03096__s083611259.py", "text": "import sys\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = []\nv3 = 0\nv4 = 0\nfor v5 in range(v1):\n    v6 = int(input())\n    if v6 != v3:\n        v2.append(v6)\n        v3 = v6\n        v4 += 1\nv1 = v4\nfrom collections import Counter\nv7 = Counter()\nv8 = 1\nv9 = 10 ** 9 + 7\nfor v5 in range(v1):\n    if v5 == 0 or v5 == v1 - 1:\n        v7[v2[v5]] += 1\n    elif v2[v5] == v2[v5 - 1]:\n        v7[v2[v5]] += v7[v2[v5 - 1]]\n    else:\n        v7[v2[v5]] += 1\n    v8 = v8 * v7[v2[v5]] % v9\nprint(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = []\nv3 = 0\nv4 = 0\nfor v5 in range(v1):\n    v6 = int(input())\n    if v6 != v3:\n        v2.append(v6)\n        v3 = v6\n        v4 += 1\nv1 = v4\nfrom collections import Counter\nv7 = Counter()\nv8 = 1\nv9 = 10 ** 9 + 7\nfor v5 in range(v1):\n    if v5 == 0 or v5 == v1 - 1:\n        v7[v2[v5]] += 1\n    elif v2[v5] == v2[v5 - 1]:\n        v7[v2[v5]] += v7[v2[v5 - 1]]\n    else:\n        v7[v2[v5]] += 1\n    v8 = v8 * v7[v2[v5]] % v9\nprint(v8)\n"}
{"id": "llm_code\\p03095__s965499633.py", "text": "import bisect\nimport itertools\nv1 = int(input())\nv2 = input()\nv3 = {}\nfor v4 in range(v1):\n    if v2[v4] in v3:\n        v3[v2[v4]].append(v4)\n    else:\n        v3[v2[v4]] = [v4]\nv5 = 0\nv6 = 10 ** 9 + 7\nv7 = []\nfor v8, v9 in v3.items():\n    v7.append(len(v9) - bisect.bisect_left(v9, 0))\nfor v4 in range(1, 27):\n    v10 = v5\n    for v11 in itertools.combinations(v7, v4):\n        v12 = 1\n        for v13 in v11:\n            v12 = v12 * v13 % v6\n        v5 = (v5 + v12) % v6\n    if v10 == v5:\n        break\nprint(v5)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import bisect\nimport itertools\nv1 = int(input())\nv2 = input()\nv3 = {}\nfor v4 in range(v1):\n    if v2[v4] in v3:\n        v3[v2[v4]].append(v4)\n    else:\n        v3[v2[v4]] = [v4]\nv5 = 0\nv6 = 10 ** 9 + 7\nv7 = []\nfor v8, v9 in v3.items():\n    v7.append(len(v9) - bisect.bisect_left(v9, 0))\nfor v4 in range(1, 27):\n    v10 = v5\n    for v11 in itertools.combinations(v7, v4):\n        v12 = 1\n        for v13 in v11:\n            v12 = v12 * v13 % v6\n        v5 = (v5 + v12) % v6\n    if v10 == v5:\n        break\nprint(v5)\n"}
{"id": "llm_code\\maximum-balanced-subsequence-sum__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxBalancedSubsequenceSum(self, a1):\n        v1 = len(a1)\n        v2 = float('-inf')\n        v3 = sorted({a1[i] - i for v4 in range(v1)})\n        v5 = len(v3)\n        v6 = {v3[v4]: v4 + 1 for v4 in range(v5)}\n        v7 = [v2] * (v5 + 2)\n\n        def modify(a1, a2):\n            while a1 <= v5:\n                v7[a1] = max(v7[a1], a2)\n                a1 += a1 & -a1\n\n        def prefix_max(a1):\n            v1 = v2\n            while a1 > 0:\n                v1 = max(v1, v7[a1])\n                a1 -= a1 & -a1\n            return v1\n        for v4 in range(v1):\n            v8 = a1[v4]\n            v9 = v8 - v4\n            v10 = v6[v9]\n            v11 = prefix_max(v10)\n            v12 = max(v11, 0) + v8\n            modify(v10, v12)\n        return prefix_max(v5)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxBalancedSubsequenceSum(self, a1):\n        v1 = len(a1)\n        v2 = float('-inf')\n        v3 = sorted({a1[i] - i for v4 in range(v1)})\n        v5 = len(v3)\n        v6 = {v3[v4]: v4 + 1 for v4 in range(v5)}\n        v7 = [v2] * (v5 + 2)\n\n        def modify(a1, a2):\n            while a1 <= v5:\n                v7[a1] = max(v7[a1], a2)\n                a1 += a1 & -a1\n\n        def prefix_max(a1):\n            v1 = v2\n            while a1 > 0:\n                v1 = max(v1, v7[a1])\n                a1 -= a1 & -a1\n            return v1\n        for v4 in range(v1):\n            v8 = a1[v4]\n            v9 = v8 - v4\n            v10 = v6[v9]\n            v11 = prefix_max(v10)\n            v12 = max(v11, 0) + v8\n            modify(v10, v12)\n        return prefix_max(v5)\n"}
{"id": "human_code\\find-maximum-area-of-a-triangle.py", "text": "import collections\n\nclass C1(object):\n\n    def maxArea(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = max((x for v2, v3 in a1))\n        v4 = min((v2 for v2, v3 in a1))\n        v5 = max((y for v3, v6 in a1))\n        v7 = min((v6 for v3, v6 in a1))\n        v8 = collections.defaultdict(lambda: float('-inf'))\n        v9 = collections.defaultdict(lambda: float('inf'))\n        v10 = collections.defaultdict(lambda: float('-inf'))\n        v11 = collections.defaultdict(lambda: float('inf'))\n        for v2, v6 in a1:\n            v8[v2] = max(v8[v2], v6)\n            v9[v2] = min(v9[v2], v6)\n            v10[v6] = max(v10[v6], v2)\n            v11[v6] = min(v11[v6], v2)\n        v12 = max(max(((v8[v2] - v9[v2]) * max(v2 - v4, v1 - v2) for v2 in v8.keys())), max(((v10[v6] - v11[v6]) * max(v6 - v7, v5 - v6) for v6 in v10.keys())))\n        return v12 if v12 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def maxArea(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = max((x for v2, v3 in a1))\n        v4 = min((v2 for v2, v3 in a1))\n        v5 = max((y for v3, v6 in a1))\n        v7 = min((v6 for v3, v6 in a1))\n        v8 = collections.defaultdict(lambda: float('-inf'))\n        v9 = collections.defaultdict(lambda: float('inf'))\n        v10 = collections.defaultdict(lambda: float('-inf'))\n        v11 = collections.defaultdict(lambda: float('inf'))\n        for v2, v6 in a1:\n            v8[v2] = max(v8[v2], v6)\n            v9[v2] = min(v9[v2], v6)\n            v10[v6] = max(v10[v6], v2)\n            v11[v6] = min(v11[v6], v2)\n        v12 = max(max(((v8[v2] - v9[v2]) * max(v2 - v4, v1 - v2) for v2 in v8.keys())), max(((v10[v6] - v11[v6]) * max(v6 - v7, v5 - v6) for v6 in v10.keys())))\n        return v12 if v12 else -1\n"}
{"id": "human_code\\p02733__s556330014.py", "text": "v1, v2, v3 = (int(x) for v4 in input().split())\nv5 = [input() for v6 in range(v1)]\nv7 = 10 ** 18\nfor v8 in range(1 << v1 - 1):\n    v9 = [0] * v1\n    v10 = 0\n    for v11 in range(v1 - 1):\n        if v8 & 1 << v11:\n            v10 += 1\n        v9[v11 + 1] = v10\n    v12 = max(v9) + 1\n    v13 = v12 - 1\n    v14 = [0] * v12\n    for v15 in range(v2):\n        v16 = [0] * v12\n        for v11 in range(v1):\n            v14[v9[v11]] += int(v5[v11][v15])\n            v16[v9[v11]] += int(v5[v11][v15])\n            if v14[v9[v11]] > v3:\n                v13 += 1\n                for v17 in range(v12):\n                    v14[v17] = v16[v17]\n    v7 = min(v7, v13)\nprint(v7)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = (int(x) for v4 in input().split())\nv5 = [input() for v6 in range(v1)]\nv7 = 10 ** 18\nfor v8 in range(1 << v1 - 1):\n    v9 = [0] * v1\n    v10 = 0\n    for v11 in range(v1 - 1):\n        if v8 & 1 << v11:\n            v10 += 1\n        v9[v11 + 1] = v10\n    v12 = max(v9) + 1\n    v13 = v12 - 1\n    v14 = [0] * v12\n    for v15 in range(v2):\n        v16 = [0] * v12\n        for v11 in range(v1):\n            v14[v9[v11]] += int(v5[v11][v15])\n            v16[v9[v11]] += int(v5[v11][v15])\n            if v14[v9[v11]] > v3:\n                v13 += 1\n                for v17 in range(v12):\n                    v14[v17] = v16[v17]\n    v7 = min(v7, v13)\nprint(v7)\n"}
{"id": "llm_code\\minimum-moves-to-reach-target-in-grid__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minMoves(self, a1, a2, a3, a4):\n        v1, v2 = (a1, a2)\n        v3, v4 = (a3, a4)\n        v5 = 0\n        while v3 != v1 or v4 != v2:\n            if v3 < v1 or v4 < v2:\n                return -1\n            if v3 == v4:\n                if v1 == 0:\n                    v3 = 0\n                elif v2 == 0:\n                    v4 = 0\n                else:\n                    return -1\n            elif v3 < v4:\n                v6 = v4 // 2\n                if v3 > v6:\n                    v4 -= v3\n                else:\n                    if v4 % 2:\n                        return -1\n                    v4 = v6\n            else:\n                v6 = v3 // 2\n                if v4 > v6:\n                    v3 -= v4\n                else:\n                    if v3 % 2:\n                        return -1\n                    v3 = v6\n            v5 += 1\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minMoves(self, a1, a2, a3, a4):\n        v1, v2 = (a1, a2)\n        v3, v4 = (a3, a4)\n        v5 = 0\n        while v3 != v1 or v4 != v2:\n            if v3 < v1 or v4 < v2:\n                return -1\n            if v3 == v4:\n                if v1 == 0:\n                    v3 = 0\n                elif v2 == 0:\n                    v4 = 0\n                else:\n                    return -1\n            elif v3 < v4:\n                v6 = v4 // 2\n                if v3 > v6:\n                    v4 -= v3\n                else:\n                    if v4 % 2:\n                        return -1\n                    v4 = v6\n            else:\n                v6 = v3 // 2\n                if v4 > v6:\n                    v3 -= v4\n                else:\n                    if v3 % 2:\n                        return -1\n                    v3 = v6\n            v5 += 1\n        return v5\n"}
{"id": "llm_code\\count-cells-in-overlapping-horizontal-and-vertical-substrings__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def countCells(self, a1, a2):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = len(a2)\n\n        def compute_z(a1):\n            v1 = len(a1)\n            v2 = [0] * v1\n            v3, v4 = (0, 0)\n            for v5 in range(1, v1):\n                if v5 < v4:\n                    v2[v5] = min(v4 - v5, v2[v5 - v3])\n                while v5 + v2[v5] < v1 and a1[v2[v5]] == a1[v5 + v2[v5]]:\n                    v2[v5] += 1\n                if v5 + v2[v5] > v4:\n                    v3, v4 = (v5, v5 + v2[v5])\n            return v2\n\n        def get_mask(a1, a2, a3):\n            if not a3:\n                a1, a2 = (a2, a1)\n            v3 = ''.join((a1[x][y] for v4 in range(a1) for v5 in range(a2))) if a3 else ''.join((a1[v5][v4] for v4 in range(a1) for v5 in range(a2)))\n            v6 = a2 + v3\n            v7 = compute_z(v6)\n            v8 = a1 * a2\n            v9 = [False] * v8\n            v10 = 0\n            for v11 in range(v3, len(v6)):\n                if v7[v11] >= v3:\n                    v12 = v11 - v3\n                    v10 = max(v10, v12)\n                    v13 = v12 + v3 - 1\n                    while v10 <= v13:\n                        v9[v10] = True\n                        v10 += 1\n            v14 = [[False] * a2 for v15 in range(a1)]\n            v16 = a2\n            for v17 in range(v8):\n                if v9[v17]:\n                    v14[v17 // v16][v17 % v16] = True\n            return v14\n        v4 = get_mask(v1, v2, True)\n        v5 = get_mask(v1, v2, False)\n        return sum((v4[i][j] and v5[j][i] for v6 in range(v1) for v7 in range(v2)))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def countCells(self, a1, a2):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = len(a2)\n\n        def compute_z(a1):\n            v1 = len(a1)\n            v2 = [0] * v1\n            v3, v4 = (0, 0)\n            for v5 in range(1, v1):\n                if v5 < v4:\n                    v2[v5] = min(v4 - v5, v2[v5 - v3])\n                while v5 + v2[v5] < v1 and a1[v2[v5]] == a1[v5 + v2[v5]]:\n                    v2[v5] += 1\n                if v5 + v2[v5] > v4:\n                    v3, v4 = (v5, v5 + v2[v5])\n            return v2\n\n        def get_mask(a1, a2, a3):\n            if not a3:\n                a1, a2 = (a2, a1)\n            v3 = ''.join((a1[x][y] for v4 in range(a1) for v5 in range(a2))) if a3 else ''.join((a1[v5][v4] for v4 in range(a1) for v5 in range(a2)))\n            v6 = a2 + v3\n            v7 = compute_z(v6)\n            v8 = a1 * a2\n            v9 = [False] * v8\n            v10 = 0\n            for v11 in range(v3, len(v6)):\n                if v7[v11] >= v3:\n                    v12 = v11 - v3\n                    v10 = max(v10, v12)\n                    v13 = v12 + v3 - 1\n                    while v10 <= v13:\n                        v9[v10] = True\n                        v10 += 1\n            v14 = [[False] * a2 for v15 in range(a1)]\n            v16 = a2\n            for v17 in range(v8):\n                if v9[v17]:\n                    v14[v17 // v16][v17 % v16] = True\n            return v14\n        v4 = get_mask(v1, v2, True)\n        v5 = get_mask(v1, v2, False)\n        return sum((v4[i][j] and v5[j][i] for v6 in range(v1) for v7 in range(v2)))\n"}
{"id": "llm_code\\minimum-operations-to-make-all-array-elements-equal__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minOperations(self, a1, a2):\n        v1 = sorted(a1)\n        v2 = len(v1)\n        v3 = [0]\n        for v4 in v1:\n            v3.append(v3[-1] + v4)\n\n        def get_pos(a1, a2):\n            v1, v2 = (0, v2)\n            while v1 < v2:\n                v3 = (v1 + v2) // 2\n                if a1[v3] < a2:\n                    v1 = v3 + 1\n                else:\n                    v2 = v3\n            return v1\n        v5 = []\n        for v6 in a2:\n            v7 = get_pos(v1, v6)\n            v8 = v6 * v7 - v3[v7]\n            v9 = v3[v2] - v3[v7] - v6 * (v2 - v7)\n            v5.append(v8 + v9)\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minOperations(self, a1, a2):\n        v1 = sorted(a1)\n        v2 = len(v1)\n        v3 = [0]\n        for v4 in v1:\n            v3.append(v3[-1] + v4)\n\n        def get_pos(a1, a2):\n            v1, v2 = (0, v2)\n            while v1 < v2:\n                v3 = (v1 + v2) // 2\n                if a1[v3] < a2:\n                    v1 = v3 + 1\n                else:\n                    v2 = v3\n            return v1\n        v5 = []\n        for v6 in a2:\n            v7 = get_pos(v1, v6)\n            v8 = v6 * v7 - v3[v7]\n            v9 = v3[v2] - v3[v7] - v6 * (v2 - v7)\n            v5.append(v8 + v9)\n        return v5\n"}
{"id": "human_code\\count-number-of-possible-root-nodes__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def rootCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            v1 = int((a2, a1) in lookup)\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 += dfs(v2, a1)\n            return v1\n\n        def dfs2(a1, a2, a3):\n            if (a2, a1) in lookup:\n                a3 -= 1\n            if (a1, a2) in lookup:\n                a3 += 1\n            v2 = int(a3 >= a3)\n            for v3 in adj[a1]:\n                if v3 == a2:\n                    continue\n                v2 += dfs2(v3, a1, a3)\n            return v2\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a1:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = {(v2, v3) for v2, v3 in a2}\n        v5 = dfs(0, -1)\n        return dfs2(0, -1, v5)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def rootCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            v1 = int((a2, a1) in lookup)\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 += dfs(v2, a1)\n            return v1\n\n        def dfs2(a1, a2, a3):\n            if (a2, a1) in lookup:\n                a3 -= 1\n            if (a1, a2) in lookup:\n                a3 += 1\n            v2 = int(a3 >= a3)\n            for v3 in adj[a1]:\n                if v3 == a2:\n                    continue\n                v2 += dfs2(v3, a1, a3)\n            return v2\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a1:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = {(v2, v3) for v2, v3 in a2}\n        v5 = dfs(0, -1)\n        return dfs2(0, -1, v5)\n"}
{"id": "llm_code\\binary-tree-longest-consecutive-sequence-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def longestConsecutive(self, a1):\n        v1 = [0]\n\n        def dfs(a1):\n            if not a1:\n                return (0, 0)\n            v1, v2 = dfs(a1.left)\n            v3, v4 = dfs(a1.right)\n            v5 = 1\n            if a1.left and a1.left.val == a1.val + 1:\n                v5 = max(v5, v1 + 1)\n            if a1.right and a1.right.val == a1.val + 1:\n                v5 = max(v5, v3 + 1)\n            v6 = 1\n            if a1.left and a1.left.val == a1.val - 1:\n                v6 = max(v6, v2 + 1)\n            if a1.right and a1.right.val == a1.val - 1:\n                v6 = max(v6, v4 + 1)\n            v1[0] = max(v1[0], v5 + v6 - 1)\n            return (v5, v6)\n        dfs(a1)\n        return v1[0]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestConsecutive(self, a1):\n        v1 = [0]\n\n        def dfs(a1):\n            if not a1:\n                return (0, 0)\n            v1, v2 = dfs(a1.left)\n            v3, v4 = dfs(a1.right)\n            v5 = 1\n            if a1.left and a1.left.val == a1.val + 1:\n                v5 = max(v5, v1 + 1)\n            if a1.right and a1.right.val == a1.val + 1:\n                v5 = max(v5, v3 + 1)\n            v6 = 1\n            if a1.left and a1.left.val == a1.val - 1:\n                v6 = max(v6, v2 + 1)\n            if a1.right and a1.right.val == a1.val - 1:\n                v6 = max(v6, v4 + 1)\n            v1[0] = max(v1[0], v5 + v6 - 1)\n            return (v5, v6)\n        dfs(a1)\n        return v1[0]\n"}
{"id": "llm_code\\booking-concert-tickets-in-groups__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1: int, a2: int):\n        self.n = a1\n        self.ninf = -float('inf')\n        self.tree = [[0, 0] for v1 in range(4 * a1)]\n        self._build(1, 0, a1 - 1, a2)\n\n    def _build(self, a1: int, a2: int, a3: int, a4: int):\n        if a2 == a3:\n            self.tree[a1] = [a4, a4]\n            return\n        v1 = (a2 + a3) // 2\n        self._build(2 * a1, a2, v1, a4)\n        self._build(2 * a1 + 1, v1 + 1, a3, a4)\n        v2 = self.tree[2 * a1]\n        v3 = self.tree[2 * a1 + 1]\n        self.tree[a1] = [max(v2[0], v3[0]), v2[1] + v3[1]]\n\n    def update(self, a1: int, a2: int):\n        self._update(1, 0, self.n - 1, a1, a2)\n\n    def _update(self, a1: int, a2: int, a3: int, a4: int, a5: int):\n        if a2 == a3:\n            self.tree[a1] = [a5, a5]\n            return\n        v1 = (a2 + a3) // 2\n        if a4 <= v1:\n            self._update(2 * a1, a2, v1, a4, a5)\n        else:\n            self._update(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        v2 = self.tree[2 * a1]\n        v3 = self.tree[2 * a1 + 1]\n        self.tree[a1] = [max(v2[0], v3[0]), v2[1] + v3[1]]\n\n    def range_query(self, a1: int, a2: int):\n        return self._query(1, 0, self.n - 1, a1, a2)\n\n    def _query(self, a1: int, a2: int, a3: int, a4: int, a5: int):\n        if a4 > a3 or a5 < a2:\n            return [self.ninf, 0]\n        if a4 <= a2 and a3 <= a5:\n            return self.tree[a1]\n        v1 = (a2 + a3) // 2\n        v2 = self._query(2 * a1, a2, v1, a4, a5)\n        v3 = self._query(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        return [max(v2[0], v3[0]), v2[1] + v3[1]]\n\n    def find_leftmost_ge(self, a1: int, a2: int):\n        v1 = self.n + 1\n\n        def dfs(a1: int, a2: int, a3: int):\n            nonlocal ans\n            if v1 <= a1:\n                return\n            if self.tree[a1][0] < a2:\n                return\n            if a2 == a3:\n                v1 = a2\n                return\n            v2 = (a2 + a3) // 2\n            dfs(2 * a1, a2, v2)\n            dfs(2 * a1 + 1, v2 + 1, a3)\n        dfs(1, 0, self.n - 1)\n        return v1 if v1 <= a1 else -1\n\nclass C2:\n\n    def __init__(self, a1: int, a2: int):\n        self.seg_tree = C1(a1, a2)\n        self.row_capacity = a2\n        self.first_row = 0\n\n    def gather(self, a1: int, a2: int) -> list[int]:\n        v1 = self.seg_tree.find_leftmost_ge(a2, a1)\n        if v1 == -1:\n            return []\n        v2 = self.seg_tree.range_query(v1, v1)[0]\n        v3 = self.row_capacity - v2\n        self.seg_tree.update(v1, v2 - a1)\n        return [v1, v3]\n\n    def scatter(self, a1: int, a2: int) -> bool:\n        if a1 == 0:\n            return True\n        v1 = self.seg_tree.range_query(self.first_row, a2)[1]\n        if v1 < a1:\n            return False\n        v2 = a1\n        v3 = self.first_row\n        while v2 > 0 and v3 <= a2:\n            v4 = self.seg_tree.range_query(v3, v3)[0]\n            v5 = min(v4, v2)\n            self.seg_tree.update(v3, v4 - v5)\n            v2 -= v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1: int, a2: int):\n        self.n = a1\n        self.ninf = -float('inf')\n        self.tree = [[0, 0] for v1 in range(4 * a1)]\n        self._build(1, 0, a1 - 1, a2)\n\n    def _build(self, a1: int, a2: int, a3: int, a4: int):\n        if a2 == a3:\n            self.tree[a1] = [a4, a4]\n            return\n        v1 = (a2 + a3) // 2\n        self._build(2 * a1, a2, v1, a4)\n        self._build(2 * a1 + 1, v1 + 1, a3, a4)\n        v2 = self.tree[2 * a1]\n        v3 = self.tree[2 * a1 + 1]\n        self.tree[a1] = [max(v2[0], v3[0]), v2[1] + v3[1]]\n\n    def update(self, a1: int, a2: int):\n        self._update(1, 0, self.n - 1, a1, a2)\n\n    def _update(self, a1: int, a2: int, a3: int, a4: int, a5: int):\n        if a2 == a3:\n            self.tree[a1] = [a5, a5]\n            return\n        v1 = (a2 + a3) // 2\n        if a4 <= v1:\n            self._update(2 * a1, a2, v1, a4, a5)\n        else:\n            self._update(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        v2 = self.tree[2 * a1]\n        v3 = self.tree[2 * a1 + 1]\n        self.tree[a1] = [max(v2[0], v3[0]), v2[1] + v3[1]]\n\n    def range_query(self, a1: int, a2: int):\n        return self._query(1, 0, self.n - 1, a1, a2)\n\n    def _query(self, a1: int, a2: int, a3: int, a4: int, a5: int):\n        if a4 > a3 or a5 < a2:\n            return [self.ninf, 0]\n        if a4 <= a2 and a3 <= a5:\n            return self.tree[a1]\n        v1 = (a2 + a3) // 2\n        v2 = self._query(2 * a1, a2, v1, a4, a5)\n        v3 = self._query(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        return [max(v2[0], v3[0]), v2[1] + v3[1]]\n\n    def find_leftmost_ge(self, a1: int, a2: int):\n        v1 = self.n + 1\n\n        def dfs(a1: int, a2: int, a3: int):\n            nonlocal ans\n            if v1 <= a1:\n                return\n            if self.tree[a1][0] < a2:\n                return\n            if a2 == a3:\n                v1 = a2\n                return\n            v2 = (a2 + a3) // 2\n            dfs(2 * a1, a2, v2)\n            dfs(2 * a1 + 1, v2 + 1, a3)\n        dfs(1, 0, self.n - 1)\n        return v1 if v1 <= a1 else -1\n\nclass C2:\n\n    def __init__(self, a1: int, a2: int):\n        self.seg_tree = C1(a1, a2)\n        self.row_capacity = a2\n        self.first_row = 0\n\n    def gather(self, a1: int, a2: int) -> list[int]:\n        v1 = self.seg_tree.find_leftmost_ge(a2, a1)\n        if v1 == -1:\n            return []\n        v2 = self.seg_tree.range_query(v1, v1)[0]\n        v3 = self.row_capacity - v2\n        self.seg_tree.update(v1, v2 - a1)\n        return [v1, v3]\n\n    def scatter(self, a1: int, a2: int) -> bool:\n        if a1 == 0:\n            return True\n        v1 = self.seg_tree.range_query(self.first_row, a2)[1]\n        if v1 < a1:\n            return False\n        v2 = a1\n        v3 = self.first_row\n        while v2 > 0 and v3 <= a2:\n            v4 = self.seg_tree.range_query(v3, v3)[0]\n            v5 = min(v4, v2)\n            self.seg_tree.update(v3, v4 - v5)\n            v2 -= v5\n"}
{"id": "llm_code\\mark-elements-on-array-by-performing-queries__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def unmarkedSumArray(self, a1, a2):\n        v1 = len(a1)\n        v2 = 0\n        for v3 in a1:\n            v2 += v3\n        v4 = [False] * v1\n        v5 = []\n        for v6 in range(v1):\n            heapq.heappush(v5, (a1[v6], v6))\n        v7 = []\n        for v8, v9 in a2:\n            if not v4[v8]:\n                v4[v8] = True\n                v2 -= a1[v8]\n            v10 = 0\n            while v10 < v9 and v5:\n                v11, v12 = heapq.heappop(v5)\n                if v4[v12]:\n                    continue\n                v4[v12] = True\n                v2 -= v11\n                v10 += 1\n            v7.append(v2)\n        return v7\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def unmarkedSumArray(self, a1, a2):\n        v1 = len(a1)\n        v2 = 0\n        for v3 in a1:\n            v2 += v3\n        v4 = [False] * v1\n        v5 = []\n        for v6 in range(v1):\n            heapq.heappush(v5, (a1[v6], v6))\n        v7 = []\n        for v8, v9 in a2:\n            if not v4[v8]:\n                v4[v8] = True\n                v2 -= a1[v8]\n            v10 = 0\n            while v10 < v9 and v5:\n                v11, v12 = heapq.heappop(v5)\n                if v4[v12]:\n                    continue\n                v4[v12] = True\n                v2 -= v11\n                v10 += 1\n            v7.append(v2)\n        return v7\n"}
{"id": "human_code\\copy-list-with-random-pointer__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n        self.random = None\n\nclass C2(object):\n\n    def copyRandomList(self, a1):\n        v1 = a1\n        while v1:\n            v2 = C1(v1.val)\n            v2.next = v1.__next__\n            v1.next = v2\n            v1 = v2.__next__\n        v1 = a1\n        while v1:\n            if v1.random:\n                v1.next.random = v1.random.__next__\n            v1 = v1.next.__next__\n        v3 = C1(0)\n        v4, v1 = (v3, a1)\n        while v1:\n            v4.next = v1.__next__\n            v1.next = v1.next.__next__\n            v4, v1 = (v4.__next__, v1.__next__)\n        return v3.__next__\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n        self.random = None\n\nclass C2(object):\n\n    def copyRandomList(self, a1):\n        v1 = a1\n        while v1:\n            v2 = C1(v1.val)\n            v2.next = v1.__next__\n            v1.next = v2\n            v1 = v2.__next__\n        v1 = a1\n        while v1:\n            if v1.random:\n                v1.next.random = v1.random.__next__\n            v1 = v1.next.__next__\n        v3 = C1(0)\n        v4, v1 = (v3, a1)\n        while v1:\n            v4.next = v1.__next__\n            v1.next = v1.next.__next__\n            v4, v1 = (v4.__next__, v1.__next__)\n        return v3.__next__\n"}
{"id": "llm_code\\phone-number-prefix__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def phonePrefix(self, a1):\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.is_end = False\n        v1 = TrieNode()\n\n        def insert(a1):\n            v1 = v1\n            for v2 in a1:\n                if v1.is_end:\n                    return False\n                v3 = int(v2)\n                if v3 not in v1.children:\n                    v1.children[v3] = TrieNode()\n                v1 = v1.children[v3]\n            if v1.is_end or v1.children:\n                return False\n            v1.is_end = True\n            return True\n        for v2 in a1:\n            if not insert(v2):\n                return False\n        return True\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def phonePrefix(self, a1):\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.is_end = False\n        v1 = TrieNode()\n\n        def insert(a1):\n            v1 = v1\n            for v2 in a1:\n                if v1.is_end:\n                    return False\n                v3 = int(v2)\n                if v3 not in v1.children:\n                    v1.children[v3] = TrieNode()\n                v1 = v1.children[v3]\n            if v1.is_end or v1.children:\n                return False\n            v1.is_end = True\n            return True\n        for v2 in a1:\n            if not insert(v2):\n                return False\n        return True\n"}
{"id": "human_code\\basic-calculator__part2.py", "text": "class C1(object):\n\n    def calculate(self, a1):\n        v1, v2 = ([], [])\n        v3 = ''\n        for v4 in reversed(range(len(a1))):\n            if a1[v4].isdigit():\n                v3 += a1[v4]\n                if v4 == 0 or not a1[v4 - 1].isdigit():\n                    v1.append(int(v3[::-1]))\n                    v3 = ''\n            elif a1[v4] == ')' or a1[v4] == '+' or a1[v4] == '-':\n                v2.append(a1[v4])\n            elif a1[v4] == '(':\n                while v2[-1] != ')':\n                    self.compute(v1, v2)\n                v2.pop()\n        while v2:\n            self.compute(v1, v2)\n        return v1[-1]\n\n    def compute(self, a1, a2):\n        v1, v2 = (a1.pop(), a1.pop())\n        v3 = a2.pop()\n        if v3 == '+':\n            a1.append(v1 + v2)\n        elif v3 == '-':\n            a1.append(v1 - v2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def calculate(self, a1):\n        v1, v2 = ([], [])\n        v3 = ''\n        for v4 in reversed(range(len(a1))):\n            if a1[v4].isdigit():\n                v3 += a1[v4]\n                if v4 == 0 or not a1[v4 - 1].isdigit():\n                    v1.append(int(v3[::-1]))\n                    v3 = ''\n            elif a1[v4] == ')' or a1[v4] == '+' or a1[v4] == '-':\n                v2.append(a1[v4])\n            elif a1[v4] == '(':\n                while v2[-1] != ')':\n                    self.compute(v1, v2)\n                v2.pop()\n        while v2:\n            self.compute(v1, v2)\n        return v1[-1]\n\n    def compute(self, a1, a2):\n        v1, v2 = (a1.pop(), a1.pop())\n        v3 = a2.pop()\n        if v3 == '+':\n            a1.append(v1 + v2)\n        elif v3 == '-':\n            a1.append(v1 - v2)\n"}
{"id": "llm_code\\next-greater-element-iii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def nextGreaterElement(self, a1):\n        v1 = [int(c) for v2 in str(a1)]\n        v3 = len(v1)\n        v4 = -1\n        for v5 in range(v3 - 2, -1, -1):\n            if v1[v5] < v1[v5 + 1]:\n                v4 = v5\n                break\n        if v4 == -1:\n            return -1\n        v6 = -1\n        for v7 in range(v3 - 1, v4, -1):\n            if v1[v7] > v1[v4]:\n                v6 = v7\n                break\n        v1[v4], v1[v6] = (v1[v6], v1[v4])\n        v1[v4 + 1:] = reversed(v1[v4 + 1:])\n        v8 = 0\n        for v9 in v1:\n            v8 = v8 * 10 + v9\n        return v8 if v8 <= 2147483647 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def nextGreaterElement(self, a1):\n        v1 = [int(c) for v2 in str(a1)]\n        v3 = len(v1)\n        v4 = -1\n        for v5 in range(v3 - 2, -1, -1):\n            if v1[v5] < v1[v5 + 1]:\n                v4 = v5\n                break\n        if v4 == -1:\n            return -1\n        v6 = -1\n        for v7 in range(v3 - 1, v4, -1):\n            if v1[v7] > v1[v4]:\n                v6 = v7\n                break\n        v1[v4], v1[v6] = (v1[v6], v1[v4])\n        v1[v4 + 1:] = reversed(v1[v4 + 1:])\n        v8 = 0\n        for v9 in v1:\n            v8 = v8 * 10 + v9\n        return v8 if v8 <= 2147483647 else -1\n"}
{"id": "human_code\\range-sum-query-mutable__part2.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2=lambda x, y: x + y, a3=lambda x, y: y, a4=0):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        v1 = len(a1)\n        self.__original_length = v1\n        self.__tree_length = 2 ** (v1.bit_length() + (v1 & v1 - 1 != 0)) - 1\n        self.__query_fn = a2\n        self.__update_fn = a3\n        self.__default_val = a4\n        self.__tree = [a4 for v2 in range(self.__tree_length)]\n        self.__lazy = [None for v2 in range(self.__tree_length)]\n        self.__constructTree(a1, 0, self.__original_length - 1, 0)\n\n    def update(self, a1, a2):\n        self.__updateTree(a2, a1, a1, 0, self.__original_length - 1, 0)\n\n    def sumRange(self, a1, a2):\n        return self.__queryRange(a1, a2, 0, self.__original_length - 1, 0)\n\n    def __constructTree(self, a1, a2, a3, a4):\n        if a2 > a3:\n            return\n        if a2 == a3:\n            self.__tree[a4] = self.__update_fn(self.__tree[a4], a1[a2])\n            return\n        v1 = a2 + (a3 - a2) // 2\n        self.__constructTree(a1, a2, v1, a4 * 2 + 1)\n        self.__constructTree(a1, v1 + 1, a3, a4 * 2 + 2)\n        self.__tree[a4] = self.__query_fn(self.__tree[a4 * 2 + 1], self.__tree[a4 * 2 + 2])\n\n    def __apply(self, a1, a2, a3, a4):\n        self.__tree[a3] = self.__update_fn(self.__tree[a3], a4)\n        if a1 != a2:\n            self.__lazy[a3 * 2 + 1] = self.__update_fn(self.__lazy[a3 * 2 + 1], a4)\n            self.__lazy[a3 * 2 + 2] = self.__update_fn(self.__lazy[a3 * 2 + 2], a4)\n\n    def __updateTree(self, a1, a2, a3, a4, a5, a6):\n        if a4 > a5:\n            return\n        if self.__lazy[a6] is not None:\n            self.__apply(a4, a5, a6, self.__lazy[a6])\n            self.__lazy[a6] = None\n        if a2 > a5 or a3 < a4:\n            return\n        if a2 <= a4 and a5 <= a3:\n            self.__apply(a4, a5, a6, a1)\n            return\n        v1 = a4 + (a5 - a4) // 2\n        self.__updateTree(a1, a2, a3, a4, v1, a6 * 2 + 1)\n        self.__updateTree(a1, a2, a3, v1 + 1, a5, a6 * 2 + 2)\n        self.__tree[a6] = self.__query_fn(self.__tree[a6 * 2 + 1], self.__tree[a6 * 2 + 2])\n\n    def __queryRange(self, a1, a2, a3, a4, a5):\n        if a3 > a4:\n            return self.__default_val\n        if self.__lazy[a5] is not None:\n            self.__apply(a3, a4, a5, self.__lazy[a5])\n            self.__lazy[a5] = None\n        if a4 < a1 or a3 > a2:\n            return self.__default_val\n        if a1 <= a3 and a4 <= a2:\n            return self.__tree[a5]\n        v1 = a3 + (a4 - a3) // 2\n        return self.__query_fn(self.__queryRange(a1, a2, a3, v1, a5 * 2 + 1), self.__queryRange(a1, a2, v1 + 1, a4, a5 * 2 + 2))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2=lambda x, y: x + y, a3=lambda x, y: y, a4=0):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        v1 = len(a1)\n        self.__original_length = v1\n        self.__tree_length = 2 ** (v1.bit_length() + (v1 & v1 - 1 != 0)) - 1\n        self.__query_fn = a2\n        self.__update_fn = a3\n        self.__default_val = a4\n        self.__tree = [a4 for v2 in range(self.__tree_length)]\n        self.__lazy = [None for v2 in range(self.__tree_length)]\n        self.__constructTree(a1, 0, self.__original_length - 1, 0)\n\n    def update(self, a1, a2):\n        self.__updateTree(a2, a1, a1, 0, self.__original_length - 1, 0)\n\n    def sumRange(self, a1, a2):\n        return self.__queryRange(a1, a2, 0, self.__original_length - 1, 0)\n\n    def __constructTree(self, a1, a2, a3, a4):\n        if a2 > a3:\n            return\n        if a2 == a3:\n            self.__tree[a4] = self.__update_fn(self.__tree[a4], a1[a2])\n            return\n        v1 = a2 + (a3 - a2) // 2\n        self.__constructTree(a1, a2, v1, a4 * 2 + 1)\n        self.__constructTree(a1, v1 + 1, a3, a4 * 2 + 2)\n        self.__tree[a4] = self.__query_fn(self.__tree[a4 * 2 + 1], self.__tree[a4 * 2 + 2])\n\n    def __apply(self, a1, a2, a3, a4):\n        self.__tree[a3] = self.__update_fn(self.__tree[a3], a4)\n        if a1 != a2:\n            self.__lazy[a3 * 2 + 1] = self.__update_fn(self.__lazy[a3 * 2 + 1], a4)\n            self.__lazy[a3 * 2 + 2] = self.__update_fn(self.__lazy[a3 * 2 + 2], a4)\n\n    def __updateTree(self, a1, a2, a3, a4, a5, a6):\n        if a4 > a5:\n            return\n        if self.__lazy[a6] is not None:\n            self.__apply(a4, a5, a6, self.__lazy[a6])\n            self.__lazy[a6] = None\n        if a2 > a5 or a3 < a4:\n            return\n        if a2 <= a4 and a5 <= a3:\n            self.__apply(a4, a5, a6, a1)\n            return\n        v1 = a4 + (a5 - a4) // 2\n        self.__updateTree(a1, a2, a3, a4, v1, a6 * 2 + 1)\n        self.__updateTree(a1, a2, a3, v1 + 1, a5, a6 * 2 + 2)\n        self.__tree[a6] = self.__query_fn(self.__tree[a6 * 2 + 1], self.__tree[a6 * 2 + 2])\n\n    def __queryRange(self, a1, a2, a3, a4, a5):\n        if a3 > a4:\n            return self.__default_val\n        if self.__lazy[a5] is not None:\n            self.__apply(a3, a4, a5, self.__lazy[a5])\n            self.__lazy[a5] = None\n        if a4 < a1 or a3 > a2:\n            return self.__default_val\n        if a1 <= a3 and a4 <= a2:\n            return self.__tree[a5]\n        v1 = a3 + (a4 - a3) // 2\n        return self.__query_fn(self.__queryRange(a1, a2, a3, v1, a5 * 2 + 1), self.__queryRange(a1, a2, v1 + 1, a4, a5 * 2 + 2))\n"}
{"id": "llm_code\\clone-n-ary-tree__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.children = list(a2) if a2 else []\n\nclass C2:\n\n    def cloneTree(self, a1):\n        if not a1:\n            return None\n        v1 = []\n        v2 = C1(a1.val)\n        v1.append([a1, v2, 0])\n        while v1:\n            v3, v4, v5 = v1[-1]\n            if v5 >= len(v3.children):\n                v1.pop()\n            else:\n                v6 = v3.children[v5]\n                v7 = C1(v6.val)\n                v4.children.append(v7)\n                v1[-1][2] += 1\n                v1.append([v6, v7, 0])\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.children = list(a2) if a2 else []\n\nclass C2:\n\n    def cloneTree(self, a1):\n        if not a1:\n            return None\n        v1 = []\n        v2 = C1(a1.val)\n        v1.append([a1, v2, 0])\n        while v1:\n            v3, v4, v5 = v1[-1]\n            if v5 >= len(v3.children):\n                v1.pop()\n            else:\n                v6 = v3.children[v5]\n                v7 = C1(v6.val)\n                v4.children.append(v7)\n                v1[-1][2] += 1\n                v1.append([v6, v7, 0])\n        return v2\n"}
{"id": "llm_code\\p02787__s747071780.py", "text": "from operator import itemgetter\nv1, v2 = map(int, input().split())\nv3 = []\nv4 = 0\nfor v5 in range(v2):\n    v6, v7 = map(int, input().split())\n    v4 = max(v6, v4)\n    v3.append([v6 / v7, v6, v7])\nv3.sort(key=itemgetter(0), reverse=True)\nv3.sort(key=itemgetter(1), reverse=True)\nv8 = 0\n\ndef f1(a1, a2, a3):\n    if a1 == 0:\n        return 0\n    for v1 in v3[a2:]:\n        if a1 < v1[1]:\n            continue\n        else:\n            v2 = a1 // v1[1]\n            v3 = a1 - v2 * v1[1]\n            return min(a3, v2 * v1[2] + f1(v3, a2 + 1, v1[2]))\n    v4 = a3\n    for v1 in v3[a2:]:\n        v4 = min(v4, v1[2])\n    return v4\nv8 = f1(v1, 0, 10 ** 9)\nprint(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from operator import itemgetter\nv1, v2 = map(int, input().split())\nv3 = []\nv4 = 0\nfor v5 in range(v2):\n    v6, v7 = map(int, input().split())\n    v4 = max(v6, v4)\n    v3.append([v6 / v7, v6, v7])\nv3.sort(key=itemgetter(0), reverse=True)\nv3.sort(key=itemgetter(1), reverse=True)\nv8 = 0\n\ndef f1(a1, a2, a3):\n    if a1 == 0:\n        return 0\n    for v1 in v3[a2:]:\n        if a1 < v1[1]:\n            continue\n        else:\n            v2 = a1 // v1[1]\n            v3 = a1 - v2 * v1[1]\n            return min(a3, v2 * v1[2] + f1(v3, a2 + 1, v1[2]))\n    v4 = a3\n    for v1 in v3[a2:]:\n        v4 = min(v4, v1[2])\n    return v4\nv8 = f1(v1, 0, 10 ** 9)\nprint(v8)\n"}
{"id": "human_code\\number-of-distinct-roll-sequences.py", "text": "import collections\n\nclass C1(object):\n\n    def distinctSequences(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n        if a1 == 1:\n            return 6\n        v1 = 10 ** 9 + 7\n        v2 = [[0] * 6 for v3 in range(6)]\n        for v4 in range(6):\n            for v5 in range(6):\n                if v4 != v5 and gcd(v4 + 1, v5 + 1) == 1:\n                    v2[v4][v5] = 1\n        for v3 in range(a1 - 2):\n            v6 = [[0] * 6 for v3 in range(6)]\n            for v4 in range(6):\n                for v5 in range(6):\n                    if not v2[v4][v5]:\n                        continue\n                    for v7 in range(6):\n                        if not v2[v5][v7]:\n                            continue\n                        if v7 != v4:\n                            v6[v4][v5] = (v6[v4][v5] + v2[v5][v7]) % v1\n            v2 = v6\n        return sum((v2[v4][v5] for v4 in range(6) for v5 in range(6))) % v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def distinctSequences(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n        if a1 == 1:\n            return 6\n        v1 = 10 ** 9 + 7\n        v2 = [[0] * 6 for v3 in range(6)]\n        for v4 in range(6):\n            for v5 in range(6):\n                if v4 != v5 and gcd(v4 + 1, v5 + 1) == 1:\n                    v2[v4][v5] = 1\n        for v3 in range(a1 - 2):\n            v6 = [[0] * 6 for v3 in range(6)]\n            for v4 in range(6):\n                for v5 in range(6):\n                    if not v2[v4][v5]:\n                        continue\n                    for v7 in range(6):\n                        if not v2[v5][v7]:\n                            continue\n                        if v7 != v4:\n                            v6[v4][v5] = (v6[v4][v5] + v2[v5][v7]) % v1\n            v2 = v6\n        return sum((v2[v4][v5] for v4 in range(6) for v5 in range(6))) % v1\n"}
{"id": "human_code\\palindrome-rearrangement-queries__part2.py", "text": "class C1(object):\n\n    def canMakePalindromeQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4):\n\n            def same(a1, a2):\n                return all((prefixs1[a2 + 1][i] - prefixs1[a1][i] == prefixs2[a2 + 1][i] - prefixs2[a1][i] for v1 in range(26)))\n            v1, v2 = (min(a1, a3), max(a1, a3))\n            v3, v4 = (min(a2, a4), max(a2, a4))\n            if not prefix[v1] - prefix[0] == prefix[-1] - prefix[v4 + 1] == 0:\n                return False\n            if v3 < v2:\n                return prefix[v2] - prefix[v3 + 1] == 0 and same(v1, v3) and same(v2, v4)\n            if (a1 == v1) == (a2 == v4):\n                return same(v1, v4)\n            v5, v6 = (prefixs1, prefixs2) if v1 == a1 else (prefixs2, prefixs1)\n            v7 = [v5[v3 + 1][i] - v5[v1][i] - (v6[v2][i] - v6[v1][i]) for v8 in range(26)]\n            v9 = [v6[v4 + 1][v8] - v6[v2][v8] - (v5[v4 + 1][v8] - v5[v3 + 1][v8]) for v8 in range(26)]\n            return v7 == v9 and all((x >= 0 for v10 in v7))\n        v1 = [0] * (len(a1) // 2 + 1)\n        v2 = [[0] * 26 for v3 in range(len(a1) // 2 + 1)]\n        v4 = [[0] * 26 for v3 in range(len(a1) // 2 + 1)]\n        for v5 in range(len(a1) // 2):\n            v6, v7 = (ord(a1[v5]) - ord('a'), ord(a1[~v5]) - ord('a'))\n            v1[v5 + 1] = v1[v5] + int(v6 != v7)\n            for v8 in range(26):\n                v2[v5 + 1][v8] = v2[v5][v8] + int(v8 == v6)\n                v4[v5 + 1][v8] = v4[v5][v8] + int(v8 == v7)\n        return [check(q[0], q[1], len(a1) - 1 - q[3], len(a1) - 1 - q[2]) for v9 in a2]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def canMakePalindromeQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4):\n\n            def same(a1, a2):\n                return all((prefixs1[a2 + 1][i] - prefixs1[a1][i] == prefixs2[a2 + 1][i] - prefixs2[a1][i] for v1 in range(26)))\n            v1, v2 = (min(a1, a3), max(a1, a3))\n            v3, v4 = (min(a2, a4), max(a2, a4))\n            if not prefix[v1] - prefix[0] == prefix[-1] - prefix[v4 + 1] == 0:\n                return False\n            if v3 < v2:\n                return prefix[v2] - prefix[v3 + 1] == 0 and same(v1, v3) and same(v2, v4)\n            if (a1 == v1) == (a2 == v4):\n                return same(v1, v4)\n            v5, v6 = (prefixs1, prefixs2) if v1 == a1 else (prefixs2, prefixs1)\n            v7 = [v5[v3 + 1][i] - v5[v1][i] - (v6[v2][i] - v6[v1][i]) for v8 in range(26)]\n            v9 = [v6[v4 + 1][v8] - v6[v2][v8] - (v5[v4 + 1][v8] - v5[v3 + 1][v8]) for v8 in range(26)]\n            return v7 == v9 and all((x >= 0 for v10 in v7))\n        v1 = [0] * (len(a1) // 2 + 1)\n        v2 = [[0] * 26 for v3 in range(len(a1) // 2 + 1)]\n        v4 = [[0] * 26 for v3 in range(len(a1) // 2 + 1)]\n        for v5 in range(len(a1) // 2):\n            v6, v7 = (ord(a1[v5]) - ord('a'), ord(a1[~v5]) - ord('a'))\n            v1[v5 + 1] = v1[v5] + int(v6 != v7)\n            for v8 in range(26):\n                v2[v5 + 1][v8] = v2[v5][v8] + int(v8 == v6)\n                v4[v5 + 1][v8] = v4[v5][v8] + int(v8 == v7)\n        return [check(q[0], q[1], len(a1) - 1 - q[3], len(a1) - 1 - q[2]) for v9 in a2]\n"}
{"id": "llm_code\\maximum-product-of-two-integers-with-no-common-bits__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxProduct(self, a1):\n        v1 = max(a1)\n        v2 = 1\n        v3 = 0\n        while v2 <= v1:\n            v2 *= 2\n            v3 += 1\n        v4 = 1 << v3\n        v5 = [0] * v4\n        for v6 in a1:\n            v5[v6] = v6\n        for v7 in range(v3):\n            v8 = 1 << v7\n            for v9 in range(v4):\n                if v9 & v8 == 0:\n                    v10 = v9 | v8\n                    v5[v10] = max(v5[v10], v5[v9])\n        v11 = v4 - 1\n        v12 = 0\n        for v13 in range(v4):\n            v14 = v11 ^ v13\n            v15 = v5[v13] * v5[v14]\n            if v15 > v12:\n                v12 = v15\n        return v12\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxProduct(self, a1):\n        v1 = max(a1)\n        v2 = 1\n        v3 = 0\n        while v2 <= v1:\n            v2 *= 2\n            v3 += 1\n        v4 = 1 << v3\n        v5 = [0] * v4\n        for v6 in a1:\n            v5[v6] = v6\n        for v7 in range(v3):\n            v8 = 1 << v7\n            for v9 in range(v4):\n                if v9 & v8 == 0:\n                    v10 = v9 | v8\n                    v5[v10] = max(v5[v10], v5[v9])\n        v11 = v4 - 1\n        v12 = 0\n        for v13 in range(v4):\n            v14 = v11 ^ v13\n            v15 = v5[v13] * v5[v14]\n            if v15 > v12:\n                v12 = v15\n        return v12\n"}
{"id": "human_code\\single-threaded-cpu.py", "text": "import heapq\n\nclass C1(object):\n\n    def getOrder(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = list(range(len(a1)))\n        v1.sort(key=lambda x: a1[x][0])\n        v2, v3 = ([], [])\n        v4, v5 = (0, a1[v1[0]][0])\n        while v4 < len(v1) or v3:\n            while v4 < len(v1) and a1[v1[v4]][0] <= v5:\n                heapq.heappush(v3, (a1[v1[v4]][1], v1[v4]))\n                v4 += 1\n            if not v3:\n                v5 = a1[v1[v4]][0]\n                continue\n            v6, v7 = heapq.heappop(v3)\n            v5 += v6\n            v2.append(v7)\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def getOrder(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = list(range(len(a1)))\n        v1.sort(key=lambda x: a1[x][0])\n        v2, v3 = ([], [])\n        v4, v5 = (0, a1[v1[0]][0])\n        while v4 < len(v1) or v3:\n            while v4 < len(v1) and a1[v1[v4]][0] <= v5:\n                heapq.heappush(v3, (a1[v1[v4]][1], v1[v4]))\n                v4 += 1\n            if not v3:\n                v5 = a1[v1[v4]][0]\n                continue\n            v6, v7 = heapq.heappop(v3)\n            v5 += v6\n            v2.append(v7)\n        return v2\n"}
{"id": "human_code\\maximize-the-number-of-target-nodes-after-connecting-trees-i__part1.py", "text": "class C1(object):\n\n    def maxTargetNodes(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def centroid_decomposition(a1, a2):\n\n            def dfs(a1):\n\n                def find_subtree_size(a1, a2):\n                    sizes[a1] = 1\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        sizes[a1] += find_subtree_size(v1, a1)\n                    return sizes[a1]\n\n                def find_centroid(a1, a2):\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        if sizes[v1] * 2 > n:\n                            return find_centroid(v1, a1)\n                    return a1\n\n                def count(a1, a2, a3):\n                    if a3 > a2:\n                        return\n                    if a3 - 1 == len(cnt):\n                        cnt.append(0)\n                    cnt[a3 - 1] += 1\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        count(v1, a1, a3 + 1)\n\n                def update(a1, a2, a3):\n                    if a3 > a2:\n                        return\n                    result[a1] += total[min(a2 - a3, len(total) - 1)] - curr[min(a2 - a3, len(curr) - 1)]\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        update(v1, a1, a3 + 1)\n                find_subtree_size(a1, -1)\n                v1 = sizes[a1]\n                a1 = find_centroid(a1, -1)\n                lookup[a1] = True\n                v3 = 0\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    v5 = []\n                    count(v4, a1, 0 + 1)\n                    prefix[v4].append(0)\n                    for v6 in range(len(v5)):\n                        prefix[v4].append(prefix[v4][-1] + v5[v6])\n                    v3 = max(v3, len(v5))\n                v7 = [1] * (v3 + 1)\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    for v6 in range(len(v7)):\n                        v7[v6] += prefix[v4][min(v6, len(prefix[v4]) - 1)]\n                result[a1] += v7[min(a2, len(v7) - 1)]\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    v8, prefix[v4] = (prefix[v4], [])\n                    update(v4, a1, 0 + 1)\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    dfs(v4)\n            v1 = [0] * len(a1)\n            v2 = [0] * len(a1)\n            v3 = [False] * len(a1)\n            v4 = [[] for v5 in range(len(a1))]\n            if a2 >= 0:\n                dfs(0)\n            return v1\n\n        def find_adj(a1):\n            v1 = [[] for v2 in range(len(a1) + 1)]\n            for v3, v4 in a1:\n                v1[v3].append(v4)\n                v1[v4].append(v3)\n            return v1\n        v1 = find_adj(a2)\n        v2 = max(centroid_decomposition(v1, a3 - 1))\n        v3 = find_adj(a1)\n        return [v2 + x for v4 in centroid_decomposition(v3, a3)]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxTargetNodes(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def centroid_decomposition(a1, a2):\n\n            def dfs(a1):\n\n                def find_subtree_size(a1, a2):\n                    sizes[a1] = 1\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        sizes[a1] += find_subtree_size(v1, a1)\n                    return sizes[a1]\n\n                def find_centroid(a1, a2):\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        if sizes[v1] * 2 > n:\n                            return find_centroid(v1, a1)\n                    return a1\n\n                def count(a1, a2, a3):\n                    if a3 > a2:\n                        return\n                    if a3 - 1 == len(cnt):\n                        cnt.append(0)\n                    cnt[a3 - 1] += 1\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        count(v1, a1, a3 + 1)\n\n                def update(a1, a2, a3):\n                    if a3 > a2:\n                        return\n                    result[a1] += total[min(a2 - a3, len(total) - 1)] - curr[min(a2 - a3, len(curr) - 1)]\n                    for v1 in a1[a1]:\n                        if v1 == a2 or lookup[v1]:\n                            continue\n                        update(v1, a1, a3 + 1)\n                find_subtree_size(a1, -1)\n                v1 = sizes[a1]\n                a1 = find_centroid(a1, -1)\n                lookup[a1] = True\n                v3 = 0\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    v5 = []\n                    count(v4, a1, 0 + 1)\n                    prefix[v4].append(0)\n                    for v6 in range(len(v5)):\n                        prefix[v4].append(prefix[v4][-1] + v5[v6])\n                    v3 = max(v3, len(v5))\n                v7 = [1] * (v3 + 1)\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    for v6 in range(len(v7)):\n                        v7[v6] += prefix[v4][min(v6, len(prefix[v4]) - 1)]\n                result[a1] += v7[min(a2, len(v7) - 1)]\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    v8, prefix[v4] = (prefix[v4], [])\n                    update(v4, a1, 0 + 1)\n                for v4 in a1[a1]:\n                    if lookup[v4]:\n                        continue\n                    dfs(v4)\n            v1 = [0] * len(a1)\n            v2 = [0] * len(a1)\n            v3 = [False] * len(a1)\n            v4 = [[] for v5 in range(len(a1))]\n            if a2 >= 0:\n                dfs(0)\n            return v1\n\n        def find_adj(a1):\n            v1 = [[] for v2 in range(len(a1) + 1)]\n            for v3, v4 in a1:\n                v1[v3].append(v4)\n                v1[v4].append(v3)\n            return v1\n        v1 = find_adj(a2)\n        v2 = max(centroid_decomposition(v1, a3 - 1))\n        v3 = find_adj(a1)\n        return [v2 + x for v4 in centroid_decomposition(v3, a3)]\n"}
{"id": "human_code\\number-of-beautiful-integers-in-the-range__part3.py", "text": "class C1(object):\n\n    def numberOfBeautifulIntegers(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def f(a1):\n            v1 = list(map(int, str(a1)))\n            v2 = [[[[[-1] * a3 for v3 in range(2 * len(v1) + 1)] for v3 in range(2)] for v3 in range(2)] for v3 in range(len(v1))]\n\n            def memoization(a1, a2, a3, a4, a5):\n                if a1 == len(v1):\n                    return int(a2 == a4 == a5 == 0)\n                if v2[a1][a2][a3][a4][a5] == -1:\n                    v1 = 0\n                    for v2 in range((v1[a1] if a3 else 9) + 1):\n                        v3 = int(a2 and v2 == 0)\n                        v4 = int(a3 and v2 == v1[a1])\n                        v5 = a4 + ((1 if v2 % 2 == 0 else -1) if v3 == 0 else 0)\n                        v6 = (a5 * 10 + v2) % a3\n                        v1 += memoization(a1 + 1, v3, v4, v5, v6)\n                    v2[a1][a2][a3][a4][a5] = v1\n                return v2[a1][a2][a3][a4][a5]\n            return memoization(0, 1, 1, 0, 0)\n        return f(a2) - f(a1 - 1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numberOfBeautifulIntegers(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def f(a1):\n            v1 = list(map(int, str(a1)))\n            v2 = [[[[[-1] * a3 for v3 in range(2 * len(v1) + 1)] for v3 in range(2)] for v3 in range(2)] for v3 in range(len(v1))]\n\n            def memoization(a1, a2, a3, a4, a5):\n                if a1 == len(v1):\n                    return int(a2 == a4 == a5 == 0)\n                if v2[a1][a2][a3][a4][a5] == -1:\n                    v1 = 0\n                    for v2 in range((v1[a1] if a3 else 9) + 1):\n                        v3 = int(a2 and v2 == 0)\n                        v4 = int(a3 and v2 == v1[a1])\n                        v5 = a4 + ((1 if v2 % 2 == 0 else -1) if v3 == 0 else 0)\n                        v6 = (a5 * 10 + v2) % a3\n                        v1 += memoization(a1 + 1, v3, v4, v5, v6)\n                    v2[a1][a2][a3][a4][a5] = v1\n                return v2[a1][a2][a3][a4][a5]\n            return memoization(0, 1, 1, 0, 0)\n        return f(a2) - f(a1 - 1)\n"}
{"id": "llm_code\\n-ary-tree-postorder-traversal__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a1\n        self.children = a2\n\nclass C2(object):\n\n    def postorder(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        v2 = [(a1, 0)]\n        while v2:\n            v3, v4 = v2[-1]\n            if v4 < len(v3.children):\n                v2[-1] = (v3, v4 + 1)\n                v5 = v3.children[v4]\n                if v5:\n                    v2.append((v5, 0))\n            else:\n                v1.append(v3.val)\n                v2.pop()\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a1\n        self.children = a2\n\nclass C2(object):\n\n    def postorder(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        v2 = [(a1, 0)]\n        while v2:\n            v3, v4 = v2[-1]\n            if v4 < len(v3.children):\n                v2[-1] = (v3, v4 + 1)\n                v5 = v3.children[v4]\n                if v5:\n                    v2.append((v5, 0))\n            else:\n                v1.append(v3.val)\n                v2.pop()\n        return v1\n"}
{"id": "llm_code\\maximum-number-of-robots-within-budget__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def maximumRobots(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = 0\n        v3 = 0\n        v4 = 0\n        v5 = deque()\n        for v6 in range(v1):\n            while v5 and a1[v5[-1]] <= a1[v6]:\n                v5.pop()\n            v5.append(v6)\n            v3 += a2[v6]\n            while v4 <= v6 and a1[v5[0]] + (v6 - v4 + 1) * v3 > a3:\n                v3 -= a2[v4]\n                v4 += 1\n                while v5 and v5[0] < v4:\n                    v5.popleft()\n            v2 = max(v2, v6 - v4 + 1)\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def maximumRobots(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = 0\n        v3 = 0\n        v4 = 0\n        v5 = deque()\n        for v6 in range(v1):\n            while v5 and a1[v5[-1]] <= a1[v6]:\n                v5.pop()\n            v5.append(v6)\n            v3 += a2[v6]\n            while v4 <= v6 and a1[v5[0]] + (v6 - v4 + 1) * v3 > a3:\n                v3 -= a2[v4]\n                v4 += 1\n                while v5 and v5[0] < v4:\n                    v5.popleft()\n            v2 = max(v2, v6 - v4 + 1)\n        return v2\n"}
{"id": "llm_code\\p02991__unrelated.py", "text": "from collections import deque\n\ndef f1(a1, a2, a3):\n    v1 = deque([(a2, 0, 0)])\n    v2 = set([a2])\n    while v1:\n        v3, v4, v5 = v1.popleft()\n        if v3 == a3 and v4 % 3 == 0:\n            return v5\n        for v6 in a1[v3]:\n            if v6 not in v2:\n                v2.add(v6)\n                v1.append((v6, v4 + 1, v5 + (v4 + 1) // 3))\n    return -1\n\ndef f2(a1, a2, a3, a4, a5):\n    v1 = [[] for v2 in range(a1 + 1)]\n    for v3, v4 in a3:\n        v1[v3].append(v4)\n    return f1(v1, a4, a5)\nv1, v2 = map(int, input().split())\nv3 = [tuple(map(int, input().split())) for v4 in range(v2)]\nv5, v6 = map(int, input().split())\nprint(f2(v1, v2, v3, v5, v6))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from collections import deque\n\ndef f1(a1, a2, a3):\n    v1 = deque([(a2, 0, 0)])\n    v2 = set([a2])\n    while v1:\n        v3, v4, v5 = v1.popleft()\n        if v3 == a3 and v4 % 3 == 0:\n            return v5\n        for v6 in a1[v3]:\n            if v6 not in v2:\n                v2.add(v6)\n                v1.append((v6, v4 + 1, v5 + (v4 + 1) // 3))\n    return -1\n\ndef f2(a1, a2, a3, a4, a5):\n    v1 = [[] for v2 in range(a1 + 1)]\n    for v3, v4 in a3:\n        v1[v3].append(v4)\n    return f1(v1, a4, a5)\nv1, v2 = map(int, input().split())\nv3 = [tuple(map(int, input().split())) for v4 in range(v2)]\nv5, v6 = map(int, input().split())\nprint(f2(v1, v2, v3, v5, v6))\n"}
{"id": "human_code\\p02855__s400792601.py", "text": "def f1(a1, a2, a3, a4):\n    v1 = a2 - 1\n    if v1 < 0:\n        return\n    elif a1[v1][a3] != 0:\n        return\n    else:\n        a1[v1][a3] = a4\n        f1(a1, v1, a3, a4)\n\ndef f2(a1, a2, a3, a4):\n    v1 = a2 + 1\n    if v1 >= len(a1):\n        return\n    elif a1[v1][a3] != 0:\n        return\n    else:\n        a1[v1][a3] = a4\n        f2(a1, v1, a3, a4)\nv1, v2, v3 = map(int, input().split())\nv4 = []\nfor v5 in range(v1):\n    v6 = input()\n    v7 = []\n    for v8 in range(len(v6)):\n        if v6[v8] == '#':\n            v7.append(1)\n        else:\n            v7.append(0)\n    v4.append(v7)\nv9 = [[0] * v2 for v5 in range(v1)]\nv10 = 1\nfor v5 in range(v1):\n    v11 = v4[v5].count(1)\n    if v11 == 0:\n        continue\n    else:\n        v12 = True\n        for v8 in range(v2):\n            if v4[v5][v8] == 0:\n                v9[v5][v8] = v10\n            elif v12:\n                v9[v5][v8] = v10\n                v12 = False\n            else:\n                v10 += 1\n                v9[v5][v8] = v10\n        v10 += 1\nfor v5 in range(v1):\n    for v8 in range(v2):\n        if v9[v5][v8] != 0:\n            f1(v9, v5, v8, v9[v5][v8])\n            f2(v9, v5, v8, v9[v5][v8])\nfor v5 in range(v1):\n    print(' '.join(list(map(str, v9[v5]))))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1, a2, a3, a4):\n    v1 = a2 - 1\n    if v1 < 0:\n        return\n    elif a1[v1][a3] != 0:\n        return\n    else:\n        a1[v1][a3] = a4\n        f1(a1, v1, a3, a4)\n\ndef f2(a1, a2, a3, a4):\n    v1 = a2 + 1\n    if v1 >= len(a1):\n        return\n    elif a1[v1][a3] != 0:\n        return\n    else:\n        a1[v1][a3] = a4\n        f2(a1, v1, a3, a4)\nv1, v2, v3 = map(int, input().split())\nv4 = []\nfor v5 in range(v1):\n    v6 = input()\n    v7 = []\n    for v8 in range(len(v6)):\n        if v6[v8] == '#':\n            v7.append(1)\n        else:\n            v7.append(0)\n    v4.append(v7)\nv9 = [[0] * v2 for v5 in range(v1)]\nv10 = 1\nfor v5 in range(v1):\n    v11 = v4[v5].count(1)\n    if v11 == 0:\n        continue\n    else:\n        v12 = True\n        for v8 in range(v2):\n            if v4[v5][v8] == 0:\n                v9[v5][v8] = v10\n            elif v12:\n                v9[v5][v8] = v10\n                v12 = False\n            else:\n                v10 += 1\n                v9[v5][v8] = v10\n        v10 += 1\nfor v5 in range(v1):\n    for v8 in range(v2):\n        if v9[v5][v8] != 0:\n            f1(v9, v5, v8, v9[v5][v8])\n            f2(v9, v5, v8, v9[v5][v8])\nfor v5 in range(v1):\n    print(' '.join(list(map(str, v9[v5]))))\n"}
{"id": "llm_code\\minimum-time-to-reach-destination-in-directed-graph__grok-4.1-fast__v1.py", "text": "import heapq\nimport sys\n\nclass C1(object):\n\n    def minTime(self, a1, a2):\n        v1 = sys.maxsize\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5, v6, cls in a2:\n            v2[v4].append((v5, v6, cls))\n        v7 = [v1] * a1\n        v7[0] = 0\n        v8 = [(0, 0)]\n        while v8:\n            v9, v10 = heapq.heappop(v8)\n            if v9 > v7[v10]:\n                continue\n            for v11, v12, v13 in v2[v10]:\n                if v9 > v13:\n                    continue\n                v14 = max(v9, v12)\n                v15 = v14 + 1\n                if v15 < v7[v11]:\n                    v7[v11] = v15\n                    heapq.heappush(v8, (v15, v11))\n        v16 = v7[a1 - 1]\n        return v16 if v16 != v1 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\nimport sys\n\nclass C1(object):\n\n    def minTime(self, a1, a2):\n        v1 = sys.maxsize\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5, v6, cls in a2:\n            v2[v4].append((v5, v6, cls))\n        v7 = [v1] * a1\n        v7[0] = 0\n        v8 = [(0, 0)]\n        while v8:\n            v9, v10 = heapq.heappop(v8)\n            if v9 > v7[v10]:\n                continue\n            for v11, v12, v13 in v2[v10]:\n                if v9 > v13:\n                    continue\n                v14 = max(v9, v12)\n                v15 = v14 + 1\n                if v15 < v7[v11]:\n                    v7[v11] = v15\n                    heapq.heappush(v8, (v15, v11))\n        v16 = v7[a1 - 1]\n        return v16 if v16 != v1 else -1\n"}
{"id": "llm_code\\p03786__s057017053.py", "text": "v1 = int(input())\nv2 = input().split()\nv3 = list()\nfor v4 in v2:\n    v3.append(int(v4))\nv2 = v3\n\ndef f1(a1, a2, a3):\n    if not a3:\n        return False\n    if len(a1) == 0:\n        return True\n    if 2 * a2 >= max(a1):\n        return True\n    v1 = min(a1)\n    if 2 * a2 >= v1:\n        a2 += v1\n        a1.remove(v1)\n        if f1(a1, a2, True):\n            return True\n        else:\n            a2 -= v1\n            a1.append(v1)\n    return False\nv5 = 0\nfor v4 in range(len(v2)):\n    v6 = list(v2)\n    v6.remove(v2[v4])\n    if f1(v6, v2[v4], True):\n        v5 += 1\nprint(v5)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = input().split()\nv3 = list()\nfor v4 in v2:\n    v3.append(int(v4))\nv2 = v3\n\ndef f1(a1, a2, a3):\n    if not a3:\n        return False\n    if len(a1) == 0:\n        return True\n    if 2 * a2 >= max(a1):\n        return True\n    v1 = min(a1)\n    if 2 * a2 >= v1:\n        a2 += v1\n        a1.remove(v1)\n        if f1(a1, a2, True):\n            return True\n        else:\n            a2 -= v1\n            a1.append(v1)\n    return False\nv5 = 0\nfor v4 in range(len(v2)):\n    v6 = list(v2)\n    v6.remove(v2[v4])\n    if f1(v6, v2[v4], True):\n        v5 += 1\nprint(v5)\n"}
{"id": "llm_code\\p02665__s241281257.py", "text": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = [0] * (v1 + 1)\nv3[0] = 1\nif v2[0] != 0:\n    if v1 != 0:\n        print(-1)\n        exit()\n    else:\n        print(1)\n        exit()\nif v2[v1] == 0:\n    print(-1)\n    exit()\nv3[v1] = v2[v1]\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef f1(a1, a2):\n    if a1 == 0:\n        if v3[0] == 1:\n            return True\n        else:\n            return False\n    v1 = v2[a1] - -a2 // 2\n    v3[a1] = v1\n    if not f1(a1 - 1, a2):\n        return False\n    v2 = v2[a1] + a2\n    v2 = min(v2, 2 ** a1)\n    while v2 >= v2[a1] - -a2 // 2:\n        if f1(a1 - 1, a2):\n            v3[a1] = v2\n            break\n        v2 -= 1\n    else:\n        return False\n    return True\nv4 = f1(v1 - 1, v3[v1])\nif v4:\n    print(sum(v3))\nelse:\n    print(-1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = [0] * (v1 + 1)\nv3[0] = 1\nif v2[0] != 0:\n    if v1 != 0:\n        print(-1)\n        exit()\n    else:\n        print(1)\n        exit()\nif v2[v1] == 0:\n    print(-1)\n    exit()\nv3[v1] = v2[v1]\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef f1(a1, a2):\n    if a1 == 0:\n        if v3[0] == 1:\n            return True\n        else:\n            return False\n    v1 = v2[a1] - -a2 // 2\n    v3[a1] = v1\n    if not f1(a1 - 1, a2):\n        return False\n    v2 = v2[a1] + a2\n    v2 = min(v2, 2 ** a1)\n    while v2 >= v2[a1] - -a2 // 2:\n        if f1(a1 - 1, a2):\n            v3[a1] = v2\n            break\n        v2 -= 1\n    else:\n        return False\n    return True\nv4 = f1(v1 - 1, v3[v1])\nif v4:\n    print(sum(v3))\nelse:\n    print(-1)\n"}
{"id": "human_code\\p03049__s836745363.py", "text": "v1 = int(input())\nv2 = 0\nv3 = 0\nv4 = 0\nv5 = 0\nfor v6 in range(0, v1):\n    v7 = input()\n    v2 = v2 + v7.count('AB')\n    if v7[0] == 'B' and v7[-1] == 'A':\n        v5 = v5 + 1\n    elif v7[0] == 'B':\n        v4 = v4 + 1\n    elif v7[-1] == 'A':\n        v3 = v3 + 1\nv2 = v2 + v5\nif v3 == 0 and v4 == 0 and (v5 != 0):\n    v2 = v2 - 1\nelif v4 >= v3:\n    v2 = v2 + v3\nelse:\n    v2 = v2 + v4\nprint(v2)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = 0\nv3 = 0\nv4 = 0\nv5 = 0\nfor v6 in range(0, v1):\n    v7 = input()\n    v2 = v2 + v7.count('AB')\n    if v7[0] == 'B' and v7[-1] == 'A':\n        v5 = v5 + 1\n    elif v7[0] == 'B':\n        v4 = v4 + 1\n    elif v7[-1] == 'A':\n        v3 = v3 + 1\nv2 = v2 + v5\nif v3 == 0 and v4 == 0 and (v5 != 0):\n    v2 = v2 - 1\nelif v4 >= v3:\n    v2 = v2 + v3\nelse:\n    v2 = v2 + v4\nprint(v2)\n"}
{"id": "human_code\\detonate-the-maximum-bombs__part2.py", "text": "class C1(object):\n\n    def maximumDetonation(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, (v4, v5, v6) in enumerate(a1):\n            for v7, (v8, v9, v2) in enumerate(a1):\n                if v7 == v3:\n                    continue\n                if (v4 - v8) ** 2 + (v5 - v9) ** 2 <= v6 ** 2:\n                    v1[v3].append(v7)\n        v10 = 0\n        for v3 in range(len(a1)):\n            v11 = [v3]\n            v12 = {v3}\n            while v11:\n                v13 = v11.pop()\n                for v14 in v1[v13]:\n                    if v14 in v12:\n                        continue\n                    v12.add(v14)\n                    v11.append(v14)\n            v10 = max(v10, len(v12))\n            if v10 == len(a1):\n                break\n        return v10\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumDetonation(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, (v4, v5, v6) in enumerate(a1):\n            for v7, (v8, v9, v2) in enumerate(a1):\n                if v7 == v3:\n                    continue\n                if (v4 - v8) ** 2 + (v5 - v9) ** 2 <= v6 ** 2:\n                    v1[v3].append(v7)\n        v10 = 0\n        for v3 in range(len(a1)):\n            v11 = [v3]\n            v12 = {v3}\n            while v11:\n                v13 = v11.pop()\n                for v14 in v1[v13]:\n                    if v14 in v12:\n                        continue\n                    v12.add(v14)\n                    v11.append(v14)\n            v10 = max(v10, len(v12))\n            if v10 == len(a1):\n                break\n        return v10\n"}
{"id": "human_code\\p03015__s728617512.py", "text": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\n\ndef f1():\n    return [int(x) for v1 in sys.stdin.readline().split()]\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return [list(x) for v1 in sys.stdin.readline().split()]\n\ndef f4():\n    v1 = list(sys.stdin.readline())\n    if v1[-1] == '\\n':\n        return v1[:-1]\n    return v1\n\ndef f5(a1):\n    return [f2() for v1 in range(a1)]\n\ndef f6(a1):\n    return [f1() for v1 in range(a1)]\n\ndef f7(a1):\n    return [f4() for v1 in range(a1)]\n\ndef f8(a1):\n    return [f3() for v1 in range(a1)]\nsys.setrecursionlimit(1000000)\nv1 = 1000000007\n\ndef f9():\n    v1 = list(map(int, input()))\n    v2 = len(v1)\n    v3 = [[0] * 2 for v4 in range(v2 + 1)]\n    v3[0][0] = 1\n    for v4 in range(v2):\n        v5 = v4 + 1\n        for v6 in range(2):\n            v7 = 1 if v6 else v1[v4]\n            for v8 in range(v7 + 1):\n                v9 = v6 or v8 < v1[v4]\n                if v8:\n                    v3[v5][v9] += 2 * v3[v4][v6]\n                else:\n                    v3[v5][v9] += v3[v4][v6]\n                v3[v5][v9] %= v1\n    print(sum(v3[v2]) % v1)\n    return\nif __name__ == '__main__':\n    f9()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\n\ndef f1():\n    return [int(x) for v1 in sys.stdin.readline().split()]\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return [list(x) for v1 in sys.stdin.readline().split()]\n\ndef f4():\n    v1 = list(sys.stdin.readline())\n    if v1[-1] == '\\n':\n        return v1[:-1]\n    return v1\n\ndef f5(a1):\n    return [f2() for v1 in range(a1)]\n\ndef f6(a1):\n    return [f1() for v1 in range(a1)]\n\ndef f7(a1):\n    return [f4() for v1 in range(a1)]\n\ndef f8(a1):\n    return [f3() for v1 in range(a1)]\nsys.setrecursionlimit(1000000)\nv1 = 1000000007\n\ndef f9():\n    v1 = list(map(int, input()))\n    v2 = len(v1)\n    v3 = [[0] * 2 for v4 in range(v2 + 1)]\n    v3[0][0] = 1\n    for v4 in range(v2):\n        v5 = v4 + 1\n        for v6 in range(2):\n            v7 = 1 if v6 else v1[v4]\n            for v8 in range(v7 + 1):\n                v9 = v6 or v8 < v1[v4]\n                if v8:\n                    v3[v5][v9] += 2 * v3[v4][v6]\n                else:\n                    v3[v5][v9] += v3[v4][v6]\n                v3[v5][v9] %= v1\n    print(sum(v3[v2]) % v1)\n    return\nif __name__ == '__main__':\n    f9()\n"}
{"id": "human_code\\p02697__s853844371.py", "text": "v1, v2 = [int(i) for v3 in input().split()]\nif v1 % 2 == 1:\n    v4 = 1\n    v5 = 2 * v2\n    for v6 in range(v2):\n        print(v4, v5)\n        v4 += 1\n        v5 -= 1\nelse:\n    v4 = 1\n    v7 = v1 - 1\n    v8 = 0\n    v9 = v1 // 2\n    v10 = True\n    while True:\n        if v10 and v7 <= v9:\n            v7 -= 1\n            v10 = False\n        v8 += 1\n        print(v4, v4 + v7)\n        v4 += 1\n        v7 -= 2\n        if v8 == v2:\n            break\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = [int(i) for v3 in input().split()]\nif v1 % 2 == 1:\n    v4 = 1\n    v5 = 2 * v2\n    for v6 in range(v2):\n        print(v4, v5)\n        v4 += 1\n        v5 -= 1\nelse:\n    v4 = 1\n    v7 = v1 - 1\n    v8 = 0\n    v9 = v1 // 2\n    v10 = True\n    while True:\n        if v10 and v7 <= v9:\n            v7 -= 1\n            v10 = False\n        v8 += 1\n        print(v4, v4 + v7)\n        v4 += 1\n        v7 -= 2\n        if v8 == v2:\n            break\n"}
{"id": "llm_code\\p03127__s629597165.py", "text": "import sys\nimport math\n\ndef f1():\n    return sys.stdin.readline().strip()\nv1 = 10 ** 9 + 7\nsys.setrecursionlimit(20000000)\n\ndef f2():\n    v1 = int(f1())\n    v2 = list(map(int, f1().split()))\n    v2.sort()\n    v3 = v2[0]\n    v4 = set()\n    for v5 in range(1, v1):\n        v6 = math.gcd(v2[v5], v3)\n        if v6 == 1:\n            v4.add(1)\n        elif v6 == v3:\n            continue\n        else:\n            v4.add(v6)\n    if len(v4) == 0:\n        print(v3)\n    else:\n        print(min(v4))\nif __name__ == '__main__':\n    f2()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nimport math\n\ndef f1():\n    return sys.stdin.readline().strip()\nv1 = 10 ** 9 + 7\nsys.setrecursionlimit(20000000)\n\ndef f2():\n    v1 = int(f1())\n    v2 = list(map(int, f1().split()))\n    v2.sort()\n    v3 = v2[0]\n    v4 = set()\n    for v5 in range(1, v1):\n        v6 = math.gcd(v2[v5], v3)\n        if v6 == 1:\n            v4.add(1)\n        elif v6 == v3:\n            continue\n        else:\n            v4.add(v6)\n    if len(v4) == 0:\n        print(v3)\n    else:\n        print(min(v4))\nif __name__ == '__main__':\n    f2()\n"}
{"id": "human_code\\number-of-subarrays-with-lcm-equal-to-k__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def subarrayLCM(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lcm(a1, a2):\n            return a1 // gcd(a1, a2) * a2\n        v1 = 0\n        v2 = collections.Counter()\n        for v3 in a1:\n            v4 = collections.Counter()\n            if a2 % v3 == 0:\n                v2[v3] += 1\n                for v5, v6 in v2.items():\n                    v4[lcm(v5, v3)] += v6\n            v2 = v4\n            v1 += v2[a2]\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def subarrayLCM(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lcm(a1, a2):\n            return a1 // gcd(a1, a2) * a2\n        v1 = 0\n        v2 = collections.Counter()\n        for v3 in a1:\n            v4 = collections.Counter()\n            if a2 % v3 == 0:\n                v2[v3] += 1\n                for v5, v6 in v2.items():\n                    v4[lcm(v5, v3)] += v6\n            v2 = v4\n            v1 += v2[a2]\n        return v1\n"}
{"id": "human_code\\check-if-an-original-string-exists-given-two-encoded-strings__part2.py", "text": "class C1(object):\n\n    def possiblyEquals(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def memoization(a1, a2, a3, a4, a5, a6):\n            if (a3, a4, a5) not in a6:\n                if a3 == len(a1) and a4 == len(a2):\n                    a6[a3, a4, a5] = a5 == 0\n                elif a3 != len(a1) and a1[a3].isdigit():\n                    a6[a3, a4, a5] = False\n                    for v1 in range(a3 + 1, len(a1) + 1):\n                        if (v1 == len(a1) or a1[v1] != '0') and memoization(a1, a2, v1, a4, a5 + int(a1[a3:v1]), a6):\n                            a6[a3, a4, a5] = True\n                            break\n                        if v1 == len(a1) or not a1[v1].isdigit():\n                            break\n                elif a4 != len(a2) and a2[a4].isdigit():\n                    a6[a3, a4, a5] = False\n                    for v2 in range(a4 + 1, len(a2) + 1):\n                        if (v2 == len(a2) or a2[v2] != '0') and memoization(a1, a2, a3, v2, a5 - int(a2[a4:v2]), a6):\n                            a6[a3, a4, a5] = True\n                            break\n                        if v2 == len(a2) or not a2[v2].isdigit():\n                            break\n                elif a5 < 0:\n                    a6[a3, a4, a5] = memoization(a1, a2, a3 + 1, a4, a5 + 1, a6) if a3 != len(a1) else False\n                elif a5 > 0:\n                    a6[a3, a4, a5] = memoization(a1, a2, a3, a4 + 1, a5 - 1, a6) if a4 != len(a2) else False\n                else:\n                    a6[a3, a4, a5] = memoization(a1, a2, a3 + 1, a4 + 1, a5, a6) if a3 != len(a1) and a4 != len(a2) and (a1[a3] == a2[a4]) else False\n            return a6[a3, a4, a5]\n        return memoization(a1, a2, 0, 0, 0, {})\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def possiblyEquals(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def memoization(a1, a2, a3, a4, a5, a6):\n            if (a3, a4, a5) not in a6:\n                if a3 == len(a1) and a4 == len(a2):\n                    a6[a3, a4, a5] = a5 == 0\n                elif a3 != len(a1) and a1[a3].isdigit():\n                    a6[a3, a4, a5] = False\n                    for v1 in range(a3 + 1, len(a1) + 1):\n                        if (v1 == len(a1) or a1[v1] != '0') and memoization(a1, a2, v1, a4, a5 + int(a1[a3:v1]), a6):\n                            a6[a3, a4, a5] = True\n                            break\n                        if v1 == len(a1) or not a1[v1].isdigit():\n                            break\n                elif a4 != len(a2) and a2[a4].isdigit():\n                    a6[a3, a4, a5] = False\n                    for v2 in range(a4 + 1, len(a2) + 1):\n                        if (v2 == len(a2) or a2[v2] != '0') and memoization(a1, a2, a3, v2, a5 - int(a2[a4:v2]), a6):\n                            a6[a3, a4, a5] = True\n                            break\n                        if v2 == len(a2) or not a2[v2].isdigit():\n                            break\n                elif a5 < 0:\n                    a6[a3, a4, a5] = memoization(a1, a2, a3 + 1, a4, a5 + 1, a6) if a3 != len(a1) else False\n                elif a5 > 0:\n                    a6[a3, a4, a5] = memoization(a1, a2, a3, a4 + 1, a5 - 1, a6) if a4 != len(a2) else False\n                else:\n                    a6[a3, a4, a5] = memoization(a1, a2, a3 + 1, a4 + 1, a5, a6) if a3 != len(a1) and a4 != len(a2) and (a1[a3] == a2[a4]) else False\n            return a6[a3, a4, a5]\n        return memoization(a1, a2, 0, 0, 0, {})\n"}
{"id": "llm_code\\subtree-inversion-sum__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def subtreeInversionSum(self, a1, a2, a3):\n        v1 = len(a2)\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5 in a1:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = []\n\n        def traverse(a1, a2):\n            v6.append([0, 0])\n            v1 = a2[a1]\n            v2 = 0\n            v3 = 0\n            for v4 in v2[a1]:\n                if v4 == a2:\n                    continue\n                v5, v6, v7 = traverse(v4, a1)\n                v1 += v5\n                v2 += v6\n                v3 += v7\n            v2 = max(v2, v6[-1][1] - 2 * v1)\n            v3 = max(v3, v6[-1][0] + 2 * v1)\n            v6.pop()\n            v8 = len(v6)\n            if v8 >= a3:\n                v6[v8 - a3][0] += v2\n                v6[v8 - a3][1] += v3\n            return (v1, v2, v3)\n        v7, v8, v3 = traverse(0, -1)\n        return v7 + v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def subtreeInversionSum(self, a1, a2, a3):\n        v1 = len(a2)\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5 in a1:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = []\n\n        def traverse(a1, a2):\n            v6.append([0, 0])\n            v1 = a2[a1]\n            v2 = 0\n            v3 = 0\n            for v4 in v2[a1]:\n                if v4 == a2:\n                    continue\n                v5, v6, v7 = traverse(v4, a1)\n                v1 += v5\n                v2 += v6\n                v3 += v7\n            v2 = max(v2, v6[-1][1] - 2 * v1)\n            v3 = max(v3, v6[-1][0] + 2 * v1)\n            v6.pop()\n            v8 = len(v6)\n            if v8 >= a3:\n                v6[v8 - a3][0] += v2\n                v6[v8 - a3][1] += v3\n            return (v1, v2, v3)\n        v7, v8, v3 = traverse(0, -1)\n        return v7 + v8\n"}
{"id": "llm_code\\reverse-subarray-to-maximize-array-value__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxValueAfterReverse(self, a1):\n        v1 = 0\n        v2 = float('-inf')\n        v3 = float('inf')\n        v4 = 0\n        v5, v6 = (a1[0], a1[-1])\n        v7 = len(a1)\n        for v8 in range(v7 - 1):\n            v1 += abs(a1[v8] - a1[v8 + 1])\n            v9 = min(a1[v8], a1[v8 + 1])\n            v10 = max(a1[v8], a1[v8 + 1])\n            v2 = max(v2, v9)\n            v3 = min(v3, v10)\n        for v8 in range(1, v7):\n            v11 = abs(a1[v8 - 1] - a1[v8])\n            v4 = max(v4, abs(v5 - a1[v8]) - v11)\n            v4 = max(v4, abs(v6 - a1[v8 - 1]) - v11)\n        v12 = 2 * (v2 - v3)\n        return v1 + max(v4, v12)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxValueAfterReverse(self, a1):\n        v1 = 0\n        v2 = float('-inf')\n        v3 = float('inf')\n        v4 = 0\n        v5, v6 = (a1[0], a1[-1])\n        v7 = len(a1)\n        for v8 in range(v7 - 1):\n            v1 += abs(a1[v8] - a1[v8 + 1])\n            v9 = min(a1[v8], a1[v8 + 1])\n            v10 = max(a1[v8], a1[v8 + 1])\n            v2 = max(v2, v9)\n            v3 = min(v3, v10)\n        for v8 in range(1, v7):\n            v11 = abs(a1[v8 - 1] - a1[v8])\n            v4 = max(v4, abs(v5 - a1[v8]) - v11)\n            v4 = max(v4, abs(v6 - a1[v8 - 1]) - v11)\n        v12 = 2 * (v2 - v3)\n        return v1 + max(v4, v12)\n"}
{"id": "human_code\\find-array-given-subset-sums__part4.py", "text": "import collections\n\nclass C1(object):\n\n    def recoverArray(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = {k: v for v2, v3 in collections.Counter(a2).items()}\n        v4 = sorted(v1.keys())\n        v5 = 0\n        v6 = []\n        for v7 in range(a1):\n            v8 = {}\n            v9 = []\n            v10 = v4[0] - v4[1] if v1[v4[0]] == 1 else 0\n            assert v10 <= 0\n            for v11 in v4:\n                if not v1[v11]:\n                    continue\n                v1[v11 - v10] -= v1[v11] if v10 else v1[v11] // 2\n                v8[v11 - v10] = v1[v11]\n                v9.append(v11 - v10)\n            v1 = v8\n            v4 = v9\n            if v5 in v1:\n                v6.append(v10)\n            else:\n                v6.append(-v10)\n                v5 -= v10\n        return v6\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def recoverArray(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = {k: v for v2, v3 in collections.Counter(a2).items()}\n        v4 = sorted(v1.keys())\n        v5 = 0\n        v6 = []\n        for v7 in range(a1):\n            v8 = {}\n            v9 = []\n            v10 = v4[0] - v4[1] if v1[v4[0]] == 1 else 0\n            assert v10 <= 0\n            for v11 in v4:\n                if not v1[v11]:\n                    continue\n                v1[v11 - v10] -= v1[v11] if v10 else v1[v11] // 2\n                v8[v11 - v10] = v1[v11]\n                v9.append(v11 - v10)\n            v1 = v8\n            v4 = v9\n            if v5 in v1:\n                v6.append(v10)\n            else:\n                v6.append(-v10)\n                v5 -= v10\n        return v6\n"}
{"id": "human_code\\select-cells-in-grid-with-maximum-score__part1.py", "text": "class C1(object):\n\n    def maxScore(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def hungarian(a1):\n            if not a1:\n                return (0, [])\n            v1, v2 = (len(a1) + 1, len(a1[0]) + 1)\n            v3, v4, v5, v6 = ([0] * v1, [0] * v2, [0] * v2, [0] * (v1 - 1))\n            for v7 in range(1, v1):\n                v5[0] = v7\n                v8 = 0\n                v9, v10 = ([float('inf')] * v2, [-1] * v2)\n                v11 = [False] * (v2 + 1)\n                while True:\n                    v11[v8] = True\n                    v12, v13, v14 = (v5[v8], None, float('inf'))\n                    for v15 in range(1, v2):\n                        if v11[v15]:\n                            continue\n                        v16 = a1[v12 - 1][v15 - 1] - v3[v12] - v4[v15]\n                        if v16 < v9[v15]:\n                            v9[v15], v10[v15] = (v16, v8)\n                        if v9[v15] < v14:\n                            v14, v13 = (v9[v15], v15)\n                    for v15 in range(v2):\n                        if v11[v15]:\n                            v3[v5[v15]] += v14\n                            v4[v15] -= v14\n                        else:\n                            v9[v15] -= v14\n                    v8 = v13\n                    if not v5[v8]:\n                        break\n                while v8:\n                    v13 = v10[v8]\n                    v5[v8], v8 = (v5[v13], v13)\n            for v15 in range(1, v2):\n                if v5[v15]:\n                    v6[v5[v15] - 1] = v15 - 1\n            return (-v4[0], v6)\n        v1 = max((x for v2 in a1 for v3 in v2))\n        v4 = [[0] * max(v1, len(a1)) for v5 in range(len(a1))]\n        for v6, v2 in enumerate(a1):\n            for v3 in v2:\n                v4[v6][v3 - 1] = -v3\n        return -hungarian(v4)[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxScore(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def hungarian(a1):\n            if not a1:\n                return (0, [])\n            v1, v2 = (len(a1) + 1, len(a1[0]) + 1)\n            v3, v4, v5, v6 = ([0] * v1, [0] * v2, [0] * v2, [0] * (v1 - 1))\n            for v7 in range(1, v1):\n                v5[0] = v7\n                v8 = 0\n                v9, v10 = ([float('inf')] * v2, [-1] * v2)\n                v11 = [False] * (v2 + 1)\n                while True:\n                    v11[v8] = True\n                    v12, v13, v14 = (v5[v8], None, float('inf'))\n                    for v15 in range(1, v2):\n                        if v11[v15]:\n                            continue\n                        v16 = a1[v12 - 1][v15 - 1] - v3[v12] - v4[v15]\n                        if v16 < v9[v15]:\n                            v9[v15], v10[v15] = (v16, v8)\n                        if v9[v15] < v14:\n                            v14, v13 = (v9[v15], v15)\n                    for v15 in range(v2):\n                        if v11[v15]:\n                            v3[v5[v15]] += v14\n                            v4[v15] -= v14\n                        else:\n                            v9[v15] -= v14\n                    v8 = v13\n                    if not v5[v8]:\n                        break\n                while v8:\n                    v13 = v10[v8]\n                    v5[v8], v8 = (v5[v13], v13)\n            for v15 in range(1, v2):\n                if v5[v15]:\n                    v6[v5[v15] - 1] = v15 - 1\n            return (-v4[0], v6)\n        v1 = max((x for v2 in a1 for v3 in v2))\n        v4 = [[0] * max(v1, len(a1)) for v5 in range(len(a1))]\n        for v6, v2 in enumerate(a1):\n            for v3 in v2:\n                v4[v6][v3 - 1] = -v3\n        return -hungarian(v4)[0]\n"}
{"id": "llm_code\\maximum-number-of-alloys__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxNumberOfAlloys(self, a1, a2, a3, a4, a5, a6):\n        v1 = sum(a5)\n        v2 = v1 + a3 + 1\n        v3 = 0\n        for v4 in a4:\n            v5 = 0\n            v6 = v2\n            while v5 < v6:\n                v7 = (v5 + v6 + 1) // 2\n                v8 = 0\n                v9 = True\n                for v10 in range(a1):\n                    v11 = v7 * v4[v10] - a5[v10]\n                    if v11 > 0:\n                        v8 += v11 * a6[v10]\n                        if v8 > a3:\n                            v9 = False\n                            break\n                if v9:\n                    v5 = v7\n                else:\n                    v6 = v7 - 1\n            v3 = max(v3, v5)\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxNumberOfAlloys(self, a1, a2, a3, a4, a5, a6):\n        v1 = sum(a5)\n        v2 = v1 + a3 + 1\n        v3 = 0\n        for v4 in a4:\n            v5 = 0\n            v6 = v2\n            while v5 < v6:\n                v7 = (v5 + v6 + 1) // 2\n                v8 = 0\n                v9 = True\n                for v10 in range(a1):\n                    v11 = v7 * v4[v10] - a5[v10]\n                    if v11 > 0:\n                        v8 += v11 * a6[v10]\n                        if v8 > a3:\n                            v9 = False\n                            break\n                if v9:\n                    v5 = v7\n                else:\n                    v6 = v7 - 1\n            v3 = max(v3, v5)\n        return v3\n"}
{"id": "llm_code\\p02616__s082181891.py", "text": "import sys\nsys.setrecursionlimit(10 ** 6)\nv1 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    v1, v2 = map(int, a1().split())\n    v3 = list(map(int, a1().split()))\n    v4 = 0\n    for v5 in range(v1):\n        if v3[v5] < 0:\n            v4 += 1\n    v6 = 0\n    v7 = 0\n    v8 = 1\n    v3 = sorted(v3, key=abs, reverse=True)\n    v9 = 0\n    for v5 in range(v1):\n        if v2 == v7:\n            break\n        if v3[v5] < 0:\n            if v2 - v7 > 1 and v6 < v4:\n                if v6 % 2 == 1:\n                    v8 = v8 * v9 * v3[v5] % v1\n                    v7 += 2\n                else:\n                    v9 = v3[v5]\n                v6 += 1\n        else:\n            v8 = v8 * v3[v5] % v1\n            v7 += 1\n    if v7 == v2:\n        a2(v8)\n        return\n    v8 = 1\n    v3 = sorted(v3, key=abs)\n    v9 = 0\n    for v5 in range(v2):\n        v8 = v8 * v3[v5] % v1\n    a2(v8)\nif __name__ == '__main__':\n    f1(sys.stdin.readline, print)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 6)\nv1 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    v1, v2 = map(int, a1().split())\n    v3 = list(map(int, a1().split()))\n    v4 = 0\n    for v5 in range(v1):\n        if v3[v5] < 0:\n            v4 += 1\n    v6 = 0\n    v7 = 0\n    v8 = 1\n    v3 = sorted(v3, key=abs, reverse=True)\n    v9 = 0\n    for v5 in range(v1):\n        if v2 == v7:\n            break\n        if v3[v5] < 0:\n            if v2 - v7 > 1 and v6 < v4:\n                if v6 % 2 == 1:\n                    v8 = v8 * v9 * v3[v5] % v1\n                    v7 += 2\n                else:\n                    v9 = v3[v5]\n                v6 += 1\n        else:\n            v8 = v8 * v3[v5] % v1\n            v7 += 1\n    if v7 == v2:\n        a2(v8)\n        return\n    v8 = 1\n    v3 = sorted(v3, key=abs)\n    v9 = 0\n    for v5 in range(v2):\n        v8 = v8 * v3[v5] % v1\n    a2(v8)\nif __name__ == '__main__':\n    f1(sys.stdin.readline, print)\n"}
{"id": "human_code\\split-a-string-into-the-max-number-of-unique-substrings.py", "text": "class C1(object):\n\n    def maxUniqueSplit(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def popcount(a1):\n            v1 = 0\n            while a1:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n        v1 = 1\n        v2 = 2 ** (len(a1) - 1)\n        v3 = 0\n        while v3 < v2:\n            if popcount(v3) < v1:\n                v3 += 1\n                continue\n            v4, v5, v6 = (set(), [], v2 // 2)\n            for v7 in range(len(a1)):\n                v5.append(a1[v7])\n                if v3 & v6 or v6 == 0:\n                    if ''.join(v5) in v4:\n                        v3 = (v3 | v6 - 1) + 1 if v6 else v3 + 1\n                        break\n                    v4.add(''.join(v5))\n                    v5 = []\n                v6 >>= 1\n            else:\n                v1 = max(v1, len(v4))\n                v3 += 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxUniqueSplit(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def popcount(a1):\n            v1 = 0\n            while a1:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n        v1 = 1\n        v2 = 2 ** (len(a1) - 1)\n        v3 = 0\n        while v3 < v2:\n            if popcount(v3) < v1:\n                v3 += 1\n                continue\n            v4, v5, v6 = (set(), [], v2 // 2)\n            for v7 in range(len(a1)):\n                v5.append(a1[v7])\n                if v3 & v6 or v6 == 0:\n                    if ''.join(v5) in v4:\n                        v3 = (v3 | v6 - 1) + 1 if v6 else v3 + 1\n                        break\n                    v4.add(''.join(v5))\n                    v5 = []\n                v6 >>= 1\n            else:\n                v1 = max(v1, len(v4))\n                v3 += 1\n        return v1\n"}
{"id": "llm_code\\p02955__s646633003.py", "text": "import sys\nimport collections\nimport copy\nimport math\ninput = sys.stdin.readline\nv1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = sum(v3)\n\ndef f1(a1):\n    v1 = []\n    for v2 in range(1, int(a1 ** 0.5) + 1):\n        if a1 % v2 == 0:\n            v1.append(v2)\n            if v2 != a1 // v2:\n                v1.append(a1 // v2)\n    v1.sort(reverse=True)\n    return v1\nv5 = f1(v4)\nv6 = 0\nfor v7 in range(len(v5)):\n    v8 = v5[v7]\n    v9 = 0\n    v10 = v8\n    v9 += v3[0] % v8\n    v11 = [v3[0] % v8]\n    for v12 in range(1, v1):\n        v9 += v3[v12] % v8\n        v11.append(v3[v12] % v8)\n    v13 = v9 // v8\n    v11.sort(reverse=True)\n    v14 = 0\n    for v12 in range(v13):\n        v14 += v8 - v11[v12]\n    if v14 > v2:\n        continue\n    else:\n        print(v8)\n        break\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nimport collections\nimport copy\nimport math\ninput = sys.stdin.readline\nv1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = sum(v3)\n\ndef f1(a1):\n    v1 = []\n    for v2 in range(1, int(a1 ** 0.5) + 1):\n        if a1 % v2 == 0:\n            v1.append(v2)\n            if v2 != a1 // v2:\n                v1.append(a1 // v2)\n    v1.sort(reverse=True)\n    return v1\nv5 = f1(v4)\nv6 = 0\nfor v7 in range(len(v5)):\n    v8 = v5[v7]\n    v9 = 0\n    v10 = v8\n    v9 += v3[0] % v8\n    v11 = [v3[0] % v8]\n    for v12 in range(1, v1):\n        v9 += v3[v12] % v8\n        v11.append(v3[v12] % v8)\n    v13 = v9 // v8\n    v11.sort(reverse=True)\n    v14 = 0\n    for v12 in range(v13):\n        v14 += v8 - v11[v12]\n    if v14 > v2:\n        continue\n    else:\n        print(v8)\n        break\n"}
{"id": "human_code\\total-characters-in-string-after-transformations-ii.py", "text": "import itertools\nfrom functools import reduce\n\nclass C1(object):\n\n    def lengthAfterTransformations(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def matrix_mult(a1, a2):\n            v1 = list(zip(*a2))\n            return [[sum((a * b % v1 for v2, v3 in zip(row, col))) % v1 for v4 in v1] for v5 in a1]\n\n        def matrix_expo(a1, a2):\n            v1 = [[int(i == j) for v2 in range(len(a1))] for v3 in range(len(a1))]\n            while a2:\n                if a2 % 2:\n                    v1 = matrix_mult(v1, a1)\n                a1 = matrix_mult(a1, a1)\n                a2 /= 2\n            return v1\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = [[0] * 26 for v5 in range(26)]\n        for v6 in range(len(a3)):\n            for v7 in range(1, a3[v6] + 1):\n                v4[v6][(v6 + v7) % 26] = 1\n        v8 = matrix_expo(v4, a2)\n        return reduce(lambda accu, x: (accu + v3) % v1, matrix_mult([v2], v8)[0], 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\nfrom functools import reduce\n\nclass C1(object):\n\n    def lengthAfterTransformations(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def matrix_mult(a1, a2):\n            v1 = list(zip(*a2))\n            return [[sum((a * b % v1 for v2, v3 in zip(row, col))) % v1 for v4 in v1] for v5 in a1]\n\n        def matrix_expo(a1, a2):\n            v1 = [[int(i == j) for v2 in range(len(a1))] for v3 in range(len(a1))]\n            while a2:\n                if a2 % 2:\n                    v1 = matrix_mult(v1, a1)\n                a1 = matrix_mult(a1, a1)\n                a2 /= 2\n            return v1\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = [[0] * 26 for v5 in range(26)]\n        for v6 in range(len(a3)):\n            for v7 in range(1, a3[v6] + 1):\n                v4[v6][(v6 + v7) % 26] = 1\n        v8 = matrix_expo(v4, a2)\n        return reduce(lambda accu, x: (accu + v3) % v1, matrix_mult([v2], v8)[0], 0)\n"}
{"id": "human_code\\shortest-uncommon-substring-in-an-array.py", "text": "class C1(object):\n\n    def shortestSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self):\n                self.__nodes = []\n                self.__cnts = []\n                self.__new_node()\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 26)\n                self.__cnts.append(0)\n                return len(self.__nodes) - 1\n\n            def add(self, a1, a2):\n                for v1 in range(len(a1)):\n                    v2 = 0\n                    for v3 in range(v1, len(a1)):\n                        v4 = ord(a1[v3]) - ord('a')\n                        if self.__nodes[v2][v4] == -1:\n                            self.__nodes[v2][v4] = self.__new_node()\n                        v2 = self.__nodes[v2][v4]\n                        self.__cnts[v2] += a2\n\n            def query(self, a1):\n                v1 = (float('inf'), '')\n                for v2 in range(len(a1)):\n                    v3 = 0\n                    for v4 in range(v2, len(a1)):\n                        v3 = self.__nodes[v3][ord(a1[v4]) - ord('a')]\n                        if self.__cnts[v3] == 0:\n                            v1 = min(v1, (v4 - v2 + 1, a1[v2:v4 + 1]))\n                            break\n                return v1[1]\n        v1 = Trie()\n        for v2 in a1:\n            v1.add(v2, +1)\n        v3 = []\n        for v2 in a1:\n            v1.add(v2, -1)\n            v3.append(v1.query(v2))\n            v1.add(v2, +1)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def shortestSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self):\n                self.__nodes = []\n                self.__cnts = []\n                self.__new_node()\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 26)\n                self.__cnts.append(0)\n                return len(self.__nodes) - 1\n\n            def add(self, a1, a2):\n                for v1 in range(len(a1)):\n                    v2 = 0\n                    for v3 in range(v1, len(a1)):\n                        v4 = ord(a1[v3]) - ord('a')\n                        if self.__nodes[v2][v4] == -1:\n                            self.__nodes[v2][v4] = self.__new_node()\n                        v2 = self.__nodes[v2][v4]\n                        self.__cnts[v2] += a2\n\n            def query(self, a1):\n                v1 = (float('inf'), '')\n                for v2 in range(len(a1)):\n                    v3 = 0\n                    for v4 in range(v2, len(a1)):\n                        v3 = self.__nodes[v3][ord(a1[v4]) - ord('a')]\n                        if self.__cnts[v3] == 0:\n                            v1 = min(v1, (v4 - v2 + 1, a1[v2:v4 + 1]))\n                            break\n                return v1[1]\n        v1 = Trie()\n        for v2 in a1:\n            v1.add(v2, +1)\n        v3 = []\n        for v2 in a1:\n            v1.add(v2, -1)\n            v3.append(v1.query(v2))\n            v1.add(v2, +1)\n        return v3\n"}
{"id": "llm_code\\apply-operations-to-maximize-frequency-score__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxFrequencyScore(self, a1, a2):\n        a1.sort()\n        v1 = len(a1)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n\n        def get_cost(a1, a2):\n            v1 = a2 - a1 + 1\n            v2 = a1 + v1 // 2\n            v3 = a1 + (v1 + 1) // 2\n            v4 = v2[v2] - v2[a1]\n            v5 = v2[a2 + 1] - v2[v3]\n            return v5 - v4\n        v4 = 0\n        v5 = 0\n        for v6 in range(v1):\n            while v4 <= v6 and get_cost(v4, v6) > a2:\n                v4 += 1\n            v5 = max(v5, v6 - v4 + 1)\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxFrequencyScore(self, a1, a2):\n        a1.sort()\n        v1 = len(a1)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n\n        def get_cost(a1, a2):\n            v1 = a2 - a1 + 1\n            v2 = a1 + v1 // 2\n            v3 = a1 + (v1 + 1) // 2\n            v4 = v2[v2] - v2[a1]\n            v5 = v2[a2 + 1] - v2[v3]\n            return v5 - v4\n        v4 = 0\n        v5 = 0\n        for v6 in range(v1):\n            while v4 <= v6 and get_cost(v4, v6) > a2:\n                v4 += 1\n            v5 = max(v5, v6 - v4 + 1)\n        return v5\n"}
{"id": "human_code\\maximum-number-of-removable-characters__part2.py", "text": "class C1(object):\n\n    def maximumRemovals(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4):\n            v1 = 0\n            for v2 in range(len(a1)):\n                if a3[v2] <= a4 or a1[v2] != a2[v1]:\n                    continue\n                v1 += 1\n                if v1 == len(a2):\n                    return True\n            return False\n        v1 = [float('inf')] * len(a1)\n        for v2, v3 in enumerate(a3):\n            v1[v3] = v2 + 1\n        v4, v5 = (0, len(a3))\n        while v4 <= v5:\n            v6 = v4 + (v5 - v4) // 2\n            if not check(a1, a2, v1, v6):\n                v5 = v6 - 1\n            else:\n                v4 = v6 + 1\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumRemovals(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4):\n            v1 = 0\n            for v2 in range(len(a1)):\n                if a3[v2] <= a4 or a1[v2] != a2[v1]:\n                    continue\n                v1 += 1\n                if v1 == len(a2):\n                    return True\n            return False\n        v1 = [float('inf')] * len(a1)\n        for v2, v3 in enumerate(a3):\n            v1[v3] = v2 + 1\n        v4, v5 = (0, len(a3))\n        while v4 <= v5:\n            v6 = v4 + (v5 - v4) // 2\n            if not check(a1, a2, v1, v6):\n                v5 = v6 - 1\n            else:\n                v4 = v6 + 1\n        return v5\n"}
{"id": "human_code\\minimum-number-of-days-to-disconnect-island__part2.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.size = [1] * a1\n        self.snapshots = []\n        self.undos = []\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            v3 = v1.pop()\n            self.undos.append((~v3, self.set[v3]))\n            self.set[v3] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.size[a1] > self.size[a2]:\n            a1, a2 = (a2, a1)\n        self.undos.append((a1, a2))\n        self.set[a1] = self.set[a2]\n        self.size[a2] += self.size[a1]\n        return True\n\n    def total(self, a1):\n        return self.size[self.find_set(a1)]\n\n    def snapshot(self):\n        self.snapshots.append(len(self.undos))\n\n    def rollback(self):\n        for v1 in range(len(self.undos) - self.snapshots.pop()):\n            v2, v3 = self.undos.pop()\n            if v2 >= 0:\n                self.size[v3] -= self.size[v2]\n                self.set[v2] = v2\n            else:\n                self.set[~v2] = v3\n\nclass C2(object):\n\n    def minDays(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def floodfill(a1, a2, a3, a4):\n            v1 = [(a2, a3)]\n            a4[a2][a3] = 1\n            while v1:\n                a2, a3 = v1.pop()\n                for v4, v5 in v1:\n                    v6, v7 = (a2 + v4, a3 + v5)\n                    if not (0 <= v6 < R and 0 <= v7 < C and a1[v6][v7] and (not a4[v6][v7])):\n                        continue\n                    a4[v6][v7] = 1\n                    v1.append((v6, v7))\n\n        def count_islands(a1):\n            v1 = [[0] * C for v2 in range(R)]\n            v3 = 0\n            for v4 in range(R):\n                for v5 in range(C):\n                    if a1[v4][v5] == 0 or v1[v4][v5]:\n                        continue\n                    v3 += 1\n                    floodfill(a1, v4, v5, v1)\n            return v3\n\n        def merge(a1):\n            v1, v2 = divmod(a1, C)\n            for v3, v4 in v1:\n                v5, v6 = (v1 + v3, v2 + v4)\n                v7 = v5 * C + v6\n                if 0 <= v5 < R and 0 <= v6 < C and (a1[v5][v6] == a1[v1][v2]) and lookup[v7]:\n                    uf.union_set(a1, v7)\n\n        def check(a1):\n            v1, v2 = divmod(a1, C)\n            if a1[v1][v2] == 0:\n                return False\n            v3 = set()\n            for v4, v5 in v1:\n                v6, v7 = (v1 + v4, v2 + v5)\n                if 0 <= v6 < R and 0 <= v7 < C and (a1[v6][v7] == a1[v1][v2]):\n                    v3.add(uf.find_set(v6 * C + v7))\n            return len(v3) != 1\n\n        def dfs(a1, a2):\n            if a1 == a2:\n                return check(a1)\n            v1 = a1 + (a2 - a1) // 2\n            v2, v3, v4, v5 = (a1, v1, v1 + 1, a2)\n            for v6 in range(2):\n                uf.snapshot()\n                for v7 in range(v2, v3 + 1):\n                    lookup[v7] = True\n                    merge(v7)\n                if dfs(v4, v5):\n                    return True\n                for v7 in range(v2, v3 + 1):\n                    lookup[v7] = False\n                uf.rollback()\n                v2, v3, v4, v5 = (v4, v5, v2, v3)\n            return False\n        v2, v3 = (len(a1), len(a1[0]))\n        if count_islands(a1) != 1:\n            return 0\n        v4 = C1(v2 * v3)\n        v5 = [False] * (v2 * v3)\n        return 1 if dfs(0, v2 * v3 - 1) else 2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.size = [1] * a1\n        self.snapshots = []\n        self.undos = []\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            v3 = v1.pop()\n            self.undos.append((~v3, self.set[v3]))\n            self.set[v3] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.size[a1] > self.size[a2]:\n            a1, a2 = (a2, a1)\n        self.undos.append((a1, a2))\n        self.set[a1] = self.set[a2]\n        self.size[a2] += self.size[a1]\n        return True\n\n    def total(self, a1):\n        return self.size[self.find_set(a1)]\n\n    def snapshot(self):\n        self.snapshots.append(len(self.undos))\n\n    def rollback(self):\n        for v1 in range(len(self.undos) - self.snapshots.pop()):\n            v2, v3 = self.undos.pop()\n            if v2 >= 0:\n                self.size[v3] -= self.size[v2]\n                self.set[v2] = v2\n            else:\n                self.set[~v2] = v3\n\nclass C2(object):\n\n    def minDays(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def floodfill(a1, a2, a3, a4):\n            v1 = [(a2, a3)]\n            a4[a2][a3] = 1\n            while v1:\n                a2, a3 = v1.pop()\n                for v4, v5 in v1:\n                    v6, v7 = (a2 + v4, a3 + v5)\n                    if not (0 <= v6 < R and 0 <= v7 < C and a1[v6][v7] and (not a4[v6][v7])):\n                        continue\n                    a4[v6][v7] = 1\n                    v1.append((v6, v7))\n\n        def count_islands(a1):\n            v1 = [[0] * C for v2 in range(R)]\n            v3 = 0\n            for v4 in range(R):\n                for v5 in range(C):\n                    if a1[v4][v5] == 0 or v1[v4][v5]:\n                        continue\n                    v3 += 1\n                    floodfill(a1, v4, v5, v1)\n            return v3\n\n        def merge(a1):\n            v1, v2 = divmod(a1, C)\n            for v3, v4 in v1:\n                v5, v6 = (v1 + v3, v2 + v4)\n                v7 = v5 * C + v6\n                if 0 <= v5 < R and 0 <= v6 < C and (a1[v5][v6] == a1[v1][v2]) and lookup[v7]:\n                    uf.union_set(a1, v7)\n\n        def check(a1):\n            v1, v2 = divmod(a1, C)\n            if a1[v1][v2] == 0:\n                return False\n            v3 = set()\n            for v4, v5 in v1:\n                v6, v7 = (v1 + v4, v2 + v5)\n                if 0 <= v6 < R and 0 <= v7 < C and (a1[v6][v7] == a1[v1][v2]):\n                    v3.add(uf.find_set(v6 * C + v7))\n            return len(v3) != 1\n\n        def dfs(a1, a2):\n            if a1 == a2:\n                return check(a1)\n            v1 = a1 + (a2 - a1) // 2\n            v2, v3, v4, v5 = (a1, v1, v1 + 1, a2)\n            for v6 in range(2):\n                uf.snapshot()\n                for v7 in range(v2, v3 + 1):\n                    lookup[v7] = True\n                    merge(v7)\n                if dfs(v4, v5):\n                    return True\n                for v7 in range(v2, v3 + 1):\n                    lookup[v7] = False\n                uf.rollback()\n                v2, v3, v4, v5 = (v4, v5, v2, v3)\n            return False\n        v2, v3 = (len(a1), len(a1[0]))\n        if count_islands(a1) != 1:\n            return 0\n        v4 = C1(v2 * v3)\n        v5 = [False] * (v2 * v3)\n        return 1 if dfs(0, v2 * v3 - 1) else 2\n"}
{"id": "human_code\\minimum-changes-to-make-k-semi-palindromes__part2.py", "text": "class C1(object):\n\n    def minimumChanges(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(len(a1) + 1)]\n        for v3 in range(1, len(v1)):\n            for v4 in range(v3, len(v1), v3):\n                v1[v4].append(v3)\n        v5 = [[{} for v2 in range(len(a1))] for v2 in range(len(a1))]\n        for v6 in range(1, len(a1) + 1):\n            for v7 in range(len(a1) - v6 + 1):\n                v8 = v7 + v6 - 1\n                for v9 in v1[v6]:\n                    v5[v7][v8][v9] = (v5[v7 + v9][v8 - v9][v9] if v7 + v9 < v8 - v9 else 0) + sum((a1[v7 + v3] != a1[v8 - (v9 - 1) + v3] for v3 in range(v9)))\n        v10 = [[len(a1)] * (a2 + 1) for v2 in range(len(a1) + 1)]\n        v10[0][0] = 0\n        for v3 in range(len(a1)):\n            for v4 in range(v3):\n                v11 = min((v5[v4][v3][v9] for v9 in v1[v3 - v4 + 1] if v9 != v3 - v4 + 1))\n                for v6 in range(a2):\n                    v10[v3 + 1][v6 + 1] = min(v10[v3 + 1][v6 + 1], v10[v4][v6] + v11)\n        return v10[len(a1)][a2]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumChanges(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(len(a1) + 1)]\n        for v3 in range(1, len(v1)):\n            for v4 in range(v3, len(v1), v3):\n                v1[v4].append(v3)\n        v5 = [[{} for v2 in range(len(a1))] for v2 in range(len(a1))]\n        for v6 in range(1, len(a1) + 1):\n            for v7 in range(len(a1) - v6 + 1):\n                v8 = v7 + v6 - 1\n                for v9 in v1[v6]:\n                    v5[v7][v8][v9] = (v5[v7 + v9][v8 - v9][v9] if v7 + v9 < v8 - v9 else 0) + sum((a1[v7 + v3] != a1[v8 - (v9 - 1) + v3] for v3 in range(v9)))\n        v10 = [[len(a1)] * (a2 + 1) for v2 in range(len(a1) + 1)]\n        v10[0][0] = 0\n        for v3 in range(len(a1)):\n            for v4 in range(v3):\n                v11 = min((v5[v4][v3][v9] for v9 in v1[v3 - v4 + 1] if v9 != v3 - v4 + 1))\n                for v6 in range(a2):\n                    v10[v3 + 1][v6 + 1] = min(v10[v3 + 1][v6 + 1], v10[v4][v6] + v11)\n        return v10[len(a1)][a2]\n"}
{"id": "human_code\\find-x-sum-of-all-k-long-subarrays-i.py", "text": "from sortedcontainers import SortedList\nimport collections\n\nclass C1(object):\n\n    def findXSum(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def update(a1, a2, a3):\n            if a2 == 1:\n                sl.add((-cnt[a1], -a1))\n            if sl.index((-cnt[a1], -a1)) < a3:\n                a3 += a2 * cnt[a1] * a1\n                if a3 < len(sl):\n                    v2, v3 = sl[a3]\n                    a3 -= a2 * v2 * v3\n            if a2 != 1:\n                sl.remove((-cnt[a1], -a1))\n            return a3\n        v1 = SortedList()\n        v2 = collections.defaultdict(int)\n        v3 = []\n        v4 = 0\n        for v5, v6 in enumerate(a1):\n            if v6 in v2:\n                v4 = update(v6, -1, v4)\n            v2[v6] += 1\n            v4 = update(v6, +1, v4)\n            if v5 < a2 - 1:\n                continue\n            v3.append(v4)\n            v4 = update(a1[v5 - (a2 - 1)], -1, v4)\n            v2[a1[v5 - (a2 - 1)]] -= 1\n            if v2[a1[v5 - (a2 - 1)]]:\n                v4 = update(a1[v5 - (a2 - 1)], +1, v4)\n            else:\n                del v2[a1[v5 - (a2 - 1)]]\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from sortedcontainers import SortedList\nimport collections\n\nclass C1(object):\n\n    def findXSum(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def update(a1, a2, a3):\n            if a2 == 1:\n                sl.add((-cnt[a1], -a1))\n            if sl.index((-cnt[a1], -a1)) < a3:\n                a3 += a2 * cnt[a1] * a1\n                if a3 < len(sl):\n                    v2, v3 = sl[a3]\n                    a3 -= a2 * v2 * v3\n            if a2 != 1:\n                sl.remove((-cnt[a1], -a1))\n            return a3\n        v1 = SortedList()\n        v2 = collections.defaultdict(int)\n        v3 = []\n        v4 = 0\n        for v5, v6 in enumerate(a1):\n            if v6 in v2:\n                v4 = update(v6, -1, v4)\n            v2[v6] += 1\n            v4 = update(v6, +1, v4)\n            if v5 < a2 - 1:\n                continue\n            v3.append(v4)\n            v4 = update(a1[v5 - (a2 - 1)], -1, v4)\n            v2[a1[v5 - (a2 - 1)]] -= 1\n            if v2[a1[v5 - (a2 - 1)]]:\n                v4 = update(a1[v5 - (a2 - 1)], +1, v4)\n            else:\n                del v2[a1[v5 - (a2 - 1)]]\n        return v3\n"}
{"id": "llm_code\\p02616__s040370754.py", "text": "v1, v2 = map(int, input().split())\nv3 = 10 ** 9 + 7\nfrom collections import deque\nv4 = list(map(int, input().split()))\nv4.sort()\nv5, v6, v7 = (0, 0, 0)\nfor v8 in range(v1):\n    if v4[v8] < 0:\n        v5 += 1\n    elif v4[v8] == 0:\n        v6 += 1\n    else:\n        v7 += 1\nv9 = deque(v4)\nv10 = False\nv11 = v7 - v2\nif v11 >= 0:\n    v10 = True\nelif -v11 <= v5 and (-v11 % 2 == 0 or v11 > 0):\n    v10 = True\nif v10:\n    v12 = 1\n    v13 = 0\n    while v13 < v2:\n        if v2 - v13 >= 2:\n            v13 += 2\n            if v9[0] * v9[1] >= v9[-1] * v9[-2]:\n                v12 *= v9.popleft()\n                v12 *= v9.popleft()\n                v12 %= v3\n            else:\n                v12 *= v9.pop()\n                v12 *= v9.pop()\n                v12 %= v3\n        else:\n            v12 *= v9.pop()\n            v12 %= v3\n            v13 += 1\n    print(v12)\nelif v6 > 0:\n    print(0)\nelse:\n    v4 = [abs(v4[v8]) for v8 in range(v1)]\n    v4.sort()\n    v12 = 1\n    for v8 in range(v2):\n        v12 *= v4[v8]\n        v12 %= v3\n    v12 = -v12 % v3\n    print(v12)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = 10 ** 9 + 7\nfrom collections import deque\nv4 = list(map(int, input().split()))\nv4.sort()\nv5, v6, v7 = (0, 0, 0)\nfor v8 in range(v1):\n    if v4[v8] < 0:\n        v5 += 1\n    elif v4[v8] == 0:\n        v6 += 1\n    else:\n        v7 += 1\nv9 = deque(v4)\nv10 = False\nv11 = v7 - v2\nif v11 >= 0:\n    v10 = True\nelif -v11 <= v5 and (-v11 % 2 == 0 or v11 > 0):\n    v10 = True\nif v10:\n    v12 = 1\n    v13 = 0\n    while v13 < v2:\n        if v2 - v13 >= 2:\n            v13 += 2\n            if v9[0] * v9[1] >= v9[-1] * v9[-2]:\n                v12 *= v9.popleft()\n                v12 *= v9.popleft()\n                v12 %= v3\n            else:\n                v12 *= v9.pop()\n                v12 *= v9.pop()\n                v12 %= v3\n        else:\n            v12 *= v9.pop()\n            v12 %= v3\n            v13 += 1\n    print(v12)\nelif v6 > 0:\n    print(0)\nelse:\n    v4 = [abs(v4[v8]) for v8 in range(v1)]\n    v4.sort()\n    v12 = 1\n    for v8 in range(v2):\n        v12 *= v4[v8]\n        v12 %= v3\n    v12 = -v12 % v3\n    print(v12)\n"}
{"id": "llm_code\\p03050__s153536257.py", "text": "import math\nfrom itertools import combinations\n\ndef f1(a1):\n    v1 = 2\n    v2 = []\n    while v1 * v1 <= a1:\n        while a1 % v1 == 0:\n            a1 //= v1\n            v2.append(v1)\n        v1 = v1 + 1\n    if a1 > 1:\n        v2.append(a1)\n    return v2\n\ndef f2(a1):\n    v1 = 1\n    for v2 in a1:\n        v1 *= v2\n    return v1\nv1 = int(input())\nv2 = f1(v1)\nv3 = []\nfor v4 in range(len(v2)):\n    v3 += [a for v5 in combinations(v2, v4 + 1)]\nv3 = set(v3)\nv6 = 0\nfor v5 in v3:\n    v7 = f2(v5)\n    if v7 < math.sqrt(v1):\n        continue\n    v8 = v1 // v7\n    v9 = v1 % v7\n    if v8 == v9:\n        v6 += v7\nprint(v6)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import math\nfrom itertools import combinations\n\ndef f1(a1):\n    v1 = 2\n    v2 = []\n    while v1 * v1 <= a1:\n        while a1 % v1 == 0:\n            a1 //= v1\n            v2.append(v1)\n        v1 = v1 + 1\n    if a1 > 1:\n        v2.append(a1)\n    return v2\n\ndef f2(a1):\n    v1 = 1\n    for v2 in a1:\n        v1 *= v2\n    return v1\nv1 = int(input())\nv2 = f1(v1)\nv3 = []\nfor v4 in range(len(v2)):\n    v3 += [a for v5 in combinations(v2, v4 + 1)]\nv3 = set(v3)\nv6 = 0\nfor v5 in v3:\n    v7 = f2(v5)\n    if v7 < math.sqrt(v1):\n        continue\n    v8 = v1 // v7\n    v9 = v1 % v7\n    if v8 == v9:\n        v6 += v7\nprint(v6)\n"}
{"id": "llm_code\\design-hashset__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self):\n        self.capacity = 10007\n        self.buckets = [[] for v1 in range(self.capacity)]\n\n    def add(self, a1: int) -> None:\n        v1 = a1 % self.capacity\n        v2 = self.buckets[v1]\n        if a1 not in v2:\n            v2.append(a1)\n\n    def remove(self, a1: int) -> None:\n        v1 = a1 % self.capacity\n        v2 = self.buckets[v1]\n        for v3 in range(len(v2)):\n            if v2[v3] == a1:\n                del v2[v3]\n                return\n\n    def contains(self, a1: int) -> bool:\n        v1 = a1 % self.capacity\n        v2 = self.buckets[v1]\n        return a1 in v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self):\n        self.capacity = 10007\n        self.buckets = [[] for v1 in range(self.capacity)]\n\n    def add(self, a1: int) -> None:\n        v1 = a1 % self.capacity\n        v2 = self.buckets[v1]\n        if a1 not in v2:\n            v2.append(a1)\n\n    def remove(self, a1: int) -> None:\n        v1 = a1 % self.capacity\n        v2 = self.buckets[v1]\n        for v3 in range(len(v2)):\n            if v2[v3] == a1:\n                del v2[v3]\n                return\n\n    def contains(self, a1: int) -> bool:\n        v1 = a1 % self.capacity\n        v2 = self.buckets[v1]\n        return a1 in v2\n"}
{"id": "llm_code\\palindrome-linked-list__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def isPalindrome(self, a1):\n        if not a1 or not a1.next:\n            return True\n        v1 = a1\n        v2 = a1\n        while v2.next and v2.next.next:\n            v1 = v1.next\n            v2 = v2.next.next\n        v3 = None\n        v4 = v1.next\n        while v4:\n            v5 = v4.next\n            v4.next = v3\n            v3 = v4\n            v4 = v5\n        v6 = a1\n        v7 = v3\n        while v7:\n            if v6.val != v7.val:\n                return False\n            v6 = v6.next\n            v7 = v7.next\n        return True\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def isPalindrome(self, a1):\n        if not a1 or not a1.next:\n            return True\n        v1 = a1\n        v2 = a1\n        while v2.next and v2.next.next:\n            v1 = v1.next\n            v2 = v2.next.next\n        v3 = None\n        v4 = v1.next\n        while v4:\n            v5 = v4.next\n            v4.next = v3\n            v3 = v4\n            v4 = v5\n        v6 = a1\n        v7 = v3\n        while v7:\n            if v6.val != v7.val:\n                return False\n            v6 = v6.next\n            v7 = v7.next\n        return True\n"}
{"id": "human_code\\mean-of-array-after-removing-some-elements.py", "text": "import random\n\nclass C1(object):\n\n    def trimMean(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 20\n\n        def nth_element(a1, a2, a3=0, a4=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1 = len(a1) - 1\n            while a3 <= v1:\n                v2 = random.randint(a3, v1)\n                v3, v4 = tri_partition(a1, a3, v1, a1[v2], a4)\n                if v3 <= a2 <= v4:\n                    return\n                elif v3 > a2:\n                    v1 = v3 - 1\n                else:\n                    a3 = v4 + 1\n        v2 = len(a1) // v1\n        nth_element(a1, v2 - 1)\n        nth_element(a1, len(a1) - v2, left=v2)\n        return float(sum((a1[i] for v3 in range(v2, len(a1) - v2)))) / (len(a1) - 2 * v2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def trimMean(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 20\n\n        def nth_element(a1, a2, a3=0, a4=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1 = len(a1) - 1\n            while a3 <= v1:\n                v2 = random.randint(a3, v1)\n                v3, v4 = tri_partition(a1, a3, v1, a1[v2], a4)\n                if v3 <= a2 <= v4:\n                    return\n                elif v3 > a2:\n                    v1 = v3 - 1\n                else:\n                    a3 = v4 + 1\n        v2 = len(a1) // v1\n        nth_element(a1, v2 - 1)\n        nth_element(a1, len(a1) - v2, left=v2)\n        return float(sum((a1[i] for v3 in range(v2, len(a1) - v2)))) / (len(a1) - 2 * v2)\n"}
{"id": "human_code\\p02834__s854767798.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = 0\nv2 -= 1\nv3 -= 1\nv5 = [[] for v6 in range(v1)]\nv7 = float('inf')\nv8 = [v7] * v1\nfor v9 in range(v1 - 1):\n    v10, v11 = map(int, input().split())\n    v10 -= 1\n    v11 -= 1\n    v5[v10].append(v11)\n    v5[v11].append(v10)\nv12 = v5[v3]\nv8[v3] = 0\nv13 = 1\nv14 = {v3}\nwhile v12:\n    v15 = []\n    for v9 in v12:\n        v14.add(v9)\n        for v16 in v5[v9]:\n            if v16 not in v14:\n                v15.append(v16)\n        v8[v9] = v13\n    v13 += 1\n    v12 = v15\nv12 = v5[v2]\nv17 = [-1] * v1\nv17[v2] = 0\nv13 = 1\nv14 = {v2}\nv18 = -1\nwhile v12:\n    v15 = []\n    for v9 in v12:\n        v14.add(v9)\n        for v16 in v5[v9]:\n            if v8[v16] <= v13 + 1:\n                if v8[v16] == v13 + 1:\n                    v4 = 1\n                if v18 < 0:\n                    v18 = v9\n                continue\n            if v16 not in v14:\n                v15.append(v16)\n        v17[v9] = v13\n    v13 += 1\n    v12 = v15\nv12 = v5[v18]\nv13 = v17[v18] + 1\nv14 = {v18}\nwhile v12:\n    v15 = []\n    for v9 in v12:\n        v14.add(v9)\n        if v17[v9] == -1:\n            continue\n        v17[v9] = max(v13, v17[v9])\n        for v16 in v5[v9]:\n            if v16 not in v14:\n                v15.append(v16)\n    v13 += 1\n    v12 = v15\nv19 = 0\nfor v9 in range(v1):\n    if v8[v9] > v17[v9]:\n        v19 = max(v19, v17[v9])\nprint(v19 + v4)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = 0\nv2 -= 1\nv3 -= 1\nv5 = [[] for v6 in range(v1)]\nv7 = float('inf')\nv8 = [v7] * v1\nfor v9 in range(v1 - 1):\n    v10, v11 = map(int, input().split())\n    v10 -= 1\n    v11 -= 1\n    v5[v10].append(v11)\n    v5[v11].append(v10)\nv12 = v5[v3]\nv8[v3] = 0\nv13 = 1\nv14 = {v3}\nwhile v12:\n    v15 = []\n    for v9 in v12:\n        v14.add(v9)\n        for v16 in v5[v9]:\n            if v16 not in v14:\n                v15.append(v16)\n        v8[v9] = v13\n    v13 += 1\n    v12 = v15\nv12 = v5[v2]\nv17 = [-1] * v1\nv17[v2] = 0\nv13 = 1\nv14 = {v2}\nv18 = -1\nwhile v12:\n    v15 = []\n    for v9 in v12:\n        v14.add(v9)\n        for v16 in v5[v9]:\n            if v8[v16] <= v13 + 1:\n                if v8[v16] == v13 + 1:\n                    v4 = 1\n                if v18 < 0:\n                    v18 = v9\n                continue\n            if v16 not in v14:\n                v15.append(v16)\n        v17[v9] = v13\n    v13 += 1\n    v12 = v15\nv12 = v5[v18]\nv13 = v17[v18] + 1\nv14 = {v18}\nwhile v12:\n    v15 = []\n    for v9 in v12:\n        v14.add(v9)\n        if v17[v9] == -1:\n            continue\n        v17[v9] = max(v13, v17[v9])\n        for v16 in v5[v9]:\n            if v16 not in v14:\n                v15.append(v16)\n    v13 += 1\n    v12 = v15\nv19 = 0\nfor v9 in range(v1):\n    if v8[v9] > v17[v9]:\n        v19 = max(v19, v17[v9])\nprint(v19 + v4)\n"}
{"id": "human_code\\p02900__s491210311.py", "text": "import math\nimport os\nimport sys\nif os.getenv('LOCAL'):\n    sys.stdin = open('_in.txt', 'r')\nsys.setrecursionlimit(2147483647)\nv1 = float('inf')\nv2 = 10 ** 18\nv3 = 10 ** 9 + 7\n\ndef f1(a1):\n    \"\"\"\n    n の約数をリストで返す\n    :param int n:\n    :rtype: list of int\n    \"\"\"\n    v1 = []\n    for v2 in range(1, int(math.sqrt(a1)) + 1):\n        if a1 % v2 == 0:\n            v1.append(v2)\n            if a1 // v2 != v2:\n                v1.append(a1 // v2)\n    return v1\n\ndef f2(a1):\n    \"\"\"\n    素因数分解\n    :param int n:\n    :rtype: list of int\n    \"\"\"\n    if a1 <= 1:\n        return []\n    v1 = []\n    while a1 > 2 and a1 % 2 == 0:\n        v1.append(2)\n        a1 //= 2\n    v3 = 3\n    while v3 <= math.sqrt(a1):\n        if a1 % v3 == 0:\n            v1.append(v3)\n            a1 //= v3\n        else:\n            v3 += 2\n    v1.append(a1)\n    return v1\nv4, v5 = list(map(int, sys.stdin.readline().split()))\nv6 = set(f2(v4))\nv7 = set(f2(v5))\nv8 = len(v6 & v7) + 1\nprint(v8)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math\nimport os\nimport sys\nif os.getenv('LOCAL'):\n    sys.stdin = open('_in.txt', 'r')\nsys.setrecursionlimit(2147483647)\nv1 = float('inf')\nv2 = 10 ** 18\nv3 = 10 ** 9 + 7\n\ndef f1(a1):\n    \"\"\"\n    n の約数をリストで返す\n    :param int n:\n    :rtype: list of int\n    \"\"\"\n    v1 = []\n    for v2 in range(1, int(math.sqrt(a1)) + 1):\n        if a1 % v2 == 0:\n            v1.append(v2)\n            if a1 // v2 != v2:\n                v1.append(a1 // v2)\n    return v1\n\ndef f2(a1):\n    \"\"\"\n    素因数分解\n    :param int n:\n    :rtype: list of int\n    \"\"\"\n    if a1 <= 1:\n        return []\n    v1 = []\n    while a1 > 2 and a1 % 2 == 0:\n        v1.append(2)\n        a1 //= 2\n    v3 = 3\n    while v3 <= math.sqrt(a1):\n        if a1 % v3 == 0:\n            v1.append(v3)\n            a1 //= v3\n        else:\n            v3 += 2\n    v1.append(a1)\n    return v1\nv4, v5 = list(map(int, sys.stdin.readline().split()))\nv6 = set(f2(v4))\nv7 = set(f2(v5))\nv8 = len(v6 & v7) + 1\nprint(v8)\n"}
{"id": "llm_code\\basic-calculator__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def calculate(self, a1):\n        v1 = [0]\n\n        def factor():\n            if a1[v1[0]].isdigit():\n                v1 = 0\n                while v1[0] < len(a1) and a1[v1[0]].isdigit():\n                    v1 = v1 * 10 + int(a1[v1[0]])\n                    v1[0] += 1\n                return v1\n            v1[0] += 1\n            v2 = expr()\n            v1[0] += 1\n            return v2\n\n        def term():\n            v1 = factor()\n            while v1[0] < len(a1) and a1[v1[0]] in '*/':\n                v2 = a1[v1[0]]\n                v1[0] += 1\n                v3 = factor()\n                if v2 == '*':\n                    v1 *= v3\n                else:\n                    v1 //= v3\n            return v1\n\n        def expr():\n            v1 = term()\n            while v1[0] < len(a1) and a1[v1[0]] in '+-':\n                v2 = a1[v1[0]]\n                v1[0] += 1\n                v3 = term()\n                if v2 == '+':\n                    v1 += v3\n                else:\n                    v1 -= v3\n            return v1\n        return expr()\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def calculate(self, a1):\n        v1 = [0]\n\n        def factor():\n            if a1[v1[0]].isdigit():\n                v1 = 0\n                while v1[0] < len(a1) and a1[v1[0]].isdigit():\n                    v1 = v1 * 10 + int(a1[v1[0]])\n                    v1[0] += 1\n                return v1\n            v1[0] += 1\n            v2 = expr()\n            v1[0] += 1\n            return v2\n\n        def term():\n            v1 = factor()\n            while v1[0] < len(a1) and a1[v1[0]] in '*/':\n                v2 = a1[v1[0]]\n                v1[0] += 1\n                v3 = factor()\n                if v2 == '*':\n                    v1 *= v3\n                else:\n                    v1 //= v3\n            return v1\n\n        def expr():\n            v1 = term()\n            while v1[0] < len(a1) and a1[v1[0]] in '+-':\n                v2 = a1[v1[0]]\n                v1[0] += 1\n                v3 = term()\n                if v2 == '+':\n                    v1 += v3\n                else:\n                    v1 -= v3\n            return v1\n        return expr()\n"}
{"id": "human_code\\linked-list-cycle-ii.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\n    def __str__(self):\n        if self:\n            return '{}'.format(self.val)\n        else:\n            return None\n\nclass C2(object):\n\n    def detectCycle(self, a1):\n        v1, v2 = (a1, a1)\n        while v1 and v1.__next__:\n            v1, v2 = (v1.next.__next__, v2.__next__)\n            if v1 is v2:\n                v1 = a1\n                while v1 is not v2:\n                    v1, v2 = (v1.__next__, v2.__next__)\n                return v1\n        return None\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\n    def __str__(self):\n        if self:\n            return '{}'.format(self.val)\n        else:\n            return None\n\nclass C2(object):\n\n    def detectCycle(self, a1):\n        v1, v2 = (a1, a1)\n        while v1 and v1.__next__:\n            v1, v2 = (v1.next.__next__, v2.__next__)\n            if v1 is v2:\n                v1 = a1\n                while v1 is not v2:\n                    v1, v2 = (v1.__next__, v2.__next__)\n                return v1\n        return None\n"}
{"id": "human_code\\split-and-merge-array-transformation__part2.py", "text": "class C1(object):\n\n    def minSplitMerge(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def bfs(a1, a2):\n\n            def adj(a1):\n                for v1 in range(len(a1)):\n                    for v2 in range(v1, len(a1)):\n                        v3 = a1[v1:v2 + 1]\n                        v4 = a1[:v1] + a1[v2 + 1:]\n                        for v5 in range(len(v4) + 1):\n                            if v5 == v1:\n                                continue\n                            yield (v4[:v5] + v3 + v4[v5:])\n            v1 = 0\n            v2 = {a1}\n            v3 = [a1]\n            while v3:\n                v4 = []\n                for v5 in v3:\n                    if v5 == a2:\n                        return v1\n                    for v6 in adj(v5):\n                        if v6 in v2:\n                            continue\n                        v2.add(v6)\n                        v4.append(v6)\n                v3 = v4\n                v1 += 1\n            return -1\n        return bfs(tuple(a1), tuple(a2))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minSplitMerge(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def bfs(a1, a2):\n\n            def adj(a1):\n                for v1 in range(len(a1)):\n                    for v2 in range(v1, len(a1)):\n                        v3 = a1[v1:v2 + 1]\n                        v4 = a1[:v1] + a1[v2 + 1:]\n                        for v5 in range(len(v4) + 1):\n                            if v5 == v1:\n                                continue\n                            yield (v4[:v5] + v3 + v4[v5:])\n            v1 = 0\n            v2 = {a1}\n            v3 = [a1]\n            while v3:\n                v4 = []\n                for v5 in v3:\n                    if v5 == a2:\n                        return v1\n                    for v6 in adj(v5):\n                        if v6 in v2:\n                            continue\n                        v2.add(v6)\n                        v4.append(v6)\n                v3 = v4\n                v1 += 1\n            return -1\n        return bfs(tuple(a1), tuple(a2))\n"}
{"id": "llm_code\\shortest-distance-from-all-buildings__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def shortestDistance(self, a1):\n        if not a1 or not a1[0]:\n            return -1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = sum((1 for v4 in range(v1) for v5 in range(v2) if a1[v4][v5] == 1))\n        v6 = [[0] * v2 for v7 in range(v1)]\n        v8 = [[0] * v2 for v7 in range(v1)]\n\n        def explore(a1, a2):\n            v1 = [[False] * v2 for v7 in range(v1)]\n            v2 = deque([(a1, a2, 0)])\n            v1[a1][a2] = True\n            while v2:\n                v3, v4, v5 = v2.popleft()\n                if a1[v3][v4] == 0:\n                    v6[v3][v4] += v5\n                    v8[v3][v4] += 1\n                for v6, v7 in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    v8, v9 = (v3 + v6, v4 + v7)\n                    if 0 <= v8 < v1 and 0 <= v9 < v2 and (a1[v8][v9] == 0) and (not v1[v8][v9]):\n                        v1[v8][v9] = True\n                        v2.append((v8, v9, v5 + 1))\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] == 1:\n                    explore(v4, v5)\n        v9 = float('inf')\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] == 0 and v8[v4][v5] == v3:\n                    v9 = min(v9, v6[v4][v5])\n        return v9 if v9 != float('inf') else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def shortestDistance(self, a1):\n        if not a1 or not a1[0]:\n            return -1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = sum((1 for v4 in range(v1) for v5 in range(v2) if a1[v4][v5] == 1))\n        v6 = [[0] * v2 for v7 in range(v1)]\n        v8 = [[0] * v2 for v7 in range(v1)]\n\n        def explore(a1, a2):\n            v1 = [[False] * v2 for v7 in range(v1)]\n            v2 = deque([(a1, a2, 0)])\n            v1[a1][a2] = True\n            while v2:\n                v3, v4, v5 = v2.popleft()\n                if a1[v3][v4] == 0:\n                    v6[v3][v4] += v5\n                    v8[v3][v4] += 1\n                for v6, v7 in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    v8, v9 = (v3 + v6, v4 + v7)\n                    if 0 <= v8 < v1 and 0 <= v9 < v2 and (a1[v8][v9] == 0) and (not v1[v8][v9]):\n                        v1[v8][v9] = True\n                        v2.append((v8, v9, v5 + 1))\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] == 1:\n                    explore(v4, v5)\n        v9 = float('inf')\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] == 0 and v8[v4][v5] == v3:\n                    v9 = min(v9, v6[v4][v5])\n        return v9 if v9 != float('inf') else -1\n"}
{"id": "llm_code\\surrounded-regions__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def solve(self, a1):\n        if not a1 or not a1[0]:\n            return\n        v1, v2 = (len(a1), len(a1[0]))\n\n        def dfs(a1, a2):\n            if a1 < 0 or a1 >= v1 or a2 < 0 or (a2 >= v2) or (a1[a1][a2] != 'O'):\n                return\n            a1[a1][a2] = 'T'\n            dfs(a1 + 1, a2)\n            dfs(a1 - 1, a2)\n            dfs(a1, a2 + 1)\n            dfs(a1, a2 - 1)\n        for v3 in range(v1):\n            dfs(v3, 0)\n            dfs(v3, v2 - 1)\n        for v4 in range(v2):\n            dfs(0, v4)\n            dfs(v1 - 1, v4)\n        for v3 in range(v1):\n            for v4 in range(v2):\n                a1[v3][v4] = 'X' if a1[v3][v4] == 'O' else 'O'\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def solve(self, a1):\n        if not a1 or not a1[0]:\n            return\n        v1, v2 = (len(a1), len(a1[0]))\n\n        def dfs(a1, a2):\n            if a1 < 0 or a1 >= v1 or a2 < 0 or (a2 >= v2) or (a1[a1][a2] != 'O'):\n                return\n            a1[a1][a2] = 'T'\n            dfs(a1 + 1, a2)\n            dfs(a1 - 1, a2)\n            dfs(a1, a2 + 1)\n            dfs(a1, a2 - 1)\n        for v3 in range(v1):\n            dfs(v3, 0)\n            dfs(v3, v2 - 1)\n        for v4 in range(v2):\n            dfs(0, v4)\n            dfs(v1 - 1, v4)\n        for v3 in range(v1):\n            for v4 in range(v2):\n                a1[v3][v4] = 'X' if a1[v3][v4] == 'O' else 'O'\n"}
{"id": "llm_code\\find-the-shortest-superstring__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def shortestSuperstring(self, a1):\n        v1 = len(a1)\n        v2 = [[0] * v1 for v3 in range(v1)]\n        for v4 in range(v1):\n            for v5 in range(v1):\n                v6, v7 = (len(a1[v4]), len(a1[v5]))\n                for v8 in range(min(v6, v7), -1, -1):\n                    if a1[v4][-v8:] == a1[v5][:v8]:\n                        v2[v4][v5] = v8\n                        break\n        v9 = 10 ** 9\n        v10 = [[v9] * v1 for v3 in range(1 << v1)]\n        v11 = [[-1] * v1 for v3 in range(1 << v1)]\n        for v4 in range(v1):\n            v12 = 1 << v4\n            v10[v12][v4] = len(a1[v4])\n        for v12 in range(1 << v1):\n            for v13 in range(v1):\n                if v12 & 1 << v13 == 0 or v10[v12][v13] == v9:\n                    continue\n                for v14 in range(v1):\n                    if v12 & 1 << v14:\n                        continue\n                    v15 = v12 | 1 << v14\n                    v16 = len(a1[v14]) - v2[v13][v14]\n                    v17 = v10[v12][v13] + v16\n                    if v17 < v10[v15][v14]:\n                        v10[v15][v14] = v17\n                        v11[v15][v14] = v13\n        v18 = (1 << v1) - 1\n        v19 = v9\n        v20 = -1\n        for v5 in range(v1):\n            if v10[v18][v5] < v19:\n                v19 = v10[v18][v5]\n                v20 = v5\n        v21 = []\n        v22 = v18\n        v23 = v20\n        while v23 != -1:\n            v21.append(v23)\n            v24 = v11[v22][v23]\n            v22 ^= 1 << v23\n            v23 = v24\n        v21.reverse()\n        if not v21:\n            return ''\n        v25 = a1[v21[0]]\n        for v26 in range(1, len(v21)):\n            v27 = v21[v26 - 1]\n            v28 = v2[v27][v21[v26]]\n            v25 += a1[v21[v26]][v28:]\n        return v25\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def shortestSuperstring(self, a1):\n        v1 = len(a1)\n        v2 = [[0] * v1 for v3 in range(v1)]\n        for v4 in range(v1):\n            for v5 in range(v1):\n                v6, v7 = (len(a1[v4]), len(a1[v5]))\n                for v8 in range(min(v6, v7), -1, -1):\n                    if a1[v4][-v8:] == a1[v5][:v8]:\n                        v2[v4][v5] = v8\n                        break\n        v9 = 10 ** 9\n        v10 = [[v9] * v1 for v3 in range(1 << v1)]\n        v11 = [[-1] * v1 for v3 in range(1 << v1)]\n        for v4 in range(v1):\n            v12 = 1 << v4\n            v10[v12][v4] = len(a1[v4])\n        for v12 in range(1 << v1):\n            for v13 in range(v1):\n                if v12 & 1 << v13 == 0 or v10[v12][v13] == v9:\n                    continue\n                for v14 in range(v1):\n                    if v12 & 1 << v14:\n                        continue\n                    v15 = v12 | 1 << v14\n                    v16 = len(a1[v14]) - v2[v13][v14]\n                    v17 = v10[v12][v13] + v16\n                    if v17 < v10[v15][v14]:\n                        v10[v15][v14] = v17\n                        v11[v15][v14] = v13\n        v18 = (1 << v1) - 1\n        v19 = v9\n        v20 = -1\n        for v5 in range(v1):\n            if v10[v18][v5] < v19:\n                v19 = v10[v18][v5]\n                v20 = v5\n        v21 = []\n        v22 = v18\n        v23 = v20\n        while v23 != -1:\n            v21.append(v23)\n            v24 = v11[v22][v23]\n            v22 ^= 1 << v23\n            v23 = v24\n        v21.reverse()\n        if not v21:\n            return ''\n        v25 = a1[v21[0]]\n        for v26 in range(1, len(v21)):\n            v27 = v21[v26 - 1]\n            v28 = v2[v27][v21[v26]]\n            v25 += a1[v21[v26]][v28:]\n        return v25\n"}
{"id": "human_code\\maximal-square__part1.py", "text": "class C1(object):\n\n    def maximalSquare(self, a1):\n        if not a1:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [[0 for v4 in range(v2)] for v5 in range(2)]\n        v6 = 0\n        for v4 in range(v2):\n            if a1[0][v4] == '1':\n                v3[0][v4] = 1\n            v6 = max(v6, v3[0][v4])\n        for v5 in range(1, v1):\n            if a1[v5][0] == '1':\n                v3[v5 % 2][0] = 1\n            else:\n                v3[v5 % 2][0] = 0\n            for v4 in range(1, v2):\n                if a1[v5][v4] == '1':\n                    v3[v5 % 2][v4] = min(v3[v5 % 2][v4 - 1], v3[(v5 - 1) % 2][v4], v3[(v5 - 1) % 2][v4 - 1]) + 1\n                    v6 = max(v6, v3[v5 % 2][v4])\n                else:\n                    v3[v5 % 2][v4] = 0\n        return v6 * v6\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximalSquare(self, a1):\n        if not a1:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [[0 for v4 in range(v2)] for v5 in range(2)]\n        v6 = 0\n        for v4 in range(v2):\n            if a1[0][v4] == '1':\n                v3[0][v4] = 1\n            v6 = max(v6, v3[0][v4])\n        for v5 in range(1, v1):\n            if a1[v5][0] == '1':\n                v3[v5 % 2][0] = 1\n            else:\n                v3[v5 % 2][0] = 0\n            for v4 in range(1, v2):\n                if a1[v5][v4] == '1':\n                    v3[v5 % 2][v4] = min(v3[v5 % 2][v4 - 1], v3[(v5 - 1) % 2][v4], v3[(v5 - 1) % 2][v4 - 1]) + 1\n                    v6 = max(v6, v3[v5 % 2][v4])\n                else:\n                    v3[v5 % 2][v4] = 0\n        return v6 * v6\n"}
{"id": "human_code\\tag-validator.py", "text": "class C1(object):\n\n    def isValid(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def validText(a1, a2):\n            v1 = a2\n            a2 = a1.find('<', a2)\n            return (a2 != v1, a2)\n\n        def validCData(a1, a2):\n            if a1.find('<![CDATA[', a2) != a2:\n                return (False, a2)\n            v1 = a1.find(']]>', a2)\n            if v1 == -1:\n                return (False, a2)\n            return (True, v1 + 3)\n\n        def parseTagName(a1, a2):\n            if a1[a2] != '<':\n                return ('', a2)\n            v1 = a1.find('>', a2)\n            if v1 == -1 or not 1 <= v1 - 1 - a2 <= 9:\n                return ('', a2)\n            v2 = a1[a2 + 1:v1]\n            for v3 in v2:\n                if not ord('A') <= ord(v3) <= ord('Z'):\n                    return ('', a2)\n            return (v2, v1 + 1)\n\n        def parseContent(a1, a2):\n            while a2 < len(a1):\n                v1, a2 = validText(a1, a2)\n                if v1:\n                    continue\n                v1, a2 = validCData(a1, a2)\n                if v1:\n                    continue\n                v1, a2 = validTag(a1, a2)\n                if v1:\n                    continue\n                break\n            return a2\n\n        def validTag(a1, a2):\n            v1, v2 = parseTagName(a1, a2)\n            if not v1:\n                return (False, a2)\n            v2 = parseContent(a1, v2)\n            v3 = v2 + len(v1) + 2\n            if v3 >= len(a1) or a1[v2:v3 + 1] != '</' + v1 + '>':\n                return (False, a2)\n            return (True, v3 + 1)\n        v1, v2 = validTag(a1, 0)\n        return v1 and v2 == len(a1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def isValid(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def validText(a1, a2):\n            v1 = a2\n            a2 = a1.find('<', a2)\n            return (a2 != v1, a2)\n\n        def validCData(a1, a2):\n            if a1.find('<![CDATA[', a2) != a2:\n                return (False, a2)\n            v1 = a1.find(']]>', a2)\n            if v1 == -1:\n                return (False, a2)\n            return (True, v1 + 3)\n\n        def parseTagName(a1, a2):\n            if a1[a2] != '<':\n                return ('', a2)\n            v1 = a1.find('>', a2)\n            if v1 == -1 or not 1 <= v1 - 1 - a2 <= 9:\n                return ('', a2)\n            v2 = a1[a2 + 1:v1]\n            for v3 in v2:\n                if not ord('A') <= ord(v3) <= ord('Z'):\n                    return ('', a2)\n            return (v2, v1 + 1)\n\n        def parseContent(a1, a2):\n            while a2 < len(a1):\n                v1, a2 = validText(a1, a2)\n                if v1:\n                    continue\n                v1, a2 = validCData(a1, a2)\n                if v1:\n                    continue\n                v1, a2 = validTag(a1, a2)\n                if v1:\n                    continue\n                break\n            return a2\n\n        def validTag(a1, a2):\n            v1, v2 = parseTagName(a1, a2)\n            if not v1:\n                return (False, a2)\n            v2 = parseContent(a1, v2)\n            v3 = v2 + len(v1) + 2\n            if v3 >= len(a1) or a1[v2:v3 + 1] != '</' + v1 + '>':\n                return (False, a2)\n            return (True, v3 + 1)\n        v1, v2 = validTag(a1, 0)\n        return v1 and v2 == len(a1)\n"}
{"id": "human_code\\p02936__s190898018.py", "text": "from pprint import pprint\nfrom collections import deque\nimport sys\nv1, v2 = map(int, sys.stdin.readline().strip().split(' '))\nv3 = [[] for v4 in range(v1)]\nfor v4 in range(v1 - 1):\n    v5, v6 = map(int, sys.stdin.readline().strip().split(' '))\n    v3[v5 - 1].append(v6 - 1)\n    v3[v6 - 1].append(v5 - 1)\nv7 = [0] * v1\nv8 = [0] * v1\nfor v4 in range(v2):\n    v9, v10 = map(int, sys.stdin.readline().strip().split(' '))\n    v7[v9 - 1] += v10\nv11 = deque()\nv11.append(0)\nv12 = set()\nwhile v11:\n    v13 = v11.popleft()\n    if v13 in v12:\n        continue\n    v12.add(v13)\n    for v14 in v3[v13]:\n        if v14 in v12:\n            continue\n        v7[v14] += v7[v13]\n        v11.append(v14)\nprint(' '.join(list(map(str, v7))))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from pprint import pprint\nfrom collections import deque\nimport sys\nv1, v2 = map(int, sys.stdin.readline().strip().split(' '))\nv3 = [[] for v4 in range(v1)]\nfor v4 in range(v1 - 1):\n    v5, v6 = map(int, sys.stdin.readline().strip().split(' '))\n    v3[v5 - 1].append(v6 - 1)\n    v3[v6 - 1].append(v5 - 1)\nv7 = [0] * v1\nv8 = [0] * v1\nfor v4 in range(v2):\n    v9, v10 = map(int, sys.stdin.readline().strip().split(' '))\n    v7[v9 - 1] += v10\nv11 = deque()\nv11.append(0)\nv12 = set()\nwhile v11:\n    v13 = v11.popleft()\n    if v13 in v12:\n        continue\n    v12.add(v13)\n    for v14 in v3[v13]:\n        if v14 in v12:\n            continue\n        v7[v14] += v7[v13]\n        v11.append(v14)\nprint(' '.join(list(map(str, v7))))\n"}
{"id": "human_code\\minimum-division-operations-to-make-array-non-decreasing.py", "text": "def f1(a1):\n    v1 = []\n    v2 = [-1] * (a1 + 1)\n    for v3 in range(2, a1 + 1):\n        if v2[v3] == -1:\n            v2[v3] = v3\n            v1.append(v3)\n        for v4 in v1:\n            if v3 * v4 > a1 or v4 > v2[v3]:\n                break\n            v2[v3 * v4] = v4\n    return v2\nv1 = 10 ** 6\nv2 = f1(v1)\n\nclass C1(object):\n\n    def minOperations(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        for v2 in reversed(range(len(a1) - 1)):\n            if a1[v2] <= a1[v2 + 1]:\n                continue\n            if v2[a1[v2]] > a1[v2 + 1]:\n                return -1\n            a1[v2] = v2[a1[v2]]\n            v1 += 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "def f1(a1):\n    v1 = []\n    v2 = [-1] * (a1 + 1)\n    for v3 in range(2, a1 + 1):\n        if v2[v3] == -1:\n            v2[v3] = v3\n            v1.append(v3)\n        for v4 in v1:\n            if v3 * v4 > a1 or v4 > v2[v3]:\n                break\n            v2[v3 * v4] = v4\n    return v2\nv1 = 10 ** 6\nv2 = f1(v1)\n\nclass C1(object):\n\n    def minOperations(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        for v2 in reversed(range(len(a1) - 1)):\n            if a1[v2] <= a1[v2 + 1]:\n                continue\n            if v2[a1[v2]] > a1[v2 + 1]:\n                return -1\n            a1[v2] = v2[a1[v2]]\n            v1 += 1\n        return v1\n"}
{"id": "human_code\\p03385__s770107983.py", "text": "import functools\nimport os\nv1 = float('inf')\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return float(input())\n\ndef f3():\n    return input()\n\ndef f4():\n    return list(map(int, input().split()))\n\ndef f5():\n    return list(map(float, input().split()))\n\ndef f6():\n    return input().split()\n\ndef f7(a1):\n    if not os.getenv('LOCAL'):\n        return a1\n\n    @functools.wraps(a1)\n    def wrapper(*a1, **a2):\n        print('DEBUG: {}({}) -> '.format(a1.__name__, ', '.join(list(map(str, a1)) + ['{}={}'.format(k, str(v)) for v1, v2 in a2.items()])), end='')\n        v3 = a1(*a1, **a2)\n        print(v3)\n        return v3\n    return wrapper\nv2 = list(input())\nv2.sort()\nif v2 == list('abc'):\n    print('Yes')\nelse:\n    print('No')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import functools\nimport os\nv1 = float('inf')\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return float(input())\n\ndef f3():\n    return input()\n\ndef f4():\n    return list(map(int, input().split()))\n\ndef f5():\n    return list(map(float, input().split()))\n\ndef f6():\n    return input().split()\n\ndef f7(a1):\n    if not os.getenv('LOCAL'):\n        return a1\n\n    @functools.wraps(a1)\n    def wrapper(*a1, **a2):\n        print('DEBUG: {}({}) -> '.format(a1.__name__, ', '.join(list(map(str, a1)) + ['{}={}'.format(k, str(v)) for v1, v2 in a2.items()])), end='')\n        v3 = a1(*a1, **a2)\n        print(v3)\n        return v3\n    return wrapper\nv2 = list(input())\nv2.sort()\nif v2 == list('abc'):\n    print('Yes')\nelse:\n    print('No')\n"}
{"id": "llm_code\\p03379__unrelated.py", "text": "import heapq\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = []\nv4 = []\nv5 = []\nfor v6 in range(v1):\n    if not v3 or v2[v6] < -heapq.heappop(v3):\n        heapq.heappush(v3, -v2[v6])\n    else:\n        heapq.heappush(v4, v2[v6])\n    if len(v3) > len(v4) + 1:\n        heapq.heappush(v4, -heapq.heappop(v3))\n    elif len(v4) > len(v3):\n        heapq.heappush(v3, -heapq.heappop(v4))\n    if v6 >= v1 // 2:\n        v5.append(-v3[0])\nfor v6 in range(v1 // 2):\n    v5.append(v5[v6])\nfor v7 in v5:\n    print(v7)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import heapq\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = []\nv4 = []\nv5 = []\nfor v6 in range(v1):\n    if not v3 or v2[v6] < -heapq.heappop(v3):\n        heapq.heappush(v3, -v2[v6])\n    else:\n        heapq.heappush(v4, v2[v6])\n    if len(v3) > len(v4) + 1:\n        heapq.heappush(v4, -heapq.heappop(v3))\n    elif len(v4) > len(v3):\n        heapq.heappush(v3, -heapq.heappop(v4))\n    if v6 >= v1 // 2:\n        v5.append(-v3[0])\nfor v6 in range(v1 // 2):\n    v5.append(v5[v6])\nfor v7 in v5:\n    print(v7)\n"}
{"id": "human_code\\p03311__s902318239.py", "text": "import sys\n\ndef f1(a1, a2):\n    v1 = 0\n    for v2, v3 in enumerate(a1):\n        v1 += abs(v3 - (a2 + (v2 + 1)))\n    return v1\n\ndef f2(a1, a2):\n    v1 = []\n    for v2, v3 in enumerate(a2):\n        v1.append(v3 - (v2 + 1))\n    return f1(a2, sorted(v1)[a1 // 2])\n\ndef f3():\n\n    def iterate_tokens():\n        for v1 in sys.stdin:\n            for v2 in v1.split():\n                yield v2\n    v1 = iterate_tokens()\n    v2 = int(next(v1))\n    v3 = [int(next(v1)) for v4 in range(v2)]\n    print(f2(v2, v3))\nif __name__ == '__main__':\n    f3()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\n\ndef f1(a1, a2):\n    v1 = 0\n    for v2, v3 in enumerate(a1):\n        v1 += abs(v3 - (a2 + (v2 + 1)))\n    return v1\n\ndef f2(a1, a2):\n    v1 = []\n    for v2, v3 in enumerate(a2):\n        v1.append(v3 - (v2 + 1))\n    return f1(a2, sorted(v1)[a1 // 2])\n\ndef f3():\n\n    def iterate_tokens():\n        for v1 in sys.stdin:\n            for v2 in v1.split():\n                yield v2\n    v1 = iterate_tokens()\n    v2 = int(next(v1))\n    v3 = [int(next(v1)) for v4 in range(v2)]\n    print(f2(v2, v3))\nif __name__ == '__main__':\n    f3()\n"}
{"id": "human_code\\p02683__s650696207.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = [[0] * v2 for v5 in range(v1)]\nv6 = [0] * v1\nv7 = 10 ** 10\nfor v8 in range(v1):\n    v9 = list(map(int, input().split()))\n    v6[v8] = v9[0]\n    v4[v8] = v9[1:]\nimport itertools\nfor v10 in itertools.product([0, 1], repeat=v1):\n    v9 = [0] * v2\n    v11 = 0\n    for v8 in range(v1):\n        if v10[v8] == 1:\n            for v12 in range(len(v4[v8])):\n                v9[v12] += v4[v8][v12]\n            v11 += v6[v8]\n    v13 = False\n    for v8 in range(len(v9)):\n        if v9[v8] < v3:\n            v13 = True\n    if v13:\n        pass\n    else:\n        v7 = min(v7, v11)\nif v7 != 10 ** 10:\n    print(v7)\nelse:\n    print(-1)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = [[0] * v2 for v5 in range(v1)]\nv6 = [0] * v1\nv7 = 10 ** 10\nfor v8 in range(v1):\n    v9 = list(map(int, input().split()))\n    v6[v8] = v9[0]\n    v4[v8] = v9[1:]\nimport itertools\nfor v10 in itertools.product([0, 1], repeat=v1):\n    v9 = [0] * v2\n    v11 = 0\n    for v8 in range(v1):\n        if v10[v8] == 1:\n            for v12 in range(len(v4[v8])):\n                v9[v12] += v4[v8][v12]\n            v11 += v6[v8]\n    v13 = False\n    for v8 in range(len(v9)):\n        if v9[v8] < v3:\n            v13 = True\n    if v13:\n        pass\n    else:\n        v7 = min(v7, v11)\nif v7 != 10 ** 10:\n    print(v7)\nelse:\n    print(-1)\n"}
{"id": "human_code\\total-characters-in-string-after-transformations-i__part3.py", "text": "import itertools\nfrom functools import reduce\n\nclass C1(object):\n\n    def lengthAfterTransformations(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def matrix_mult(a1, a2):\n            v1 = list(zip(*a2))\n            return [[sum((a * b % v1 for v2, v3 in zip(row, col))) % v1 for v4 in v1] for v5 in a1]\n\n        def matrix_expo(a1, a2):\n            v1 = [[int(i == j) for v2 in range(len(a1))] for v3 in range(len(a1))]\n            while a2:\n                if a2 % 2:\n                    v1 = matrix_mult(v1, a1)\n                a1 = matrix_mult(a1, a1)\n                a2 /= 2\n            return v1\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = [1] * 26\n        v4[-1] = 2\n        v5 = [[0] * 26 for v6 in range(26)]\n        for v7 in range(len(v4)):\n            for v8 in range(1, v4[v7] + 1):\n                v5[v7][(v7 + v8) % 26] = 1\n        v9 = matrix_expo(v5, a2)\n        return reduce(lambda accu, x: (accu + v3) % v1, matrix_mult([v2], v9)[0], 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\nfrom functools import reduce\n\nclass C1(object):\n\n    def lengthAfterTransformations(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def matrix_mult(a1, a2):\n            v1 = list(zip(*a2))\n            return [[sum((a * b % v1 for v2, v3 in zip(row, col))) % v1 for v4 in v1] for v5 in a1]\n\n        def matrix_expo(a1, a2):\n            v1 = [[int(i == j) for v2 in range(len(a1))] for v3 in range(len(a1))]\n            while a2:\n                if a2 % 2:\n                    v1 = matrix_mult(v1, a1)\n                a1 = matrix_mult(a1, a1)\n                a2 /= 2\n            return v1\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = [1] * 26\n        v4[-1] = 2\n        v5 = [[0] * 26 for v6 in range(26)]\n        for v7 in range(len(v4)):\n            for v8 in range(1, v4[v7] + 1):\n                v5[v7][(v7 + v8) % 26] = 1\n        v9 = matrix_expo(v5, a2)\n        return reduce(lambda accu, x: (accu + v3) % v1, matrix_mult([v2], v9)[0], 0)\n"}
{"id": "human_code\\minimum-number-of-operations-to-sort-a-binary-tree-by-level.py", "text": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        pass\n\nclass C2(object):\n\n    def minimumOperations(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = [a1]\n        while v2:\n            v3 = []\n            for v4 in v2:\n                if v4.left:\n                    v3.append(v4.left)\n                if v4.right:\n                    v3.append(v4.right)\n            v5 = list(range(len(v2)))\n            v5.sort(key=lambda x: v2[x].val)\n            for v6 in range(len(v2)):\n                while v5[v6] != v6:\n                    v5[v5[v6]], v5[v6] = (v5[v6], v5[v5[v6]])\n                    v1 += 1\n            v2 = v3\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        pass\n\nclass C2(object):\n\n    def minimumOperations(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = [a1]\n        while v2:\n            v3 = []\n            for v4 in v2:\n                if v4.left:\n                    v3.append(v4.left)\n                if v4.right:\n                    v3.append(v4.right)\n            v5 = list(range(len(v2)))\n            v5.sort(key=lambda x: v2[x].val)\n            for v6 in range(len(v2)):\n                while v5[v6] != v6:\n                    v5[v5[v6]], v5[v6] = (v5[v6], v5[v5[v6]])\n                    v1 += 1\n            v2 = v3\n        return v1\n"}
{"id": "human_code\\k-th-largest-perfect-subtree-size-in-binary-tree__part2.py", "text": "import random\n\nclass C1(object):\n\n    def kthLargestPerfectSubtree(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3, a4, a5=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4):\n                v1 = a2\n                while v1 <= a3:\n                    if a5(a1[v1], a4):\n                        a1[v1], a1[a2] = (a1[a2], a1[v1])\n                        a2 += 1\n                        v1 += 1\n                    elif a5(a4, a1[v1]):\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                    else:\n                        v1 += 1\n                return (a2, a3)\n            while a2 <= a4:\n                v1 = random.randint(a2, a4)\n                v2, v3 = tri_partition(a1, a2, a4, a1[v1])\n                if v2 <= a3 <= v3:\n                    return\n                elif v2 > a3:\n                    a4 = v2 - 1\n                else:\n                    a2 = v3 + 1\n\n        def dfs(a1):\n            if not a1:\n                result.append(0)\n                return\n            dfs(a1.left)\n            v1 = result[-1]\n            dfs(a1.right)\n            v2 = result[-1]\n            result.append(v1 + v2 + 1 if v1 == v2 != -1 else -1)\n        v1 = []\n        dfs(a1)\n        nth_element(v1, 0, a2 - 1, len(v1) - 1, lambda a, b: a > b)\n        return v1[a2 - 1] if a2 - 1 < len(v1) and v1[a2 - 1] > 0 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def kthLargestPerfectSubtree(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3, a4, a5=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4):\n                v1 = a2\n                while v1 <= a3:\n                    if a5(a1[v1], a4):\n                        a1[v1], a1[a2] = (a1[a2], a1[v1])\n                        a2 += 1\n                        v1 += 1\n                    elif a5(a4, a1[v1]):\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                    else:\n                        v1 += 1\n                return (a2, a3)\n            while a2 <= a4:\n                v1 = random.randint(a2, a4)\n                v2, v3 = tri_partition(a1, a2, a4, a1[v1])\n                if v2 <= a3 <= v3:\n                    return\n                elif v2 > a3:\n                    a4 = v2 - 1\n                else:\n                    a2 = v3 + 1\n\n        def dfs(a1):\n            if not a1:\n                result.append(0)\n                return\n            dfs(a1.left)\n            v1 = result[-1]\n            dfs(a1.right)\n            v2 = result[-1]\n            result.append(v1 + v2 + 1 if v1 == v2 != -1 else -1)\n        v1 = []\n        dfs(a1)\n        nth_element(v1, 0, a2 - 1, len(v1) - 1, lambda a, b: a > b)\n        return v1[a2 - 1] if a2 - 1 < len(v1) and v1[a2 - 1] > 0 else -1\n"}
{"id": "human_code\\p02686__s033856324.py", "text": "import sys\nv1 = int(input())\nv2 = []\nv3 = []\nfor v4 in range(v1):\n    v5 = input()\n    v6 = 0\n    v7 = 0\n    v8 = 0\n    for v9 in range(len(v5)):\n        if v5[v9] == '(':\n            v8 += 1\n        else:\n            v8 -= 1\n        v7 = min(v8, v7)\n    v6 = v8\n    if v6 >= 0:\n        v2.append([v6, v7])\n    else:\n        v3.append([v6, v7])\nv10 = 0\nv2 = sorted(v2, key=lambda t: t[1])\nv2.reverse()\nv3 = sorted(v3, key=lambda t: t[0] - t[1])\nv3.reverse()\nfor v4 in v2:\n    if v10 + v4[1] < 0:\n        print('No')\n        sys.exit()\n    v10 += v4[0]\nfor v4 in v3:\n    if v10 + v4[1] < 0:\n        print('No')\n        sys.exit()\n    v10 += v4[0]\nif v10 == 0:\n    print('Yes')\nelse:\n    print('No')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1 = int(input())\nv2 = []\nv3 = []\nfor v4 in range(v1):\n    v5 = input()\n    v6 = 0\n    v7 = 0\n    v8 = 0\n    for v9 in range(len(v5)):\n        if v5[v9] == '(':\n            v8 += 1\n        else:\n            v8 -= 1\n        v7 = min(v8, v7)\n    v6 = v8\n    if v6 >= 0:\n        v2.append([v6, v7])\n    else:\n        v3.append([v6, v7])\nv10 = 0\nv2 = sorted(v2, key=lambda t: t[1])\nv2.reverse()\nv3 = sorted(v3, key=lambda t: t[0] - t[1])\nv3.reverse()\nfor v4 in v2:\n    if v10 + v4[1] < 0:\n        print('No')\n        sys.exit()\n    v10 += v4[0]\nfor v4 in v3:\n    if v10 + v4[1] < 0:\n        print('No')\n        sys.exit()\n    v10 += v4[0]\nif v10 == 0:\n    print('Yes')\nelse:\n    print('No')\n"}
{"id": "llm_code\\p03762__s653054719.py", "text": "v1, v2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = list(map(int, input().split()))\nv5 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    return (a1 + a2) % v5\n\ndef f2(a1, a2):\n    return a1 * a2 % v5\n\ndef f3(a1, a2):\n    v1 = 0\n    for v2 in range(a2):\n        v1 = f1(v1, f2(f2(a1[v2], a2 - v2), v2 + 1))\n    return v1\n\ndef f4(a1, a2):\n    v1 = [0] * (a2 - 1)\n    for v2 in range(1, a2):\n        v1[v2 - 1] = a1[v2] - a1[v2 - 1]\n    return v1\nv6 = f4(v3, v1)\nv7 = f4(v4, v2)\nprint(f2(f3(v6, v1 - 1), f3(v7, v2 - 1)))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = list(map(int, input().split()))\nv5 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    return (a1 + a2) % v5\n\ndef f2(a1, a2):\n    return a1 * a2 % v5\n\ndef f3(a1, a2):\n    v1 = 0\n    for v2 in range(a2):\n        v1 = f1(v1, f2(f2(a1[v2], a2 - v2), v2 + 1))\n    return v1\n\ndef f4(a1, a2):\n    v1 = [0] * (a2 - 1)\n    for v2 in range(1, a2):\n        v1[v2 - 1] = a1[v2] - a1[v2 - 1]\n    return v1\nv6 = f4(v3, v1)\nv7 = f4(v4, v2)\nprint(f2(f3(v6, v1 - 1), f3(v7, v2 - 1)))\n"}
{"id": "human_code\\minimize-malware-spread.py", "text": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[min(v1, v2)] = max(v1, v2)\n        return True\n\nclass C2(object):\n\n    def minMalwareSpread(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = C1(len(a1))\n        for v2 in range(len(a1)):\n            for v3 in range(v2 + 1, len(a1)):\n                if a1[v2][v3] == 1:\n                    v1.union_set(v2, v3)\n        v4 = collections.Counter((v1.find_set(v2) for v2 in range(len(a1))))\n        v5 = collections.Counter((v1.find_set(v2) for v2 in a2))\n        return min(a2, key=lambda x: [v5[v1.find_set(x)] > 1, -v4[v1.find_set(x)], x])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[min(v1, v2)] = max(v1, v2)\n        return True\n\nclass C2(object):\n\n    def minMalwareSpread(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = C1(len(a1))\n        for v2 in range(len(a1)):\n            for v3 in range(v2 + 1, len(a1)):\n                if a1[v2][v3] == 1:\n                    v1.union_set(v2, v3)\n        v4 = collections.Counter((v1.find_set(v2) for v2 in range(len(a1))))\n        v5 = collections.Counter((v1.find_set(v2) for v2 in a2))\n        return min(a2, key=lambda x: [v5[v1.find_set(x)] > 1, -v4[v1.find_set(x)], x])\n"}
{"id": "llm_code\\sort-items-by-groups-respecting-dependencies__grok-4.1-fast__v1.py", "text": "from collections import defaultdict, deque\n\nclass C1:\n\n    def sortItems(self, a1, a2, a3, a4):\n        v1 = a3[:]\n        v2 = a2\n        for v3 in range(a1):\n            if v1[v3] == -1:\n                v1[v3] = v2\n                v2 += 1\n        v4 = [[] for v5 in range(v2)]\n        for v3 in range(a1):\n            v4[v1[v3]].append(v3)\n        v6 = defaultdict(set)\n        v7 = defaultdict(int)\n        v8 = [defaultdict(set) for v5 in range(v2)]\n        v9 = [defaultdict(int) for v5 in range(v2)]\n        for v3 in range(a1):\n            v10 = v1[v3]\n            for v11 in a4[v3]:\n                v12 = v1[v11]\n                if v10 == v12:\n                    if v3 not in v8[v10][v11]:\n                        v8[v10][v11].add(v3)\n                        v9[v10][v3] += 1\n                elif v10 not in v6[v12]:\n                    v6[v12].add(v10)\n                    v7[v10] += 1\n\n        def kahn(a1, a2, a3):\n            v1 = deque((nd for v2 in a3 if a2[v2] == 0))\n            v3 = []\n            while v1:\n                v2 = v1.popleft()\n                v3.append(v2)\n                for v4 in a1[v2]:\n                    a2[v4] -= 1\n                    if a2[v4] == 0:\n                        v1.append(v4)\n            return v3 if len(v3) == len(a3) else None\n        v13 = list(range(v2))\n        v14 = kahn(v6, v7, v13)\n        if v14 is None:\n            return []\n        v15 = []\n        for v16 in v14:\n            v17 = v4[v16]\n            v18 = kahn(v8[v16], v9[v16], v17)\n            if v18 is None:\n                return []\n            v15.extend(v18)\n        return v15\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import defaultdict, deque\n\nclass C1:\n\n    def sortItems(self, a1, a2, a3, a4):\n        v1 = a3[:]\n        v2 = a2\n        for v3 in range(a1):\n            if v1[v3] == -1:\n                v1[v3] = v2\n                v2 += 1\n        v4 = [[] for v5 in range(v2)]\n        for v3 in range(a1):\n            v4[v1[v3]].append(v3)\n        v6 = defaultdict(set)\n        v7 = defaultdict(int)\n        v8 = [defaultdict(set) for v5 in range(v2)]\n        v9 = [defaultdict(int) for v5 in range(v2)]\n        for v3 in range(a1):\n            v10 = v1[v3]\n            for v11 in a4[v3]:\n                v12 = v1[v11]\n                if v10 == v12:\n                    if v3 not in v8[v10][v11]:\n                        v8[v10][v11].add(v3)\n                        v9[v10][v3] += 1\n                elif v10 not in v6[v12]:\n                    v6[v12].add(v10)\n                    v7[v10] += 1\n\n        def kahn(a1, a2, a3):\n            v1 = deque((nd for v2 in a3 if a2[v2] == 0))\n            v3 = []\n            while v1:\n                v2 = v1.popleft()\n                v3.append(v2)\n                for v4 in a1[v2]:\n                    a2[v4] -= 1\n                    if a2[v4] == 0:\n                        v1.append(v4)\n            return v3 if len(v3) == len(a3) else None\n        v13 = list(range(v2))\n        v14 = kahn(v6, v7, v13)\n        if v14 is None:\n            return []\n        v15 = []\n        for v16 in v14:\n            v17 = v4[v16]\n            v18 = kahn(v8[v16], v9[v16], v17)\n            if v18 is None:\n                return []\n            v15.extend(v18)\n        return v15\n"}
{"id": "llm_code\\maximum-score-after-applying-operations-on-a-tree__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def maximumScoreAfterOperations(self, a1, a2):\n        v1 = len(a2)\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5 in a1:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = [[] for v3 in range(v1)]\n        v7 = [False] * v1\n        v8 = deque([0])\n        v7[0] = True\n        while v8:\n            v9 = v8.popleft()\n            for v10 in v2[v9]:\n                if not v7[v10]:\n                    v7[v10] = True\n                    v6[v9].append(v10)\n                    v8.append(v10)\n        v11 = sum(a2)\n\n        def get_dp(a1):\n            if not v6[a1]:\n                return a2[a1]\n            v1 = sum((get_dp(c) for v2 in v6[a1]))\n            return min(v1, a2[a1])\n        return v11 - get_dp(0)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def maximumScoreAfterOperations(self, a1, a2):\n        v1 = len(a2)\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5 in a1:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = [[] for v3 in range(v1)]\n        v7 = [False] * v1\n        v8 = deque([0])\n        v7[0] = True\n        while v8:\n            v9 = v8.popleft()\n            for v10 in v2[v9]:\n                if not v7[v10]:\n                    v7[v10] = True\n                    v6[v9].append(v10)\n                    v8.append(v10)\n        v11 = sum(a2)\n\n        def get_dp(a1):\n            if not v6[a1]:\n                return a2[a1]\n            v1 = sum((get_dp(c) for v2 in v6[a1]))\n            return min(v1, a2[a1])\n        return v11 - get_dp(0)\n"}
{"id": "llm_code\\find-a-peak-element-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def findPeakGrid(self, a1):\n        v1 = len(a1)\n        v2 = len(a1[0])\n        if v1 > v2:\n            v3 = 0\n            v4 = v1 - 1\n            while v3 < v4:\n                v5 = (v3 + v4) // 2\n                if max(a1[v5]) > max(a1[v5 + 1]):\n                    v4 = v5\n                else:\n                    v3 = v5 + 1\n            v6 = v3\n            v7 = a1[v6][0]\n            v8 = 0\n            for v9 in range(1, v2):\n                if a1[v6][v9] > v7:\n                    v7 = a1[v6][v9]\n                    v8 = v9\n            return [v6, v8]\n        else:\n\n            def colmax(a1):\n                v1 = a1[0][a1]\n                for v2 in range(1, v1):\n                    if a1[v2][a1] > v1:\n                        v1 = a1[v2][a1]\n                return v1\n            v3 = 0\n            v4 = v2 - 1\n            while v3 < v4:\n                v5 = (v3 + v4) // 2\n                if colmax(v5) > colmax(v5 + 1):\n                    v4 = v5\n                else:\n                    v3 = v5 + 1\n            v8 = v3\n            v7 = a1[0][v8]\n            v6 = 0\n            for v10 in range(1, v1):\n                if a1[v10][v8] > v7:\n                    v7 = a1[v10][v8]\n                    v6 = v10\n            return [v6, v8]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def findPeakGrid(self, a1):\n        v1 = len(a1)\n        v2 = len(a1[0])\n        if v1 > v2:\n            v3 = 0\n            v4 = v1 - 1\n            while v3 < v4:\n                v5 = (v3 + v4) // 2\n                if max(a1[v5]) > max(a1[v5 + 1]):\n                    v4 = v5\n                else:\n                    v3 = v5 + 1\n            v6 = v3\n            v7 = a1[v6][0]\n            v8 = 0\n            for v9 in range(1, v2):\n                if a1[v6][v9] > v7:\n                    v7 = a1[v6][v9]\n                    v8 = v9\n            return [v6, v8]\n        else:\n\n            def colmax(a1):\n                v1 = a1[0][a1]\n                for v2 in range(1, v1):\n                    if a1[v2][a1] > v1:\n                        v1 = a1[v2][a1]\n                return v1\n            v3 = 0\n            v4 = v2 - 1\n            while v3 < v4:\n                v5 = (v3 + v4) // 2\n                if colmax(v5) > colmax(v5 + 1):\n                    v4 = v5\n                else:\n                    v3 = v5 + 1\n            v8 = v3\n            v7 = a1[0][v8]\n            v6 = 0\n            for v10 in range(1, v1):\n                if a1[v10][v8] > v7:\n                    v7 = a1[v10][v8]\n                    v6 = v10\n            return [v6, v8]\n"}
{"id": "human_code\\minimum-moves-to-reach-target-with-rotations.py", "text": "class C1(object):\n\n    def minimumMoves(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = (0, [(0, 0, False)], set())\n        while v2:\n            v4 = []\n            for v5, v6, v7 in v2:\n                if (v5, v6, v7) in v3:\n                    continue\n                if (v5, v6, v7) == (len(a1) - 1, len(a1) - 2, False):\n                    return v1\n                v3.add((v5, v6, v7))\n                if not v7:\n                    if v6 + 2 != len(a1[0]) and a1[v5][v6 + 2] == 0:\n                        v4.append((v5, v6 + 1, v7))\n                    if v5 + 1 != len(a1) and a1[v5 + 1][v6] == 0 and (a1[v5 + 1][v6 + 1] == 0):\n                        v4.append((v5 + 1, v6, v7))\n                        v4.append((v5, v6, not v7))\n                else:\n                    if v5 + 2 != len(a1) and a1[v5 + 2][v6] == 0:\n                        v4.append((v5 + 1, v6, v7))\n                    if v6 + 1 != len(a1) and a1[v5][v6 + 1] == 0 and (a1[v5 + 1][v6 + 1] == 0):\n                        v4.append((v5, v6 + 1, v7))\n                        v4.append((v5, v6, not v7))\n            v2 = v4\n            v1 += 1\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumMoves(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = (0, [(0, 0, False)], set())\n        while v2:\n            v4 = []\n            for v5, v6, v7 in v2:\n                if (v5, v6, v7) in v3:\n                    continue\n                if (v5, v6, v7) == (len(a1) - 1, len(a1) - 2, False):\n                    return v1\n                v3.add((v5, v6, v7))\n                if not v7:\n                    if v6 + 2 != len(a1[0]) and a1[v5][v6 + 2] == 0:\n                        v4.append((v5, v6 + 1, v7))\n                    if v5 + 1 != len(a1) and a1[v5 + 1][v6] == 0 and (a1[v5 + 1][v6 + 1] == 0):\n                        v4.append((v5 + 1, v6, v7))\n                        v4.append((v5, v6, not v7))\n                else:\n                    if v5 + 2 != len(a1) and a1[v5 + 2][v6] == 0:\n                        v4.append((v5 + 1, v6, v7))\n                    if v6 + 1 != len(a1) and a1[v5][v6 + 1] == 0 and (a1[v5 + 1][v6 + 1] == 0):\n                        v4.append((v5, v6 + 1, v7))\n                        v4.append((v5, v6, not v7))\n            v2 = v4\n            v1 += 1\n        return -1\n"}
{"id": "human_code\\minimum-time-for-k-virus-variants-to-spread__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2=lambda x, y: [y] * (2 * x), a3=lambda x, y: y if x is None else max(x, y), a4=lambda x, y: y if x is None else x + y, a5=0):\n        self.N = a1\n        self.H = (a1 - 1).bit_length()\n        self.query_fn = a3\n        self.update_fn = a4\n        self.default_val = a5\n        self.tree = a2(a1, a5)\n        self.lazy = [None] * a1\n\n    def __apply(self, a1, a2):\n        self.tree[a1] = self.update_fn(self.tree[a1], a2)\n        if a1 < self.N:\n            self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n    def update(self, a1, a2, a3):\n\n        def pull(a1):\n            while a1 > 1:\n                a1 //= 2\n                self.tree[a1] = self.query_fn(self.tree[a1 * 2], self.tree[a1 * 2 + 1])\n                if self.lazy[a1] is not None:\n                    self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1])\n        a1 += self.N\n        a2 += self.N\n        v3, v4 = (a1, a2)\n        while a1 <= a2:\n            if a1 & 1:\n                self.__apply(a1, a3)\n                a1 += 1\n            if a2 & 1 == 0:\n                self.__apply(a2, a3)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        pull(v3)\n        pull(v4)\n\n    def query(self, a1, a2):\n\n        def push(a1):\n            v1 = 2 ** self.H\n            while v1 != 1:\n                v2 = a1 // v1\n                if self.lazy[v2] is not None:\n                    self.__apply(v2 * 2, self.lazy[v2])\n                    self.__apply(v2 * 2 + 1, self.lazy[v2])\n                    self.lazy[v2] = None\n                v1 //= 2\n        v1 = None\n        if a1 > a2:\n            return v1\n        a1 += self.N\n        a2 += self.N\n        push(a1)\n        push(a2)\n        while a1 <= a2:\n            if a1 & 1:\n                v1 = self.query_fn(v1, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v1 = self.query_fn(v1, self.tree[a2])\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return v1\n\n    def __str__(self):\n        v1 = []\n        for v2 in range(self.N):\n            v1.append(self.query(v2, v2))\n        return ','.join(map(str, v1))\n\nclass C2(object):\n\n    def minDayskVariants(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def add_rec(a1, a2):\n            v1, v2, v3, v4 = a1\n            a2.append([[v1, +1], [v2, v4]])\n            a2.append([[v3 + 1, -1], [v2, v4]])\n\n        def check(a1, a2, a3):\n            v1 = []\n            v2 = set()\n            for v3, v4 in a1:\n                add_rec([v3 - a3, v4 - a3, v3 + a3, v4 + a3], v1)\n                v2.add(v4 - a3)\n                v2.add(v4 + a3)\n            v1.sort()\n            v5 = {v4: i for v6, v4 in enumerate(sorted(v2))}\n            v7 = C1(len(v5))\n            for [v8, v9], [v10, v11] in v1:\n                v7.update(v5[v10], v5[v11], v9)\n                if v7.query(0, len(v5) - 1) >= a2:\n                    return True\n            return False\n        a1 = [[x + y, x - y] for v2, v3 in a1]\n        v4 = min(a1)[0]\n        v5 = max(a1)[0]\n        v6 = min(a1, key=lambda x: v2[1])[1]\n        v7 = max(a1, key=lambda x: v2[1])[1]\n        v8, v9 = (0, (v5 - v4 + (v7 - v6) + 1) // 2)\n        while v8 <= v9:\n            v10 = v8 + (v9 - v8) // 2\n            if check(a1, a2, v10):\n                v9 = v10 - 1\n            else:\n                v8 = v10 + 1\n        return v8\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2=lambda x, y: [y] * (2 * x), a3=lambda x, y: y if x is None else max(x, y), a4=lambda x, y: y if x is None else x + y, a5=0):\n        self.N = a1\n        self.H = (a1 - 1).bit_length()\n        self.query_fn = a3\n        self.update_fn = a4\n        self.default_val = a5\n        self.tree = a2(a1, a5)\n        self.lazy = [None] * a1\n\n    def __apply(self, a1, a2):\n        self.tree[a1] = self.update_fn(self.tree[a1], a2)\n        if a1 < self.N:\n            self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n    def update(self, a1, a2, a3):\n\n        def pull(a1):\n            while a1 > 1:\n                a1 //= 2\n                self.tree[a1] = self.query_fn(self.tree[a1 * 2], self.tree[a1 * 2 + 1])\n                if self.lazy[a1] is not None:\n                    self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1])\n        a1 += self.N\n        a2 += self.N\n        v3, v4 = (a1, a2)\n        while a1 <= a2:\n            if a1 & 1:\n                self.__apply(a1, a3)\n                a1 += 1\n            if a2 & 1 == 0:\n                self.__apply(a2, a3)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        pull(v3)\n        pull(v4)\n\n    def query(self, a1, a2):\n\n        def push(a1):\n            v1 = 2 ** self.H\n            while v1 != 1:\n                v2 = a1 // v1\n                if self.lazy[v2] is not None:\n                    self.__apply(v2 * 2, self.lazy[v2])\n                    self.__apply(v2 * 2 + 1, self.lazy[v2])\n                    self.lazy[v2] = None\n                v1 //= 2\n        v1 = None\n        if a1 > a2:\n            return v1\n        a1 += self.N\n        a2 += self.N\n        push(a1)\n        push(a2)\n        while a1 <= a2:\n            if a1 & 1:\n                v1 = self.query_fn(v1, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v1 = self.query_fn(v1, self.tree[a2])\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return v1\n\n    def __str__(self):\n        v1 = []\n        for v2 in range(self.N):\n            v1.append(self.query(v2, v2))\n        return ','.join(map(str, v1))\n\nclass C2(object):\n\n    def minDayskVariants(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def add_rec(a1, a2):\n            v1, v2, v3, v4 = a1\n            a2.append([[v1, +1], [v2, v4]])\n            a2.append([[v3 + 1, -1], [v2, v4]])\n\n        def check(a1, a2, a3):\n            v1 = []\n            v2 = set()\n            for v3, v4 in a1:\n                add_rec([v3 - a3, v4 - a3, v3 + a3, v4 + a3], v1)\n                v2.add(v4 - a3)\n                v2.add(v4 + a3)\n            v1.sort()\n            v5 = {v4: i for v6, v4 in enumerate(sorted(v2))}\n            v7 = C1(len(v5))\n            for [v8, v9], [v10, v11] in v1:\n                v7.update(v5[v10], v5[v11], v9)\n                if v7.query(0, len(v5) - 1) >= a2:\n                    return True\n            return False\n        a1 = [[x + y, x - y] for v2, v3 in a1]\n        v4 = min(a1)[0]\n        v5 = max(a1)[0]\n        v6 = min(a1, key=lambda x: v2[1])[1]\n        v7 = max(a1, key=lambda x: v2[1])[1]\n        v8, v9 = (0, (v5 - v4 + (v7 - v6) + 1) // 2)\n        while v8 <= v9:\n            v10 = v8 + (v9 - v8) // 2\n            if check(a1, a2, v10):\n                v9 = v10 - 1\n            else:\n                v8 = v10 + 1\n        return v8\n"}
{"id": "human_code\\soup-servings.py", "text": "class C1(object):\n\n    def soupServings(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dp(a1, a2, a3):\n            if (a1, a2) in a3:\n                return a3[a1, a2]\n            if a1 <= 0 and a2 <= 0:\n                return 0.5\n            if a1 <= 0:\n                return 1.0\n            if a2 <= 0:\n                return 0.0\n            a3[a1, a2] = 0.25 * (dp(a1 - 4, a2, a3) + dp(a1 - 3, a2 - 1, a3) + dp(a1 - 2, a2 - 2, a3) + dp(a1 - 1, a2 - 3, a3))\n            return a3[a1, a2]\n        if a1 >= 4800:\n            return 1.0\n        v1 = {}\n        a1 = (a1 + 24) // 25\n        return dp(a1, a1, v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def soupServings(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dp(a1, a2, a3):\n            if (a1, a2) in a3:\n                return a3[a1, a2]\n            if a1 <= 0 and a2 <= 0:\n                return 0.5\n            if a1 <= 0:\n                return 1.0\n            if a2 <= 0:\n                return 0.0\n            a3[a1, a2] = 0.25 * (dp(a1 - 4, a2, a3) + dp(a1 - 3, a2 - 1, a3) + dp(a1 - 2, a2 - 2, a3) + dp(a1 - 1, a2 - 3, a3))\n            return a3[a1, a2]\n        if a1 >= 4800:\n            return 1.0\n        v1 = {}\n        a1 = (a1 + 24) // 25\n        return dp(a1, a1, v1)\n"}
{"id": "llm_code\\partition-array-for-maximum-xor-and-and__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maximizeXorAndXor(self, a1):\n        v1 = len(a1)\n        v2 = 1 << v1\n        v3 = (1 << 32) - 1\n        v4 = [0] * v2\n        v5 = [0] * v2\n        v4[0] = v3\n        v5[0] = 0\n        for v6 in range(1, v2):\n            v7 = 0\n            v8 = v6\n            while v8 & 1 == 0:\n                v7 += 1\n                v8 >>= 1\n            v9 = v6 ^ 1 << v7\n            v4[v6] = v4[v9] & a1[v7]\n            v5[v6] = v5[v9] ^ a1[v7]\n        v10 = 0\n        v11 = v2 - 1\n\n        def highest_subset_xor(a1):\n            if not a1:\n                return 0\n            v1 = max((item.bit_length() for v2 in a1))\n            v3 = [0] * (v1 + 1)\n            for v4 in a1:\n                v5 = v4\n                for v6 in range(v1, -1, -1):\n                    if v5 & 1 << v6 == 0:\n                        continue\n                    if v3[v6]:\n                        v5 ^= v3[v6]\n                    else:\n                        v3[v6] = v5\n                        break\n            v7 = 0\n            for v6 in range(v1, -1, -1):\n                if v3[v6] and v7 ^ v3[v6] > v7:\n                    v7 ^= v3[v6]\n            return v7\n        for v12 in range(1, v2):\n            v13 = v4[v12]\n            v14 = v11 ^ v12\n            v15 = v5[v14]\n            v16 = [a1[k] & ~v15 for v17 in range(v1) if v12 & 1 << v17 == 0]\n            v18 = highest_subset_xor(v16)\n            v19 = v13 + v15 + 2 * v18\n            if v19 > v10:\n                v10 = v19\n        return v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximizeXorAndXor(self, a1):\n        v1 = len(a1)\n        v2 = 1 << v1\n        v3 = (1 << 32) - 1\n        v4 = [0] * v2\n        v5 = [0] * v2\n        v4[0] = v3\n        v5[0] = 0\n        for v6 in range(1, v2):\n            v7 = 0\n            v8 = v6\n            while v8 & 1 == 0:\n                v7 += 1\n                v8 >>= 1\n            v9 = v6 ^ 1 << v7\n            v4[v6] = v4[v9] & a1[v7]\n            v5[v6] = v5[v9] ^ a1[v7]\n        v10 = 0\n        v11 = v2 - 1\n\n        def highest_subset_xor(a1):\n            if not a1:\n                return 0\n            v1 = max((item.bit_length() for v2 in a1))\n            v3 = [0] * (v1 + 1)\n            for v4 in a1:\n                v5 = v4\n                for v6 in range(v1, -1, -1):\n                    if v5 & 1 << v6 == 0:\n                        continue\n                    if v3[v6]:\n                        v5 ^= v3[v6]\n                    else:\n                        v3[v6] = v5\n                        break\n            v7 = 0\n            for v6 in range(v1, -1, -1):\n                if v3[v6] and v7 ^ v3[v6] > v7:\n                    v7 ^= v3[v6]\n            return v7\n        for v12 in range(1, v2):\n            v13 = v4[v12]\n            v14 = v11 ^ v12\n            v15 = v5[v14]\n            v16 = [a1[k] & ~v15 for v17 in range(v1) if v12 & 1 << v17 == 0]\n            v18 = highest_subset_xor(v16)\n            v19 = v13 + v15 + 2 * v18\n            if v19 > v10:\n                v10 = v19\n        return v10\n"}
{"id": "human_code\\construct-string-with-minimum-cost__part1.py", "text": "import itertools\nfrom functools import reduce\n\nclass C1(object):\n\n    def minimumCost(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n\n        def query(a1):\n            v1 = trie\n            for v2 in range(a1, len(a1)):\n                v3 = a1[v2]\n                if v3 not in v1:\n                    break\n                v1 = v1[v3]\n                if '_end' in v1:\n                    dp[v2 + 1] = min(dp[v2 + 1], dp[a1] + v1['_end'])\n        v2 = lambda: collections.defaultdict(v2)\n        v3 = v2()\n        for v4, v5 in zip(a2, a3):\n            v6 = reduce(dict.__getitem__, v4, v3)\n            if '_end' not in v6:\n                v6['_end'] = v1\n            v6['_end'] = min(v6['_end'], v5)\n        v7 = [v1] * (len(a1) + 1)\n        v7[0] = 0\n        for v8 in range(len(a1)):\n            if v7[v8] == v1:\n                continue\n            query(v8)\n        return v7[-1] if v7[-1] != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\nfrom functools import reduce\n\nclass C1(object):\n\n    def minimumCost(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n\n        def query(a1):\n            v1 = trie\n            for v2 in range(a1, len(a1)):\n                v3 = a1[v2]\n                if v3 not in v1:\n                    break\n                v1 = v1[v3]\n                if '_end' in v1:\n                    dp[v2 + 1] = min(dp[v2 + 1], dp[a1] + v1['_end'])\n        v2 = lambda: collections.defaultdict(v2)\n        v3 = v2()\n        for v4, v5 in zip(a2, a3):\n            v6 = reduce(dict.__getitem__, v4, v3)\n            if '_end' not in v6:\n                v6['_end'] = v1\n            v6['_end'] = min(v6['_end'], v5)\n        v7 = [v1] * (len(a1) + 1)\n        v7[0] = 0\n        for v8 in range(len(a1)):\n            if v7[v8] == v1:\n                continue\n            query(v8)\n        return v7[-1] if v7[-1] != v1 else -1\n"}
{"id": "human_code\\maximum-total-area-occupied-by-pistons__part1.py", "text": "import itertools\n\nclass C1(object):\n\n    def maxArea(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * (2 * a1 + 1)\n        for v2, v3 in zip(a3, a2):\n            if v2 == 'U':\n                v1[a1 - v3] -= 1\n                v1[a1 - v3 + a1] += 1\n            else:\n                v1[v3] += 1\n                v1[v3 + a1] -= 1\n        v4 = v5 = sum(a2)\n        v6 = a3.count('U')\n        for v7 in range(1, len(v1)):\n            v5 += -(len(a3) - v6) + v6\n            v4 = max(v4, v5)\n            v6 += v1[v7]\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\n\nclass C1(object):\n\n    def maxArea(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * (2 * a1 + 1)\n        for v2, v3 in zip(a3, a2):\n            if v2 == 'U':\n                v1[a1 - v3] -= 1\n                v1[a1 - v3 + a1] += 1\n            else:\n                v1[v3] += 1\n                v1[v3 + a1] -= 1\n        v4 = v5 = sum(a2)\n        v6 = a3.count('U')\n        for v7 in range(1, len(v1)):\n            v5 += -(len(a3) - v6) + v6\n            v4 = max(v4, v5)\n            v6 += v1[v7]\n        return v4\n"}
{"id": "human_code\\p03061__s147202029.py", "text": "import sys\nv1 = sys.stdin\n\ndef f1():\n    return v1.readline().rstrip()\n\ndef f2():\n    return int(f1())\n\ndef f3():\n    return list(map(int, v1.readline().split()))\n\ndef f4(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f5():\n    v1 = f2()\n    v2 = f3()\n    v3 = [1] * v1\n    v3[0] = v2[0]\n    v4 = [1] * v1\n    v4[v1 - 1] = v2[v1 - 1]\n    for v5 in range(1, v1):\n        v3[v5] = f4(v3[v5 - 1], v2[v5])\n    for v5 in list(range(0, v1 - 1))[::-1]:\n        v4[v5] = f4(v4[v5 + 1], v2[v5])\n    v6 = max(v4[1], v3[v1 - 2])\n    for v5 in range(1, v1 - 1):\n        v6 = max(v6, f4(v3[v5 - 1], v4[v5 + 1]))\n    print(v6)\nif __name__ == '__main__':\n    f5()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1 = sys.stdin\n\ndef f1():\n    return v1.readline().rstrip()\n\ndef f2():\n    return int(f1())\n\ndef f3():\n    return list(map(int, v1.readline().split()))\n\ndef f4(a1, a2):\n    while a2:\n        a1, a2 = (a2, a1 % a2)\n    return a1\n\ndef f5():\n    v1 = f2()\n    v2 = f3()\n    v3 = [1] * v1\n    v3[0] = v2[0]\n    v4 = [1] * v1\n    v4[v1 - 1] = v2[v1 - 1]\n    for v5 in range(1, v1):\n        v3[v5] = f4(v3[v5 - 1], v2[v5])\n    for v5 in list(range(0, v1 - 1))[::-1]:\n        v4[v5] = f4(v4[v5 + 1], v2[v5])\n    v6 = max(v4[1], v3[v1 - 2])\n    for v5 in range(1, v1 - 1):\n        v6 = max(v6, f4(v3[v5 - 1], v4[v5 + 1]))\n    print(v6)\nif __name__ == '__main__':\n    f5()\n"}
{"id": "human_code\\clone-binary-tree-with-random-pointer__part2.py", "text": "class C1(object):\n\n    def copyRandomBinaryTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            if not a1:\n                return None\n            v1, v2 = a2(a1)\n            dfs(v1, a2)\n            dfs(a1.right, a2)\n            return v2\n\n        def merge(a1):\n            v1 = NodeCopy(a1.val)\n            a1.left, v1.left = (v1, a1.left)\n            return (v1.left, v1)\n\n        def clone(a1):\n            v1 = a1.left\n            a1.left.random = a1.random.left if a1.random else None\n            a1.left.right = a1.right.left if a1.right else None\n            return (v1.left, v1)\n\n        def split(a1):\n            v1 = a1.left\n            a1.left, v1.left = (v1.left, v1.left.left if v1.left else None)\n            return (a1.left, v1)\n        dfs(a1, merge)\n        dfs(a1, clone)\n        return dfs(a1, split)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def copyRandomBinaryTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2):\n            if not a1:\n                return None\n            v1, v2 = a2(a1)\n            dfs(v1, a2)\n            dfs(a1.right, a2)\n            return v2\n\n        def merge(a1):\n            v1 = NodeCopy(a1.val)\n            a1.left, v1.left = (v1, a1.left)\n            return (v1.left, v1)\n\n        def clone(a1):\n            v1 = a1.left\n            a1.left.random = a1.random.left if a1.random else None\n            a1.left.right = a1.right.left if a1.right else None\n            return (v1.left, v1)\n\n        def split(a1):\n            v1 = a1.left\n            a1.left, v1.left = (v1.left, v1.left.left if v1.left else None)\n            return (a1.left, v1)\n        dfs(a1, merge)\n        dfs(a1, clone)\n        return dfs(a1, split)\n"}
{"id": "human_code\\maximize-subarray-sum-after-removing-all-occurrences-of-one-element__part3.py", "text": "import collections\n\nclass C1(object):\n\n    def maxSubarraySum(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3, v4 = list(range(4))\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: y if x is None else x if y is None else max(x, y), a4=lambda x: x):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(a2)\n                while v1 > 1:\n                    v1 >>= 1\n                    self.tree[v1] = self.query_fn(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def query(self, a1, a2):\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n\n        def build(a1):\n            return [a1[a1]] * 4\n\n        def query(a1, a2):\n            if a1 is None:\n                return a2\n            if a2 is None:\n                return a1\n            return [max(a1[v1], a2[v1], a1[v4] + a2[v3]), a1[v2] + a2[v2], max(a1[v3], a1[v2] + a2[v3]), max(a2[v4], a1[v4] + a2[v2])]\n        v5 = max(a1)\n        if v5 < 0:\n            return v5\n        v6 = min(a1)\n        if v6 >= 0:\n            return sum(a1)\n        v7 = collections.defaultdict(list)\n        for v8, v9 in enumerate(a1):\n            v7[v9].append(v8)\n        v10 = SegmentTree(len(a1), build_fn=build, query_fn=query)\n        v11 = v10.tree[1][0]\n        for v12, v13 in v7.items():\n            for v8 in v13:\n                v10.update(v8, None)\n            v11 = max(v11, v10.tree[1][0])\n            for v8 in v13:\n                v10.update(v8, [v12] * 4)\n        return v11\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def maxSubarraySum(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3, v4 = list(range(4))\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: y if x is None else x if y is None else max(x, y), a4=lambda x: x):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(a2)\n                while v1 > 1:\n                    v1 >>= 1\n                    self.tree[v1] = self.query_fn(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def query(self, a1, a2):\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n\n        def build(a1):\n            return [a1[a1]] * 4\n\n        def query(a1, a2):\n            if a1 is None:\n                return a2\n            if a2 is None:\n                return a1\n            return [max(a1[v1], a2[v1], a1[v4] + a2[v3]), a1[v2] + a2[v2], max(a1[v3], a1[v2] + a2[v3]), max(a2[v4], a1[v4] + a2[v2])]\n        v5 = max(a1)\n        if v5 < 0:\n            return v5\n        v6 = min(a1)\n        if v6 >= 0:\n            return sum(a1)\n        v7 = collections.defaultdict(list)\n        for v8, v9 in enumerate(a1):\n            v7[v9].append(v8)\n        v10 = SegmentTree(len(a1), build_fn=build, query_fn=query)\n        v11 = v10.tree[1][0]\n        for v12, v13 in v7.items():\n            for v8 in v13:\n                v10.update(v8, None)\n            v11 = max(v11, v10.tree[1][0])\n            for v8 in v13:\n                v10.update(v8, [v12] * 4)\n        return v11\n"}
