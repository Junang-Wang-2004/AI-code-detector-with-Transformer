{"id": "human_code\\minimum-absolute-difference-queries__part1.py", "text": "class C1(object):\n\n    def minDifference(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = [[0] * (max(a1) + 1)]\n        for v3 in a1:\n            v2.append(v2[-1][:])\n            v2[-1][v3] += 1\n        v4 = []\n        for v5, v6 in a2:\n            v7, v8 = (v1, -1)\n            for v3 in range(len(v2[0])):\n                if not v2[v5][v3] < v2[v6 + 1][v3]:\n                    continue\n                if v8 != -1:\n                    v7 = min(v7, v3 - v8)\n                v8 = v3\n            v4.append(v7 if v7 != v1 else -1)\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minDifference(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = [[0] * (max(a1) + 1)]\n        for v3 in a1:\n            v2.append(v2[-1][:])\n            v2[-1][v3] += 1\n        v4 = []\n        for v5, v6 in a2:\n            v7, v8 = (v1, -1)\n            for v3 in range(len(v2[0])):\n                if not v2[v5][v3] < v2[v6 + 1][v3]:\n                    continue\n                if v8 != -1:\n                    v7 = min(v7, v3 - v8)\n                v8 = v3\n            v4.append(v7 if v7 != v1 else -1)\n        return v4\n"}
{"id": "human_code\\kth-smallest-subarray-sum.py", "text": "class C1(object):\n\n    def kthSmallestSubarraySum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            v1 = v2 = v3 = 0\n            for v4 in range(len(a1)):\n                v2 += a1[v4]\n                while v2 > a3:\n                    v2 -= a1[v3]\n                    v3 += 1\n                v1 += v4 - v3 + 1\n            return v1 >= a2\n        v1, v2 = (min(a1), sum(a1))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(a1, a2, v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def kthSmallestSubarraySum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            v1 = v2 = v3 = 0\n            for v4 in range(len(a1)):\n                v2 += a1[v4]\n                while v2 > a3:\n                    v2 -= a1[v3]\n                    v3 += 1\n                v1 += v4 - v3 + 1\n            return v1 >= a2\n        v1, v2 = (min(a1), sum(a1))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if check(a1, a2, v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v1\n"}
{"id": "llm_code\\p02955__s103678684.py", "text": "v1, v2 = map(int, input().split())\nv3 = [int(i) for v4 in input().split()]\nv5 = sum(v3)\nv6 = set()\nv7 = 1\nwhile v7 * v7 <= v5:\n    if v5 % v7 == 0:\n        v6.add(v7)\n        v6.add(v5 // v7)\n    v7 += 1\nv8 = 1\nfor v9 in v6:\n    v10 = [v3[v4] for v4 in range(v1)]\n    for v4 in range(v1):\n        if v3[v4] % v9 == 0:\n            continue\n        v11 = v3[v4] // v9 * v9\n        v12 = v11 + v9\n        if abs(v11 - v3[v4]) <= abs(v12 - v3[v4]):\n            v10[v4] = v11\n        else:\n            v10[v4] = v12\n    v13 = sum(v10)\n    if v13 != v5:\n        v10[0] += v5 - v13\n    v14 = sum([abs(v3[v4] - v10[v4]) for v4 in range(v1)])\n    if v14 <= 2 * v2:\n        v8 = max(v8, v9)\nprint(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = [int(i) for v4 in input().split()]\nv5 = sum(v3)\nv6 = set()\nv7 = 1\nwhile v7 * v7 <= v5:\n    if v5 % v7 == 0:\n        v6.add(v7)\n        v6.add(v5 // v7)\n    v7 += 1\nv8 = 1\nfor v9 in v6:\n    v10 = [v3[v4] for v4 in range(v1)]\n    for v4 in range(v1):\n        if v3[v4] % v9 == 0:\n            continue\n        v11 = v3[v4] // v9 * v9\n        v12 = v11 + v9\n        if abs(v11 - v3[v4]) <= abs(v12 - v3[v4]):\n            v10[v4] = v11\n        else:\n            v10[v4] = v12\n    v13 = sum(v10)\n    if v13 != v5:\n        v10[0] += v5 - v13\n    v14 = sum([abs(v3[v4] - v10[v4]) for v4 in range(v1)])\n    if v14 <= 2 * v2:\n        v8 = max(v8, v9)\nprint(v8)\n"}
{"id": "human_code\\implement-router.py", "text": "import collections\nfrom sortedcontainers import SortedList\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__size = a1\n        self.__q = collections.deque()\n        self.__lookup = collections.defaultdict(SortedList)\n\n    def addPacket(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        if (a3, a1) in self.__lookup[a2]:\n            return False\n        self.__lookup[a2].add((a3, a1))\n        if len(self.__q) == self.__size:\n            v1, v2, v3 = self.__q.popleft()\n            self.__lookup[v2].remove((v3, v1))\n        self.__q.append((a1, a2, a3))\n        return True\n\n    def forwardPacket(self):\n        \"\"\"\n        \"\"\"\n        if not self.__q:\n            return []\n        v1, v2, v3 = self.__q.popleft()\n        self.__lookup[v2].remove((v3, v1))\n        return [v1, v2, v3]\n\n    def getCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        return self.__lookup[a1].bisect_left((a3 + 1, 0)) - self.__lookup[a1].bisect_left((a2, 0))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom sortedcontainers import SortedList\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__size = a1\n        self.__q = collections.deque()\n        self.__lookup = collections.defaultdict(SortedList)\n\n    def addPacket(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        if (a3, a1) in self.__lookup[a2]:\n            return False\n        self.__lookup[a2].add((a3, a1))\n        if len(self.__q) == self.__size:\n            v1, v2, v3 = self.__q.popleft()\n            self.__lookup[v2].remove((v3, v1))\n        self.__q.append((a1, a2, a3))\n        return True\n\n    def forwardPacket(self):\n        \"\"\"\n        \"\"\"\n        if not self.__q:\n            return []\n        v1, v2, v3 = self.__q.popleft()\n        self.__lookup[v2].remove((v3, v1))\n        return [v1, v2, v3]\n\n    def getCount(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        return self.__lookup[a1].bisect_left((a3 + 1, 0)) - self.__lookup[a1].bisect_left((a2, 0))\n"}
{"id": "human_code\\closest-nodes-queries-in-a-binary-search-tree__part1.py", "text": "import bisect\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        pass\n\nclass C2(object):\n\n    def closestNodes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = []\n            v2 = [(1, a1)]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    if not v4:\n                        continue\n                    v2.append((1, v4.right))\n                    v2.append((2, v4))\n                    v2.append((1, v4.left))\n                elif v3 == 2:\n                    v1.append(v4.val)\n            return v1\n        v1 = iter_dfs()\n        v2 = []\n        for v3 in a2:\n            v4 = bisect.bisect_left(v1, v3)\n            if v4 == len(v1):\n                v2.append([v1[v4 - 1], -1])\n            elif v1[v4] == v3:\n                v2.append([v1[v4], v1[v4]])\n            elif v4 - 1 >= 0:\n                v2.append([v1[v4 - 1], v1[v4]])\n            else:\n                v2.append([-1, v1[v4]])\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        pass\n\nclass C2(object):\n\n    def closestNodes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = []\n            v2 = [(1, a1)]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    if not v4:\n                        continue\n                    v2.append((1, v4.right))\n                    v2.append((2, v4))\n                    v2.append((1, v4.left))\n                elif v3 == 2:\n                    v1.append(v4.val)\n            return v1\n        v1 = iter_dfs()\n        v2 = []\n        for v3 in a2:\n            v4 = bisect.bisect_left(v1, v3)\n            if v4 == len(v1):\n                v2.append([v1[v4 - 1], -1])\n            elif v1[v4] == v3:\n                v2.append([v1[v4], v1[v4]])\n            elif v4 - 1 >= 0:\n                v2.append([v1[v4 - 1], v1[v4]])\n            else:\n                v2.append([-1, v1[v4]])\n        return v2\n"}
{"id": "human_code\\minimize-the-total-price-of-the-trips__part1.py", "text": "class C1(object):\n\n    def minimumTotalPrice(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1, a2):\n            v1 = [(1, (a1, -1))]\n            while v1:\n                v2, v3 = v1.pop()\n                if v2 == 1:\n                    a1, v5 = v3\n                    lookup[a1] += 1\n                    if a1 == a2:\n                        return\n                    v1.append((2, (a1,)))\n                    for v6 in reversed(adj[a1]):\n                        if v6 == v5:\n                            continue\n                        v1.append((1, (v6, a1)))\n                elif v2 == 2:\n                    a1 = v3[0]\n                    lookup[a1] -= 1\n            lookup[a1] += 1\n            if a1 == a2:\n                return True\n            for v6 in adj[a1]:\n                if v6 == v5:\n                    continue\n                if dfs(v6, a1, a2):\n                    return True\n            lookup[a1] -= 1\n            return False\n\n        def iter_dfs2():\n            v1 = [a3[0] * lookup[0], a3[0] // 2 * lookup[0]]\n            v2 = [(1, (0, -1, v1))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6, v7 = v4\n                    for v8 in reversed(adj[v5]):\n                        if v8 == v6:\n                            continue\n                        v9 = [a3[v8] * lookup[v8], a3[v8] // 2 * lookup[v8]]\n                        v2.append((2, (v9, v7)))\n                        v2.append((1, (v8, v5, v9)))\n                elif v3 == 2:\n                    v9, v7 = v4\n                    v7[0] += min(v9)\n                    v7[1] += v9[0]\n            return min(v1)\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * a1\n        for v3, v4 in a4:\n            iter_dfs(v3, v4)\n        return iter_dfs2()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumTotalPrice(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1, a2):\n            v1 = [(1, (a1, -1))]\n            while v1:\n                v2, v3 = v1.pop()\n                if v2 == 1:\n                    a1, v5 = v3\n                    lookup[a1] += 1\n                    if a1 == a2:\n                        return\n                    v1.append((2, (a1,)))\n                    for v6 in reversed(adj[a1]):\n                        if v6 == v5:\n                            continue\n                        v1.append((1, (v6, a1)))\n                elif v2 == 2:\n                    a1 = v3[0]\n                    lookup[a1] -= 1\n            lookup[a1] += 1\n            if a1 == a2:\n                return True\n            for v6 in adj[a1]:\n                if v6 == v5:\n                    continue\n                if dfs(v6, a1, a2):\n                    return True\n            lookup[a1] -= 1\n            return False\n\n        def iter_dfs2():\n            v1 = [a3[0] * lookup[0], a3[0] // 2 * lookup[0]]\n            v2 = [(1, (0, -1, v1))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6, v7 = v4\n                    for v8 in reversed(adj[v5]):\n                        if v8 == v6:\n                            continue\n                        v9 = [a3[v8] * lookup[v8], a3[v8] // 2 * lookup[v8]]\n                        v2.append((2, (v9, v7)))\n                        v2.append((1, (v8, v5, v9)))\n                elif v3 == 2:\n                    v9, v7 = v4\n                    v7[0] += min(v9)\n                    v7[1] += v9[0]\n            return min(v1)\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * a1\n        for v3, v4 in a4:\n            iter_dfs(v3, v4)\n        return iter_dfs2()\n"}
{"id": "human_code\\find-the-safest-path-in-a-grid__part2.py", "text": "import heapq\n\nclass C1(object):\n\n    def maximumSafenessFactor(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n        def bfs():\n            v1 = [[0 if a1[r][c] == 1 else -1 for v2 in range(len(a1[0]))] for v3 in range(len(a1))]\n            v4 = [(v3, v2) for v3 in range(len(a1)) for v2 in range(len(a1[0])) if a1[v3][v2]]\n            v5 = 0\n            while v4:\n                v6 = []\n                for v3, v2 in v4:\n                    for v7, v8 in v1:\n                        v9, v10 = (v3 + v7, v2 + v8)\n                        if not (0 <= v9 < len(v1) and 0 <= v10 < len(v1[0]) and (v1[v9][v10] == -1)):\n                            continue\n                        v1[v9][v10] = v5 + 1\n                        v6.append((v9, v10))\n                v4 = v6\n                v5 += 1\n            return v1\n\n        def dijkstra(a1, a2):\n            v1 = [(-dist[a1[0]][a1[1]], a1)]\n            dist[a1[0]][a1[1]] = -1\n            while v1:\n                v2, v3 = heapq.heappop(v1)\n                v2 = -v2\n                if v3 == a2:\n                    return v2\n                for v4, v5 in v1:\n                    v6, v7 = (v3[0] + v4, v3[1] + v5)\n                    if not (0 <= v6 < len(dist) and 0 <= v7 < len(dist[0]) and (dist[v6][v7] != -1)):\n                        continue\n                    heapq.heappush(v1, (-min(v2, dist[v6][v7]), (v6, v7)))\n                    dist[v6][v7] = -1\n            return -1\n        v2 = bfs()\n        return dijkstra(v2, (0, 0), (len(a1) - 1, len(a1[0]) - 1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def maximumSafenessFactor(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1))\n\n        def bfs():\n            v1 = [[0 if a1[r][c] == 1 else -1 for v2 in range(len(a1[0]))] for v3 in range(len(a1))]\n            v4 = [(v3, v2) for v3 in range(len(a1)) for v2 in range(len(a1[0])) if a1[v3][v2]]\n            v5 = 0\n            while v4:\n                v6 = []\n                for v3, v2 in v4:\n                    for v7, v8 in v1:\n                        v9, v10 = (v3 + v7, v2 + v8)\n                        if not (0 <= v9 < len(v1) and 0 <= v10 < len(v1[0]) and (v1[v9][v10] == -1)):\n                            continue\n                        v1[v9][v10] = v5 + 1\n                        v6.append((v9, v10))\n                v4 = v6\n                v5 += 1\n            return v1\n\n        def dijkstra(a1, a2):\n            v1 = [(-dist[a1[0]][a1[1]], a1)]\n            dist[a1[0]][a1[1]] = -1\n            while v1:\n                v2, v3 = heapq.heappop(v1)\n                v2 = -v2\n                if v3 == a2:\n                    return v2\n                for v4, v5 in v1:\n                    v6, v7 = (v3[0] + v4, v3[1] + v5)\n                    if not (0 <= v6 < len(dist) and 0 <= v7 < len(dist[0]) and (dist[v6][v7] != -1)):\n                        continue\n                    heapq.heappush(v1, (-min(v2, dist[v6][v7]), (v6, v7)))\n                    dist[v6][v7] = -1\n            return -1\n        v2 = bfs()\n        return dijkstra(v2, (0, 0), (len(a1) - 1, len(a1[0]) - 1))\n"}
{"id": "human_code\\longest-palindromic-substring__part1.py", "text": "class C1(object):\n\n    def longestPalindrome(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def preProcess(a1):\n            if not a1:\n                return ['^', '$']\n            v1 = ['^']\n            for v2 in a1:\n                v1 += ['#', v2]\n            v1 += ['#', '$']\n            return v1\n        v1 = preProcess(a1)\n        v2 = [0] * len(v1)\n        v3, v4 = (0, 0)\n        for v5 in range(1, len(v1) - 1):\n            v6 = 2 * v3 - v5\n            if v4 > v5:\n                v2[v5] = min(v4 - v5, v2[v6])\n            else:\n                v2[v5] = 0\n            while v1[v5 + 1 + v2[v5]] == v1[v5 - 1 - v2[v5]]:\n                v2[v5] += 1\n            if v5 + v2[v5] > v4:\n                v3, v4 = (v5, v5 + v2[v5])\n        v7 = 0\n        for v5 in range(1, len(v1) - 1):\n            if v2[v5] > v2[v7]:\n                v7 = v5\n        v8 = (v7 - 1 - v2[v7]) // 2\n        return a1[v8:v8 + v2[v7]]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestPalindrome(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def preProcess(a1):\n            if not a1:\n                return ['^', '$']\n            v1 = ['^']\n            for v2 in a1:\n                v1 += ['#', v2]\n            v1 += ['#', '$']\n            return v1\n        v1 = preProcess(a1)\n        v2 = [0] * len(v1)\n        v3, v4 = (0, 0)\n        for v5 in range(1, len(v1) - 1):\n            v6 = 2 * v3 - v5\n            if v4 > v5:\n                v2[v5] = min(v4 - v5, v2[v6])\n            else:\n                v2[v5] = 0\n            while v1[v5 + 1 + v2[v5]] == v1[v5 - 1 - v2[v5]]:\n                v2[v5] += 1\n            if v5 + v2[v5] > v4:\n                v3, v4 = (v5, v5 + v2[v5])\n        v7 = 0\n        for v5 in range(1, len(v1) - 1):\n            if v2[v5] > v2[v7]:\n                v7 = v5\n        v8 = (v7 - 1 - v2[v7]) // 2\n        return a1[v8:v8 + v2[v7]]\n"}
{"id": "llm_code\\number-of-submatrices-that-sum-to-target__grok-4.1-fast__v1.py", "text": "from collections import defaultdict\n\nclass C1:\n\n    def numSubmatrixSumTarget(self, a1, a2):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        if v1 > v2:\n            a1 = list(map(list, zip(*a1)))\n            v1, v2 = (v2, v1)\n        v4 = []\n        for v5 in range(v1):\n            v6 = [0] * v2\n            for v7 in range(v2):\n                v6[v7] = (v6[v7 - 1] if v7 > 0 else 0) + a1[v5][v7]\n            v4.append(v6)\n        v8 = 0\n        for v9 in range(v1):\n            v10 = [0] * v2\n            for v11 in range(v9, v1):\n                for v12 in range(v2):\n                    v10[v12] += v4[v11][v12]\n                v13 = defaultdict(int)\n                v13[0] = 1\n                v14 = 0\n                for v15 in range(v2):\n                    v14 = v10[v15]\n                    v8 += v13[v14 - a2]\n                    v13[v14] += 1\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import defaultdict\n\nclass C1:\n\n    def numSubmatrixSumTarget(self, a1, a2):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        if v1 > v2:\n            a1 = list(map(list, zip(*a1)))\n            v1, v2 = (v2, v1)\n        v4 = []\n        for v5 in range(v1):\n            v6 = [0] * v2\n            for v7 in range(v2):\n                v6[v7] = (v6[v7 - 1] if v7 > 0 else 0) + a1[v5][v7]\n            v4.append(v6)\n        v8 = 0\n        for v9 in range(v1):\n            v10 = [0] * v2\n            for v11 in range(v9, v1):\n                for v12 in range(v2):\n                    v10[v12] += v4[v11][v12]\n                v13 = defaultdict(int)\n                v13[0] = 1\n                v14 = 0\n                for v15 in range(v2):\n                    v14 = v10[v15]\n                    v8 += v13[v14 - a2]\n                    v13[v14] += 1\n        return v8\n"}
{"id": "human_code\\maximum-profitable-triplets-with-increasing-prices-ii__part5.py", "text": "class C1(object):\n\n    def maxProfit(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('-inf')\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: max(x, y), a4=lambda x, y: max(x, y)):\n                self.tree = [None] * (2 * 2 ** (a1 - 1).bit_length())\n                self.base = len(self.tree) // 2\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[2 * v1], self.tree[2 * v1 + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(self.tree[v1], a2)\n                while v1 > 1:\n                    v1 //= 2\n                    self.tree[v1] = self.query_fn(self.tree[v1 * 2], self.tree[v1 * 2 + 1])\n\n            def query(self, a1, a2):\n                if a1 > a2:\n                    return None\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 //= 2\n                    a2 //= 2\n                return self.query_fn(v3, v4)\n        v2 = {x: i for v3, v4 in enumerate(sorted(set(a1)))}\n        v5 = [v1] * len(a1)\n        v6 = SegmentTree(len(v2))\n        for v3 in reversed(range(len(a1))):\n            v5[v3] = v6.query(v2[a1[v3]] + 1, len(v2) - 1)\n            v6.update(v2[a1[v3]], a2[v3])\n        v7 = v1\n        v6 = SegmentTree(len(v2))\n        for v3 in range(len(a1)):\n            v8 = v6.query(0, v2[a1[v3]] - 1)\n            if v8 is not None and v5[v3] is not None:\n                v7 = max(v7, v8 + a2[v3] + v5[v3])\n            v6.update(v2[a1[v3]], a2[v3])\n        return v7 if v7 != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxProfit(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('-inf')\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: max(x, y), a4=lambda x, y: max(x, y)):\n                self.tree = [None] * (2 * 2 ** (a1 - 1).bit_length())\n                self.base = len(self.tree) // 2\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[2 * v1], self.tree[2 * v1 + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(self.tree[v1], a2)\n                while v1 > 1:\n                    v1 //= 2\n                    self.tree[v1] = self.query_fn(self.tree[v1 * 2], self.tree[v1 * 2 + 1])\n\n            def query(self, a1, a2):\n                if a1 > a2:\n                    return None\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 //= 2\n                    a2 //= 2\n                return self.query_fn(v3, v4)\n        v2 = {x: i for v3, v4 in enumerate(sorted(set(a1)))}\n        v5 = [v1] * len(a1)\n        v6 = SegmentTree(len(v2))\n        for v3 in reversed(range(len(a1))):\n            v5[v3] = v6.query(v2[a1[v3]] + 1, len(v2) - 1)\n            v6.update(v2[a1[v3]], a2[v3])\n        v7 = v1\n        v6 = SegmentTree(len(v2))\n        for v3 in range(len(a1)):\n            v8 = v6.query(0, v2[a1[v3]] - 1)\n            if v8 is not None and v5[v3] is not None:\n                v7 = max(v7, v8 + a2[v3] + v5[v3])\n            v6.update(v2[a1[v3]], a2[v3])\n        return v7 if v7 != v1 else -1\n"}
{"id": "human_code\\p03007__s982064450.py", "text": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv2.sort()\nv3 = 0\nfor v4 in v2:\n    if v4 <= 0:\n        v3 += 1\nif v3 == v1 or v3 == v1 - 1:\n    v5 = v2[-1] - sum(v2[:-1])\n    print(v5)\n    v4, v6 = (v2[-1], v2[0])\n    for v7 in range(1, v1):\n        print(v4, v6)\n        v4, v6 = (v4 - v6, v2[v7])\nelif v3 == 0 or v3 == 1:\n    v5 = sum(v2[1:]) - v2[0]\n    print(v5)\n    v4, v6 = (v2[0], 0)\n    for v7 in range(1, v1 - 1):\n        v4, v6 = (v4 - v6, v2[v7])\n        print(v4, v6)\n    v4, v6 = (v2[-1], v4 - v6)\n    print(v4, v6)\nelse:\n    v5 = sum(v2[v3:]) - sum(v2[:v3])\n    print(v5)\n    v4, v6 = (v2[0], 0)\n    for v7 in range(v1 - v3 - 1):\n        v4, v6 = (v4 - v6, v2[v3 + v7])\n        print(v4, v6)\n    v4, v6 = (v2[-1], v4 - v6)\n    print(v4, v6)\n    for v7 in range(v3 - 1):\n        v4, v6 = (v4 - v6, v2[v7 + 1])\n        print(v4, v6)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv2.sort()\nv3 = 0\nfor v4 in v2:\n    if v4 <= 0:\n        v3 += 1\nif v3 == v1 or v3 == v1 - 1:\n    v5 = v2[-1] - sum(v2[:-1])\n    print(v5)\n    v4, v6 = (v2[-1], v2[0])\n    for v7 in range(1, v1):\n        print(v4, v6)\n        v4, v6 = (v4 - v6, v2[v7])\nelif v3 == 0 or v3 == 1:\n    v5 = sum(v2[1:]) - v2[0]\n    print(v5)\n    v4, v6 = (v2[0], 0)\n    for v7 in range(1, v1 - 1):\n        v4, v6 = (v4 - v6, v2[v7])\n        print(v4, v6)\n    v4, v6 = (v2[-1], v4 - v6)\n    print(v4, v6)\nelse:\n    v5 = sum(v2[v3:]) - sum(v2[:v3])\n    print(v5)\n    v4, v6 = (v2[0], 0)\n    for v7 in range(v1 - v3 - 1):\n        v4, v6 = (v4 - v6, v2[v3 + v7])\n        print(v4, v6)\n    v4, v6 = (v2[-1], v4 - v6)\n    print(v4, v6)\n    for v7 in range(v3 - 1):\n        v4, v6 = (v4 - v6, v2[v7 + 1])\n        print(v4, v6)\n"}
{"id": "llm_code\\find-shortest-path-with-k-hops__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def shortestPathWithHops(self, a1, a2, a3, a4, a5):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = float('inf')\n        v7 = [[v6] * (a5 + 1) for v2 in range(a1)]\n        v7[a3][0] = 0\n        v8 = [(0, a3, 0)]\n        while v8:\n            v9, v3, v10 = heapq.heappop(v8)\n            if v9 > v7[v3][v10]:\n                continue\n            if v3 == a4:\n                return v9\n            for v4, v5 in v1[v3]:\n                if v9 + v5 < v7[v4][v10]:\n                    v7[v4][v10] = v9 + v5\n                    heapq.heappush(v8, (v7[v4][v10], v4, v10))\n                if v10 < a5 and v9 < v7[v4][v10 + 1]:\n                    v7[v4][v10 + 1] = v9\n                    heapq.heappush(v8, (v7[v4][v10 + 1], v4, v10 + 1))\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def shortestPathWithHops(self, a1, a2, a3, a4, a5):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = float('inf')\n        v7 = [[v6] * (a5 + 1) for v2 in range(a1)]\n        v7[a3][0] = 0\n        v8 = [(0, a3, 0)]\n        while v8:\n            v9, v3, v10 = heapq.heappop(v8)\n            if v9 > v7[v3][v10]:\n                continue\n            if v3 == a4:\n                return v9\n            for v4, v5 in v1[v3]:\n                if v9 + v5 < v7[v4][v10]:\n                    v7[v4][v10] = v9 + v5\n                    heapq.heappush(v8, (v7[v4][v10], v4, v10))\n                if v10 < a5 and v9 < v7[v4][v10 + 1]:\n                    v7[v4][v10 + 1] = v9\n                    heapq.heappush(v8, (v7[v4][v10 + 1], v4, v10 + 1))\n        return -1\n"}
{"id": "llm_code\\couples-holding-hands__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minSwapsCouples(self, a1):\n        v1 = len(a1) // 2\n        v2 = [0] * (2 * v1)\n        for v3, v4 in enumerate(a1):\n            v2[v4] = v3 // 2\n        v5 = list(range(v1))\n        v6 = [0] * v1\n\n        def find(a1):\n            if v5[a1] != a1:\n                v5[a1] = find(v5[a1])\n            return v5[a1]\n\n        def unite(a1, a2):\n            v1 = find(a1)\n            v2 = find(a2)\n            if v1 != v2:\n                if v6[v1] < v6[v2]:\n                    v5[v1] = v2\n                elif v6[v1] > v6[v2]:\n                    v5[v2] = v1\n                else:\n                    v5[v2] = v1\n                    v6[v1] += 1\n        for v7 in range(v1):\n            unite(v2[2 * v7], v2[2 * v7 + 1])\n        v8 = set((find(v3) for v3 in range(v1)))\n        return v1 - len(v8)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minSwapsCouples(self, a1):\n        v1 = len(a1) // 2\n        v2 = [0] * (2 * v1)\n        for v3, v4 in enumerate(a1):\n            v2[v4] = v3 // 2\n        v5 = list(range(v1))\n        v6 = [0] * v1\n\n        def find(a1):\n            if v5[a1] != a1:\n                v5[a1] = find(v5[a1])\n            return v5[a1]\n\n        def unite(a1, a2):\n            v1 = find(a1)\n            v2 = find(a2)\n            if v1 != v2:\n                if v6[v1] < v6[v2]:\n                    v5[v1] = v2\n                elif v6[v1] > v6[v2]:\n                    v5[v2] = v1\n                else:\n                    v5[v2] = v1\n                    v6[v1] += 1\n        for v7 in range(v1):\n            unite(v2[2 * v7], v2[2 * v7 + 1])\n        v8 = set((find(v3) for v3 in range(v1)))\n        return v1 - len(v8)\n"}
{"id": "llm_code\\maximum-total-subarray-value-ii__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def maxTotalValue(self, a1, a2):\n        v1 = len(a1)\n        if v1 == 0 or a2 == 0:\n            return 0\n        v2 = [0] * (v1 + 2)\n        for v3 in range(2, v1 + 1):\n            v2[v3] = v2[v3 // 2] + 1\n        v4 = [[0] * v1 for v5 in range(v2[v1] + 1)]\n        v6 = [[0] * v1 for v5 in range(v2[v1] + 1)]\n        for v3 in range(v1):\n            v4[0][v3] = a1[v3]\n            v6[0][v3] = a1[v3]\n        for v7 in range(1, v2[v1] + 1):\n            for v3 in range(v1 - (1 << v7) + 1):\n                v4[v7][v3] = min(v4[v7 - 1][v3], v4[v7 - 1][v3 + (1 << v7 - 1)])\n                v6[v7][v3] = max(v6[v7 - 1][v3], v6[v7 - 1][v3 + (1 << v7 - 1)])\n\n        def range_min(a1, a2):\n            v1 = v2[a2 - a1 + 1]\n            return min(v4[v1][a1], v4[v1][a2 - (1 << v1) + 1])\n\n        def range_max(a1, a2):\n            v1 = v2[a2 - a1 + 1]\n            return max(v6[v1][a1], v6[v1][a2 - (1 << v1) + 1])\n        v8 = [(-(range_max(v3, v1 - 1) - range_min(v3, v1 - 1)), v3, v1 - 1) for v3 in range(v1)]\n        heapq.heapify(v8)\n        v9 = 0\n        v10 = 0\n        while v10 < a2 and v8:\n            v5, v11, v12 = heapq.heappop(v8)\n            v9 += range_max(v11, v12) - range_min(v11, v12)\n            v10 += 1\n            if v11 < v12:\n                v13 = -(range_max(v11, v12 - 1) - range_min(v11, v12 - 1))\n                heapq.heappush(v8, (v13, v11, v12 - 1))\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def maxTotalValue(self, a1, a2):\n        v1 = len(a1)\n        if v1 == 0 or a2 == 0:\n            return 0\n        v2 = [0] * (v1 + 2)\n        for v3 in range(2, v1 + 1):\n            v2[v3] = v2[v3 // 2] + 1\n        v4 = [[0] * v1 for v5 in range(v2[v1] + 1)]\n        v6 = [[0] * v1 for v5 in range(v2[v1] + 1)]\n        for v3 in range(v1):\n            v4[0][v3] = a1[v3]\n            v6[0][v3] = a1[v3]\n        for v7 in range(1, v2[v1] + 1):\n            for v3 in range(v1 - (1 << v7) + 1):\n                v4[v7][v3] = min(v4[v7 - 1][v3], v4[v7 - 1][v3 + (1 << v7 - 1)])\n                v6[v7][v3] = max(v6[v7 - 1][v3], v6[v7 - 1][v3 + (1 << v7 - 1)])\n\n        def range_min(a1, a2):\n            v1 = v2[a2 - a1 + 1]\n            return min(v4[v1][a1], v4[v1][a2 - (1 << v1) + 1])\n\n        def range_max(a1, a2):\n            v1 = v2[a2 - a1 + 1]\n            return max(v6[v1][a1], v6[v1][a2 - (1 << v1) + 1])\n        v8 = [(-(range_max(v3, v1 - 1) - range_min(v3, v1 - 1)), v3, v1 - 1) for v3 in range(v1)]\n        heapq.heapify(v8)\n        v9 = 0\n        v10 = 0\n        while v10 < a2 and v8:\n            v5, v11, v12 = heapq.heappop(v8)\n            v9 += range_max(v11, v12) - range_min(v11, v12)\n            v10 += 1\n            if v11 < v12:\n                v13 = -(range_max(v11, v12 - 1) - range_min(v11, v12 - 1))\n                heapq.heappush(v8, (v13, v11, v12 - 1))\n        return v9\n"}
{"id": "human_code\\p03347__s523620682.py", "text": "v1 = int(input())\nv2 = [int(input()) for v3 in range(v1)]\nif v2[0] != 0:\n    print(-1)\n    exit()\nfor v3 in range(v1 - 1):\n    if v2[v3] < v2[v3 + 1] and v2[v3 + 1] - v2[v3] != 1:\n        print(-1)\n        exit()\n    if v2[v3] > v3 + 1:\n        print(-1)\n        exit()\nv4 = 0\nv3 = 1\nv5 = 0\nwhile v3 != v1:\n    if v2[v3] <= v5:\n        v4 += v5\n    v5 = v2[v3]\n    v3 += 1\nprint(v4 + v2[-1])\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [int(input()) for v3 in range(v1)]\nif v2[0] != 0:\n    print(-1)\n    exit()\nfor v3 in range(v1 - 1):\n    if v2[v3] < v2[v3 + 1] and v2[v3 + 1] - v2[v3] != 1:\n        print(-1)\n        exit()\n    if v2[v3] > v3 + 1:\n        print(-1)\n        exit()\nv4 = 0\nv3 = 1\nv5 = 0\nwhile v3 != v1:\n    if v2[v3] <= v5:\n        v4 += v5\n    v5 = v2[v3]\n    v3 += 1\nprint(v4 + v2[-1])\n"}
{"id": "llm_code\\find-the-index-of-permutation__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def getPermutationIndex(self, a1):\n        v1 = 1000000007\n        v2 = len(a1)\n        v3 = [1] * (v2 + 1)\n        for v4 in range(1, v2 + 1):\n            v3[v4] = v3[v4 - 1] * v4 % v1\n        v5 = [0] * (v2 + 2)\n\n        def update(a1, a2):\n            while a1 <= v2:\n                v5[a1] = (v5[a1] + a2) % v1\n                a1 += a1 & -a1\n\n        def prefix_sum(a1):\n            v1 = 0\n            while a1 > 0:\n                v1 = (v1 + v5[a1]) % v1\n                a1 -= a1 & -a1\n            return v1\n        v6 = 0\n        for v7 in range(v2):\n            v8 = a1[v7]\n            v9 = prefix_sum(v8 - 1)\n            v10 = (v8 - 1 - v9) % v1\n            v6 = (v6 + v10 * v3[v2 - 1 - v7] % v1) % v1\n            update(v8, 1)\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def getPermutationIndex(self, a1):\n        v1 = 1000000007\n        v2 = len(a1)\n        v3 = [1] * (v2 + 1)\n        for v4 in range(1, v2 + 1):\n            v3[v4] = v3[v4 - 1] * v4 % v1\n        v5 = [0] * (v2 + 2)\n\n        def update(a1, a2):\n            while a1 <= v2:\n                v5[a1] = (v5[a1] + a2) % v1\n                a1 += a1 & -a1\n\n        def prefix_sum(a1):\n            v1 = 0\n            while a1 > 0:\n                v1 = (v1 + v5[a1]) % v1\n                a1 -= a1 & -a1\n            return v1\n        v6 = 0\n        for v7 in range(v2):\n            v8 = a1[v7]\n            v9 = prefix_sum(v8 - 1)\n            v10 = (v8 - 1 - v9) % v1\n            v6 = (v6 + v10 * v3[v2 - 1 - v7] % v1) % v1\n            update(v8, 1)\n        return v6\n"}
{"id": "human_code\\remove-invalid-parentheses.py", "text": "class C1(object):\n\n    def removeInvalidParentheses(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def findMinRemove(a1):\n            v1, v2 = (0, 0)\n            for v3 in a1:\n                if v3 == '(':\n                    v1 += 1\n                elif v3 == ')':\n                    if not v1:\n                        v2 += 1\n                    else:\n                        v1 -= 1\n            return (v1, v2)\n\n        def isValid(a1):\n            sum = 0\n            for v1 in a1:\n                if v1 == '(':\n                    sum += 1\n                elif v1 == ')':\n                    sum -= 1\n                if sum < 0:\n                    return False\n            return sum == 0\n\n        def removeInvalidParenthesesHelper(a1, a2, a3):\n            if a2 == 0 and a3 == 0:\n                v1 = ''\n                for v2, v3 in enumerate(a1):\n                    if v2 not in removed:\n                        v1 += v3\n                if isValid(v1):\n                    res.append(v1)\n                return\n            for v2 in range(a1, len(a1)):\n                if a3 == 0 and a2 > 0 and (a1[v2] == '('):\n                    if v2 == a1 or a1[v2] != a1[v2 - 1]:\n                        removed[v2] = True\n                        removeInvalidParenthesesHelper(v2 + 1, a2 - 1, a3)\n                        del removed[v2]\n                elif a3 > 0 and a1[v2] == ')':\n                    if v2 == a1 or a1[v2] != a1[v2 - 1]:\n                        removed[v2] = True\n                        removeInvalidParenthesesHelper(v2 + 1, a2, a3 - 1)\n                        del removed[v2]\n        v1, v2 = ([], {})\n        v3, v4 = findMinRemove(a1)\n        removeInvalidParenthesesHelper(0, v3, v4)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def removeInvalidParentheses(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def findMinRemove(a1):\n            v1, v2 = (0, 0)\n            for v3 in a1:\n                if v3 == '(':\n                    v1 += 1\n                elif v3 == ')':\n                    if not v1:\n                        v2 += 1\n                    else:\n                        v1 -= 1\n            return (v1, v2)\n\n        def isValid(a1):\n            sum = 0\n            for v1 in a1:\n                if v1 == '(':\n                    sum += 1\n                elif v1 == ')':\n                    sum -= 1\n                if sum < 0:\n                    return False\n            return sum == 0\n\n        def removeInvalidParenthesesHelper(a1, a2, a3):\n            if a2 == 0 and a3 == 0:\n                v1 = ''\n                for v2, v3 in enumerate(a1):\n                    if v2 not in removed:\n                        v1 += v3\n                if isValid(v1):\n                    res.append(v1)\n                return\n            for v2 in range(a1, len(a1)):\n                if a3 == 0 and a2 > 0 and (a1[v2] == '('):\n                    if v2 == a1 or a1[v2] != a1[v2 - 1]:\n                        removed[v2] = True\n                        removeInvalidParenthesesHelper(v2 + 1, a2 - 1, a3)\n                        del removed[v2]\n                elif a3 > 0 and a1[v2] == ')':\n                    if v2 == a1 or a1[v2] != a1[v2 - 1]:\n                        removed[v2] = True\n                        removeInvalidParenthesesHelper(v2 + 1, a2, a3 - 1)\n                        del removed[v2]\n        v1, v2 = ([], {})\n        v3, v4 = findMinRemove(a1)\n        removeInvalidParenthesesHelper(0, v3, v4)\n        return v1\n"}
{"id": "llm_code\\lfu-cache__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def __init__(self, a1):\n        self._maxsz = a1\n        self._valmap = {}\n        self._freqmap = {}\n        self._freqmap_to_keys = collections.defaultdict(collections.OrderedDict)\n        self._lowfreq = float('inf')\n        self._currsz = 0\n\n    def _evict(self, a1):\n        v1 = self._freqmap[a1]\n        del self._freqmap_to_keys[v1][a1]\n        if len(self._freqmap_to_keys[v1]) == 0:\n            del self._freqmap_to_keys[v1]\n            if v1 == self._lowfreq:\n                self._lowfreq += 1\n        del self._freqmap[a1]\n        del self._valmap[a1]\n        self._currsz -= 1\n\n    def _bumpfreq(self, a1):\n        v1 = self._freqmap.get(a1, 0)\n        if v1 > 0:\n            del self._freqmap_to_keys[v1][a1]\n            if len(self._freqmap_to_keys[v1]) == 0:\n                del self._freqmap_to_keys[v1]\n                if v1 == self._lowfreq:\n                    self._lowfreq += 1\n        v2 = v1 + 1\n        self._freqmap[a1] = v2\n        self._freqmap_to_keys[v2][a1] = None\n        self._lowfreq = min(self._lowfreq, v2)\n\n    def get(self, a1):\n        if a1 not in self._valmap:\n            return -1\n        self._bumpfreq(a1)\n        return self._valmap[a1]\n\n    def put(self, a1, a2):\n        if self._maxsz <= 0:\n            return\n        self._valmap[a1] = a2\n        if a1 in self._freqmap:\n            self._bumpfreq(a1)\n        else:\n            if self._currsz == self._maxsz:\n                v1 = next(iter(self._freqmap_to_keys[self._lowfreq]))\n                self._evict(v1)\n            self._bumpfreq(a1)\n            self._currsz += 1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def __init__(self, a1):\n        self._maxsz = a1\n        self._valmap = {}\n        self._freqmap = {}\n        self._freqmap_to_keys = collections.defaultdict(collections.OrderedDict)\n        self._lowfreq = float('inf')\n        self._currsz = 0\n\n    def _evict(self, a1):\n        v1 = self._freqmap[a1]\n        del self._freqmap_to_keys[v1][a1]\n        if len(self._freqmap_to_keys[v1]) == 0:\n            del self._freqmap_to_keys[v1]\n            if v1 == self._lowfreq:\n                self._lowfreq += 1\n        del self._freqmap[a1]\n        del self._valmap[a1]\n        self._currsz -= 1\n\n    def _bumpfreq(self, a1):\n        v1 = self._freqmap.get(a1, 0)\n        if v1 > 0:\n            del self._freqmap_to_keys[v1][a1]\n            if len(self._freqmap_to_keys[v1]) == 0:\n                del self._freqmap_to_keys[v1]\n                if v1 == self._lowfreq:\n                    self._lowfreq += 1\n        v2 = v1 + 1\n        self._freqmap[a1] = v2\n        self._freqmap_to_keys[v2][a1] = None\n        self._lowfreq = min(self._lowfreq, v2)\n\n    def get(self, a1):\n        if a1 not in self._valmap:\n            return -1\n        self._bumpfreq(a1)\n        return self._valmap[a1]\n\n    def put(self, a1, a2):\n        if self._maxsz <= 0:\n            return\n        self._valmap[a1] = a2\n        if a1 in self._freqmap:\n            self._bumpfreq(a1)\n        else:\n            if self._currsz == self._maxsz:\n                v1 = next(iter(self._freqmap_to_keys[self._lowfreq]))\n                self._evict(v1)\n            self._bumpfreq(a1)\n            self._currsz += 1\n"}
{"id": "human_code\\p02937__s020122167.py", "text": "import bisect\nv1 = input()\nv2 = input()\nv3 = len(v1)\nv4 = len(v2)\nv5 = [[] for v6 in range(28)]\n\ndef f1(a1):\n    return ord(a1) - 97\nfor v6 in range(v3):\n    v7 = f1(v1[v6])\n    v5[v7].append(v6)\n\ndef f2():\n    v1 = 0\n    for v2 in range(v4):\n        v3 = v1 % v3\n        v4 = f1(v2[v2])\n        v5 = v5[v4]\n        if len(v5) == 0:\n            return -1\n        if v2 == 0 and v5[0] == 0:\n            v1 = 0\n            continue\n        if v5[len(v5) - 1] <= v3:\n            v1 += v3 - v3\n            v3 = -1\n        v6 = bisect.bisect_right(v5, v3)\n        v7 = v5[v6]\n        if v3 != -1:\n            v1 += v7 - v3\n        else:\n            v1 += v7\n    return v1 + 1\nprint(f2())\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import bisect\nv1 = input()\nv2 = input()\nv3 = len(v1)\nv4 = len(v2)\nv5 = [[] for v6 in range(28)]\n\ndef f1(a1):\n    return ord(a1) - 97\nfor v6 in range(v3):\n    v7 = f1(v1[v6])\n    v5[v7].append(v6)\n\ndef f2():\n    v1 = 0\n    for v2 in range(v4):\n        v3 = v1 % v3\n        v4 = f1(v2[v2])\n        v5 = v5[v4]\n        if len(v5) == 0:\n            return -1\n        if v2 == 0 and v5[0] == 0:\n            v1 = 0\n            continue\n        if v5[len(v5) - 1] <= v3:\n            v1 += v3 - v3\n            v3 = -1\n        v6 = bisect.bisect_right(v5, v3)\n        v7 = v5[v6]\n        if v3 != -1:\n            v1 += v7 - v3\n        else:\n            v1 += v7\n    return v1 + 1\nprint(f2())\n"}
{"id": "llm_code\\p03476__s510621773.py", "text": "from itertools import accumulate\n\ndef f1(a1):\n    v1 = [n & 1 for v2 in range(a1 + 1)]\n    v1[1] = 0\n    v1[2] = 1\n    v3 = [0] * (a1 + 1)\n    v4 = 1\n    while True:\n        while not v1[v4]:\n            v4 += 2\n        if v4 * v4 > a1:\n            for v5 in range(v4, a1 + 1, 2):\n                if v1[v5 + 1 >> 1]:\n                    v3[v5] = 1\n            return v3\n        if v1[v4 + 1 >> 1]:\n            v3[v4] = 1\n        for v5 in range(v4 * 2, a1 + 1, v4):\n            v1[v5] = 0\n        v4 += 2\nv1 = f1(10 ** 5)\nv2 = list(accumulate(v1))\nv3 = int(input())\nfor v4 in range(v3):\n    v5, v6 = map(int, input().split())\n    print(v2[v6] - v2[v5 - 1])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from itertools import accumulate\n\ndef f1(a1):\n    v1 = [n & 1 for v2 in range(a1 + 1)]\n    v1[1] = 0\n    v1[2] = 1\n    v3 = [0] * (a1 + 1)\n    v4 = 1\n    while True:\n        while not v1[v4]:\n            v4 += 2\n        if v4 * v4 > a1:\n            for v5 in range(v4, a1 + 1, 2):\n                if v1[v5 + 1 >> 1]:\n                    v3[v5] = 1\n            return v3\n        if v1[v4 + 1 >> 1]:\n            v3[v4] = 1\n        for v5 in range(v4 * 2, a1 + 1, v4):\n            v1[v5] = 0\n        v4 += 2\nv1 = f1(10 ** 5)\nv2 = list(accumulate(v1))\nv3 = int(input())\nfor v4 in range(v3):\n    v5, v6 = map(int, input().split())\n    print(v2[v6] - v2[v5 - 1])\n"}
{"id": "llm_code\\p03971__s568729278.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = input()\nv2 += v3\nv5 = 0\nv6 = 0\nfor v7 in range(v1):\n    if v4[v7] == 'a':\n        if v5 < v2:\n            print('Yes')\n            v5 += 1\n        else:\n            print('No')\n    elif v4[v7] == 'b':\n        if v5 < v2 and v6 < v3:\n            print('Yes')\n            v5 += 1\n            v6 += 1\n        else:\n            print('No')\n    else:\n        print('No')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = input()\nv2 += v3\nv5 = 0\nv6 = 0\nfor v7 in range(v1):\n    if v4[v7] == 'a':\n        if v5 < v2:\n            print('Yes')\n            v5 += 1\n        else:\n            print('No')\n    elif v4[v7] == 'b':\n        if v5 < v2 and v6 < v3:\n            print('Yes')\n            v5 += 1\n            v6 += 1\n        else:\n            print('No')\n    else:\n        print('No')\n"}
{"id": "human_code\\top-k-frequent-elements__part2.py", "text": "from random import randint\n\nclass C1(object):\n\n    def topKFrequent(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.Counter(a1)\n        v2 = []\n        for v3, v4 in v1.items():\n            v2.append((-v4, v3))\n        self.kthElement(v2, a2 - 1)\n        v5 = []\n        for v6 in range(a2):\n            v5.append(v2[v6][1])\n        return v5\n\n    def kthElement(self, a1, a2):\n\n        def PartitionAroundPivot(a1, a2, a3, a4):\n            v1 = a4[a3]\n            v2 = a1\n            a4[a3], a4[a2] = (a4[a2], a4[a3])\n            for v3 in range(a1, a2):\n                if a4[v3] < v1:\n                    a4[v3], a4[v2] = (a4[v2], a4[v3])\n                    v2 += 1\n            a4[a2], a4[v2] = (a4[v2], a4[a2])\n            return v2\n        v1, v2 = (0, len(a1) - 1)\n        while v1 <= v2:\n            v3 = randint(v1, v2)\n            v4 = PartitionAroundPivot(v1, v2, v3, a1)\n            if v4 == a2:\n                return\n            elif v4 > a2:\n                v2 = v4 - 1\n            else:\n                v1 = v4 + 1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from random import randint\n\nclass C1(object):\n\n    def topKFrequent(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.Counter(a1)\n        v2 = []\n        for v3, v4 in v1.items():\n            v2.append((-v4, v3))\n        self.kthElement(v2, a2 - 1)\n        v5 = []\n        for v6 in range(a2):\n            v5.append(v2[v6][1])\n        return v5\n\n    def kthElement(self, a1, a2):\n\n        def PartitionAroundPivot(a1, a2, a3, a4):\n            v1 = a4[a3]\n            v2 = a1\n            a4[a3], a4[a2] = (a4[a2], a4[a3])\n            for v3 in range(a1, a2):\n                if a4[v3] < v1:\n                    a4[v3], a4[v2] = (a4[v2], a4[v3])\n                    v2 += 1\n            a4[a2], a4[v2] = (a4[v2], a4[a2])\n            return v2\n        v1, v2 = (0, len(a1) - 1)\n        while v1 <= v2:\n            v3 = randint(v1, v2)\n            v4 = PartitionAroundPivot(v1, v2, v3, a1)\n            if v4 == a2:\n                return\n            elif v4 > a2:\n                v2 = v4 - 1\n            else:\n                v1 = v4 + 1\n"}
{"id": "human_code\\zuma-game__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def findMinStep(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def shrink(a1):\n            while True:\n                v1 = 0\n                for v2 in range(len(a1)):\n                    while v1 < len(a1) and a1[v2] == a1[v1]:\n                        v1 += 1\n                    if v1 - v2 >= 3:\n                        a1 = a1[0:v2] + a1[v1:]\n                        break\n                else:\n                    break\n            return a1\n\n        def findMinStepHelper(a1, a2, a3):\n            if not a1:\n                return 0\n            if not a2:\n                return float('inf')\n            if tuple(a2) in a3[tuple(a1)]:\n                return a3[tuple(a1)][tuple(a2)]\n            v1 = float('inf')\n            for v2 in range(len(a2)):\n                for v3 in range(len(a1) + 1):\n                    v4 = shrink(a1[0:v3] + a2[v2:v2 + 1] + a1[v3:])\n                    v5 = a2[0:v2] + a2[v2 + 1:]\n                    v1 = min(v1, findMinStepHelper(v4, v5, a3) + 1)\n            a3[tuple(a1)][tuple(a2)] = v1\n            return v1\n        v1 = collections.defaultdict(dict)\n        a1, a2 = (list(a1), list(a2))\n        v4 = findMinStepHelper(a1, a2, v1)\n        return -1 if v4 == float('inf') else v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def findMinStep(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def shrink(a1):\n            while True:\n                v1 = 0\n                for v2 in range(len(a1)):\n                    while v1 < len(a1) and a1[v2] == a1[v1]:\n                        v1 += 1\n                    if v1 - v2 >= 3:\n                        a1 = a1[0:v2] + a1[v1:]\n                        break\n                else:\n                    break\n            return a1\n\n        def findMinStepHelper(a1, a2, a3):\n            if not a1:\n                return 0\n            if not a2:\n                return float('inf')\n            if tuple(a2) in a3[tuple(a1)]:\n                return a3[tuple(a1)][tuple(a2)]\n            v1 = float('inf')\n            for v2 in range(len(a2)):\n                for v3 in range(len(a1) + 1):\n                    v4 = shrink(a1[0:v3] + a2[v2:v2 + 1] + a1[v3:])\n                    v5 = a2[0:v2] + a2[v2 + 1:]\n                    v1 = min(v1, findMinStepHelper(v4, v5, a3) + 1)\n            a3[tuple(a1)][tuple(a2)] = v1\n            return v1\n        v1 = collections.defaultdict(dict)\n        a1, a2 = (list(a1), list(a2))\n        v4 = findMinStepHelper(a1, a2, v1)\n        return -1 if v4 == float('inf') else v4\n"}
{"id": "human_code\\tweet-counts-per-frequency__part1.py", "text": "import collections\nimport random\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a2\n        self.nexts = [None] * a1\n        self.prevs = [None] * a1\n\nclass C2(object):\n    v1, v2 = (1, 2)\n    v3 = 32\n\n    def __init__(self, a1=float('inf'), a2=False):\n        random.seed(0)\n        self.__head = C1()\n        self.__len = 0\n        self.__can_duplicated = a2\n        self.add(a1)\n\n    def lower_bound(self, a1):\n        return self.__lower_bound(a1, self.__find_prev_nodes(a1))\n\n    def find(self, a1):\n        return self.__find(a1, self.__find_prev_nodes(a1))\n\n    def add(self, a1):\n        if not self.__can_duplicated and self.find(a1):\n            return False\n        v1 = C1(self.__random_level(), a1)\n        if len(self.__head.nexts) < len(v1.nexts):\n            self.__head.nexts.extend([None] * (len(v1.nexts) - len(self.__head.nexts)))\n        v2 = self.__find_prev_nodes(a1)\n        for v3 in range(len(v1.nexts)):\n            v1.nexts[v3] = v2[v3].nexts[v3]\n            if v2[v3].nexts[v3]:\n                v2[v3].nexts[v3].prevs[v3] = v1\n            v2[v3].nexts[v3] = v1\n            v1.prevs[v3] = v2[v3]\n        self.__len += 1\n        return True\n\n    def remove(self, a1):\n        v1 = self.__find_prev_nodes(a1)\n        v2 = self.__find(a1, v1)\n        if not v2:\n            return False\n        self.__len -= 1\n        for v3 in reversed(range(len(v2.nexts))):\n            v1[v3].nexts[v3] = v2.nexts[v3]\n            if v2.nexts[v3]:\n                v2.nexts[v3].prevs[v3] = v1[v3]\n            if not self.__head.nexts[v3]:\n                self.__head.nexts.pop()\n        return True\n\n    def __lower_bound(self, a1, a2):\n        if a2:\n            v1 = a2[0].nexts[0]\n            if v1:\n                return v1\n        return None\n\n    def __find(self, a1, a2):\n        v1 = self.__lower_bound(a1, a2)\n        if v1 and v1.val == a1:\n            return v1\n        return None\n\n    def __find_prev_nodes(self, a1):\n        v1 = [None] * len(self.__head.nexts)\n        v2 = self.__head\n        for v3 in reversed(range(len(self.__head.nexts))):\n            while v2.nexts[v3] and v2.nexts[v3].val < a1:\n                v2 = v2.nexts[v3]\n            v1[v3] = v2\n        return v1\n\n    def __random_level(self):\n        v1 = 1\n        while random.randint(1, C2.P_DENOMINATOR) <= C2.P_NUMERATOR and v1 < C2.MAX_LEVEL:\n            v1 += 1\n        return v1\n\n    def __len__(self):\n        return self.__len - 1\n\n    def __str__(self):\n        v1 = []\n        for v2 in reversed(range(len(self.__head.nexts))):\n            v1.append([])\n            v3 = self.__head.nexts[v2]\n            while v3:\n                v1[-1].append(str(v3.val))\n                v3 = v3.nexts[v2]\n        return '\\n'.join(['->'.join(x) for v4 in v1])\n\nclass C3(object):\n\n    def __init__(self):\n        self.__records = collections.defaultdict(lambda: C2(can_duplicated=True))\n        self.__lookup = {'minute': 60, 'hour': 3600, 'day': 86400}\n\n    def recordTweet(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__records[a1].add(a2)\n\n    def getTweetCountsPerFrequency(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = self.__lookup[a1]\n        v2 = [0] * ((a4 - a3) // v1 + 1)\n        v3 = self.__records[a2].lower_bound(a3)\n        while v3 is not None and v3.val <= a4:\n            v2[(v3.val - a3) // v1] += 1\n            v3 = v3.nexts[0]\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport random\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a2\n        self.nexts = [None] * a1\n        self.prevs = [None] * a1\n\nclass C2(object):\n    v1, v2 = (1, 2)\n    v3 = 32\n\n    def __init__(self, a1=float('inf'), a2=False):\n        random.seed(0)\n        self.__head = C1()\n        self.__len = 0\n        self.__can_duplicated = a2\n        self.add(a1)\n\n    def lower_bound(self, a1):\n        return self.__lower_bound(a1, self.__find_prev_nodes(a1))\n\n    def find(self, a1):\n        return self.__find(a1, self.__find_prev_nodes(a1))\n\n    def add(self, a1):\n        if not self.__can_duplicated and self.find(a1):\n            return False\n        v1 = C1(self.__random_level(), a1)\n        if len(self.__head.nexts) < len(v1.nexts):\n            self.__head.nexts.extend([None] * (len(v1.nexts) - len(self.__head.nexts)))\n        v2 = self.__find_prev_nodes(a1)\n        for v3 in range(len(v1.nexts)):\n            v1.nexts[v3] = v2[v3].nexts[v3]\n            if v2[v3].nexts[v3]:\n                v2[v3].nexts[v3].prevs[v3] = v1\n            v2[v3].nexts[v3] = v1\n            v1.prevs[v3] = v2[v3]\n        self.__len += 1\n        return True\n\n    def remove(self, a1):\n        v1 = self.__find_prev_nodes(a1)\n        v2 = self.__find(a1, v1)\n        if not v2:\n            return False\n        self.__len -= 1\n        for v3 in reversed(range(len(v2.nexts))):\n            v1[v3].nexts[v3] = v2.nexts[v3]\n            if v2.nexts[v3]:\n                v2.nexts[v3].prevs[v3] = v1[v3]\n            if not self.__head.nexts[v3]:\n                self.__head.nexts.pop()\n        return True\n\n    def __lower_bound(self, a1, a2):\n        if a2:\n            v1 = a2[0].nexts[0]\n            if v1:\n                return v1\n        return None\n\n    def __find(self, a1, a2):\n        v1 = self.__lower_bound(a1, a2)\n        if v1 and v1.val == a1:\n            return v1\n        return None\n\n    def __find_prev_nodes(self, a1):\n        v1 = [None] * len(self.__head.nexts)\n        v2 = self.__head\n        for v3 in reversed(range(len(self.__head.nexts))):\n            while v2.nexts[v3] and v2.nexts[v3].val < a1:\n                v2 = v2.nexts[v3]\n            v1[v3] = v2\n        return v1\n\n    def __random_level(self):\n        v1 = 1\n        while random.randint(1, C2.P_DENOMINATOR) <= C2.P_NUMERATOR and v1 < C2.MAX_LEVEL:\n            v1 += 1\n        return v1\n\n    def __len__(self):\n        return self.__len - 1\n\n    def __str__(self):\n        v1 = []\n        for v2 in reversed(range(len(self.__head.nexts))):\n            v1.append([])\n            v3 = self.__head.nexts[v2]\n            while v3:\n                v1[-1].append(str(v3.val))\n                v3 = v3.nexts[v2]\n        return '\\n'.join(['->'.join(x) for v4 in v1])\n\nclass C3(object):\n\n    def __init__(self):\n        self.__records = collections.defaultdict(lambda: C2(can_duplicated=True))\n        self.__lookup = {'minute': 60, 'hour': 3600, 'day': 86400}\n\n    def recordTweet(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__records[a1].add(a2)\n\n    def getTweetCountsPerFrequency(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = self.__lookup[a1]\n        v2 = [0] * ((a4 - a3) // v1 + 1)\n        v3 = self.__records[a2].lower_bound(a3)\n        while v3 is not None and v3.val <= a4:\n            v2[(v3.val - a3) // v1] += 1\n            v3 = v3.nexts[0]\n        return v2\n"}
{"id": "human_code\\next-palindrome-using-same-digits.py", "text": "class C1(object):\n\n    def nextPalindrome(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def next_permutation(a1, a2, a3):\n\n            def reverse(a1, a2, a3):\n                v1, v2 = (a2, a3 - 1)\n                while v1 < v2:\n                    a1[v1], a1[v2] = (a1[v2], a1[v1])\n                    v1 += 1\n                    v2 -= 1\n            v1, v2 = (a2 - 1, a2)\n            for v3 in reversed(range(a2, a3 - 1)):\n                if a1[v3] < a1[v3 + 1]:\n                    v1 = v3\n                    break\n            else:\n                reverse(a1, a2, a3)\n                return False\n            for v3 in reversed(range(v1 + 1, a3)):\n                if a1[v3] > a1[v1]:\n                    v2 = v3\n                    break\n            a1[v1], a1[v2] = (a1[v2], a1[v1])\n            reverse(a1, v1 + 1, a3)\n            return True\n        v1 = list(a1)\n        if not next_permutation(v1, 0, len(v1) // 2):\n            return ''\n        for v2 in range(len(v1) // 2):\n            v1[-1 - v2] = v1[v2]\n        return ''.join(v1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def nextPalindrome(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def next_permutation(a1, a2, a3):\n\n            def reverse(a1, a2, a3):\n                v1, v2 = (a2, a3 - 1)\n                while v1 < v2:\n                    a1[v1], a1[v2] = (a1[v2], a1[v1])\n                    v1 += 1\n                    v2 -= 1\n            v1, v2 = (a2 - 1, a2)\n            for v3 in reversed(range(a2, a3 - 1)):\n                if a1[v3] < a1[v3 + 1]:\n                    v1 = v3\n                    break\n            else:\n                reverse(a1, a2, a3)\n                return False\n            for v3 in reversed(range(v1 + 1, a3)):\n                if a1[v3] > a1[v1]:\n                    v2 = v3\n                    break\n            a1[v1], a1[v2] = (a1[v2], a1[v1])\n            reverse(a1, v1 + 1, a3)\n            return True\n        v1 = list(a1)\n        if not next_permutation(v1, 0, len(v1) // 2):\n            return ''\n        for v2 in range(len(v1) // 2):\n            v1[-1 - v2] = v1[v2]\n        return ''.join(v1)\n"}
{"id": "llm_code\\minimum-window-substring__grok-4.1-fast__v1.py", "text": "from collections import defaultdict\n\nclass C1:\n\n    def minWindow(self, a1: str, a2: str) -> str:\n        if not a1 or not a2:\n            return ''\n        v1 = defaultdict(int)\n        for v2 in a2:\n            v1[v2] += 1\n        v3 = len(a2)\n        v4 = defaultdict(int)\n        v5 = 0\n        v6 = 0\n        v7 = float('inf')\n        v8 = 0\n        for v9 in range(len(a1)):\n            v4[a1[v9]] += 1\n            if a1[v9] in v1 and v4[a1[v9]] <= v1[a1[v9]]:\n                v5 += 1\n            while v5 == v3 and v6 <= v9:\n                v10 = v9 - v6 + 1\n                if v10 < v7:\n                    v7 = v10\n                    v8 = v6\n                v4[a1[v6]] -= 1\n                if a1[v6] in v1 and v4[a1[v6]] < v1[a1[v6]]:\n                    v5 -= 1\n                v6 += 1\n        return a1[v8:v8 + v7] if v7 != float('inf') else ''\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import defaultdict\n\nclass C1:\n\n    def minWindow(self, a1: str, a2: str) -> str:\n        if not a1 or not a2:\n            return ''\n        v1 = defaultdict(int)\n        for v2 in a2:\n            v1[v2] += 1\n        v3 = len(a2)\n        v4 = defaultdict(int)\n        v5 = 0\n        v6 = 0\n        v7 = float('inf')\n        v8 = 0\n        for v9 in range(len(a1)):\n            v4[a1[v9]] += 1\n            if a1[v9] in v1 and v4[a1[v9]] <= v1[a1[v9]]:\n                v5 += 1\n            while v5 == v3 and v6 <= v9:\n                v10 = v9 - v6 + 1\n                if v10 < v7:\n                    v7 = v10\n                    v8 = v6\n                v4[a1[v6]] -= 1\n                if a1[v6] in v1 and v4[a1[v6]] < v1[a1[v6]]:\n                    v5 -= 1\n                v6 += 1\n        return a1[v8:v8 + v7] if v7 != float('inf') else ''\n"}
{"id": "human_code\\p02763__s349624520.py", "text": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\n\ndef f1():\n    return sys.stdin.readline().strip()\n\ndef f2():\n    return int(f1())\n\ndef f3():\n    return map(int, f1().split())\n\ndef f4():\n    return list(map(int, f1().split()))\nsys.setrecursionlimit(10 ** 9)\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3 = f2()\nv4 = list(f1())\nv5 = f2()\n\nclass C1:\n\n    def __init__(self, a1):\n        self.size = a1\n        self.tree = [0] * (a1 + 1)\n\n    def sum(self, a1):\n        v1 = 0\n        while a1 > 0:\n            v1 += self.tree[a1]\n            a1 -= a1 & -a1\n        return v1\n\n    def add(self, a1, a2):\n        while a1 <= self.size:\n            self.tree[a1] += a2\n            a1 += a1 & -a1\nv6 = defaultdict(int)\nfor v7, v8 in enumerate(ascii_lowercase):\n    v6[v8] = v7\nv9 = [None] * len(ascii_uppercase)\nfor v7 in range(len(ascii_uppercase)):\n    v9[v7] = C1(v3)\nfor v7 in range(v3):\n    v9[v6[v4[v7]]].add(v7 + 1, 1)\nfor v10 in range(v5):\n    v11, v12, v13 = f1().split()\n    if v11 == '1':\n        v12 = int(v12)\n        v8 = v4[v12 - 1]\n        v9[v6[v8]].add(v12, -1)\n        v9[v6[v13]].add(v12, 1)\n        v4[v12 - 1] = v13\n    if v11 == '2':\n        v14 = 0\n        v12, v13 = (int(v12), int(v13))\n        for v7 in range(len(ascii_uppercase)):\n            v14 += v9[v7].sum(v13) - v9[v7].sum(v12 - 1) >= 1\n        print(v14)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\n\ndef f1():\n    return sys.stdin.readline().strip()\n\ndef f2():\n    return int(f1())\n\ndef f3():\n    return map(int, f1().split())\n\ndef f4():\n    return list(map(int, f1().split()))\nsys.setrecursionlimit(10 ** 9)\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3 = f2()\nv4 = list(f1())\nv5 = f2()\n\nclass C1:\n\n    def __init__(self, a1):\n        self.size = a1\n        self.tree = [0] * (a1 + 1)\n\n    def sum(self, a1):\n        v1 = 0\n        while a1 > 0:\n            v1 += self.tree[a1]\n            a1 -= a1 & -a1\n        return v1\n\n    def add(self, a1, a2):\n        while a1 <= self.size:\n            self.tree[a1] += a2\n            a1 += a1 & -a1\nv6 = defaultdict(int)\nfor v7, v8 in enumerate(ascii_lowercase):\n    v6[v8] = v7\nv9 = [None] * len(ascii_uppercase)\nfor v7 in range(len(ascii_uppercase)):\n    v9[v7] = C1(v3)\nfor v7 in range(v3):\n    v9[v6[v4[v7]]].add(v7 + 1, 1)\nfor v10 in range(v5):\n    v11, v12, v13 = f1().split()\n    if v11 == '1':\n        v12 = int(v12)\n        v8 = v4[v12 - 1]\n        v9[v6[v8]].add(v12, -1)\n        v9[v6[v13]].add(v12, 1)\n        v4[v12 - 1] = v13\n    if v11 == '2':\n        v14 = 0\n        v12, v13 = (int(v12), int(v13))\n        for v7 in range(len(ascii_uppercase)):\n            v14 += v9[v7].sum(v13) - v9[v7].sum(v12 - 1) >= 1\n        print(v14)\n"}
{"id": "llm_code\\closest-leaf-in-a-binary-tree__grok-4.1-fast__v1.py", "text": "from collections import defaultdict, deque\n\nclass C1:\n\n    def findClosestLeaf(self, a1, a2):\n        v1 = defaultdict(list)\n        v2 = set()\n        v3 = deque([a1])\n        while v3:\n            v4 = v3.popleft()\n            if not v4.left and (not v4.right):\n                v2.add(v4.val)\n            if v4.left:\n                v1[v4.val].append(v4.left.val)\n                v1[v4.left.val].append(v4.val)\n                v3.append(v4.left)\n            if v4.right:\n                v1[v4.val].append(v4.right.val)\n                v1[v4.right.val].append(v4.val)\n                v3.append(v4.right)\n        v5 = deque([a2])\n        v6 = set([a2])\n        while v5:\n            v7 = v5.popleft()\n            if v7 in v2:\n                return v7\n            for v8 in v1[v7]:\n                if v8 not in v6:\n                    v6.add(v8)\n                    v5.append(v8)\n        return 0\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import defaultdict, deque\n\nclass C1:\n\n    def findClosestLeaf(self, a1, a2):\n        v1 = defaultdict(list)\n        v2 = set()\n        v3 = deque([a1])\n        while v3:\n            v4 = v3.popleft()\n            if not v4.left and (not v4.right):\n                v2.add(v4.val)\n            if v4.left:\n                v1[v4.val].append(v4.left.val)\n                v1[v4.left.val].append(v4.val)\n                v3.append(v4.left)\n            if v4.right:\n                v1[v4.val].append(v4.right.val)\n                v1[v4.right.val].append(v4.val)\n                v3.append(v4.right)\n        v5 = deque([a2])\n        v6 = set([a2])\n        while v5:\n            v7 = v5.popleft()\n            if v7 in v2:\n                return v7\n            for v8 in v1[v7]:\n                if v8 not in v6:\n                    v6.add(v8)\n                    v5.append(v8)\n        return 0\n"}
{"id": "llm_code\\p02975__s538564295.py", "text": "v1 = int(input())\nv2 = [int(s) for v3 in input().split(' ')]\nv4 = {}\nfor v5 in v2:\n    if v5 in v4:\n        v4[v5] += 1\n    else:\n        v4[v5] = 1\nv6 = list(v4.keys())\nv7 = len(v6)\nif v1 < 3:\n    v8 = False\nelse:\n    v8 = False\n    if 0 in v6:\n        for v9, v10 in v4.items():\n            if v10 >= 2 and v9 != 0:\n                v8 = True\n                break\n    if not v8:\n        for v11 in range(v7):\n            for v12 in range(v11 + 1, v7):\n                v13 = v6[v11] ^ v6[v12]\n                if v13 in v6 and v13 != v6[v11] and (v13 != v6[v12]) and (v4[v13] >= 2):\n                    v8 = True\n                    break\n            if v8:\n                break\nprint('Yes' if v8 else 'No')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [int(s) for v3 in input().split(' ')]\nv4 = {}\nfor v5 in v2:\n    if v5 in v4:\n        v4[v5] += 1\n    else:\n        v4[v5] = 1\nv6 = list(v4.keys())\nv7 = len(v6)\nif v1 < 3:\n    v8 = False\nelse:\n    v8 = False\n    if 0 in v6:\n        for v9, v10 in v4.items():\n            if v10 >= 2 and v9 != 0:\n                v8 = True\n                break\n    if not v8:\n        for v11 in range(v7):\n            for v12 in range(v11 + 1, v7):\n                v13 = v6[v11] ^ v6[v12]\n                if v13 in v6 and v13 != v6[v11] and (v13 != v6[v12]) and (v4[v13] >= 2):\n                    v8 = True\n                    break\n            if v8:\n                break\nprint('Yes' if v8 else 'No')\n"}
{"id": "human_code\\kth-largest-element-in-an-array__part1.py", "text": "from random import randint\n\nclass C1(object):\n\n    def findKthLargest(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = randint(v1, v2)\n                v4, v5 = tri_partition(a1, v1, v2, a1[v3], a3)\n                if v4 <= a2 <= v5:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v5 + 1\n        nth_element(a1, a2 - 1, compare=lambda a, b: a > b)\n        return a1[a2 - 1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from random import randint\n\nclass C1(object):\n\n    def findKthLargest(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = randint(v1, v2)\n                v4, v5 = tri_partition(a1, v1, v2, a1[v3], a3)\n                if v4 <= a2 <= v5:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v5 + 1\n        nth_element(a1, a2 - 1, compare=lambda a, b: a > b)\n        return a1[a2 - 1]\n"}
{"id": "human_code\\populating-next-right-pointers-in-each-node-ii.py", "text": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None, a4=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n        self.next = a4\n\nclass C2(object):\n\n    def connect(self, a1):\n        v1 = a1\n        v2 = C1(0)\n        v3 = v2\n        while a1:\n            while a1:\n                if a1.left:\n                    v3.next = a1.left\n                    v3 = v3.__next__\n                if a1.right:\n                    v3.next = a1.right\n                    v3 = v3.__next__\n                a1 = a1.__next__\n            a1, v3 = (v2.__next__, v2)\n            v3.next = None\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None, a4=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n        self.next = a4\n\nclass C2(object):\n\n    def connect(self, a1):\n        v1 = a1\n        v2 = C1(0)\n        v3 = v2\n        while a1:\n            while a1:\n                if a1.left:\n                    v3.next = a1.left\n                    v3 = v3.__next__\n                if a1.right:\n                    v3.next = a1.right\n                    v3 = v3.__next__\n                a1 = a1.__next__\n            a1, v3 = (v2.__next__, v2)\n            v3.next = None\n        return v1\n"}
{"id": "human_code\\find-all-good-strings.py", "text": "class C1(object):\n\n    def findGoodStrings(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def getPrefix(a1):\n            v1 = [-1] * len(a1)\n            v2 = -1\n            for v3 in range(1, len(a1)):\n                while v2 != -1 and a1[v2 + 1] != a1[v3]:\n                    v2 = v1[v2]\n                if a1[v2 + 1] == a1[v3]:\n                    v2 += 1\n                v1[v3] = v2\n            return v1\n        v2 = getPrefix(a4)\n        v3 = [[[[0] * len(a4) for v4 in range(2)] for v4 in range(2)] for v4 in range(2)]\n        v3[0][0][0][0] = 1\n        for v5 in range(a1):\n            v3[(v5 + 1) % 2] = [[[0] * len(a4) for v4 in range(2)] for v4 in range(2)]\n            for v6 in range(2):\n                for v7 in range(2):\n                    v8 = 'a' if v6 else a2[v5]\n                    v9 = 'z' if v7 else a3[v5]\n                    for v10 in range(len(a4)):\n                        if not v3[v5 % 2][v6][v7][v10]:\n                            continue\n                        for v11 in range(ord(v8) - ord('a'), ord(v9) - ord('a') + 1):\n                            v11 = chr(v11 + ord('a'))\n                            v12 = v10 - 1\n                            while v12 != -1 and a4[v12 + 1] != v11:\n                                v12 = v2[v12]\n                            if a4[v12 + 1] == v11:\n                                v12 += 1\n                            if v12 + 1 == len(a4):\n                                continue\n                            v3[(v5 + 1) % 2][v6 or a2[v5] != v11][v7 or a3[v5] != v11][v12 + 1] = (v3[(v5 + 1) % 2][v6 or a2[v5] != v11][v7 or a3[v5] != v11][v12 + 1] + v3[v5 % 2][v6][v7][v10]) % v1\n        v13 = 0\n        for v6 in range(2):\n            for v7 in range(2):\n                for v10 in range(len(a4)):\n                    v13 = (v13 + v3[a1 % 2][v6][v7][v10]) % v1\n        return v13\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findGoodStrings(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def getPrefix(a1):\n            v1 = [-1] * len(a1)\n            v2 = -1\n            for v3 in range(1, len(a1)):\n                while v2 != -1 and a1[v2 + 1] != a1[v3]:\n                    v2 = v1[v2]\n                if a1[v2 + 1] == a1[v3]:\n                    v2 += 1\n                v1[v3] = v2\n            return v1\n        v2 = getPrefix(a4)\n        v3 = [[[[0] * len(a4) for v4 in range(2)] for v4 in range(2)] for v4 in range(2)]\n        v3[0][0][0][0] = 1\n        for v5 in range(a1):\n            v3[(v5 + 1) % 2] = [[[0] * len(a4) for v4 in range(2)] for v4 in range(2)]\n            for v6 in range(2):\n                for v7 in range(2):\n                    v8 = 'a' if v6 else a2[v5]\n                    v9 = 'z' if v7 else a3[v5]\n                    for v10 in range(len(a4)):\n                        if not v3[v5 % 2][v6][v7][v10]:\n                            continue\n                        for v11 in range(ord(v8) - ord('a'), ord(v9) - ord('a') + 1):\n                            v11 = chr(v11 + ord('a'))\n                            v12 = v10 - 1\n                            while v12 != -1 and a4[v12 + 1] != v11:\n                                v12 = v2[v12]\n                            if a4[v12 + 1] == v11:\n                                v12 += 1\n                            if v12 + 1 == len(a4):\n                                continue\n                            v3[(v5 + 1) % 2][v6 or a2[v5] != v11][v7 or a3[v5] != v11][v12 + 1] = (v3[(v5 + 1) % 2][v6 or a2[v5] != v11][v7 or a3[v5] != v11][v12 + 1] + v3[v5 % 2][v6][v7][v10]) % v1\n        v13 = 0\n        for v6 in range(2):\n            for v7 in range(2):\n                for v10 in range(len(a4)):\n                    v13 = (v13 + v3[a1 % 2][v6][v7][v10]) % v1\n        return v13\n"}
{"id": "human_code\\reverse-nodes-in-even-length-groups.py", "text": "class C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.next = a2\n\nclass C2(object):\n\n    def reverseEvenLengthGroups(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (a1, 2)\n        while v1.__next__:\n            v3, v4 = (v1, 0)\n            for v5 in range(v2):\n                if not v3.__next__:\n                    break\n                v4 += 1\n                v3 = v3.__next__\n            v2 += 1\n            if v4 % 2:\n                v1 = v3\n                continue\n            v3, v6 = (v1.__next__, None)\n            for v5 in range(v4):\n                v3.next, v3, v6 = (v6, v3.next, v3)\n            v1.next.next, v1.next, v1 = (v3, v6, v1.next)\n        return a1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.next = a2\n\nclass C2(object):\n\n    def reverseEvenLengthGroups(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (a1, 2)\n        while v1.__next__:\n            v3, v4 = (v1, 0)\n            for v5 in range(v2):\n                if not v3.__next__:\n                    break\n                v4 += 1\n                v3 = v3.__next__\n            v2 += 1\n            if v4 % 2:\n                v1 = v3\n                continue\n            v3, v6 = (v1.__next__, None)\n            for v5 in range(v4):\n                v3.next, v3, v6 = (v6, v3.next, v3)\n            v1.next.next, v1.next, v1 = (v3, v6, v1.next)\n        return a1\n"}
{"id": "human_code\\maximum-number-of-tasks-you-can-assign__part4.py", "text": "import bisect\n\nclass C1(object):\n\n    def maxTaskAssign(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4, a5):\n            v1 = a2[-a5:]\n            for v2 in a1[-a5:]:\n                v3 = bisect.bisect_left(v1, v2)\n                if v3 != len(v1):\n                    v1.pop(v3)\n                    continue\n                if a3:\n                    v3 = bisect.bisect_left(v1, v2 - a4)\n                    if v3 != len(v1):\n                        v1.pop(v3)\n                        a3 -= 1\n                        continue\n                return False\n            return True\n        a1.sort(reverse=True)\n        a2.sort()\n        v1, v2 = (1, min(len(a2), len(a1)))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if not check(a1, a2, a3, a4, v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def maxTaskAssign(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4, a5):\n            v1 = a2[-a5:]\n            for v2 in a1[-a5:]:\n                v3 = bisect.bisect_left(v1, v2)\n                if v3 != len(v1):\n                    v1.pop(v3)\n                    continue\n                if a3:\n                    v3 = bisect.bisect_left(v1, v2 - a4)\n                    if v3 != len(v1):\n                        v1.pop(v3)\n                        a3 -= 1\n                        continue\n                return False\n            return True\n        a1.sort(reverse=True)\n        a2.sort()\n        v1, v2 = (1, min(len(a2), len(a1)))\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if not check(a1, a2, a3, a4, v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v2\n"}
{"id": "llm_code\\find-positive-integer-solution-for-a-given-equation__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def findSolution(self, a1, a2):\n        v1 = []\n        v2 = 1\n        while a1.f(v2, 1) < a2:\n            v2 += 1\n        v3 = 1\n        while a1.f(1, v3) < a2:\n            v3 += 1\n        for v4 in range(1, v2 + 1):\n            v5, v6 = (1, v3)\n            while v5 <= v6:\n                v7 = (v5 + v6) // 2\n                v8 = a1.f(v4, v7)\n                if v8 == a2:\n                    v1.append([v4, v7])\n                    break\n                elif v8 < a2:\n                    v5 = v7 + 1\n                else:\n                    v6 = v7 - 1\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def findSolution(self, a1, a2):\n        v1 = []\n        v2 = 1\n        while a1.f(v2, 1) < a2:\n            v2 += 1\n        v3 = 1\n        while a1.f(1, v3) < a2:\n            v3 += 1\n        for v4 in range(1, v2 + 1):\n            v5, v6 = (1, v3)\n            while v5 <= v6:\n                v7 = (v5 + v6) // 2\n                v8 = a1.f(v4, v7)\n                if v8 == a2:\n                    v1.append([v4, v7])\n                    break\n                elif v8 < a2:\n                    v5 = v7 + 1\n                else:\n                    v6 = v7 - 1\n        return v1\n"}
{"id": "human_code\\choose-edges-to-maximize-score-in-a-tree__part1.py", "text": "class C1(object):\n\n    def maxScore(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = [(0, 0) for v2 in range(len(adj))]\n            v3 = [(1, 0)]\n            while v3:\n                v4, v5 = v3.pop()\n                if v4 == 1:\n                    if not adj[v5]:\n                        continue\n                    v3.append((2, v5))\n                    for v6, v2 in adj[v5]:\n                        v3.append((1, v6))\n                elif v4 == 2:\n                    v7 = sum((max(v1[v6]) for v6, v8 in adj[v5]))\n                    v9 = max((v7 - max(v1[v6]) + (v1[v6][1] + v8) for v6, v8 in adj[v5]))\n                    v1[v5] = (v9, v7)\n            return max(v1[0])\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, (v4, v5) in enumerate(a1):\n            if v3 == 0:\n                continue\n            v1[v4].append((v3, v5))\n        return iter_dfs()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxScore(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1 = [(0, 0) for v2 in range(len(adj))]\n            v3 = [(1, 0)]\n            while v3:\n                v4, v5 = v3.pop()\n                if v4 == 1:\n                    if not adj[v5]:\n                        continue\n                    v3.append((2, v5))\n                    for v6, v2 in adj[v5]:\n                        v3.append((1, v6))\n                elif v4 == 2:\n                    v7 = sum((max(v1[v6]) for v6, v8 in adj[v5]))\n                    v9 = max((v7 - max(v1[v6]) + (v1[v6][1] + v8) for v6, v8 in adj[v5]))\n                    v1[v5] = (v9, v7)\n            return max(v1[0])\n        v1 = [[] for v2 in range(len(a1))]\n        for v3, (v4, v5) in enumerate(a1):\n            if v3 == 0:\n                continue\n            v1[v4].append((v3, v5))\n        return iter_dfs()\n"}
{"id": "human_code\\minimize-the-maximum-of-two-arrays__part2.py", "text": "class C1(object):\n\n    def minimizeSet(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lcm(a1, a2):\n            return a1 // gcd(a1, a2) * a2\n\n        def check(a1):\n            return a1 - a1 // a1 >= a3 and a1 - a1 // a2 >= a4 and (a1 - a1 // l >= a3 + a4)\n        v1 = lcm(a1, a2)\n        v2, v3 = (2, 2 ** 31 - 1)\n        while v2 <= v3:\n            v4 = v2 + (v3 - v2) // 2\n            if check(v4):\n                v3 = v4 - 1\n            else:\n                v2 = v4 + 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimizeSet(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lcm(a1, a2):\n            return a1 // gcd(a1, a2) * a2\n\n        def check(a1):\n            return a1 - a1 // a1 >= a3 and a1 - a1 // a2 >= a4 and (a1 - a1 // l >= a3 + a4)\n        v1 = lcm(a1, a2)\n        v2, v3 = (2, 2 ** 31 - 1)\n        while v2 <= v3:\n            v4 = v2 + (v3 - v2) // 2\n            if check(v4):\n                v3 = v4 - 1\n            else:\n                v2 = v4 + 1\n        return v2\n"}
{"id": "human_code\\p03438__s682275301.py", "text": "import bisect\nimport heapq\nimport itertools\nimport math\nimport operator\nimport os\nimport re\nimport string\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom functools import lru_cache, reduce\nfrom operator import itemgetter, mul, add, xor\nimport numpy as np\nif os.getenv('LOCAL'):\n    sys.stdin = open('_in.txt', 'r')\nsys.setrecursionlimit(10 ** 9)\nv1 = float('inf')\nv2 = 10 ** 18\nv3 = 10 ** 9 + 7\nv4 = int(sys.stdin.buffer.readline())\nv5 = list(map(int, sys.stdin.buffer.readline().split()))\nv6 = list(map(int, sys.stdin.buffer.readline().split()))\nv5 = np.array(v5, dtype=int)\nv6 = np.array(v6, dtype=int)\nv7 = v6.sum() - v5.sum()\nv8 = 0\nv9 = 0\nfor v10, v11 in zip(v5, v6):\n    if v11 < v10:\n        v9 += v10 - v11\n    if v10 < v11:\n        if (v11 - v10) % 2 == 0:\n            v8 += (v11 - v10) // 2\n        else:\n            v8 += (v11 - v10) // 2 + 1\n            v9 += 1\nif v8 > v9:\n    v12 = v8 - v9\n    v8 += v12\n    v9 += 2 * v12\nv13 = v9 == v8 and v9 == v7\nif v13:\n    print('Yes')\nelse:\n    print('No')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import bisect\nimport heapq\nimport itertools\nimport math\nimport operator\nimport os\nimport re\nimport string\nimport sys\nfrom collections import Counter, deque, defaultdict\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom fractions import gcd\nfrom functools import lru_cache, reduce\nfrom operator import itemgetter, mul, add, xor\nimport numpy as np\nif os.getenv('LOCAL'):\n    sys.stdin = open('_in.txt', 'r')\nsys.setrecursionlimit(10 ** 9)\nv1 = float('inf')\nv2 = 10 ** 18\nv3 = 10 ** 9 + 7\nv4 = int(sys.stdin.buffer.readline())\nv5 = list(map(int, sys.stdin.buffer.readline().split()))\nv6 = list(map(int, sys.stdin.buffer.readline().split()))\nv5 = np.array(v5, dtype=int)\nv6 = np.array(v6, dtype=int)\nv7 = v6.sum() - v5.sum()\nv8 = 0\nv9 = 0\nfor v10, v11 in zip(v5, v6):\n    if v11 < v10:\n        v9 += v10 - v11\n    if v10 < v11:\n        if (v11 - v10) % 2 == 0:\n            v8 += (v11 - v10) // 2\n        else:\n            v8 += (v11 - v10) // 2 + 1\n            v9 += 1\nif v8 > v9:\n    v12 = v8 - v9\n    v8 += v12\n    v9 += 2 * v12\nv13 = v9 == v8 and v9 == v7\nif v13:\n    print('Yes')\nelse:\n    print('No')\n"}
{"id": "human_code\\minimum-xor-sum-of-two-arrays__part1.py", "text": "class C1(object):\n\n    def minimumXORSum(self, a1, a2):\n\n        def hungarian(a1):\n            if not a1:\n                return (0, [])\n            v1, v2 = (len(a1) + 1, len(a1[0]) + 1)\n            v3, v4, v5, v6 = ([0] * v1, [0] * v2, [0] * v2, [0] * (v1 - 1))\n            for v7 in range(1, v1):\n                v5[0] = v7\n                v8 = 0\n                v9, v10 = ([float('inf')] * v2, [-1] * v2)\n                v11 = [False] * (v2 + 1)\n                while True:\n                    v11[v8] = True\n                    v12, v13, v14 = (v5[v8], None, float('inf'))\n                    for v15 in range(1, v2):\n                        if v11[v15]:\n                            continue\n                        v16 = a1[v12 - 1][v15 - 1] - v3[v12] - v4[v15]\n                        if v16 < v9[v15]:\n                            v9[v15], v10[v15] = (v16, v8)\n                        if v9[v15] < v14:\n                            v14, v13 = (v9[v15], v15)\n                    for v15 in range(v2):\n                        if v11[v15]:\n                            v3[v5[v15]] += v14\n                            v4[v15] -= v14\n                        else:\n                            v9[v15] -= v14\n                    v8 = v13\n                    if not v5[v8]:\n                        break\n                while v8:\n                    v13 = v10[v8]\n                    v5[v8], v8 = (v5[v13], v13)\n            for v15 in range(1, v2):\n                if v5[v15]:\n                    v6[v5[v15] - 1] = v15 - 1\n            return (-v4[0], v6)\n        v1 = [[0] * len(a2) for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            for v4 in range(len(a2)):\n                v1[v3][v4] = a1[v3] ^ a2[v4]\n        return hungarian(v1)[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumXORSum(self, a1, a2):\n\n        def hungarian(a1):\n            if not a1:\n                return (0, [])\n            v1, v2 = (len(a1) + 1, len(a1[0]) + 1)\n            v3, v4, v5, v6 = ([0] * v1, [0] * v2, [0] * v2, [0] * (v1 - 1))\n            for v7 in range(1, v1):\n                v5[0] = v7\n                v8 = 0\n                v9, v10 = ([float('inf')] * v2, [-1] * v2)\n                v11 = [False] * (v2 + 1)\n                while True:\n                    v11[v8] = True\n                    v12, v13, v14 = (v5[v8], None, float('inf'))\n                    for v15 in range(1, v2):\n                        if v11[v15]:\n                            continue\n                        v16 = a1[v12 - 1][v15 - 1] - v3[v12] - v4[v15]\n                        if v16 < v9[v15]:\n                            v9[v15], v10[v15] = (v16, v8)\n                        if v9[v15] < v14:\n                            v14, v13 = (v9[v15], v15)\n                    for v15 in range(v2):\n                        if v11[v15]:\n                            v3[v5[v15]] += v14\n                            v4[v15] -= v14\n                        else:\n                            v9[v15] -= v14\n                    v8 = v13\n                    if not v5[v8]:\n                        break\n                while v8:\n                    v13 = v10[v8]\n                    v5[v8], v8 = (v5[v13], v13)\n            for v15 in range(1, v2):\n                if v5[v15]:\n                    v6[v5[v15] - 1] = v15 - 1\n            return (-v4[0], v6)\n        v1 = [[0] * len(a2) for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            for v4 in range(len(a2)):\n                v1[v3][v4] = a1[v3] ^ a2[v4]\n        return hungarian(v1)[0]\n"}
{"id": "human_code\\verify-preorder-serialization-of-a-binary-tree.py", "text": "class C1(object):\n\n    def isValidSerialization(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def split_iter(a1, a2):\n            v1 = 0\n            for v2 in range(len(a1)):\n                if a1[v2] == a2:\n                    yield a1[v1:v2]\n                    v1 = v2 + 1\n            yield a1[v1:]\n        if not a1:\n            return False\n        v1, v2 = (0, a1.count(',') + 1)\n        for v3 in split_iter(a1, ','):\n            v2 -= 1\n            if v3 == '#':\n                v1 -= 1\n                if v1 < 0:\n                    break\n            else:\n                v1 += 1\n        return v2 == 0 and v1 < 0\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def isValidSerialization(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def split_iter(a1, a2):\n            v1 = 0\n            for v2 in range(len(a1)):\n                if a1[v2] == a2:\n                    yield a1[v1:v2]\n                    v1 = v2 + 1\n            yield a1[v1:]\n        if not a1:\n            return False\n        v1, v2 = (0, a1.count(',') + 1)\n        for v3 in split_iter(a1, ','):\n            v2 -= 1\n            if v3 == '#':\n                v1 -= 1\n                if v1 < 0:\n                    break\n            else:\n                v1 += 1\n        return v2 == 0 and v1 < 0\n"}
{"id": "llm_code\\p02697__s198868693.py", "text": "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom math import floor, ceil, sqrt, factorial, log\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter, defaultdict, deque\nfrom itertools import accumulate, permutations, combinations, product, combinations_with_replacement\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom operator import itemgetter\nfrom fractions import gcd\nv1 = 10 ** 9 + 7\nv2 = float('inf')\nv3 = -float('inf')\n\ndef f1():\n    return int(sys.stdin.readline().rstrip())\n\ndef f2():\n    return map(int, sys.stdin.readline().rstrip().split())\n\ndef f3():\n    return list(f2())\n\ndef f4(a1: int):\n    return [f1() for v1 in range(a1)]\n\ndef f5(a1: int):\n    return [f3() for v1 in range(a1)]\n\ndef f6():\n    return sys.stdin.readline().rstrip()\n\ndef f7():\n    return sys.stdin.readline().rstrip().split()\n\ndef f8():\n    return list(f7())\n\ndef f9(a1: int):\n    return [f6() for v1 in range(a1)]\n\ndef f10(a1: int):\n    return [f8() for v1 in range(a1)]\nv4, v5 = f2()\nv6 = [[0] * 2 for v7 in range(v5)]\nv8 = [False] * (v4 + 1)\nfor v9 in range(v5):\n    for v10 in range(2):\n        for v11 in range(1, v4 + 1):\n            if not v8[v11]:\n                v6[v9][v10] = v11\n                v8[v11] = True\n                break\n    for v9 in range(v5):\n        print(*v6[v9])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom math import floor, ceil, sqrt, factorial, log\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter, defaultdict, deque\nfrom itertools import accumulate, permutations, combinations, product, combinations_with_replacement\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom operator import itemgetter\nfrom fractions import gcd\nv1 = 10 ** 9 + 7\nv2 = float('inf')\nv3 = -float('inf')\n\ndef f1():\n    return int(sys.stdin.readline().rstrip())\n\ndef f2():\n    return map(int, sys.stdin.readline().rstrip().split())\n\ndef f3():\n    return list(f2())\n\ndef f4(a1: int):\n    return [f1() for v1 in range(a1)]\n\ndef f5(a1: int):\n    return [f3() for v1 in range(a1)]\n\ndef f6():\n    return sys.stdin.readline().rstrip()\n\ndef f7():\n    return sys.stdin.readline().rstrip().split()\n\ndef f8():\n    return list(f7())\n\ndef f9(a1: int):\n    return [f6() for v1 in range(a1)]\n\ndef f10(a1: int):\n    return [f8() for v1 in range(a1)]\nv4, v5 = f2()\nv6 = [[0] * 2 for v7 in range(v5)]\nv8 = [False] * (v4 + 1)\nfor v9 in range(v5):\n    for v10 in range(2):\n        for v11 in range(1, v4 + 1):\n            if not v8[v11]:\n                v6[v9][v10] = v11\n                v8[v11] = True\n                break\n    for v9 in range(v5):\n        print(*v6[v9])\n"}
{"id": "llm_code\\p02664__s923297148.py", "text": "v1 = list(input())\nv2 = 0\nv3 = []\nv4 = 0\nv5 = len(v1)\nfor v6 in range(v5):\n    if v1[v6] == '?':\n        v2 += 1\nv7 = 2 ** v2\nv8 = [[''] * v5 for v6 in range(v7)]\nfor v6 in range(v5):\n    if v1[v6] != '?':\n        for v9 in range(v7):\n            v8[v9][v6] = v1[v6]\n    else:\n        for v9 in range(v7):\n            if v9 % 2 == 0:\n                v8[v9][v6] = 'P'\n            else:\n                v8[v9][v6] = 'D'\nfor v10 in range(v7):\n    v11 = 0\n    for v6 in range(v5 - 1):\n        if v8[v10][v6] == 'P' and v8[v10][v6 + 1] == 'D':\n            v11 += 1\n        elif v8[v10][v6 + 1] == 'D':\n            v11 += 1\n    v3.append(v11)\nfor v6 in range(v7):\n    if v3[v6] > v3[v4]:\n        v4 = v6\nprint(''.join(v8[v4]))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = list(input())\nv2 = 0\nv3 = []\nv4 = 0\nv5 = len(v1)\nfor v6 in range(v5):\n    if v1[v6] == '?':\n        v2 += 1\nv7 = 2 ** v2\nv8 = [[''] * v5 for v6 in range(v7)]\nfor v6 in range(v5):\n    if v1[v6] != '?':\n        for v9 in range(v7):\n            v8[v9][v6] = v1[v6]\n    else:\n        for v9 in range(v7):\n            if v9 % 2 == 0:\n                v8[v9][v6] = 'P'\n            else:\n                v8[v9][v6] = 'D'\nfor v10 in range(v7):\n    v11 = 0\n    for v6 in range(v5 - 1):\n        if v8[v10][v6] == 'P' and v8[v10][v6 + 1] == 'D':\n            v11 += 1\n        elif v8[v10][v6 + 1] == 'D':\n            v11 += 1\n    v3.append(v11)\nfor v6 in range(v7):\n    if v3[v6] > v3[v4]:\n        v4 = v6\nprint(''.join(v8[v4]))\n"}
{"id": "human_code\\subarrays-distinct-element-sum-of-squares-i__part2.py", "text": "class C1(object):\n\n    def sumCounts(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=None, a3=lambda x, y: y if x is None else x if y is None else (x + y) % v1, a4=lambda x, y: y if x is None else (x + y) % v1):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.lazy = [None] * self.base\n                self.query_fn = a3\n                self.update_fn = a4\n                if a2 is not None:\n                    for v1 in range(self.base, self.base + a1):\n                        self.tree[v1] = a2(v1 - self.base)\n                    for v1 in reversed(range(1, self.base)):\n                        self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n                self.count = [1] * len(self.tree)\n                for v1 in reversed(range(1, self.base)):\n                    self.count[v1] = self.count[v1 << 1] + self.count[(v1 << 1) + 1]\n\n            def __apply(self, a1, a2):\n                self.tree[a1] = self.update_fn(self.tree[a1], a2 * self.count[a1])\n                if a1 < self.base:\n                    self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n            def __push(self, a1):\n                for v1 in reversed(range(1, a1.bit_length())):\n                    v2 = a1 >> v1\n                    if self.lazy[v2] is not None:\n                        self.__apply(v2 << 1, self.lazy[v2])\n                        self.__apply((v2 << 1) + 1, self.lazy[v2])\n                        self.lazy[v2] = None\n\n            def update(self, a1, a2, a3):\n\n                def pull(a1):\n                    while a1 > 1:\n                        a1 >>= 1\n                        self.tree[a1] = self.query_fn(self.tree[a1 << 1], self.tree[(a1 << 1) + 1])\n                        if self.lazy[a1] is not None:\n                            self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1] * self.count[a1])\n                a1 += self.base\n                a2 += self.base\n                v3, v4 = (a1, a2)\n                while a1 <= a2:\n                    if a1 & 1:\n                        self.__apply(a1, a3)\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        self.__apply(a2, a3)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                pull(v3)\n                pull(v4)\n\n            def query(self, a1, a2):\n                if a1 > a2:\n                    return None\n                a1 += self.base\n                a2 += self.base\n                self.__push(a1)\n                self.__push(a2)\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n        v2 = v3 = 0\n        v4 = {}\n        v5 = SegmentTree(len(a1))\n        for v6 in range(len(a1)):\n            v7 = v4[a1[v6]] if a1[v6] in v4 else -1\n            v3 = (v3 + (v6 - v7 + 2 * max(v5.query(v7 + 1, v6), 0))) % v1\n            v2 = (v2 + v3) % v1\n            v5.update(v7 + 1, v6, 1)\n            v4[a1[v6]] = v6\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def sumCounts(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=None, a3=lambda x, y: y if x is None else x if y is None else (x + y) % v1, a4=lambda x, y: y if x is None else (x + y) % v1):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.lazy = [None] * self.base\n                self.query_fn = a3\n                self.update_fn = a4\n                if a2 is not None:\n                    for v1 in range(self.base, self.base + a1):\n                        self.tree[v1] = a2(v1 - self.base)\n                    for v1 in reversed(range(1, self.base)):\n                        self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n                self.count = [1] * len(self.tree)\n                for v1 in reversed(range(1, self.base)):\n                    self.count[v1] = self.count[v1 << 1] + self.count[(v1 << 1) + 1]\n\n            def __apply(self, a1, a2):\n                self.tree[a1] = self.update_fn(self.tree[a1], a2 * self.count[a1])\n                if a1 < self.base:\n                    self.lazy[a1] = self.update_fn(self.lazy[a1], a2)\n\n            def __push(self, a1):\n                for v1 in reversed(range(1, a1.bit_length())):\n                    v2 = a1 >> v1\n                    if self.lazy[v2] is not None:\n                        self.__apply(v2 << 1, self.lazy[v2])\n                        self.__apply((v2 << 1) + 1, self.lazy[v2])\n                        self.lazy[v2] = None\n\n            def update(self, a1, a2, a3):\n\n                def pull(a1):\n                    while a1 > 1:\n                        a1 >>= 1\n                        self.tree[a1] = self.query_fn(self.tree[a1 << 1], self.tree[(a1 << 1) + 1])\n                        if self.lazy[a1] is not None:\n                            self.tree[a1] = self.update_fn(self.tree[a1], self.lazy[a1] * self.count[a1])\n                a1 += self.base\n                a2 += self.base\n                v3, v4 = (a1, a2)\n                while a1 <= a2:\n                    if a1 & 1:\n                        self.__apply(a1, a3)\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        self.__apply(a2, a3)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                pull(v3)\n                pull(v4)\n\n            def query(self, a1, a2):\n                if a1 > a2:\n                    return None\n                a1 += self.base\n                a2 += self.base\n                self.__push(a1)\n                self.__push(a2)\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n        v2 = v3 = 0\n        v4 = {}\n        v5 = SegmentTree(len(a1))\n        for v6 in range(len(a1)):\n            v7 = v4[a1[v6]] if a1[v6] in v4 else -1\n            v3 = (v3 + (v6 - v7 + 2 * max(v5.query(v7 + 1, v6), 0))) % v1\n            v2 = (v2 + v3) % v1\n            v5.update(v7 + 1, v6, 1)\n            v4[a1[v6]] = v6\n        return v2\n"}
{"id": "llm_code\\minimum-absolute-sum-difference__grok-4.1-fast__v1.py", "text": "import bisect\n\nclass C1:\n\n    def minAbsoluteSumDiff(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = sorted(a1)\n        v4 = sum((abs(a1[k] - a2[k]) for v5 in range(v2))) % v1\n        v6 = 0\n        for v7 in range(v2):\n            v8 = a2[v7]\n            v9 = abs(a1[v7] - v8)\n            v10 = bisect.bisect_left(v3, v8)\n            v11 = float('inf')\n            if v10 < v2:\n                v11 = min(v11, abs(v3[v10] - v8))\n            if v10 > 0:\n                v11 = min(v11, abs(v3[v10 - 1] - v8))\n            v12 = v9 - v11\n            if v12 > v6:\n                v6 = v12\n        return (v4 - v6) % v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1:\n\n    def minAbsoluteSumDiff(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        v2 = len(a1)\n        v3 = sorted(a1)\n        v4 = sum((abs(a1[k] - a2[k]) for v5 in range(v2))) % v1\n        v6 = 0\n        for v7 in range(v2):\n            v8 = a2[v7]\n            v9 = abs(a1[v7] - v8)\n            v10 = bisect.bisect_left(v3, v8)\n            v11 = float('inf')\n            if v10 < v2:\n                v11 = min(v11, abs(v3[v10] - v8))\n            if v10 > 0:\n                v11 = min(v11, abs(v3[v10 - 1] - v8))\n            v12 = v9 - v11\n            if v12 > v6:\n                v6 = v12\n        return (v4 - v6) % v1\n"}
{"id": "llm_code\\p02679__s369445264.py", "text": "import sys\nimport math\ninput = sys.stdin.readline\nv1 = 1000000007\nv2 = 1e-06\nv3 = int(input())\nv4 = []\nv5 = []\nfor v6 in range(v3):\n    v7, v8 = map(int, input().split())\n    v4.append((v7, v8))\n    if v7 == 0:\n        v5.append((90.0, v6))\n    else:\n        v5.append((math.degrees(math.atan(v8 / v7)), v6))\nv5.sort()\nv9 = 1\nv10 = [False] * v3\nv11 = v3\nfor v6 in range(v3):\n    v12, v13 = v5[v6]\n    if v10[v13]:\n        continue\n    v10[v13] = True\n    if v12 > v2:\n        break\n    v14 = 1\n    v15 = v6 + 1\n    while v15 < v3:\n        if abs(v12 - v5[v15][0]) <= v2:\n            v16 = v5[v15][1]\n            if v4[v16][0] * v4[v13][1] == v4[v16][1] * v4[v13][0]:\n                v14 += 1\n                v10[v16] = True\n            v15 += 1\n        else:\n            break\n    v17 = 0\n    v18 = v3 - 1\n    v19 = v6 + 1\n    while v18 - v19 > 1:\n        v20 = (v18 + v19) // 2\n        if v5[v20][0] >= v12 + 90 - v2:\n            v18 = v20\n        else:\n            v19 = v20\n    v15 = v18\n    while v15 < v3:\n        if abs(v12 + 90 - v5[v15][0]) <= 2e-06:\n            v16 = v5[v15][1]\n            if v4[v16][0] * v4[v13][0] + v4[v16][1] * v4[v13][1] == 0:\n                v17 += 1\n                v10[v16] = True\n            v15 += 1\n        else:\n            break\n    if v17 != 0:\n        v9 = v9 * (pow(2, v14, v1) + pow(2, v17, v1) - 1) % v1\n        v11 -= v14 + v17\nv9 = v9 * pow(2, v11, v1) % v1 - 1\nprint(v9)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nimport math\ninput = sys.stdin.readline\nv1 = 1000000007\nv2 = 1e-06\nv3 = int(input())\nv4 = []\nv5 = []\nfor v6 in range(v3):\n    v7, v8 = map(int, input().split())\n    v4.append((v7, v8))\n    if v7 == 0:\n        v5.append((90.0, v6))\n    else:\n        v5.append((math.degrees(math.atan(v8 / v7)), v6))\nv5.sort()\nv9 = 1\nv10 = [False] * v3\nv11 = v3\nfor v6 in range(v3):\n    v12, v13 = v5[v6]\n    if v10[v13]:\n        continue\n    v10[v13] = True\n    if v12 > v2:\n        break\n    v14 = 1\n    v15 = v6 + 1\n    while v15 < v3:\n        if abs(v12 - v5[v15][0]) <= v2:\n            v16 = v5[v15][1]\n            if v4[v16][0] * v4[v13][1] == v4[v16][1] * v4[v13][0]:\n                v14 += 1\n                v10[v16] = True\n            v15 += 1\n        else:\n            break\n    v17 = 0\n    v18 = v3 - 1\n    v19 = v6 + 1\n    while v18 - v19 > 1:\n        v20 = (v18 + v19) // 2\n        if v5[v20][0] >= v12 + 90 - v2:\n            v18 = v20\n        else:\n            v19 = v20\n    v15 = v18\n    while v15 < v3:\n        if abs(v12 + 90 - v5[v15][0]) <= 2e-06:\n            v16 = v5[v15][1]\n            if v4[v16][0] * v4[v13][0] + v4[v16][1] * v4[v13][1] == 0:\n                v17 += 1\n                v10[v16] = True\n            v15 += 1\n        else:\n            break\n    if v17 != 0:\n        v9 = v9 * (pow(2, v14, v1) + pow(2, v17, v1) - 1) % v1\n        v11 -= v14 + v17\nv9 = v9 * pow(2, v11, v1) % v1 - 1\nprint(v9)\n"}
{"id": "human_code\\painting-a-grid-with-three-different-colors__part4.py", "text": "import collections\n\nclass C1(object):\n\n    def colorTheGrid(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def normalize(a1, a2, a3):\n            if a2 not in a3[a1]:\n                v1 = {}\n                v2, v3 = (0, a1)\n                while v3:\n                    v4 = a2 // v3 % 3\n                    if v4 not in v1:\n                        v1[v4] = len(v1)\n                    v2 += v1[v4] * v3\n                    v3 //= 3\n                a3[a1][a2] = v2\n            return a3[a1][a2]\n        if a1 > a2:\n            a1, a2 = (a2, a1)\n        v4 = v5 = 3 ** (a1 - 1)\n        v6 = collections.defaultdict(dict)\n        v7 = collections.Counter({0: 1})\n        for v8 in range(a1 * a2):\n            v9, v10 = divmod(v8, a1)\n            assert v9 != 0 or v10 != 0 or len(v7) == 1\n            assert v9 != 0 or v10 == 0 or len(v7) == 3 * 2 ** (v10 - 1) // 3 // (2 if v10 >= 2 else 1)\n            assert v9 == 0 or v10 != 0 or len(v7) == 3 * 2 ** (a1 - 1) // 3 // (2 if a1 >= 2 else 1)\n            assert v9 == 0 or v10 == 0 or len(v7) == (1 if a1 == 1 else 2 if a1 == 2 else 3 * 3 * 2 ** (a1 - 2) // 3 // 2)\n            v11 = collections.Counter()\n            for v12, v13 in v7.items():\n                v14 = {0, 1, 2}\n                if v9 > 0:\n                    v14.discard(v12 % 3)\n                if v10 > 0:\n                    v14.discard(v12 // v4)\n                for v15 in v14:\n                    v16 = normalize(v4 // v5, (v15 * v4 + v12 // 3) // v5, v6) * v5\n                    v11[v16] = (v11[v16] + v13) % v1\n            if v5 > 1:\n                v5 //= 3\n            v7 = v11\n        return reduce(lambda x, y: (v15 + y) % v1, iter(v7.values()), 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def colorTheGrid(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def normalize(a1, a2, a3):\n            if a2 not in a3[a1]:\n                v1 = {}\n                v2, v3 = (0, a1)\n                while v3:\n                    v4 = a2 // v3 % 3\n                    if v4 not in v1:\n                        v1[v4] = len(v1)\n                    v2 += v1[v4] * v3\n                    v3 //= 3\n                a3[a1][a2] = v2\n            return a3[a1][a2]\n        if a1 > a2:\n            a1, a2 = (a2, a1)\n        v4 = v5 = 3 ** (a1 - 1)\n        v6 = collections.defaultdict(dict)\n        v7 = collections.Counter({0: 1})\n        for v8 in range(a1 * a2):\n            v9, v10 = divmod(v8, a1)\n            assert v9 != 0 or v10 != 0 or len(v7) == 1\n            assert v9 != 0 or v10 == 0 or len(v7) == 3 * 2 ** (v10 - 1) // 3 // (2 if v10 >= 2 else 1)\n            assert v9 == 0 or v10 != 0 or len(v7) == 3 * 2 ** (a1 - 1) // 3 // (2 if a1 >= 2 else 1)\n            assert v9 == 0 or v10 == 0 or len(v7) == (1 if a1 == 1 else 2 if a1 == 2 else 3 * 3 * 2 ** (a1 - 2) // 3 // 2)\n            v11 = collections.Counter()\n            for v12, v13 in v7.items():\n                v14 = {0, 1, 2}\n                if v9 > 0:\n                    v14.discard(v12 % 3)\n                if v10 > 0:\n                    v14.discard(v12 // v4)\n                for v15 in v14:\n                    v16 = normalize(v4 // v5, (v15 * v4 + v12 // 3) // v5, v6) * v5\n                    v11[v16] = (v11[v16] + v13) % v1\n            if v5 > 1:\n                v5 //= 3\n            v7 = v11\n        return reduce(lambda x, y: (v15 + y) % v1, iter(v7.values()), 0)\n"}
{"id": "human_code\\maximal-network-rank__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def maximalNetworkRank(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * a1\n        v2 = collections.defaultdict(set)\n        for v3, v4 in a2:\n            v1[v3] += 1\n            v1[v4] += 1\n            v2[v3].add(v4)\n            v2[v4].add(v3)\n        v5 = list(range(a1))\n        v5.sort(key=lambda x: -v1[x])\n        v6 = 2\n        while v6 < a1:\n            if v1[v5[v6]] != v1[v5[1]]:\n                break\n            v6 += 1\n        v7 = v1[v5[0]] + v1[v5[1]] - 1\n        for v8 in range(v6 - 1):\n            for v9 in range(v8 + 1, v6):\n                if v1[v5[v8]] + v1[v5[v9]] - int(v5[v8] in v2 and v5[v9] in v2[v5[v8]]) > v7:\n                    return v1[v5[v8]] + v1[v5[v9]] - int(v5[v8] in v2 and v5[v9] in v2[v5[v8]])\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def maximalNetworkRank(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * a1\n        v2 = collections.defaultdict(set)\n        for v3, v4 in a2:\n            v1[v3] += 1\n            v1[v4] += 1\n            v2[v3].add(v4)\n            v2[v4].add(v3)\n        v5 = list(range(a1))\n        v5.sort(key=lambda x: -v1[x])\n        v6 = 2\n        while v6 < a1:\n            if v1[v5[v6]] != v1[v5[1]]:\n                break\n            v6 += 1\n        v7 = v1[v5[0]] + v1[v5[1]] - 1\n        for v8 in range(v6 - 1):\n            for v9 in range(v8 + 1, v6):\n                if v1[v5[v8]] + v1[v5[v9]] - int(v5[v8] in v2 and v5[v9] in v2[v5[v8]]) > v7:\n                    return v1[v5[v8]] + v1[v5[v9]] - int(v5[v8] in v2 and v5[v9] in v2[v5[v8]])\n        return v7\n"}
{"id": "human_code\\final-array-state-after-k-multiplication-operations-ii__part2.py", "text": "import math\n\nclass C1(object):\n\n    def getFinalState(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = 1e-15\n\n        def binary_search_right(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if not a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a2\n\n        def count(a1, a2):\n            return int(a2 - a1 + v2)\n\n        def check(a1):\n            v1 = 0\n            for v2, v3 in vals:\n                v4 = count(v2, a1)\n                if v4 <= 0:\n                    break\n                v1 += v4\n            return v1 <= a2\n        if a3 == 1:\n            return a1\n        v3 = sorted(((log(x) / log(a3), i) for v4, v5 in enumerate(a1)))\n        v6 = binary_search_right(1, int(v3[-1][0]) + 1, check)\n        for v7, (v5, v4) in enumerate(v3):\n            v8 = count(v5, v6)\n            if v8 <= 0:\n                break\n            a2 -= v8\n            a1[v4] *= pow(a3, v8)\n        v10, v11 = divmod(a2, len(a1))\n        v12 = pow(a3, v10, v1)\n        v13 = [0] * len(a1)\n        for v7, (v5, v4) in enumerate(sorted(((v5, v4) for v4, v5 in enumerate(a1)))):\n            v13[v4] = v5 * v12 * (a3 if v7 < v11 else 1) % v1\n        return v13\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import math\n\nclass C1(object):\n\n    def getFinalState(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = 1e-15\n\n        def binary_search_right(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if not a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a2\n\n        def count(a1, a2):\n            return int(a2 - a1 + v2)\n\n        def check(a1):\n            v1 = 0\n            for v2, v3 in vals:\n                v4 = count(v2, a1)\n                if v4 <= 0:\n                    break\n                v1 += v4\n            return v1 <= a2\n        if a3 == 1:\n            return a1\n        v3 = sorted(((log(x) / log(a3), i) for v4, v5 in enumerate(a1)))\n        v6 = binary_search_right(1, int(v3[-1][0]) + 1, check)\n        for v7, (v5, v4) in enumerate(v3):\n            v8 = count(v5, v6)\n            if v8 <= 0:\n                break\n            a2 -= v8\n            a1[v4] *= pow(a3, v8)\n        v10, v11 = divmod(a2, len(a1))\n        v12 = pow(a3, v10, v1)\n        v13 = [0] * len(a1)\n        for v7, (v5, v4) in enumerate(sorted(((v5, v4) for v4, v5 in enumerate(a1)))):\n            v13[v4] = v5 * v12 * (a3 if v7 < v11 else 1) % v1\n        return v13\n"}
{"id": "llm_code\\equal-sum-grid-partition-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def canPartitionGrid(self, a1):\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = sum((a1[r][c] for v4 in range(v1) for v5 in range(v2)))\n        if v3 % 2 != 0:\n            return False\n        v6 = v3 // 2\n        v7 = 0\n        for v4 in range(v1):\n            v8 = sum((a1[v4][v5] for v5 in range(v2)))\n            v7 += v8\n            if v7 == v6:\n                return True\n            if v7 > v6:\n                break\n        v7 = 0\n        for v5 in range(v2):\n            v9 = sum((a1[v4][v5] for v4 in range(v1)))\n            v7 += v9\n            if v7 == v6:\n                return True\n            if v7 > v6:\n                break\n        return False\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def canPartitionGrid(self, a1):\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = sum((a1[r][c] for v4 in range(v1) for v5 in range(v2)))\n        if v3 % 2 != 0:\n            return False\n        v6 = v3 // 2\n        v7 = 0\n        for v4 in range(v1):\n            v8 = sum((a1[v4][v5] for v5 in range(v2)))\n            v7 += v8\n            if v7 == v6:\n                return True\n            if v7 > v6:\n                break\n        v7 = 0\n        for v5 in range(v2):\n            v9 = sum((a1[v4][v5] for v4 in range(v1)))\n            v7 += v9\n            if v7 == v6:\n                return True\n            if v7 > v6:\n                break\n        return False\n"}
{"id": "human_code\\minimum-cost-to-make-array-equal__part1.py", "text": "import itertools\n\nclass C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def f(a1):\n            return sum((abs(y - a1) * c for v1, v2 in zip(a1, a2)))\n\n        def check(a1, a2):\n            return sum((c for v1, v2 in zip(a1, a2) if v1 <= a1)) >= a2\n        v1 = list(range(len(a1)))\n        v1.sort(key=lambda x: a1[x])\n        v2, v3 = (0, len(v1) - 1)\n        v4 = sum(a2)\n        v5 = (v4 + 1) // 2\n        while v2 <= v3:\n            v6 = v2 + (v3 - v2) // 2\n            if check(a1[v1[v6]], v5):\n                v3 = v6 - 1\n            else:\n                v2 = v6 + 1\n        return f(a1[v1[v2]])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\n\nclass C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def f(a1):\n            return sum((abs(y - a1) * c for v1, v2 in zip(a1, a2)))\n\n        def check(a1, a2):\n            return sum((c for v1, v2 in zip(a1, a2) if v1 <= a1)) >= a2\n        v1 = list(range(len(a1)))\n        v1.sort(key=lambda x: a1[x])\n        v2, v3 = (0, len(v1) - 1)\n        v4 = sum(a2)\n        v5 = (v4 + 1) // 2\n        while v2 <= v3:\n            v6 = v2 + (v3 - v2) // 2\n            if check(a1[v1[v6]], v5):\n                v3 = v6 - 1\n            else:\n                v2 = v6 + 1\n        return f(a1[v1[v2]])\n"}
{"id": "llm_code\\decode-ways-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def numDecodings(self, a1):\n        v1 = 1000000007\n        v2 = len(a1)\n        if a1[0] == '0':\n            return 0\n        v3 = 9 if a1[0] == '*' else 1\n        v4 = 1\n        for v5 in range(1, v2):\n            v6 = a1[v5]\n            v7 = a1[v5 - 1]\n            v8 = 9 if v6 == '*' else 1 if v6 != '0' else 0\n            v9 = 0\n            if v7 == '1':\n                v9 = 9 if v6 == '*' else 1\n            elif v7 == '2':\n                v9 = 6 if v6 == '*' else 1 if v6 <= '6' else 0\n            elif v7 == '*':\n                v9 = 15 if v6 == '*' else 2 if v6 <= '6' else 1\n            v10 = (v8 * v3 + v9 * v4) % v1\n            v4 = v3\n            v3 = v10\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def numDecodings(self, a1):\n        v1 = 1000000007\n        v2 = len(a1)\n        if a1[0] == '0':\n            return 0\n        v3 = 9 if a1[0] == '*' else 1\n        v4 = 1\n        for v5 in range(1, v2):\n            v6 = a1[v5]\n            v7 = a1[v5 - 1]\n            v8 = 9 if v6 == '*' else 1 if v6 != '0' else 0\n            v9 = 0\n            if v7 == '1':\n                v9 = 9 if v6 == '*' else 1\n            elif v7 == '2':\n                v9 = 6 if v6 == '*' else 1 if v6 <= '6' else 0\n            elif v7 == '*':\n                v9 = 15 if v6 == '*' else 2 if v6 <= '6' else 1\n            v10 = (v8 * v3 + v9 * v4) % v1\n            v4 = v3\n            v3 = v10\n        return v3\n"}
{"id": "llm_code\\find-beautiful-indices-in-the-given-array-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def beautifulIndices(self, a1: str, a2: str, a3: str, a4: int) -> list[int]:\n\n        def extract_starts(a1: str) -> list[int]:\n            v1 = []\n            v2 = 0\n            while True:\n                v2 = a1.find(a1, v2)\n                if v2 < 0:\n                    break\n                v1.append(v2)\n                v2 += 1\n            return v1\n        v1 = extract_starts(a2)\n        v2 = extract_starts(a3)\n        v3 = []\n        v4 = 0\n        for v5 in v1:\n            while v4 < len(v2) and v2[v4] < v5 - a4:\n                v4 += 1\n            if v4 < len(v2) and v2[v4] <= v5 + a4:\n                v3.append(v5)\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def beautifulIndices(self, a1: str, a2: str, a3: str, a4: int) -> list[int]:\n\n        def extract_starts(a1: str) -> list[int]:\n            v1 = []\n            v2 = 0\n            while True:\n                v2 = a1.find(a1, v2)\n                if v2 < 0:\n                    break\n                v1.append(v2)\n                v2 += 1\n            return v1\n        v1 = extract_starts(a2)\n        v2 = extract_starts(a3)\n        v3 = []\n        v4 = 0\n        for v5 in v1:\n            while v4 < len(v2) and v2[v4] < v5 - a4:\n                v4 += 1\n            if v4 < len(v2) and v2[v4] <= v5 + a4:\n                v3.append(v5)\n        return v3\n"}
{"id": "human_code\\design-hashmap.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a2\n        self.key = a1\n        self.next = None\n        self.prev = None\n\nclass C2(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, a1):\n        a1.next, a1.prev = (None, None)\n        if self.head is None:\n            self.head = a1\n        else:\n            self.tail.next = a1\n            a1.prev = self.tail\n        self.tail = a1\n\n    def delete(self, a1):\n        if a1.prev:\n            a1.prev.next = a1.__next__\n        else:\n            self.head = a1.__next__\n        if a1.__next__:\n            a1.next.prev = a1.prev\n        else:\n            self.tail = a1.prev\n        a1.next, a1.prev = (None, None)\n\n    def find(self, a1):\n        v1 = self.head\n        while v1:\n            if v1.key == a1:\n                break\n            v1 = v1.__next__\n        return v1\n\nclass C3(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__data = [C2() for v1 in range(10000)]\n\n    def put(self, a1, a2):\n        \"\"\"\n        value will always be positive.\n        \"\"\"\n        v1 = self.__data[a1 % len(self.__data)]\n        v2 = v1.find(a1)\n        if v2:\n            v2.val = a2\n        else:\n            v1.insert(C1(a1, a2))\n\n    def get(self, a1):\n        \"\"\"\n        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n        \"\"\"\n        v1 = self.__data[a1 % len(self.__data)]\n        v2 = v1.find(a1)\n        if v2:\n            return v2.val\n        else:\n            return -1\n\n    def remove(self, a1):\n        \"\"\"\n        Removes the mapping of the specified value key if this map contains a mapping for the key\n        \"\"\"\n        v1 = self.__data[a1 % len(self.__data)]\n        v2 = v1.find(a1)\n        if v2:\n            v1.delete(v2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a2\n        self.key = a1\n        self.next = None\n        self.prev = None\n\nclass C2(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, a1):\n        a1.next, a1.prev = (None, None)\n        if self.head is None:\n            self.head = a1\n        else:\n            self.tail.next = a1\n            a1.prev = self.tail\n        self.tail = a1\n\n    def delete(self, a1):\n        if a1.prev:\n            a1.prev.next = a1.__next__\n        else:\n            self.head = a1.__next__\n        if a1.__next__:\n            a1.next.prev = a1.prev\n        else:\n            self.tail = a1.prev\n        a1.next, a1.prev = (None, None)\n\n    def find(self, a1):\n        v1 = self.head\n        while v1:\n            if v1.key == a1:\n                break\n            v1 = v1.__next__\n        return v1\n\nclass C3(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__data = [C2() for v1 in range(10000)]\n\n    def put(self, a1, a2):\n        \"\"\"\n        value will always be positive.\n        \"\"\"\n        v1 = self.__data[a1 % len(self.__data)]\n        v2 = v1.find(a1)\n        if v2:\n            v2.val = a2\n        else:\n            v1.insert(C1(a1, a2))\n\n    def get(self, a1):\n        \"\"\"\n        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n        \"\"\"\n        v1 = self.__data[a1 % len(self.__data)]\n        v2 = v1.find(a1)\n        if v2:\n            return v2.val\n        else:\n            return -1\n\n    def remove(self, a1):\n        \"\"\"\n        Removes the mapping of the specified value key if this map contains a mapping for the key\n        \"\"\"\n        v1 = self.__data[a1 % len(self.__data)]\n        v2 = v1.find(a1)\n        if v2:\n            v1.delete(v2)\n"}
{"id": "human_code\\p02788__s356071387.py", "text": "def f1():\n    import sys\n    input = sys.stdin.readline\n    v1, v2, v3 = [int(i) for v4 in input().split()]\n    v5 = []\n    for v4 in range(v1):\n        v6, v7 = [int(v4) for v4 in input().split()]\n        v5.append((v6, 0, v7))\n    from heapq import heapify, heappop, heappush\n    heapify(v5)\n    v8 = 0\n    v9 = 0\n    while v5:\n        v6, v10, v7 = heappop(v5)\n        if v10 == 0:\n            if v8 * v3 >= v7:\n                continue\n            v11 = v7 - v8 * v3\n            v12 = (v11 - 1) // v3 + 1\n            heappush(v5, (v6 + 2 * v2, 1, v12))\n            v9 += v12\n            v8 += v12\n        else:\n            v8 -= v7\n    print(v9)\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1():\n    import sys\n    input = sys.stdin.readline\n    v1, v2, v3 = [int(i) for v4 in input().split()]\n    v5 = []\n    for v4 in range(v1):\n        v6, v7 = [int(v4) for v4 in input().split()]\n        v5.append((v6, 0, v7))\n    from heapq import heapify, heappop, heappush\n    heapify(v5)\n    v8 = 0\n    v9 = 0\n    while v5:\n        v6, v10, v7 = heappop(v5)\n        if v10 == 0:\n            if v8 * v3 >= v7:\n                continue\n            v11 = v7 - v8 * v3\n            v12 = (v11 - 1) // v3 + 1\n            heappush(v5, (v6 + 2 * v2, 1, v12))\n            v9 += v12\n            v8 += v12\n        else:\n            v8 -= v7\n    print(v9)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\count-valid-paths-in-a-tree__part2.py", "text": "class C1(object):\n\n    def countPaths(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def linear_sieve_of_eratosthenes(a1):\n            v1 = []\n            v2 = [-1] * (a1 + 1)\n            for v3 in range(2, a1 + 1):\n                if v2[v3] == -1:\n                    v2[v3] = v3\n                    v1.append(v3)\n                for v4 in v1:\n                    if v3 * v4 > a1 or v4 > v2[v3]:\n                        break\n                    v2[v3 * v4] = v4\n            return v2\n\n        def is_prime(a1):\n            return spf[a1] == a1\n\n        def dfs(a1, a2):\n            v1 = [1 - is_prime(a1 + 1), is_prime(a1 + 1)]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v3 = dfs(v2, a1)\n                result[0] += v1[0] * v3[1] + v1[1] * v3[0]\n                if is_prime(a1 + 1):\n                    v1[1] += v3[0]\n                else:\n                    v1[0] += v3[0]\n                    v1[1] += v3[1]\n            return v1\n        v1 = linear_sieve_of_eratosthenes(a1)\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5 in a2:\n            v4, v5 = (v4 - 1, v5 - 1)\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = [0]\n        dfs(0, -1)\n        return v6[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countPaths(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def linear_sieve_of_eratosthenes(a1):\n            v1 = []\n            v2 = [-1] * (a1 + 1)\n            for v3 in range(2, a1 + 1):\n                if v2[v3] == -1:\n                    v2[v3] = v3\n                    v1.append(v3)\n                for v4 in v1:\n                    if v3 * v4 > a1 or v4 > v2[v3]:\n                        break\n                    v2[v3 * v4] = v4\n            return v2\n\n        def is_prime(a1):\n            return spf[a1] == a1\n\n        def dfs(a1, a2):\n            v1 = [1 - is_prime(a1 + 1), is_prime(a1 + 1)]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v3 = dfs(v2, a1)\n                result[0] += v1[0] * v3[1] + v1[1] * v3[0]\n                if is_prime(a1 + 1):\n                    v1[1] += v3[0]\n                else:\n                    v1[0] += v3[0]\n                    v1[1] += v3[1]\n            return v1\n        v1 = linear_sieve_of_eratosthenes(a1)\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5 in a2:\n            v4, v5 = (v4 - 1, v5 - 1)\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = [0]\n        dfs(0, -1)\n        return v6[0]\n"}
{"id": "llm_code\\p03705__s025003796.py", "text": "import sys\nv1, v2, v3 = map(int, input().split())\nif v1 == 1:\n    if v2 != v3:\n        print(0)\n    else:\n        print(1)\n    sys.exit()\nif v1 == 2:\n    if v2 > v3:\n        print(0)\n    else:\n        print(1)\n    sys.exit()\nif v2 > v3:\n    print(0)\n    sys.exit()\nif v2 > 1000000007 and v3 > 1000000007:\n    v2 = v2 % 1000000007\n    v3 = v3 % 1000000007\nv4 = v2 * v1\nv5 = v3 * v1\nif v4 > v5:\n    print(0)\nelse:\n    print(v5 - v4 + 1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1, v2, v3 = map(int, input().split())\nif v1 == 1:\n    if v2 != v3:\n        print(0)\n    else:\n        print(1)\n    sys.exit()\nif v1 == 2:\n    if v2 > v3:\n        print(0)\n    else:\n        print(1)\n    sys.exit()\nif v2 > v3:\n    print(0)\n    sys.exit()\nif v2 > 1000000007 and v3 > 1000000007:\n    v2 = v2 % 1000000007\n    v3 = v3 % 1000000007\nv4 = v2 * v1\nv5 = v3 * v1\nif v4 > v5:\n    print(0)\nelse:\n    print(v5 - v4 + 1)\n"}
{"id": "llm_code\\minimum-moves-to-clean-the-classroom__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minMoves(self, a1, a2):\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v2 = len(a1)\n        v3 = len(a1[0])\n        v4 = v5 = None\n        v6 = []\n        for v7 in range(v2):\n            for v8 in range(v3):\n                v9 = a1[v7][v8]\n                if v9 == 'S':\n                    v4, v5 = (v7, v8)\n                elif v9 == 'L':\n                    v6.append((v7, v8))\n        v10 = len(v6)\n        v11 = (1 << v10) - 1\n        v12 = [[-1] * v3 for v13 in range(v2)]\n        for v14, (v15, v16) in enumerate(v6):\n            v12[v15][v16] = v14\n        v17 = [[[-1] * (1 << v10) for v13 in range(v3)] for v13 in range(v2)]\n        v17[v4][v5][0] = a2\n        v18 = [(v4, v5, 0, a2)]\n        v19 = 0\n        while v18:\n            v20 = []\n            for v21, v22, v23, v24 in v18:\n                if v17[v21][v22][v23] != v24:\n                    continue\n                if v23 == v11:\n                    return v19\n                for v25, v26 in v1:\n                    v27, v28 = (v21 + v25, v22 + v26)\n                    v29 = v24 - 1\n                    if not (0 <= v27 < v2 and 0 <= v28 < v3 and (a1[v27][v28] != 'X') and (v29 >= 0)):\n                        continue\n                    v30 = v23\n                    if a1[v27][v28] == 'R':\n                        v29 = a2\n                    v14 = v12[v27][v28]\n                    if v14 != -1:\n                        v30 |= 1 << v14\n                    if v29 > v17[v27][v28][v30]:\n                        v17[v27][v28][v30] = v29\n                        v20.append((v27, v28, v30, v29))\n            v18 = v20\n            v19 += 1\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minMoves(self, a1, a2):\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v2 = len(a1)\n        v3 = len(a1[0])\n        v4 = v5 = None\n        v6 = []\n        for v7 in range(v2):\n            for v8 in range(v3):\n                v9 = a1[v7][v8]\n                if v9 == 'S':\n                    v4, v5 = (v7, v8)\n                elif v9 == 'L':\n                    v6.append((v7, v8))\n        v10 = len(v6)\n        v11 = (1 << v10) - 1\n        v12 = [[-1] * v3 for v13 in range(v2)]\n        for v14, (v15, v16) in enumerate(v6):\n            v12[v15][v16] = v14\n        v17 = [[[-1] * (1 << v10) for v13 in range(v3)] for v13 in range(v2)]\n        v17[v4][v5][0] = a2\n        v18 = [(v4, v5, 0, a2)]\n        v19 = 0\n        while v18:\n            v20 = []\n            for v21, v22, v23, v24 in v18:\n                if v17[v21][v22][v23] != v24:\n                    continue\n                if v23 == v11:\n                    return v19\n                for v25, v26 in v1:\n                    v27, v28 = (v21 + v25, v22 + v26)\n                    v29 = v24 - 1\n                    if not (0 <= v27 < v2 and 0 <= v28 < v3 and (a1[v27][v28] != 'X') and (v29 >= 0)):\n                        continue\n                    v30 = v23\n                    if a1[v27][v28] == 'R':\n                        v29 = a2\n                    v14 = v12[v27][v28]\n                    if v14 != -1:\n                        v30 |= 1 << v14\n                    if v29 > v17[v27][v28][v30]:\n                        v17[v27][v28][v30] = v29\n                        v20.append((v27, v28, v30, v29))\n            v18 = v20\n            v19 += 1\n        return -1\n"}
{"id": "llm_code\\insert-into-a-binary-search-tree__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2:\n\n    def insertIntoBST(self, a1, a2):\n        if a1 is None:\n            return C1(a2)\n        v1 = a1\n        while True:\n            if a2 <= v1.val:\n                if v1.left is None:\n                    v1.left = C1(a2)\n                    return a1\n                v1 = v1.left\n            else:\n                if v1.right is None:\n                    v1.right = C1(a2)\n                    return a1\n                v1 = v1.right\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2:\n\n    def insertIntoBST(self, a1, a2):\n        if a1 is None:\n            return C1(a2)\n        v1 = a1\n        while True:\n            if a2 <= v1.val:\n                if v1.left is None:\n                    v1.left = C1(a2)\n                    return a1\n                v1 = v1.left\n            else:\n                if v1.right is None:\n                    v1.right = C1(a2)\n                    return a1\n                v1 = v1.right\n"}
{"id": "llm_code\\detonate-the-maximum-bombs__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumDetonation(self, a1):\n        v1 = len(a1)\n        v2 = [[] for v3 in range(v1)]\n        for v4 in range(v1):\n            v5, v6, v7 = a1[v4]\n            for v8 in range(v1):\n                if v4 == v8:\n                    continue\n                v9, v10 = (a1[v8][0], a1[v8][1])\n                v11, v12 = (v5 - v9, v6 - v10)\n                if v11 * v11 + v12 * v12 <= v7 * v7:\n                    v2[v4].append(v8)\n\n        def dfs(a1, a2):\n            a2[a1] = True\n            for v1 in v2[a1]:\n                if not a2[v1]:\n                    dfs(v1, a2)\n        v13 = 0\n        for v14 in range(v1):\n            v15 = [False] * v1\n            dfs(v14, v15)\n            v16 = sum(v15)\n            if v16 > v13:\n                v13 = v16\n            if v13 == v1:\n                return v1\n        return v13\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumDetonation(self, a1):\n        v1 = len(a1)\n        v2 = [[] for v3 in range(v1)]\n        for v4 in range(v1):\n            v5, v6, v7 = a1[v4]\n            for v8 in range(v1):\n                if v4 == v8:\n                    continue\n                v9, v10 = (a1[v8][0], a1[v8][1])\n                v11, v12 = (v5 - v9, v6 - v10)\n                if v11 * v11 + v12 * v12 <= v7 * v7:\n                    v2[v4].append(v8)\n\n        def dfs(a1, a2):\n            a2[a1] = True\n            for v1 in v2[a1]:\n                if not a2[v1]:\n                    dfs(v1, a2)\n        v13 = 0\n        for v14 in range(v1):\n            v15 = [False] * v1\n            dfs(v14, v15)\n            v16 = sum(v15)\n            if v16 > v13:\n                v13 = v16\n            if v13 == v1:\n                return v1\n        return v13\n"}
{"id": "human_code\\maximum-sum-of-subsequence-with-non-adjacent-elements.py", "text": "class C1(object):\n\n    def maximumSumSubsequence(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2, v3, v4, v5 = list(range(4))\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: y if x is None else x if y is None else max(x, y), a4=lambda x: x):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(a2)\n                while v1 > 1:\n                    v1 >>= 1\n                    self.tree[v1] = self.query_fn(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def query(self, a1, a2):\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n\n        def build(a1):\n            return [max(a1[a1], 0), 0, 0, 0]\n\n        def query(a1, a2):\n            if a1 is None:\n                return a2\n            if a2 is None:\n                return a1\n            return [max(a1[v4] + a2[v3], a1[v2] + a2[v3], a1[v4] + a2[v2]), max(a1[v5] + a2[v3], a1[v3] + a2[v3], a1[v5] + a2[v2]), max(a1[v4] + a2[v5], a1[v2] + a2[v5], a1[v4] + a2[v4]), max(a1[v5] + a2[v5], a1[v3] + a2[v5], a1[v5] + a2[v4])]\n        v6 = SegmentTree(len(a1), build_fn=build, query_fn=query)\n        v7 = 0\n        for v8, v9 in a2:\n            v6.update(v8, [max(v9, 0), 0, 0, 0])\n            v7 = (v7 + max(v6.tree[1])) % v1\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumSumSubsequence(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2, v3, v4, v5 = list(range(4))\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: y if x is None else x if y is None else max(x, y), a4=lambda x: x):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(a2)\n                while v1 > 1:\n                    v1 >>= 1\n                    self.tree[v1] = self.query_fn(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def query(self, a1, a2):\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n\n        def build(a1):\n            return [max(a1[a1], 0), 0, 0, 0]\n\n        def query(a1, a2):\n            if a1 is None:\n                return a2\n            if a2 is None:\n                return a1\n            return [max(a1[v4] + a2[v3], a1[v2] + a2[v3], a1[v4] + a2[v2]), max(a1[v5] + a2[v3], a1[v3] + a2[v3], a1[v5] + a2[v2]), max(a1[v4] + a2[v5], a1[v2] + a2[v5], a1[v4] + a2[v4]), max(a1[v5] + a2[v5], a1[v3] + a2[v5], a1[v5] + a2[v4])]\n        v6 = SegmentTree(len(a1), build_fn=build, query_fn=query)\n        v7 = 0\n        for v8, v9 in a2:\n            v6.update(v8, [max(v9, 0), 0, 0, 0])\n            v7 = (v7 + max(v6.tree[1])) % v1\n        return v7\n"}
{"id": "human_code\\minimum-incompatibility__part2.py", "text": "class C1(object):\n\n    def minimumIncompatibility(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = (len(a1) - 1) * (len(a1) // a2) + 1\n        v2 = [1]\n        for v3 in range(len(a1)):\n            v2.append(v2[-1] << 1)\n\n        def popcount(a1):\n            v1 = 0\n            while a1:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n\n        def find_candidates(a1, a2):\n            v1 = v2[len(a1)] - 1\n            v2 = len(a1) // a2\n            v3 = [v1] * (v1 + 1)\n            for v4 in range(v1 + 1):\n                if popcount(v4) != v2:\n                    continue\n                v5 = 0\n                v6, v7 = (0, v1)\n                for v8 in range(len(a1)):\n                    if v4 & v2[v8] == 0:\n                        continue\n                    if v5 & v2[a1[v8]]:\n                        break\n                    v5 |= v2[a1[v8]]\n                    v6 = max(v6, a1[v8])\n                    v7 = min(v7, a1[v8])\n                else:\n                    v3[v4] = v6 - v7\n            return v3\n        v4 = find_candidates(a1, a2)\n        v5 = len(a1) // a2\n        v6 = v2[len(a1)] - 1\n        v7 = [v1] * (v6 + 1)\n        v7[0] = 0\n        for v8 in range(v6 + 1):\n            if popcount(v8) % v5 != 0:\n                continue\n            v9 = v8\n            while v9:\n                v7[v8] = min(v7[v8], v7[v8 - v9] + v4[v9])\n                v9 = v9 - 1 & v8\n        return v7[-1] if v7[-1] != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumIncompatibility(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = (len(a1) - 1) * (len(a1) // a2) + 1\n        v2 = [1]\n        for v3 in range(len(a1)):\n            v2.append(v2[-1] << 1)\n\n        def popcount(a1):\n            v1 = 0\n            while a1:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n\n        def find_candidates(a1, a2):\n            v1 = v2[len(a1)] - 1\n            v2 = len(a1) // a2\n            v3 = [v1] * (v1 + 1)\n            for v4 in range(v1 + 1):\n                if popcount(v4) != v2:\n                    continue\n                v5 = 0\n                v6, v7 = (0, v1)\n                for v8 in range(len(a1)):\n                    if v4 & v2[v8] == 0:\n                        continue\n                    if v5 & v2[a1[v8]]:\n                        break\n                    v5 |= v2[a1[v8]]\n                    v6 = max(v6, a1[v8])\n                    v7 = min(v7, a1[v8])\n                else:\n                    v3[v4] = v6 - v7\n            return v3\n        v4 = find_candidates(a1, a2)\n        v5 = len(a1) // a2\n        v6 = v2[len(a1)] - 1\n        v7 = [v1] * (v6 + 1)\n        v7[0] = 0\n        for v8 in range(v6 + 1):\n            if popcount(v8) % v5 != 0:\n                continue\n            v9 = v8\n            while v9:\n                v7[v8] = min(v7[v8], v7[v8 - v9] + v4[v9])\n                v9 = v9 - 1 & v8\n        return v7[-1] if v7[-1] != v1 else -1\n"}
{"id": "llm_code\\beautiful-towers-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumSumOfHeights(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = [-1]\n        v4 = 0\n        for v5 in range(v1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v5]:\n                v6 = v3.pop()\n                v4 -= (v6 - v3[-1]) * a1[v6]\n            v4 += (v5 - v3[-1]) * a1[v5]\n            v3.append(v5)\n            v2[v5] = v4\n        v7 = [0] * v1\n        v3 = [v1]\n        v4 = 0\n        for v5 in range(v1 - 1, -1, -1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v5]:\n                v6 = v3.pop()\n                v4 -= (v3[-1] - v6) * a1[v6]\n            v4 += (v3[-1] - v5) * a1[v5]\n            v3.append(v5)\n            v7[v5] = v4\n        v8 = 0\n        for v5 in range(v1):\n            v8 = max(v8, v2[v5] + v7[v5] - a1[v5])\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumSumOfHeights(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = [-1]\n        v4 = 0\n        for v5 in range(v1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v5]:\n                v6 = v3.pop()\n                v4 -= (v6 - v3[-1]) * a1[v6]\n            v4 += (v5 - v3[-1]) * a1[v5]\n            v3.append(v5)\n            v2[v5] = v4\n        v7 = [0] * v1\n        v3 = [v1]\n        v4 = 0\n        for v5 in range(v1 - 1, -1, -1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v5]:\n                v6 = v3.pop()\n                v4 -= (v3[-1] - v6) * a1[v6]\n            v4 += (v3[-1] - v5) * a1[v5]\n            v3.append(v5)\n            v7[v5] = v4\n        v8 = 0\n        for v5 in range(v1):\n            v8 = max(v8, v2[v5] + v7[v5] - a1[v5])\n        return v8\n"}
{"id": "human_code\\longest-happy-string__part1.py", "text": "import heapq\n\nclass C1(object):\n\n    def longestDiverseString(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        if a1:\n            heapq.heappush(v1, (-a1, 'a'))\n        if a2:\n            heapq.heappush(v1, (-a2, 'b'))\n        if a3:\n            heapq.heappush(v1, (-a3, 'c'))\n        v2 = []\n        while v1:\n            v3, v4 = heapq.heappop(v1)\n            if len(v2) >= 2 and v2[-1] == v2[-2] == v4:\n                if not v1:\n                    return ''.join(v2)\n                v5, v6 = heapq.heappop(v1)\n                v2.append(v6)\n                v5 += 1\n                if v5:\n                    heapq.heappush(v1, (v5, v6))\n                heapq.heappush(v1, (v3, v4))\n                continue\n            v2.append(v4)\n            v3 += 1\n            if v3 != 0:\n                heapq.heappush(v1, (v3, v4))\n        return ''.join(v2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def longestDiverseString(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        if a1:\n            heapq.heappush(v1, (-a1, 'a'))\n        if a2:\n            heapq.heappush(v1, (-a2, 'b'))\n        if a3:\n            heapq.heappush(v1, (-a3, 'c'))\n        v2 = []\n        while v1:\n            v3, v4 = heapq.heappop(v1)\n            if len(v2) >= 2 and v2[-1] == v2[-2] == v4:\n                if not v1:\n                    return ''.join(v2)\n                v5, v6 = heapq.heappop(v1)\n                v2.append(v6)\n                v5 += 1\n                if v5:\n                    heapq.heappush(v1, (v5, v6))\n                heapq.heappush(v1, (v3, v4))\n                continue\n            v2.append(v4)\n            v3 += 1\n            if v3 != 0:\n                heapq.heappush(v1, (v3, v4))\n        return ''.join(v2)\n"}
{"id": "human_code\\longest-word-with-all-prefixes__part1.py", "text": "import collections\nimport string\n\nclass C1(object):\n\n    def longestWord(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1, a2):\n            v1 = -1\n            v2 = [a2]\n            while v2:\n                a2 = v2.pop()\n                if v1 == -1 or len(a1[a2['_end']]) > len(a1[v1]):\n                    v1 = a2['_end']\n                for v4 in reversed(string.ascii_lowercase):\n                    if v4 not in a2 or '_end' not in a2[v4]:\n                        continue\n                    v2.append(a2[v4])\n            return v1\n        v1 = lambda: collections.defaultdict(v1)\n        v2 = v1()\n        v2['_end'] = -1\n        for v3, v4 in enumerate(a1):\n            reduce(dict.__getitem__, v4, v2)['_end'] = v3\n        v5 = iter_dfs(a1, v2)\n        return a1[v5] if v5 != -1 else ''\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport string\n\nclass C1(object):\n\n    def longestWord(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1, a2):\n            v1 = -1\n            v2 = [a2]\n            while v2:\n                a2 = v2.pop()\n                if v1 == -1 or len(a1[a2['_end']]) > len(a1[v1]):\n                    v1 = a2['_end']\n                for v4 in reversed(string.ascii_lowercase):\n                    if v4 not in a2 or '_end' not in a2[v4]:\n                        continue\n                    v2.append(a2[v4])\n            return v1\n        v1 = lambda: collections.defaultdict(v1)\n        v2 = v1()\n        v2['_end'] = -1\n        for v3, v4 in enumerate(a1):\n            reduce(dict.__getitem__, v4, v2)['_end'] = v3\n        v5 = iter_dfs(a1, v2)\n        return a1[v5] if v5 != -1 else ''\n"}
{"id": "human_code\\number-of-operations-to-make-network-connected__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.count = a1\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[max(v1, v2)] = min(v1, v2)\n        self.count -= 1\n        return True\n\nclass C2(object):\n\n    def makeConnected(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if len(a2) < a1 - 1:\n            return -1\n        v1 = C1(a1)\n        for v2, v3 in a2:\n            v1.union_set(v2, v3)\n        return v1.count - 1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.count = a1\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[max(v1, v2)] = min(v1, v2)\n        self.count -= 1\n        return True\n\nclass C2(object):\n\n    def makeConnected(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if len(a2) < a1 - 1:\n            return -1\n        v1 = C1(a1)\n        for v2, v3 in a2:\n            v1.union_set(v2, v3)\n        return v1.count - 1\n"}
{"id": "llm_code\\p03007__s843297187.py", "text": "import sys\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = max(v2)\nv4 = min(v2)\nv2.pop(v3)\nv2.pop(v4)\nv5 = v3 - v4\nfor v6 in range(v1 - 2):\n    v5 += abs(v2[v6])\nprint(v5)\nfor v6 in range(v1 - 2):\n    if v2[v6] > 0:\n        print(v4, v2[v6])\n        v4 -= v2[v6]\n    else:\n        print(v3, v2[v6])\n        v3 -= v2[v6]\nprint(v3, v4)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.readline\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = max(v2)\nv4 = min(v2)\nv2.pop(v3)\nv2.pop(v4)\nv5 = v3 - v4\nfor v6 in range(v1 - 2):\n    v5 += abs(v2[v6])\nprint(v5)\nfor v6 in range(v1 - 2):\n    if v2[v6] > 0:\n        print(v4, v2[v6])\n        v4 -= v2[v6]\n    else:\n        print(v3, v2[v6])\n        v3 -= v2[v6]\nprint(v3, v4)\n"}
{"id": "llm_code\\minimum-positive-sum-subarray__grok-4.1-fast__v1.py", "text": "import bisect\n\nclass C1:\n\n    def minimumSumSubarray(self, a1, a2, a3):\n        v1 = float('inf')\n        v2 = float('-inf')\n        v3 = len(a1)\n        v4 = [0] * (v3 + 1)\n        for v5 in range(v3):\n            v4[v5 + 1] = v4[v5] + a1[v5]\n        v6 = sorted(set(v4))\n        v7 = len(v6)\n        if v7 == 0:\n            return -1\n        v8 = {v6[j]: j for v9 in range(v7)}\n        v10 = [v2] * (4 * v7)\n        v11 = [0] * v7\n\n        def update_tree(a1, a2, a3, a4, a5):\n            if a2 == a3:\n                v10[a1] = a5\n                return\n            v1 = (a2 + a3) // 2\n            if a4 <= v1:\n                update_tree(2 * a1, a2, v1, a4, a5)\n            else:\n                update_tree(2 * a1 + 1, v1 + 1, a3, a4, a5)\n            v10[a1] = max(v10[2 * a1], v10[2 * a1 + 1])\n\n        def query_tree(a1, a2, a3, a4, a5):\n            if a5 < a2 or a3 < a4:\n                return v2\n            if a4 <= a2 and a3 <= a5:\n                return v10[a1]\n            v1 = (a2 + a3) // 2\n            v2 = query_tree(2 * a1, a2, v1, a4, a5)\n            v3 = query_tree(2 * a1 + 1, v1 + 1, a3, a4, a5)\n            return max(v2, v3)\n        v12 = v1\n        for v5 in range(v3):\n            v13 = v5 - a2 + 1\n            if v13 >= 0:\n                v14 = v8[v4[v13]]\n                v11[v14] += 1\n                if v11[v14] == 1:\n                    update_tree(1, 0, v7 - 1, v14, v6[v14])\n            v15 = v5 - a3\n            if v15 >= 0:\n                v14 = v8[v4[v15]]\n                v11[v14] -= 1\n                if v11[v14] == 0:\n                    update_tree(1, 0, v7 - 1, v14, v2)\n            v16 = v4[v5 + 1]\n            v17 = bisect.bisect_left(v6, v16) - 1\n            if v17 >= 0:\n                v18 = query_tree(1, 0, v7 - 1, 0, v17)\n                if v18 != v2:\n                    v12 = min(v12, v16 - v18)\n        return v12 if v12 < v1 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1:\n\n    def minimumSumSubarray(self, a1, a2, a3):\n        v1 = float('inf')\n        v2 = float('-inf')\n        v3 = len(a1)\n        v4 = [0] * (v3 + 1)\n        for v5 in range(v3):\n            v4[v5 + 1] = v4[v5] + a1[v5]\n        v6 = sorted(set(v4))\n        v7 = len(v6)\n        if v7 == 0:\n            return -1\n        v8 = {v6[j]: j for v9 in range(v7)}\n        v10 = [v2] * (4 * v7)\n        v11 = [0] * v7\n\n        def update_tree(a1, a2, a3, a4, a5):\n            if a2 == a3:\n                v10[a1] = a5\n                return\n            v1 = (a2 + a3) // 2\n            if a4 <= v1:\n                update_tree(2 * a1, a2, v1, a4, a5)\n            else:\n                update_tree(2 * a1 + 1, v1 + 1, a3, a4, a5)\n            v10[a1] = max(v10[2 * a1], v10[2 * a1 + 1])\n\n        def query_tree(a1, a2, a3, a4, a5):\n            if a5 < a2 or a3 < a4:\n                return v2\n            if a4 <= a2 and a3 <= a5:\n                return v10[a1]\n            v1 = (a2 + a3) // 2\n            v2 = query_tree(2 * a1, a2, v1, a4, a5)\n            v3 = query_tree(2 * a1 + 1, v1 + 1, a3, a4, a5)\n            return max(v2, v3)\n        v12 = v1\n        for v5 in range(v3):\n            v13 = v5 - a2 + 1\n            if v13 >= 0:\n                v14 = v8[v4[v13]]\n                v11[v14] += 1\n                if v11[v14] == 1:\n                    update_tree(1, 0, v7 - 1, v14, v6[v14])\n            v15 = v5 - a3\n            if v15 >= 0:\n                v14 = v8[v4[v15]]\n                v11[v14] -= 1\n                if v11[v14] == 0:\n                    update_tree(1, 0, v7 - 1, v14, v2)\n            v16 = v4[v5 + 1]\n            v17 = bisect.bisect_left(v6, v16) - 1\n            if v17 >= 0:\n                v18 = query_tree(1, 0, v7 - 1, 0, v17)\n                if v18 != v2:\n                    v12 = min(v12, v16 - v18)\n        return v12 if v12 < v1 else -1\n"}
{"id": "human_code\\p03252__s758483892.py", "text": "import math\nimport copy\nimport sys\nimport fractions\nimport numpy as np\nfrom functools import reduce\n\ndef f1():\n    v1 = int(input())\n    return v1\n\ndef f2():\n    v1 = []\n    v2 = input().split()\n    v3 = [int(n) for v4 in v2]\n    return v3\n\ndef f3(a1):\n    v1 = []\n    for v2 in range(a1):\n        v3 = int(input())\n        v1.append(v3)\n    return v1\n\ndef f4(a1):\n    v1 = []\n    v2 = []\n    for v3 in range(a1):\n        v4 = input().split()\n        v1 = [int(a1) for a1 in v4]\n        v2.append(v1)\n    return v2\n\ndef f5():\n    v1 = str(input())\n    return v1\nv1 = f5()\nv2 = f5()\nv3 = []\nv3 = list(v1)\nv4 = []\nv4 = list(v2)\nv5 = len(v3)\nv6 = {}\nv7 = {}\nv8 = True\nfor v9 in range(v5):\n    v10 = v3[v9]\n    v11 = v4[v9]\n    if v10 not in v6:\n        v6[v10] = v11\n    elif v6[v10] != v11:\n        v8 = False\n        break\n    if v11 not in v7:\n        v7[v11] = v10\n    elif v7[v11] != v10:\n        v8 = False\n        break\nif v8:\n    print('Yes')\nelse:\n    print('No')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math\nimport copy\nimport sys\nimport fractions\nimport numpy as np\nfrom functools import reduce\n\ndef f1():\n    v1 = int(input())\n    return v1\n\ndef f2():\n    v1 = []\n    v2 = input().split()\n    v3 = [int(n) for v4 in v2]\n    return v3\n\ndef f3(a1):\n    v1 = []\n    for v2 in range(a1):\n        v3 = int(input())\n        v1.append(v3)\n    return v1\n\ndef f4(a1):\n    v1 = []\n    v2 = []\n    for v3 in range(a1):\n        v4 = input().split()\n        v1 = [int(a1) for a1 in v4]\n        v2.append(v1)\n    return v2\n\ndef f5():\n    v1 = str(input())\n    return v1\nv1 = f5()\nv2 = f5()\nv3 = []\nv3 = list(v1)\nv4 = []\nv4 = list(v2)\nv5 = len(v3)\nv6 = {}\nv7 = {}\nv8 = True\nfor v9 in range(v5):\n    v10 = v3[v9]\n    v11 = v4[v9]\n    if v10 not in v6:\n        v6[v10] = v11\n    elif v6[v10] != v11:\n        v8 = False\n        break\n    if v11 not in v7:\n        v7[v11] = v10\n    elif v7[v11] != v10:\n        v8 = False\n        break\nif v8:\n    print('Yes')\nelse:\n    print('No')\n"}
{"id": "human_code\\my-calendar-i__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.__start = a1\n        self.__end = a2\n        self.__left = None\n        self.__right = None\n\n    def insert(self, a1):\n        if a1.__start >= self.__end:\n            if not self.__right:\n                self.__right = a1\n                return True\n            return self.__right.insert(a1)\n        elif a1.__end <= self.__start:\n            if not self.__left:\n                self.__left = a1\n                return True\n            return self.__left.insert(a1)\n        else:\n            return False\n\nclass C2(object):\n\n    def __init__(self):\n        self.__root = None\n\n    def book(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if self.__root is None:\n            self.__root = C1(a1, a2)\n            return True\n        return self.root.insert(C1(a1, a2))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.__start = a1\n        self.__end = a2\n        self.__left = None\n        self.__right = None\n\n    def insert(self, a1):\n        if a1.__start >= self.__end:\n            if not self.__right:\n                self.__right = a1\n                return True\n            return self.__right.insert(a1)\n        elif a1.__end <= self.__start:\n            if not self.__left:\n                self.__left = a1\n                return True\n            return self.__left.insert(a1)\n        else:\n            return False\n\nclass C2(object):\n\n    def __init__(self):\n        self.__root = None\n\n    def book(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if self.__root is None:\n            self.__root = C1(a1, a2)\n            return True\n        return self.root.insert(C1(a1, a2))\n"}
{"id": "human_code\\p03409__s475858054.py", "text": "v1 = int(input())\nv2 = []\nfor v3 in range(v1):\n    v4 = list(map(int, input().split()))\n    v2 += [v4]\nv2.sort(reverse=False)\nv5 = []\nfor v3 in range(v1):\n    v4 = list(map(int, input().split()))\n    v5 += [v4]\nv5.sort(reverse=False)\n\ndef f1(a1):\n    v1 = 10 ** 9\n    v2 = 0\n    v3 = -1\n    for v4 in range(v1):\n        if v5[a1][0] > v2[v4][0]:\n            if v3 < v2[v4][1] and v5[a1][1] > v2[v4][1]:\n                v2 = 1\n                v3 = max(v3, v2[v4][1])\n                v5 = v4\n    if v2 == 0:\n        return False\n    else:\n        v2[v5][0] = v1\n        v2[v5][1] = v1\n        return True\nv6 = 0\nfor v7 in range(v1):\n    if f1(v7):\n        v6 += 1\nprint(v6)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = []\nfor v3 in range(v1):\n    v4 = list(map(int, input().split()))\n    v2 += [v4]\nv2.sort(reverse=False)\nv5 = []\nfor v3 in range(v1):\n    v4 = list(map(int, input().split()))\n    v5 += [v4]\nv5.sort(reverse=False)\n\ndef f1(a1):\n    v1 = 10 ** 9\n    v2 = 0\n    v3 = -1\n    for v4 in range(v1):\n        if v5[a1][0] > v2[v4][0]:\n            if v3 < v2[v4][1] and v5[a1][1] > v2[v4][1]:\n                v2 = 1\n                v3 = max(v3, v2[v4][1])\n                v5 = v4\n    if v2 == 0:\n        return False\n    else:\n        v2[v5][0] = v1\n        v2[v5][1] = v1\n        return True\nv6 = 0\nfor v7 in range(v1):\n    if f1(v7):\n        v6 += 1\nprint(v6)\n"}
{"id": "human_code\\p03559__s399128605.py", "text": "def f1(a1, a2):\n    v1 = 0\n    v2 = len(a1)\n    while v2 - v1 > 1:\n        v3 = (v2 + v1 - 1) // 2\n        if a1[v3] <= a2:\n            v1 = v3 + 1\n        else:\n            v2 = v3 + 1\n    return v1\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = list(map(int, input().split()))\nv2.sort()\nv2.append(v2[-1] + 1)\nv3.sort()\nv4.sort()\nv4 = [0] + v4\nv4 = [-c for v5 in v4[::-1]]\nv6 = 0\nfor v7 in v3:\n    v6 += f1(v2, v7 - 1) * f1(v4, -(v7 + 1))\nprint(v6)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1, a2):\n    v1 = 0\n    v2 = len(a1)\n    while v2 - v1 > 1:\n        v3 = (v2 + v1 - 1) // 2\n        if a1[v3] <= a2:\n            v1 = v3 + 1\n        else:\n            v2 = v3 + 1\n    return v1\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = list(map(int, input().split()))\nv2.sort()\nv2.append(v2[-1] + 1)\nv3.sort()\nv4.sort()\nv4 = [0] + v4\nv4 = [-c for v5 in v4[::-1]]\nv6 = 0\nfor v7 in v3:\n    v6 += f1(v2, v7 - 1) * f1(v4, -(v7 + 1))\nprint(v6)\n"}
{"id": "human_code\\maximum-value-sum-by-placing-three-rooks-i__part1.py", "text": "import heapq\nimport itertools\n\nclass C1(object):\n\n    def maximumValueSum(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 3\n        v2 = [[] for v3 in range(len(a1[0]))]\n        for v4 in range(len(a1)):\n            v5 = []\n            for v6 in range(len(a1[0])):\n                heapq.heappush(v5, (a1[v4][v6], v4, v6))\n                if len(v5) == v1 + 1:\n                    heapq.heappop(v5)\n            for v7, v4, v6 in v5:\n                heapq.heappush(v2[v6], (v7, v4, v6))\n                if len(v2[v6]) == v1 + 1:\n                    heapq.heappop(v2[v6])\n        v5 = []\n        for v8 in v2:\n            for v9 in v8:\n                heapq.heappush(v5, v9)\n                if len(v5) == (v1 - 1) * (2 * v1 - 1) + 1 + 1:\n                    heapq.heappop(v5)\n        return max((sum((v9[0] for v9 in c)) for v10 in itertools.combinations(v5, v1) if len({v9[1] for v9 in v10}) == v1 == len({v9[2] for v9 in v10})))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\nimport itertools\n\nclass C1(object):\n\n    def maximumValueSum(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 3\n        v2 = [[] for v3 in range(len(a1[0]))]\n        for v4 in range(len(a1)):\n            v5 = []\n            for v6 in range(len(a1[0])):\n                heapq.heappush(v5, (a1[v4][v6], v4, v6))\n                if len(v5) == v1 + 1:\n                    heapq.heappop(v5)\n            for v7, v4, v6 in v5:\n                heapq.heappush(v2[v6], (v7, v4, v6))\n                if len(v2[v6]) == v1 + 1:\n                    heapq.heappop(v2[v6])\n        v5 = []\n        for v8 in v2:\n            for v9 in v8:\n                heapq.heappush(v5, v9)\n                if len(v5) == (v1 - 1) * (2 * v1 - 1) + 1 + 1:\n                    heapq.heappop(v5)\n        return max((sum((v9[0] for v9 in c)) for v10 in itertools.combinations(v5, v1) if len({v9[1] for v9 in v10}) == v1 == len({v9[2] for v9 in v10})))\n"}
{"id": "human_code\\couples-holding-hands.py", "text": "class C1(object):\n\n    def minSwapsCouples(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = len(a1) // 2\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5 in enumerate(a1):\n            v2[v5 // 2].append(v4 // 2)\n        v6 = [[] for v3 in range(v1)]\n        for v7, v8 in v2:\n            v6[v7].append(v8)\n            v6[v8].append(v7)\n        v9 = 0\n        for v10 in range(v1):\n            if not v6[v10]:\n                continue\n            v7, v8 = (v10, v6[v10].pop())\n            while v8 != v10:\n                v9 += 1\n                v6[v8].remove(v7)\n                v7, v8 = (v8, v6[v8].pop())\n        return v9\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minSwapsCouples(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = len(a1) // 2\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5 in enumerate(a1):\n            v2[v5 // 2].append(v4 // 2)\n        v6 = [[] for v3 in range(v1)]\n        for v7, v8 in v2:\n            v6[v7].append(v8)\n            v6[v8].append(v7)\n        v9 = 0\n        for v10 in range(v1):\n            if not v6[v10]:\n                continue\n            v7, v8 = (v10, v6[v10].pop())\n            while v8 != v10:\n                v9 += 1\n                v6[v8].remove(v7)\n                v7, v8 = (v8, v6[v8].pop())\n        return v9\n"}
{"id": "llm_code\\jump-game-iv__grok-4.1-fast__v1.py", "text": "import collections\nfrom collections import deque\n\nclass C1(object):\n\n    def minJumps(self, a1):\n        v1 = len(a1)\n        v2 = collections.defaultdict(list)\n        for v3, v4 in enumerate(a1):\n            v2[v4].append(v3)\n        v5 = set([0])\n        v6 = deque([(0, 0)])\n        v7 = set()\n        while v6:\n            v8, v9 = v6.popleft()\n            if v8 == v1 - 1:\n                return v9\n            for v10 in [-1, 1]:\n                v11 = v8 + v10\n                if 0 <= v11 < v1 and v11 not in v5:\n                    v5.add(v11)\n                    v6.append((v11, v9 + 1))\n            v12 = a1[v8]\n            if v12 not in v7:\n                v7.add(v12)\n                for v13 in v2[v12]:\n                    if v13 not in v5:\n                        v5.add(v13)\n                        v6.append((v13, v9 + 1))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom collections import deque\n\nclass C1(object):\n\n    def minJumps(self, a1):\n        v1 = len(a1)\n        v2 = collections.defaultdict(list)\n        for v3, v4 in enumerate(a1):\n            v2[v4].append(v3)\n        v5 = set([0])\n        v6 = deque([(0, 0)])\n        v7 = set()\n        while v6:\n            v8, v9 = v6.popleft()\n            if v8 == v1 - 1:\n                return v9\n            for v10 in [-1, 1]:\n                v11 = v8 + v10\n                if 0 <= v11 < v1 and v11 not in v5:\n                    v5.add(v11)\n                    v6.append((v11, v9 + 1))\n            v12 = a1[v8]\n            if v12 not in v7:\n                v7.add(v12)\n                for v13 in v2[v12]:\n                    if v13 not in v5:\n                        v5.add(v13)\n                        v6.append((v13, v9 + 1))\n"}
{"id": "llm_code\\design-twitter__grok-4.1-fast__v1.py", "text": "import collections\nimport heapq\nfrom typing import List\n\nclass C1:\n\n    def __init__(self):\n        self.tweet_lists = collections.defaultdict(list)\n        self.followers_map = collections.defaultdict(set)\n        self.global_time = 0\n\n    def postTweet(self, a1: int, a2: int) -> None:\n        self.global_time += 1\n        self.tweet_lists[a1].append((self.global_time, a2))\n\n    def getNewsFeed(self, a1: int) -> List[int]:\n        v1 = []\n        v2 = list(self.followers_map[a1]) + [a1]\n        for v3 in v2:\n            if self.tweet_lists[v3]:\n                v4, v5 = self.tweet_lists[v3][-1]\n                heapq.heappush(v1, (-v4, v3, len(self.tweet_lists[v3]) - 1))\n        v6 = []\n        while v1 and len(v6) < 10:\n            v5, v3, v7 = heapq.heappop(v1)\n            v6.append(self.tweet_lists[v3][v7][1])\n            if v7 > 0:\n                v8, v5 = self.tweet_lists[v3][v7 - 1]\n                heapq.heappush(v1, (-v8, v3, v7 - 1))\n        return v6\n\n    def follow(self, a1: int, a2: int) -> None:\n        if a1 != a2:\n            self.followers_map[a1].add(a2)\n\n    def unfollow(self, a1: int, a2: int) -> None:\n        self.followers_map[a1].discard(a2)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\nimport heapq\nfrom typing import List\n\nclass C1:\n\n    def __init__(self):\n        self.tweet_lists = collections.defaultdict(list)\n        self.followers_map = collections.defaultdict(set)\n        self.global_time = 0\n\n    def postTweet(self, a1: int, a2: int) -> None:\n        self.global_time += 1\n        self.tweet_lists[a1].append((self.global_time, a2))\n\n    def getNewsFeed(self, a1: int) -> List[int]:\n        v1 = []\n        v2 = list(self.followers_map[a1]) + [a1]\n        for v3 in v2:\n            if self.tweet_lists[v3]:\n                v4, v5 = self.tweet_lists[v3][-1]\n                heapq.heappush(v1, (-v4, v3, len(self.tweet_lists[v3]) - 1))\n        v6 = []\n        while v1 and len(v6) < 10:\n            v5, v3, v7 = heapq.heappop(v1)\n            v6.append(self.tweet_lists[v3][v7][1])\n            if v7 > 0:\n                v8, v5 = self.tweet_lists[v3][v7 - 1]\n                heapq.heappush(v1, (-v8, v3, v7 - 1))\n        return v6\n\n    def follow(self, a1: int, a2: int) -> None:\n        if a1 != a2:\n            self.followers_map[a1].add(a2)\n\n    def unfollow(self, a1: int, a2: int) -> None:\n        self.followers_map[a1].discard(a2)\n"}
{"id": "llm_code\\number-of-nodes-in-the-sub-tree-with-the-same-label__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def countSubTrees(self, a1, a2, a3):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [[] for v2 in range(a1)]\n        v6 = [False] * a1\n        v7 = deque([0])\n        v6[0] = True\n        while v7:\n            v8 = v7.popleft()\n            for v9 in v1[v8]:\n                if not v6[v9]:\n                    v6[v9] = True\n                    v5[v8].append(v9)\n                    v7.append(v9)\n        v10 = [0] * a1\n\n        def postorder(a1):\n            v1 = ord(a3[a1]) - ord('a')\n            v2 = 1\n            v3 = [0] * 26\n            v3[v1] = 1\n            for v4 in v5[a1]:\n                v5 = postorder(v4)\n                v2 += v5[v1]\n                for v6 in range(26):\n                    v3[v6] += v5[v6]\n            v10[a1] = v2\n            return v3\n        postorder(0)\n        return v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def countSubTrees(self, a1, a2, a3):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [[] for v2 in range(a1)]\n        v6 = [False] * a1\n        v7 = deque([0])\n        v6[0] = True\n        while v7:\n            v8 = v7.popleft()\n            for v9 in v1[v8]:\n                if not v6[v9]:\n                    v6[v9] = True\n                    v5[v8].append(v9)\n                    v7.append(v9)\n        v10 = [0] * a1\n\n        def postorder(a1):\n            v1 = ord(a3[a1]) - ord('a')\n            v2 = 1\n            v3 = [0] * 26\n            v3[v1] = 1\n            for v4 in v5[a1]:\n                v5 = postorder(v4)\n                v2 += v5[v1]\n                for v6 in range(26):\n                    v3[v6] += v5[v6]\n            v10[a1] = v2\n            return v3\n        postorder(0)\n        return v10\n"}
{"id": "llm_code\\odd-even-jump__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def oddEvenJumps(self, a1):\n        v1 = len(a1)\n        v2 = [None] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            while v3 and a1[v3[-1]] < a1[v4]:\n                v3.pop()\n            if v3:\n                v2[v4] = v3[-1]\n            v3.append(v4)\n        v5 = [v1] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            while v3 and a1[v3[-1]] <= a1[v4]:\n                v3.pop()\n            if v3:\n                v5[v4] = v3[-1]\n            v3.append(v4)\n        v6 = [None] * v1\n        for v4 in range(v1):\n            v7 = v5[v4] - 1\n            if v7 > v4:\n                v6[v4] = v7\n        v8 = [False] * v1\n        v9 = [False] * v1\n        v8[v1 - 1] = True\n        v9[v1 - 1] = True\n        for v4 in range(v1 - 2, -1, -1):\n            if v2[v4] is not None:\n                v8[v4] = v9[v2[v4]]\n            if v6[v4] is not None:\n                v9[v4] = v8[v6[v4]]\n        return sum(v8)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def oddEvenJumps(self, a1):\n        v1 = len(a1)\n        v2 = [None] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            while v3 and a1[v3[-1]] < a1[v4]:\n                v3.pop()\n            if v3:\n                v2[v4] = v3[-1]\n            v3.append(v4)\n        v5 = [v1] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            while v3 and a1[v3[-1]] <= a1[v4]:\n                v3.pop()\n            if v3:\n                v5[v4] = v3[-1]\n            v3.append(v4)\n        v6 = [None] * v1\n        for v4 in range(v1):\n            v7 = v5[v4] - 1\n            if v7 > v4:\n                v6[v4] = v7\n        v8 = [False] * v1\n        v9 = [False] * v1\n        v8[v1 - 1] = True\n        v9[v1 - 1] = True\n        for v4 in range(v1 - 2, -1, -1):\n            if v2[v4] is not None:\n                v8[v4] = v9[v2[v4]]\n            if v6[v4] is not None:\n                v9[v4] = v8[v6[v4]]\n        return sum(v8)\n"}
{"id": "human_code\\maximum-partition-factor__part1.py", "text": "class C1(object):\n\n    def maxPartitionFactor(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class UnionFind(object):\n\n            def __init__(self, a1):\n                self.set = list(range(a1))\n                self.rank = [0] * a1\n                self.parity = [0] * a1\n\n            def find_set(self, a1):\n                v1 = []\n                while self.set[a1] != a1:\n                    v1.append(a1)\n                    a1 = self.set[a1]\n                while v1:\n                    v3 = v1.pop()\n                    self.parity[v3] ^= self.parity[self.set[v3]]\n                    self.set[v3] = a1\n                return a1\n\n            def union_set(self, a1, a2):\n                v1, v2 = (a1, a2)\n                a1, a2 = (self.find_set(a1), self.find_set(a2))\n                if a1 == a2:\n                    return self.parity[v1] != self.parity[v2]\n                if self.rank[a1] > self.rank[a2]:\n                    a1, a2 = (a2, a1)\n                    v1, v2 = (v2, v1)\n                if self.rank[a1] == self.rank[a2]:\n                    self.rank[a2] += 1\n                self.set[a1] = self.set[a2]\n                self.parity[a1] = self.parity[v1] ^ self.parity[v2] ^ 1\n                return True\n\n        def dist(a1, a2):\n            return abs(a1[a1][0] - a1[a2][0]) + abs(a1[a1][1] - a1[a2][1])\n        v1 = sorted(((dist(u, v), u, v) for v2 in range(len(a1)) for v3 in range(v2 + 1, len(a1))))\n        v4 = UnionFind(len(a1))\n        return next((d for v5, v2, v3 in v1 if not v4.union_set(v2, v3)), 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxPartitionFactor(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class UnionFind(object):\n\n            def __init__(self, a1):\n                self.set = list(range(a1))\n                self.rank = [0] * a1\n                self.parity = [0] * a1\n\n            def find_set(self, a1):\n                v1 = []\n                while self.set[a1] != a1:\n                    v1.append(a1)\n                    a1 = self.set[a1]\n                while v1:\n                    v3 = v1.pop()\n                    self.parity[v3] ^= self.parity[self.set[v3]]\n                    self.set[v3] = a1\n                return a1\n\n            def union_set(self, a1, a2):\n                v1, v2 = (a1, a2)\n                a1, a2 = (self.find_set(a1), self.find_set(a2))\n                if a1 == a2:\n                    return self.parity[v1] != self.parity[v2]\n                if self.rank[a1] > self.rank[a2]:\n                    a1, a2 = (a2, a1)\n                    v1, v2 = (v2, v1)\n                if self.rank[a1] == self.rank[a2]:\n                    self.rank[a2] += 1\n                self.set[a1] = self.set[a2]\n                self.parity[a1] = self.parity[v1] ^ self.parity[v2] ^ 1\n                return True\n\n        def dist(a1, a2):\n            return abs(a1[a1][0] - a1[a2][0]) + abs(a1[a1][1] - a1[a2][1])\n        v1 = sorted(((dist(u, v), u, v) for v2 in range(len(a1)) for v3 in range(v2 + 1, len(a1))))\n        v4 = UnionFind(len(a1))\n        return next((d for v5, v2, v3 in v1 if not v4.union_set(v2, v3)), 0)\n"}
{"id": "human_code\\p03150__s169796892.py", "text": "import re\nv1 = input()\nv2 = 'keyence'\nv3 = False\nfor v4 in range(0, len(v2)):\n    v5 = v2[:v4 + 1]\n    v6 = v2[-(len(v2) - v4 - 1):]\n    v7 = v1.find(v5)\n    v8 = v1.rfind(v6)\n    if v7 < 0 or v8 < 0:\n        continue\n    elif v7 == 0:\n        if v8 == len(v1) - len(v6):\n            v3 = True\nif v1.find(v2) >= 0 and v1.find(v2) == len(v1) - len(v2):\n    v3 = True\nif v1.find(v2) == 0:\n    v3 = True\nif v3:\n    print('YES')\nelse:\n    print('NO')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import re\nv1 = input()\nv2 = 'keyence'\nv3 = False\nfor v4 in range(0, len(v2)):\n    v5 = v2[:v4 + 1]\n    v6 = v2[-(len(v2) - v4 - 1):]\n    v7 = v1.find(v5)\n    v8 = v1.rfind(v6)\n    if v7 < 0 or v8 < 0:\n        continue\n    elif v7 == 0:\n        if v8 == len(v1) - len(v6):\n            v3 = True\nif v1.find(v2) >= 0 and v1.find(v2) == len(v1) - len(v2):\n    v3 = True\nif v1.find(v2) == 0:\n    v3 = True\nif v3:\n    print('YES')\nelse:\n    print('NO')\n"}
{"id": "llm_code\\coin-path__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def cheapestJump(self, a1, a2):\n        if not a1 or a1[-1] == -1:\n            return []\n        v1 = len(a1)\n        v2 = float('inf')\n        v3 = [v2] * v1\n        v4 = [-1] * v1\n        if a1[0] != -1:\n            v3[0] = a1[0]\n        for v5 in range(v1):\n            if v3[v5] == v2 or a1[v5] == -1:\n                continue\n            for v6 in range(v5 + 1, min(v1, v5 + a2 + 1)):\n                if a1[v6] == -1:\n                    continue\n                v7 = v3[v5] + a1[v6]\n                if v7 < v3[v6]:\n                    v3[v6] = v7\n                    v4[v6] = v5\n        if v3[v1 - 1] == v2:\n            return []\n        v8 = []\n        v9 = v1 - 1\n        while v9 != -1:\n            v8.append(v9 + 1)\n            v9 = v4[v9]\n        v8.reverse()\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def cheapestJump(self, a1, a2):\n        if not a1 or a1[-1] == -1:\n            return []\n        v1 = len(a1)\n        v2 = float('inf')\n        v3 = [v2] * v1\n        v4 = [-1] * v1\n        if a1[0] != -1:\n            v3[0] = a1[0]\n        for v5 in range(v1):\n            if v3[v5] == v2 or a1[v5] == -1:\n                continue\n            for v6 in range(v5 + 1, min(v1, v5 + a2 + 1)):\n                if a1[v6] == -1:\n                    continue\n                v7 = v3[v5] + a1[v6]\n                if v7 < v3[v6]:\n                    v3[v6] = v7\n                    v4[v6] = v5\n        if v3[v1 - 1] == v2:\n            return []\n        v8 = []\n        v9 = v1 - 1\n        while v9 != -1:\n            v8.append(v9 + 1)\n            v9 = v4[v9]\n        v8.reverse()\n        return v8\n"}
{"id": "llm_code\\cycle-length-queries-in-a-tree__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def cycleLengthQueries(self, a1, a2):\n        v1 = []\n        for v2, v3 in a2:\n            v4 = v2.bit_length() - 1\n            v5 = v3.bit_length() - 1\n            v6, v7 = (v4, v5)\n            if v4 > v5:\n                v2 >>= v4 - v5\n                v8 = v5\n            elif v5 > v4:\n                v3 >>= v5 - v4\n                v8 = v4\n            else:\n                v8 = v4\n            v9 = v2 ^ v3\n            v10 = v9.bit_length()\n            v11 = v8 - v10\n            v1.append(v6 + v7 - 2 * v11 + 1)\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def cycleLengthQueries(self, a1, a2):\n        v1 = []\n        for v2, v3 in a2:\n            v4 = v2.bit_length() - 1\n            v5 = v3.bit_length() - 1\n            v6, v7 = (v4, v5)\n            if v4 > v5:\n                v2 >>= v4 - v5\n                v8 = v5\n            elif v5 > v4:\n                v3 >>= v5 - v4\n                v8 = v4\n            else:\n                v8 = v4\n            v9 = v2 ^ v3\n            v10 = v9.bit_length()\n            v11 = v8 - v10\n            v1.append(v6 + v7 - 2 * v11 + 1)\n        return v1\n"}
{"id": "llm_code\\finding-mk-average__grok-4.1-fast__v1.py", "text": "import collections\nfrom sortedcontainers import SortedList\n\nclass C1:\n\n    def __init__(self, a1: int, a2: int):\n        self.m_val = a1\n        self.k_val = a2\n        self.elements_queue = collections.deque()\n        self.ordered_list = SortedList()\n        self.overall_sum = 0\n        self.smallest_k_sum = 0\n        self.largest_k_sum = 0\n\n    def addElement(self, a1: int) -> None:\n        if len(self.elements_queue) == self.m_val:\n            v1 = self.elements_queue.popleft()\n            self._handle_removal(v1)\n        self.elements_queue.append(a1)\n        self._handle_insertion(a1)\n\n    def calculateMKAverage(self) -> int:\n        if len(self.ordered_list) < self.m_val:\n            return -1\n        v1 = self.overall_sum - self.smallest_k_sum - self.largest_k_sum\n        return v1 // (self.m_val - 2 * self.k_val)\n\n    def _handle_insertion(self, a1: int) -> None:\n        self.overall_sum += a1\n        v1 = self.ordered_list.bisect_left(a1)\n        v2 = len(self.ordered_list)\n        if v1 < self.k_val:\n            self.smallest_k_sum += a1\n            if v2 >= self.k_val:\n                self.smallest_k_sum -= self.ordered_list[self.k_val - 1]\n        if v1 > v2 - self.k_val:\n            self.largest_k_sum += a1\n            if v2 >= self.k_val:\n                self.largest_k_sum -= self.ordered_list[v2 - self.k_val]\n        self.ordered_list.add(a1)\n\n    def _handle_removal(self, a1: int) -> None:\n        self.overall_sum -= a1\n        v1 = self.ordered_list.index(a1)\n        v2 = len(self.ordered_list)\n        if v1 < self.k_val:\n            self.smallest_k_sum -= a1\n            self.smallest_k_sum += self.ordered_list[self.k_val]\n        elif v1 > v2 - 1 - self.k_val:\n            self.largest_k_sum -= a1\n            self.largest_k_sum += self.ordered_list[v2 - self.k_val - 1]\n        self.ordered_list.remove(a1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom sortedcontainers import SortedList\n\nclass C1:\n\n    def __init__(self, a1: int, a2: int):\n        self.m_val = a1\n        self.k_val = a2\n        self.elements_queue = collections.deque()\n        self.ordered_list = SortedList()\n        self.overall_sum = 0\n        self.smallest_k_sum = 0\n        self.largest_k_sum = 0\n\n    def addElement(self, a1: int) -> None:\n        if len(self.elements_queue) == self.m_val:\n            v1 = self.elements_queue.popleft()\n            self._handle_removal(v1)\n        self.elements_queue.append(a1)\n        self._handle_insertion(a1)\n\n    def calculateMKAverage(self) -> int:\n        if len(self.ordered_list) < self.m_val:\n            return -1\n        v1 = self.overall_sum - self.smallest_k_sum - self.largest_k_sum\n        return v1 // (self.m_val - 2 * self.k_val)\n\n    def _handle_insertion(self, a1: int) -> None:\n        self.overall_sum += a1\n        v1 = self.ordered_list.bisect_left(a1)\n        v2 = len(self.ordered_list)\n        if v1 < self.k_val:\n            self.smallest_k_sum += a1\n            if v2 >= self.k_val:\n                self.smallest_k_sum -= self.ordered_list[self.k_val - 1]\n        if v1 > v2 - self.k_val:\n            self.largest_k_sum += a1\n            if v2 >= self.k_val:\n                self.largest_k_sum -= self.ordered_list[v2 - self.k_val]\n        self.ordered_list.add(a1)\n\n    def _handle_removal(self, a1: int) -> None:\n        self.overall_sum -= a1\n        v1 = self.ordered_list.index(a1)\n        v2 = len(self.ordered_list)\n        if v1 < self.k_val:\n            self.smallest_k_sum -= a1\n            self.smallest_k_sum += self.ordered_list[self.k_val]\n        elif v1 > v2 - 1 - self.k_val:\n            self.largest_k_sum -= a1\n            self.largest_k_sum += self.ordered_list[v2 - self.k_val - 1]\n        self.ordered_list.remove(a1)\n"}
{"id": "human_code\\find-longest-self-contained-substring__part3.py", "text": "class C1(object):\n\n    def maxSubstringLength(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def update(a1, a2, a3, a4):\n            a1 = ord(a1) - ord('a')\n            if cnt2[a1] == cnt[a1]:\n                a4 -= 1\n            if cnt2[a1] == 0:\n                a3 += 1\n            cnt2[a1] += a2\n            if cnt2[a1] == 0:\n                a3 -= 1\n            if cnt2[a1] == cnt[a1]:\n                a4 += 1\n            return (a3, a4)\n        v1 = [0] * 26\n        for v2 in a1:\n            v1[ord(v2) - ord('a')] += 1\n        v3 = -1\n        for v4 in range(1, sum((v2 != 0 for v2 in v1))):\n            v5 = [0] * 26\n            v6 = v7 = v8 = 0\n            for v9 in range(len(a1)):\n                v7, v8 = update(a1[v9], +1, v7, v8)\n                while v7 == v4 + 1:\n                    v7, v8 = update(a1[v6], -1, v7, v8)\n                    v6 += 1\n                if v8 == v4:\n                    v3 = max(v3, v9 - v6 + 1)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxSubstringLength(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def update(a1, a2, a3, a4):\n            a1 = ord(a1) - ord('a')\n            if cnt2[a1] == cnt[a1]:\n                a4 -= 1\n            if cnt2[a1] == 0:\n                a3 += 1\n            cnt2[a1] += a2\n            if cnt2[a1] == 0:\n                a3 -= 1\n            if cnt2[a1] == cnt[a1]:\n                a4 += 1\n            return (a3, a4)\n        v1 = [0] * 26\n        for v2 in a1:\n            v1[ord(v2) - ord('a')] += 1\n        v3 = -1\n        for v4 in range(1, sum((v2 != 0 for v2 in v1))):\n            v5 = [0] * 26\n            v6 = v7 = v8 = 0\n            for v9 in range(len(a1)):\n                v7, v8 = update(a1[v9], +1, v7, v8)\n                while v7 == v4 + 1:\n                    v7, v8 = update(a1[v6], -1, v7, v8)\n                    v6 += 1\n                if v8 == v4:\n                    v3 = max(v3, v9 - v6 + 1)\n        return v3\n"}
{"id": "llm_code\\p03605__s896571782.py", "text": "def f1(a1):\n    if a1 // 10 == 9:\n        print('Yes')\n    elif a1 % 10 == 9:\n        print('Yes')\n    else:\n        print('No')\nif __name__ == '__main__':\n    while True:\n        try:\n            v1 = int(input('2N:'))\n            if 10 <= v1 and v1 <= 99:\n                break\n            else:\n                print('2')\n                print('-----------------------------------------')\n                continue\n        except ValueError:\n            print('2N')\n            print('-----------------------------------------')\n    print(' ######## Result ######## ')\n    f1(v1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1):\n    if a1 // 10 == 9:\n        print('Yes')\n    elif a1 % 10 == 9:\n        print('Yes')\n    else:\n        print('No')\nif __name__ == '__main__':\n    while True:\n        try:\n            v1 = int(input('2N:'))\n            if 10 <= v1 and v1 <= 99:\n                break\n            else:\n                print('2')\n                print('-----------------------------------------')\n                continue\n        except ValueError:\n            print('2N')\n            print('-----------------------------------------')\n    print(' ######## Result ######## ')\n    f1(v1)\n"}
{"id": "llm_code\\p02900__s519239308.py", "text": "import math\n\ndef f1(a1):\n    v1 = []\n    while a1 % 2 == 0:\n        v1.append(2)\n        a1 //= 2\n    v3 = 3\n    while v3 * v3 <= a1:\n        if a1 % v3 == 0:\n            v1.append(v3)\n            a1 //= v3\n        else:\n            v3 += 2\n    if a1 != 1:\n        v1.append(a1)\n    return v1\nv1, v2 = map(int, input().split())\nv3 = math.gcd(v1, v2)\nv4 = f1(v3)\nprint(len(v4))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import math\n\ndef f1(a1):\n    v1 = []\n    while a1 % 2 == 0:\n        v1.append(2)\n        a1 //= 2\n    v3 = 3\n    while v3 * v3 <= a1:\n        if a1 % v3 == 0:\n            v1.append(v3)\n            a1 //= v3\n        else:\n            v3 += 2\n    if a1 != 1:\n        v1.append(a1)\n    return v1\nv1, v2 = map(int, input().split())\nv3 = math.gcd(v1, v2)\nv4 = f1(v3)\nprint(len(v4))\n"}
{"id": "llm_code\\minimum-operations-to-form-subsequence-with-target-sum__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def minOperations(self, a1, a2):\n        v1 = sum((num for v2 in a1))\n        if v1 < a2:\n            return -1\n        v3 = []\n        for v2 in a1:\n            if v2:\n                heapq.heappush(v3, -v2)\n        v4 = 0\n        v5 = a2\n        while v5 > 0 and v3:\n            v6 = -heapq.heappop(v3)\n            if v6 <= v5:\n                v5 -= v6\n                v1 -= v6\n            elif v1 - v6 >= v5:\n                v1 -= v6\n            else:\n                v7 = v6 // 2\n                if v7:\n                    heapq.heappush(v3, -v7)\n                    heapq.heappush(v3, -v7)\n                v4 += 1\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def minOperations(self, a1, a2):\n        v1 = sum((num for v2 in a1))\n        if v1 < a2:\n            return -1\n        v3 = []\n        for v2 in a1:\n            if v2:\n                heapq.heappush(v3, -v2)\n        v4 = 0\n        v5 = a2\n        while v5 > 0 and v3:\n            v6 = -heapq.heappop(v3)\n            if v6 <= v5:\n                v5 -= v6\n                v1 -= v6\n            elif v1 - v6 >= v5:\n                v1 -= v6\n            else:\n                v7 = v6 // 2\n                if v7:\n                    heapq.heappush(v3, -v7)\n                    heapq.heappush(v3, -v7)\n                v4 += 1\n        return v4\n"}
{"id": "human_code\\minimum-operations-to-make-character-frequencies-equal.py", "text": "class C1(object):\n\n    def makeStringGood(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * 26\n        for v2 in a1:\n            v1[ord(v2) - ord('a')] += 1\n        v3 = len(a1)\n        for v4 in range(min((v2 for v2 in v1 if v2)), max(v1) + 1):\n            v5 = v6 = 0\n            for v7 in range(26):\n                if not v1[v7]:\n                    continue\n                if v1[v7] >= v4:\n                    v8 = len(a1)\n                    v9 = min(v5, v6) + (v1[v7] - v4)\n                else:\n                    v10 = (v1[v7 - 1] - v4 if v1[v7 - 1] >= v4 else v1[v7 - 1]) if v7 - 1 >= 0 else 0\n                    v8 = min(min(v5, v6) + (v4 - v1[v7]), v6 + max(v4 - v1[v7] - v10, 0))\n                    v9 = min(v5, v6) + v1[v7]\n                v5, v6 = (v8, v9)\n            v3 = min(v3, v5, v6)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def makeStringGood(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * 26\n        for v2 in a1:\n            v1[ord(v2) - ord('a')] += 1\n        v3 = len(a1)\n        for v4 in range(min((v2 for v2 in v1 if v2)), max(v1) + 1):\n            v5 = v6 = 0\n            for v7 in range(26):\n                if not v1[v7]:\n                    continue\n                if v1[v7] >= v4:\n                    v8 = len(a1)\n                    v9 = min(v5, v6) + (v1[v7] - v4)\n                else:\n                    v10 = (v1[v7 - 1] - v4 if v1[v7 - 1] >= v4 else v1[v7 - 1]) if v7 - 1 >= 0 else 0\n                    v8 = min(min(v5, v6) + (v4 - v1[v7]), v6 + max(v4 - v1[v7] - v10, 0))\n                    v9 = min(v5, v6) + v1[v7]\n                v5, v6 = (v8, v9)\n            v3 = min(v3, v5, v6)\n        return v3\n"}
{"id": "human_code\\frog-position-after-t-seconds__part2.py", "text": "class C1(object):\n\n    def frogPosition(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = [(a3, 1, 0, 1)]\n        while v4:\n            a3, v6, v7, v8 = v4.pop()\n            if not a3 or not len(v1[v6]) - (v7 != 0):\n                if v6 == a4:\n                    return 1.0 / v8\n                continue\n            for v9 in v1[v6]:\n                if v9 == v7:\n                    continue\n                v4.append((a3 - 1, v9, v6, v8 * (len(v1[v6]) - (v7 != 0))))\n        return 0.0\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def frogPosition(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = [(a3, 1, 0, 1)]\n        while v4:\n            a3, v6, v7, v8 = v4.pop()\n            if not a3 or not len(v1[v6]) - (v7 != 0):\n                if v6 == a4:\n                    return 1.0 / v8\n                continue\n            for v9 in v1[v6]:\n                if v9 == v7:\n                    continue\n                v4.append((a3 - 1, v9, v6, v8 * (len(v1[v6]) - (v7 != 0))))\n        return 0.0\n"}
{"id": "human_code\\substring-with-concatenation-of-all-words__part2.py", "text": "class C1(object):\n\n    def findSubstring(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3, v4 = ([], len(a1), len(a2), len(a2[0]))\n        if v2 < v3 * v4:\n            return v1\n        v5 = collections.defaultdict(int)\n        for v6 in a2:\n            v5[v6] += 1\n        for v6 in range(v2 + 1 - v4 * v3):\n            v7, v8 = (collections.defaultdict(int), 0)\n            while v8 < v3:\n                v9 = a1[v6 + v8 * v4:v6 + v8 * v4 + v4]\n                if v9 not in v5:\n                    break\n                v7[v9] += 1\n                if v7[v9] > v5[v9]:\n                    break\n                v8 += 1\n            if v8 == v3:\n                v1.append(v6)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findSubstring(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3, v4 = ([], len(a1), len(a2), len(a2[0]))\n        if v2 < v3 * v4:\n            return v1\n        v5 = collections.defaultdict(int)\n        for v6 in a2:\n            v5[v6] += 1\n        for v6 in range(v2 + 1 - v4 * v3):\n            v7, v8 = (collections.defaultdict(int), 0)\n            while v8 < v3:\n                v9 = a1[v6 + v8 * v4:v6 + v8 * v4 + v4]\n                if v9 not in v5:\n                    break\n                v7[v9] += 1\n                if v7[v9] > v5[v9]:\n                    break\n                v8 += 1\n            if v8 == v3:\n                v1.append(v6)\n        return v1\n"}
{"id": "llm_code\\longest-common-suffix-queries__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def stringIndices(self, a1, a2):\n        v1 = float('inf')\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.minpair = (v1, v1)\n        v2 = TrieNode()\n        for v3, v4 in enumerate(a1):\n            v5 = len(v4)\n            v6 = v2\n            v6.minpair = min(v6.minpair, (v5, v3))\n            for v7 in range(v5 - 1, -1, -1):\n                v8 = v4[v7]\n                if v8 not in v6.children:\n                    v6.children[v8] = TrieNode()\n                v6 = v6.children[v8]\n                v6.minpair = min(v6.minpair, (v5, v3))\n        v9 = []\n        for v10 in a2:\n            v6 = v2\n            v11 = len(v10)\n            for v7 in range(v11 - 1, -1, -1):\n                v8 = v10[v7]\n                if v8 not in v6.children:\n                    break\n                v6 = v6.children[v8]\n            v12, v13 = v6.minpair\n            v9.append(int(v13))\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def stringIndices(self, a1, a2):\n        v1 = float('inf')\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.minpair = (v1, v1)\n        v2 = TrieNode()\n        for v3, v4 in enumerate(a1):\n            v5 = len(v4)\n            v6 = v2\n            v6.minpair = min(v6.minpair, (v5, v3))\n            for v7 in range(v5 - 1, -1, -1):\n                v8 = v4[v7]\n                if v8 not in v6.children:\n                    v6.children[v8] = TrieNode()\n                v6 = v6.children[v8]\n                v6.minpair = min(v6.minpair, (v5, v3))\n        v9 = []\n        for v10 in a2:\n            v6 = v2\n            v11 = len(v10)\n            for v7 in range(v11 - 1, -1, -1):\n                v8 = v10[v7]\n                if v8 not in v6.children:\n                    break\n                v6 = v6.children[v8]\n            v12, v13 = v6.minpair\n            v9.append(int(v13))\n        return v9\n"}
{"id": "llm_code\\minimum-operations-to-make-numbers-non-positive__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minOperations(self, a1, a2, a3):\n        if not a1:\n            return 0\n        v1 = 0\n        for v2 in a1:\n            v1 = max(v1, (v2 + a3 - 1) // a3)\n\n        def compute_cost(a1):\n            v1 = 0\n            for v2 in a1:\n                v3 = v2 - a1 * a3\n                if v3 > 0:\n                    v1 += (v3 + a2 - 1) // a2\n            return a1 + v1\n        v3 = 0\n        v4 = v1\n        while v4 - v3 >= 3:\n            v5 = v3 + (v4 - v3) // 3\n            v6 = v4 - (v4 - v3) // 3\n            v7 = compute_cost(v5)\n            v8 = compute_cost(v6)\n            if v7 <= v8:\n                v4 = v6\n            else:\n                v3 = v5\n        v9 = float('inf')\n        for v10 in range(v3, v4 + 1):\n            v9 = min(v9, compute_cost(v10))\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minOperations(self, a1, a2, a3):\n        if not a1:\n            return 0\n        v1 = 0\n        for v2 in a1:\n            v1 = max(v1, (v2 + a3 - 1) // a3)\n\n        def compute_cost(a1):\n            v1 = 0\n            for v2 in a1:\n                v3 = v2 - a1 * a3\n                if v3 > 0:\n                    v1 += (v3 + a2 - 1) // a2\n            return a1 + v1\n        v3 = 0\n        v4 = v1\n        while v4 - v3 >= 3:\n            v5 = v3 + (v4 - v3) // 3\n            v6 = v4 - (v4 - v3) // 3\n            v7 = compute_cost(v5)\n            v8 = compute_cost(v6)\n            if v7 <= v8:\n                v4 = v6\n            else:\n                v3 = v5\n        v9 = float('inf')\n        for v10 in range(v3, v4 + 1):\n            v9 = min(v9, compute_cost(v10))\n        return v9\n"}
{"id": "human_code\\two-sum-iv-input-is-a-bst.py", "text": "class C1(object):\n\n    def findTarget(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class BSTIterator(object):\n\n            def __init__(self, a1, a2):\n                self.__node = a1\n                self.__forward = a2\n                self.__s = []\n                self.__cur = None\n                next(self)\n\n            def val(self):\n                return self.__cur\n\n            def __next__(self):\n                while self.__node or self.__s:\n                    if self.__node:\n                        self.__s.append(self.__node)\n                        self.__node = self.__node.left if self.__forward else self.__node.right\n                    else:\n                        self.__node = self.__s.pop()\n                        self.__cur = self.__node.val\n                        self.__node = self.__node.right if self.__forward else self.__node.left\n                        break\n        if not a1:\n            return False\n        v1, v2 = (BSTIterator(a1, True), BSTIterator(a1, False))\n        while v1.val() < v2.val():\n            if v1.val() + v2.val() == a2:\n                return True\n            elif v1.val() + v2.val() < a2:\n                next(v1)\n            else:\n                next(v2)\n        return False\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findTarget(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class BSTIterator(object):\n\n            def __init__(self, a1, a2):\n                self.__node = a1\n                self.__forward = a2\n                self.__s = []\n                self.__cur = None\n                next(self)\n\n            def val(self):\n                return self.__cur\n\n            def __next__(self):\n                while self.__node or self.__s:\n                    if self.__node:\n                        self.__s.append(self.__node)\n                        self.__node = self.__node.left if self.__forward else self.__node.right\n                    else:\n                        self.__node = self.__s.pop()\n                        self.__cur = self.__node.val\n                        self.__node = self.__node.right if self.__forward else self.__node.left\n                        break\n        if not a1:\n            return False\n        v1, v2 = (BSTIterator(a1, True), BSTIterator(a1, False))\n        while v1.val() < v2.val():\n            if v1.val() + v2.val() == a2:\n                return True\n            elif v1.val() + v2.val() < a2:\n                next(v1)\n            else:\n                next(v2)\n        return False\n"}
{"id": "llm_code\\split-message-based-on-limit__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def splitMessage(self, a1, a2):\n        v1 = len(a1)\n        v2 = 0\n        v3 = 0\n        v4 = 0\n        while True:\n            v2 += 1\n            v5 = len(str(v2))\n            if v5 > v3:\n                v3 = v5\n            v4 += v5\n            v6 = v1 + v4 + v2 * (3 + v3)\n            if v6 <= v2 * a2:\n                break\n            if 3 + 2 * v3 >= a2:\n                return []\n        if 3 + 2 * v3 >= a2:\n            return []\n        v7 = []\n        v8 = 0\n        for v9 in range(1, v2 + 1):\n            v10 = len(str(v9))\n            v11 = v3\n            v12 = a2 - 3 - v10 - v11\n            v13 = a1[v8:v8 + v12]\n            v7.append(v13 + '<' + str(v9) + '/' + str(v2) + '>')\n            v8 += v12\n        return v7\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def splitMessage(self, a1, a2):\n        v1 = len(a1)\n        v2 = 0\n        v3 = 0\n        v4 = 0\n        while True:\n            v2 += 1\n            v5 = len(str(v2))\n            if v5 > v3:\n                v3 = v5\n            v4 += v5\n            v6 = v1 + v4 + v2 * (3 + v3)\n            if v6 <= v2 * a2:\n                break\n            if 3 + 2 * v3 >= a2:\n                return []\n        if 3 + 2 * v3 >= a2:\n            return []\n        v7 = []\n        v8 = 0\n        for v9 in range(1, v2 + 1):\n            v10 = len(str(v9))\n            v11 = v3\n            v12 = a2 - 3 - v10 - v11\n            v13 = a1[v8:v8 + v12]\n            v7.append(v13 + '<' + str(v9) + '/' + str(v2) + '>')\n            v8 += v12\n        return v7\n"}
{"id": "human_code\\number-of-increasing-paths-in-a-grid__part1.py", "text": "class C1(object):\n\n    def countPaths(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v3 = [[0] * len(a1[0]) for v4 in range(len(a1))]\n        v5 = []\n        for v6 in range(len(a1)):\n            for v7 in range(len(a1[0])):\n                for v8, v9 in v2:\n                    v10, v11 = (v6 + v8, v7 + v9)\n                    if 0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (a1[v6][v7] > a1[v10][v11]):\n                        v3[v6][v7] += 1\n                if not v3[v6][v7]:\n                    v5.append((v6, v7))\n        v12 = [[1] * len(a1[0]) for v4 in range(len(a1))]\n        v13 = 0\n        while v5:\n            v14 = []\n            for v6, v7 in v5:\n                v13 = (v13 + v12[v6][v7]) % v1\n                for v8, v9 in v2:\n                    v10, v11 = (v6 + v8, v7 + v9)\n                    if not (0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (a1[v6][v7] < a1[v10][v11])):\n                        continue\n                    v12[v10][v11] = (v12[v10][v11] + v12[v6][v7]) % v1\n                    v3[v10][v11] -= 1\n                    if not v3[v10][v11]:\n                        v14.append((v10, v11))\n            v5 = v14\n        return v13\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countPaths(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v3 = [[0] * len(a1[0]) for v4 in range(len(a1))]\n        v5 = []\n        for v6 in range(len(a1)):\n            for v7 in range(len(a1[0])):\n                for v8, v9 in v2:\n                    v10, v11 = (v6 + v8, v7 + v9)\n                    if 0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (a1[v6][v7] > a1[v10][v11]):\n                        v3[v6][v7] += 1\n                if not v3[v6][v7]:\n                    v5.append((v6, v7))\n        v12 = [[1] * len(a1[0]) for v4 in range(len(a1))]\n        v13 = 0\n        while v5:\n            v14 = []\n            for v6, v7 in v5:\n                v13 = (v13 + v12[v6][v7]) % v1\n                for v8, v9 in v2:\n                    v10, v11 = (v6 + v8, v7 + v9)\n                    if not (0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (a1[v6][v7] < a1[v10][v11])):\n                        continue\n                    v12[v10][v11] = (v12[v10][v11] + v12[v6][v7]) % v1\n                    v3[v10][v11] -= 1\n                    if not v3[v10][v11]:\n                        v14.append((v10, v11))\n            v5 = v14\n        return v13\n"}
{"id": "human_code\\count-houses-in-a-circular-street-ii.py", "text": "class C1:\n\n    def closeDoor(self):\n        pass\n\n    def isDoorOpen(self):\n        pass\n\n    def moveRight(self):\n        pass\n\nclass C2(object):\n\n    def houseCount(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        while not a1.isDoorOpen():\n            a1.moveRight()\n        v1 = 0\n        for v2 in range(a2 + 1):\n            if v2 and a1.isDoorOpen():\n                a1.closeDoor()\n                v1 = v2\n            a1.moveRight()\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def closeDoor(self):\n        pass\n\n    def isDoorOpen(self):\n        pass\n\n    def moveRight(self):\n        pass\n\nclass C2(object):\n\n    def houseCount(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        while not a1.isDoorOpen():\n            a1.moveRight()\n        v1 = 0\n        for v2 in range(a2 + 1):\n            if v2 and a1.isDoorOpen():\n                a1.closeDoor()\n                v1 = v2\n            a1.moveRight()\n        return v1\n"}
{"id": "human_code\\maximum-number-of-alloys__part2.py", "text": "class C1(object):\n\n    def maxNumberOfAlloys(self, a1, a2, a3, a4, a5, a6):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            for v1 in a4:\n                v2 = 0\n                for v3 in range(a1):\n                    v2 += max(a1 * v1[v3] - a5[v3], 0) * a6[v3]\n                    if v2 > a3:\n                        break\n                if v2 <= a3:\n                    return True\n            return False\n        v1, v2 = (1, min(a5) + a3)\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if not check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxNumberOfAlloys(self, a1, a2, a3, a4, a5, a6):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            for v1 in a4:\n                v2 = 0\n                for v3 in range(a1):\n                    v2 += max(a1 * v1[v3] - a5[v3], 0) * a6[v3]\n                    if v2 > a3:\n                        break\n                if v2 <= a3:\n                    return True\n            return False\n        v1, v2 = (1, min(a5) + a3)\n        while v1 <= v2:\n            v3 = v1 + (v2 - v1) // 2\n            if not check(v3):\n                v2 = v3 - 1\n            else:\n                v1 = v3 + 1\n        return v2\n"}
{"id": "human_code\\binary-tree-postorder-traversal__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def postorderTraversal(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = C1(0)\n        v1.left = a1\n        v2, v3 = ([], v1)\n        while v3:\n            if v3.left is None:\n                v3 = v3.right\n            else:\n                v4 = v3.left\n                while v4.right and v4.right != v3:\n                    v4 = v4.right\n                if v4.right is None:\n                    v4.right = v3\n                    v3 = v3.left\n                else:\n                    v2 += self.traceBack(v3.left, v4)\n                    v4.right = None\n                    v3 = v3.right\n        return v2\n\n    def traceBack(self, a1, a2):\n        v1, v2 = ([], a1)\n        while v2 is not a2:\n            v1.append(v2.val)\n            v2 = v2.right\n        v1.append(a2.val)\n        v1.reverse()\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def postorderTraversal(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = C1(0)\n        v1.left = a1\n        v2, v3 = ([], v1)\n        while v3:\n            if v3.left is None:\n                v3 = v3.right\n            else:\n                v4 = v3.left\n                while v4.right and v4.right != v3:\n                    v4 = v4.right\n                if v4.right is None:\n                    v4.right = v3\n                    v3 = v3.left\n                else:\n                    v2 += self.traceBack(v3.left, v4)\n                    v4.right = None\n                    v3 = v3.right\n        return v2\n\n    def traceBack(self, a1, a2):\n        v1, v2 = ([], a1)\n        while v2 is not a2:\n            v1.append(v2.val)\n            v2 = v2.right\n        v1.append(a2.val)\n        v1.reverse()\n        return v1\n"}
{"id": "llm_code\\least-operators-to-express-number__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def leastOpsExpressTarget(self, a1, a2):\n        v1 = []\n        v2 = a2\n        while v2:\n            v1.append(v2 % a1)\n            v2 //= a1\n        v3 = 0\n        v4 = 0\n        v5 = 0\n        for v6 in v1:\n            if v5 == 0:\n                v3 = 2 * v6\n                v4 = 2 * (a1 - v6)\n            else:\n                v7 = min(v6 * v5 + v3, (v6 + 1) * v5 + v4)\n                v8 = min((a1 - v6) * v5 + v3, (a1 - v6 - 1) * v5 + v4)\n                v3 = v7\n                v4 = v8\n            v5 += 1\n        return min(v3, v5 + v4) - 1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def leastOpsExpressTarget(self, a1, a2):\n        v1 = []\n        v2 = a2\n        while v2:\n            v1.append(v2 % a1)\n            v2 //= a1\n        v3 = 0\n        v4 = 0\n        v5 = 0\n        for v6 in v1:\n            if v5 == 0:\n                v3 = 2 * v6\n                v4 = 2 * (a1 - v6)\n            else:\n                v7 = min(v6 * v5 + v3, (v6 + 1) * v5 + v4)\n                v8 = min((a1 - v6) * v5 + v3, (a1 - v6 - 1) * v5 + v4)\n                v3 = v7\n                v4 = v8\n            v5 += 1\n        return min(v3, v5 + v4) - 1\n"}
{"id": "human_code\\p02975__s699872124.py", "text": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\n\ndef f1():\n    return [int(x) for v1 in sys.stdin.readline().split()]\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return [list(x) for v1 in sys.stdin.readline().split()]\n\ndef f4():\n    return list(sys.stdin.readline())[:-1]\n\ndef f5(a1):\n    return [f2() for v1 in range(a1)]\n\ndef f6(a1):\n    return [f1() for v1 in range(a1)]\n\ndef f7(a1):\n    return [f4() for v1 in range(a1)]\n\ndef f8(a1):\n    return [f3() for v1 in range(a1)]\nsys.setrecursionlimit(1000000)\nv1 = 1000000007\n\ndef f9():\n    v1 = f2()\n    v2 = f1()\n    if sum(v2) == 0:\n        print('Yes')\n        return\n    if v1 % 3 != 0:\n        print('No')\n        return\n    v3 = defaultdict(lambda: 0)\n    for v4 in v2:\n        v3[v4] += 1\n    if len(list(v3.items())) == 2:\n        if v3[0] == v1 // 3:\n            print('Yes')\n            return\n        else:\n            print('No')\n            return\n    v5 = 0\n    for v4, v6 in v3.items():\n        v5 ^= v4\n        if v6 != v1 // 3:\n            print('No')\n            return\n    if not v5:\n        print('Yes')\n        return\n    print('No')\n    return\n\ndef f10():\n    v1, v2 = f1()\n    v3 = []\n    v4 = [0] * (v1 + 1)\n    for v5 in range(v2):\n        v6, v7 = f1()\n        v3.append([v6, v7])\n        v4[v6] ^= 1\n    for v5 in range(v2):\n        v6, v7 = v3[v5]\n        if v4[v6]:\n            v3[v5] = [v7, v6]\n            v4[v6] ^= 1\n            v4[v7] ^= 1\n    if sum(v4):\n        print(-1)\n    else:\n        for v5 in v3:\n            print(*v5)\n    return\n\ndef f11():\n    v1 = f2()\n    v2 = [1 << i for v3 in range(100)]\n    if v1 in v2:\n        print('No')\n        quit()\n    if v1 + 1 in v2:\n        print('Yes')\n        for v3 in range(1, 2 * v1):\n            print(v3, v3 + 1)\n        quit()\n    v4 = []\n    for v3 in range(1, 3):\n        v4.append((v3, v3 + 1))\n    v4.append((3, v1 + 1))\n    for v3 in range(1, 3):\n        v4.append((v3 + v1, v3 + v1 + 1))\n    v5 = 1\n    v6 = 1\n    for v3 in range(2, v1 // 2 + v1 % 2):\n        v4.append((v5, 2 * v3))\n        v4.append((v6, 2 * v3 + 1))\n        v4.append((2 * v3, 2 * v3 + v1 + 1))\n        v4.append((2 * v3 + 1, 2 * v3 + v1))\n        v5 = 2 * v3 + v1 + 1\n        v6 = 2 * v3 + v1\n    if v1 % 2:\n        print('Yes')\n        for v3, v7 in v4:\n            print(v3, v7)\n    else:\n        v4.append((v1 - 1, v1))\n        for v3 in range(v1):\n            if v2[v3] & v1:\n                break\n        v4.append((v2[v3 + 1] - 2, 2 * v1))\n        print('Yes')\n        for v3, v7 in v4:\n            print(v3, v7)\n    return\n\ndef f12():\n    v1 = f2()\n    return\n\ndef f13():\n    v1 = f2()\n    return\n\ndef f14():\n    v1 = f2()\n    return\nif __name__ == '__main__':\n    f9()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from collections import defaultdict, deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\n\ndef f1():\n    return [int(x) for v1 in sys.stdin.readline().split()]\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return [list(x) for v1 in sys.stdin.readline().split()]\n\ndef f4():\n    return list(sys.stdin.readline())[:-1]\n\ndef f5(a1):\n    return [f2() for v1 in range(a1)]\n\ndef f6(a1):\n    return [f1() for v1 in range(a1)]\n\ndef f7(a1):\n    return [f4() for v1 in range(a1)]\n\ndef f8(a1):\n    return [f3() for v1 in range(a1)]\nsys.setrecursionlimit(1000000)\nv1 = 1000000007\n\ndef f9():\n    v1 = f2()\n    v2 = f1()\n    if sum(v2) == 0:\n        print('Yes')\n        return\n    if v1 % 3 != 0:\n        print('No')\n        return\n    v3 = defaultdict(lambda: 0)\n    for v4 in v2:\n        v3[v4] += 1\n    if len(list(v3.items())) == 2:\n        if v3[0] == v1 // 3:\n            print('Yes')\n            return\n        else:\n            print('No')\n            return\n    v5 = 0\n    for v4, v6 in v3.items():\n        v5 ^= v4\n        if v6 != v1 // 3:\n            print('No')\n            return\n    if not v5:\n        print('Yes')\n        return\n    print('No')\n    return\n\ndef f10():\n    v1, v2 = f1()\n    v3 = []\n    v4 = [0] * (v1 + 1)\n    for v5 in range(v2):\n        v6, v7 = f1()\n        v3.append([v6, v7])\n        v4[v6] ^= 1\n    for v5 in range(v2):\n        v6, v7 = v3[v5]\n        if v4[v6]:\n            v3[v5] = [v7, v6]\n            v4[v6] ^= 1\n            v4[v7] ^= 1\n    if sum(v4):\n        print(-1)\n    else:\n        for v5 in v3:\n            print(*v5)\n    return\n\ndef f11():\n    v1 = f2()\n    v2 = [1 << i for v3 in range(100)]\n    if v1 in v2:\n        print('No')\n        quit()\n    if v1 + 1 in v2:\n        print('Yes')\n        for v3 in range(1, 2 * v1):\n            print(v3, v3 + 1)\n        quit()\n    v4 = []\n    for v3 in range(1, 3):\n        v4.append((v3, v3 + 1))\n    v4.append((3, v1 + 1))\n    for v3 in range(1, 3):\n        v4.append((v3 + v1, v3 + v1 + 1))\n    v5 = 1\n    v6 = 1\n    for v3 in range(2, v1 // 2 + v1 % 2):\n        v4.append((v5, 2 * v3))\n        v4.append((v6, 2 * v3 + 1))\n        v4.append((2 * v3, 2 * v3 + v1 + 1))\n        v4.append((2 * v3 + 1, 2 * v3 + v1))\n        v5 = 2 * v3 + v1 + 1\n        v6 = 2 * v3 + v1\n    if v1 % 2:\n        print('Yes')\n        for v3, v7 in v4:\n            print(v3, v7)\n    else:\n        v4.append((v1 - 1, v1))\n        for v3 in range(v1):\n            if v2[v3] & v1:\n                break\n        v4.append((v2[v3 + 1] - 2, 2 * v1))\n        print('Yes')\n        for v3, v7 in v4:\n            print(v3, v7)\n    return\n\ndef f12():\n    v1 = f2()\n    return\n\ndef f13():\n    v1 = f2()\n    return\n\ndef f14():\n    v1 = f2()\n    return\nif __name__ == '__main__':\n    f9()\n"}
{"id": "human_code\\count-vowel-substrings-of-a-string__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def countVowelSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = set('aeiou')\n        v2 = 5\n\n        def atLeastK(a1, a2):\n            v1 = collections.Counter()\n            v2 = v3 = v4 = 0\n            for v5, v6 in enumerate(a1):\n                if v6 not in v1:\n                    v1 = collections.Counter()\n                    v3 = v4 = v5 + 1\n                    continue\n                v1[v6] += 1\n                while len(v1) > a2 - 1:\n                    v1[a1[v4]] -= 1\n                    if not v1[a1[v4]]:\n                        del v1[a1[v4]]\n                    v4 += 1\n                v2 += v4 - v3\n            return v2\n        return atLeastK(a1, v2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def countVowelSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = set('aeiou')\n        v2 = 5\n\n        def atLeastK(a1, a2):\n            v1 = collections.Counter()\n            v2 = v3 = v4 = 0\n            for v5, v6 in enumerate(a1):\n                if v6 not in v1:\n                    v1 = collections.Counter()\n                    v3 = v4 = v5 + 1\n                    continue\n                v1[v6] += 1\n                while len(v1) > a2 - 1:\n                    v1[a1[v4]] -= 1\n                    if not v1[a1[v4]]:\n                        del v1[a1[v4]]\n                    v4 += 1\n                v2 += v4 - v3\n            return v2\n        return atLeastK(a1, v2)\n"}
{"id": "llm_code\\process-restricted-friend-requests__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.p = list(range(a1))\n        self.rank = [0] * a1\n\n    def find(self, a1):\n        if self.p[a1] != a1:\n            self.p[a1] = self.find(self.p[a1])\n        return self.p[a1]\n\n    def unite(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.p[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.p[v2] = v1\n        else:\n            self.p[v2] = v1\n            self.rank[v1] += 1\n        return True\n\nclass C2:\n\n    def friendRequests(self, a1, a2, a3):\n        v1 = C1(a1)\n        v2 = []\n        for v3, v4 in a3:\n            v5 = v1.find(v3)\n            v6 = v1.find(v4)\n            if v5 == v6:\n                v2.append(True)\n                continue\n            v7 = True\n            for v8, v9 in a2:\n                v10 = v1.find(v8)\n                v11 = v1.find(v9)\n                if v10 == v5 and v11 == v6 or (v10 == v6 and v11 == v5):\n                    v7 = False\n                    break\n            v2.append(v7)\n            if v7:\n                v1.unite(v3, v4)\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.p = list(range(a1))\n        self.rank = [0] * a1\n\n    def find(self, a1):\n        if self.p[a1] != a1:\n            self.p[a1] = self.find(self.p[a1])\n        return self.p[a1]\n\n    def unite(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.p[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.p[v2] = v1\n        else:\n            self.p[v2] = v1\n            self.rank[v1] += 1\n        return True\n\nclass C2:\n\n    def friendRequests(self, a1, a2, a3):\n        v1 = C1(a1)\n        v2 = []\n        for v3, v4 in a3:\n            v5 = v1.find(v3)\n            v6 = v1.find(v4)\n            if v5 == v6:\n                v2.append(True)\n                continue\n            v7 = True\n            for v8, v9 in a2:\n                v10 = v1.find(v8)\n                v11 = v1.find(v9)\n                if v10 == v5 and v11 == v6 or (v10 == v6 and v11 == v5):\n                    v7 = False\n                    break\n            v2.append(v7)\n            if v7:\n                v1.unite(v3, v4)\n        return v2\n"}
{"id": "human_code\\p02616__s990136351.py", "text": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = 10 ** 9 + 7\nv3.sort()\nv5 = []\nv6 = []\nif v1 == v2:\n    v7 = 1\n    for v8 in v3:\n        v7 *= v8\n        v7 %= v4\n    print(v7)\n    exit()\nfor v8 in v3:\n    if v8 < 0:\n        v5.append(v8)\n    else:\n        v6.append(v8)\nif v6 == []:\n    v7 = 1\n    v9 = 0\n    if v2 % 2:\n        while v9 < v2:\n            v7 *= v3[-1 - v9]\n            v7 %= v4\n            v9 += 1\n    else:\n        while v9 < v2:\n            v7 *= v3[v9]\n            v7 %= v4\n            v9 += 1\n    print(v7)\n    exit()\nv6 = sorted(v6, reverse=True)\nv10 = 0\nv11 = 0\nif v2 % 2:\n    v9 = v6[0]\n    v2 -= 1\n    v10 += 1\nelse:\n    v9 = 1\nwhile v2 > 0:\n    v12 = True\n    v13 = True\n    if v10 + 2 <= len(v6):\n        v14 = v6[v10] * v6[v10 + 1]\n    else:\n        v14 = 1\n        v12 = False\n    if v11 + 2 <= len(v5):\n        v15 = v5[v11] * v5[v11 + 1]\n    else:\n        v15 = 1\n        v13 = False\n    if v14 > v15 or (v12 and (not v13)):\n        v10 += 2\n        v9 = v14 * v9 % v4\n    elif v13:\n        v11 += 2\n        v9 = v15 * v9 % v4\n    if v12 == False and v13 == False:\n        break\n    v2 -= 2\nprint(v9 % v4)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv4 = 10 ** 9 + 7\nv3.sort()\nv5 = []\nv6 = []\nif v1 == v2:\n    v7 = 1\n    for v8 in v3:\n        v7 *= v8\n        v7 %= v4\n    print(v7)\n    exit()\nfor v8 in v3:\n    if v8 < 0:\n        v5.append(v8)\n    else:\n        v6.append(v8)\nif v6 == []:\n    v7 = 1\n    v9 = 0\n    if v2 % 2:\n        while v9 < v2:\n            v7 *= v3[-1 - v9]\n            v7 %= v4\n            v9 += 1\n    else:\n        while v9 < v2:\n            v7 *= v3[v9]\n            v7 %= v4\n            v9 += 1\n    print(v7)\n    exit()\nv6 = sorted(v6, reverse=True)\nv10 = 0\nv11 = 0\nif v2 % 2:\n    v9 = v6[0]\n    v2 -= 1\n    v10 += 1\nelse:\n    v9 = 1\nwhile v2 > 0:\n    v12 = True\n    v13 = True\n    if v10 + 2 <= len(v6):\n        v14 = v6[v10] * v6[v10 + 1]\n    else:\n        v14 = 1\n        v12 = False\n    if v11 + 2 <= len(v5):\n        v15 = v5[v11] * v5[v11 + 1]\n    else:\n        v15 = 1\n        v13 = False\n    if v14 > v15 or (v12 and (not v13)):\n        v10 += 2\n        v9 = v14 * v9 % v4\n    elif v13:\n        v11 += 2\n        v9 = v15 * v9 % v4\n    if v12 == False and v13 == False:\n        break\n    v2 -= 2\nprint(v9 % v4)\n"}
{"id": "llm_code\\p02901__s366386266.py", "text": "import sys\nsys.setrecursionlimit(10 ** 9)\nv1 = 10 ** 20\n\ndef f1():\n    v1, v2 = map(int, input().split())\n    v3 = []\n    v4 = [[v1] * 2 for v5 in range(v1 + 1)]\n    for v6 in range(v2):\n        v7, v5 = map(int, input().split())\n        v8 = set(map(int, input().split()))\n        v3.append((v7, v8))\n        for v9 in range(1, v1 + 1):\n            if v9 in v8:\n                if v4[v9][0] > v7:\n                    v4[v9][0] = v7\n                    v4[v9][1] = v6\n    v10 = v1\n    for v6 in range(2 ** (v1 + 1)):\n        v11 = 0\n        v12 = set()\n        for v9 in range(1, v1 + 1):\n            if v6 >> v9 & 1:\n                if v4[v9][0] == v1:\n                    print(-1)\n                    exit()\n                v11 += v4[v9][0]\n                v12 = v12.union(v3[v4[v9][1]][1])\n        if len(v12) == v1:\n            v10 = min(v10, v11)\n    print(v10 if v10 != v1 else -1)\nif __name__ == '__main__':\n    f1()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 9)\nv1 = 10 ** 20\n\ndef f1():\n    v1, v2 = map(int, input().split())\n    v3 = []\n    v4 = [[v1] * 2 for v5 in range(v1 + 1)]\n    for v6 in range(v2):\n        v7, v5 = map(int, input().split())\n        v8 = set(map(int, input().split()))\n        v3.append((v7, v8))\n        for v9 in range(1, v1 + 1):\n            if v9 in v8:\n                if v4[v9][0] > v7:\n                    v4[v9][0] = v7\n                    v4[v9][1] = v6\n    v10 = v1\n    for v6 in range(2 ** (v1 + 1)):\n        v11 = 0\n        v12 = set()\n        for v9 in range(1, v1 + 1):\n            if v6 >> v9 & 1:\n                if v4[v9][0] == v1:\n                    print(-1)\n                    exit()\n                v11 += v4[v9][0]\n                v12 = v12.union(v3[v4[v9][1]][1])\n        if len(v12) == v1:\n            v10 = min(v10, v11)\n    print(v10 if v10 != v1 else -1)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\p03038__s747795343.py", "text": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv3.sort()\nv4 = [-1] * (2 * v1)\nv5 = []\nfor v6 in range(v2):\n    v7, v8 = map(int, input().split())\n    v5.append((v8, v7))\nv5.sort(reverse=True)\nv6 = 0\nfor v9 in range(v2):\n    if v6 >= v1:\n        break\n    for v10 in range(v5[v9][1]):\n        v4[v6] = v5[v9][0]\n        v6 += 1\nv9 = 0\nfor v6 in range(v1):\n    if v3[v6] < v4[v9]:\n        v3[v6] = v4[v9]\n        v9 += 1\nprint(sum(v3))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nv3.sort()\nv4 = [-1] * (2 * v1)\nv5 = []\nfor v6 in range(v2):\n    v7, v8 = map(int, input().split())\n    v5.append((v8, v7))\nv5.sort(reverse=True)\nv6 = 0\nfor v9 in range(v2):\n    if v6 >= v1:\n        break\n    for v10 in range(v5[v9][1]):\n        v4[v6] = v5[v9][0]\n        v6 += 1\nv9 = 0\nfor v6 in range(v1):\n    if v3[v6] < v4[v9]:\n        v3[v6] = v4[v9]\n        v9 += 1\nprint(sum(v3))\n"}
{"id": "human_code\\reverse-integer.py", "text": "class C1(object):\n\n    def reverse(self, a1):\n        \"\"\"\n        \"\"\"\n        if a1 < 0:\n            return -self.reverse(-a1)\n        v1 = 0\n        while a1:\n            v1 = v1 * 10 + a1 % 10\n            a1 //= 10\n        return v1 if v1 <= 2147483647 else 0\n\n    def reverse2(self, a1):\n        \"\"\"\n        \"\"\"\n        if a1 < 0:\n            a1 = int(str(a1)[::-1][-1] + str(a1)[::-1][:-1])\n        else:\n            a1 = int(str(a1)[::-1])\n        a1 = 0 if abs(a1) > 2147483647 else a1\n        return a1\n\n    def reverse3(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = cmp(a1, 0)\n        v2 = int(repr(v1 * a1)[::-1])\n        return v1 * v2 * (v2 < 2 ** 31)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def reverse(self, a1):\n        \"\"\"\n        \"\"\"\n        if a1 < 0:\n            return -self.reverse(-a1)\n        v1 = 0\n        while a1:\n            v1 = v1 * 10 + a1 % 10\n            a1 //= 10\n        return v1 if v1 <= 2147483647 else 0\n\n    def reverse2(self, a1):\n        \"\"\"\n        \"\"\"\n        if a1 < 0:\n            a1 = int(str(a1)[::-1][-1] + str(a1)[::-1][:-1])\n        else:\n            a1 = int(str(a1)[::-1])\n        a1 = 0 if abs(a1) > 2147483647 else a1\n        return a1\n\n    def reverse3(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = cmp(a1, 0)\n        v2 = int(repr(v1 * a1)[::-1])\n        return v1 * v2 * (v2 < 2 ** 31)\n"}
{"id": "human_code\\p04019__s505730495.py", "text": "v1 = input()\nv1 = list(v1)\nv2 = 0\nwhile v2 == 0:\n    if 'N' in v1:\n        if 'S' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\n    if 'S' in v1:\n        if 'N' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\n    if 'E' in v1:\n        if 'W' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\n    if 'W' in v1:\n        if 'E' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\nelse:\n    print('Yes')\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = input()\nv1 = list(v1)\nv2 = 0\nwhile v2 == 0:\n    if 'N' in v1:\n        if 'S' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\n    if 'S' in v1:\n        if 'N' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\n    if 'E' in v1:\n        if 'W' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\n    if 'W' in v1:\n        if 'E' in v1:\n            v2 += 1\n        else:\n            print('No')\n            break\nelse:\n    print('Yes')\n"}
{"id": "llm_code\\remove-comments__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def removeComments(self, a1):\n        v1 = []\n        v2 = False\n        for v3 in a1:\n            v4 = []\n            v5 = 0\n            v6 = len(v3)\n            while v5 < v6:\n                if v2:\n                    if v5 + 1 < v6 and v3[v5:v5 + 2] == '*/':\n                        v2 = False\n                        v5 += 2\n                    else:\n                        v5 += 1\n                    continue\n                if v5 + 1 < v6 and v3[v5:v5 + 2] == '//':\n                    break\n                if v5 + 1 < v6 and v3[v5:v5 + 2] == '/*':\n                    v2 = True\n                    v5 += 2\n                    continue\n                v4.append(v3[v5])\n                v5 += 1\n            if v4:\n                v1.append(''.join(v4))\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def removeComments(self, a1):\n        v1 = []\n        v2 = False\n        for v3 in a1:\n            v4 = []\n            v5 = 0\n            v6 = len(v3)\n            while v5 < v6:\n                if v2:\n                    if v5 + 1 < v6 and v3[v5:v5 + 2] == '*/':\n                        v2 = False\n                        v5 += 2\n                    else:\n                        v5 += 1\n                    continue\n                if v5 + 1 < v6 and v3[v5:v5 + 2] == '//':\n                    break\n                if v5 + 1 < v6 and v3[v5:v5 + 2] == '/*':\n                    v2 = True\n                    v5 += 2\n                    continue\n                v4.append(v3[v5])\n                v5 += 1\n            if v4:\n                v1.append(''.join(v4))\n        return v1\n"}
{"id": "human_code\\the-k-strongest-values-in-an-array__part3.py", "text": "import random\n\nclass C1(object):\n\n    def getStrongest(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=lambda a, b: a < b):\n\n            def partition_around_pivot(a1, a2, a3, a4, a5):\n                v1 = a1\n                a4[a3], a4[a2] = (a4[a2], a4[a3])\n                for v2 in range(a1, a2):\n                    if a5(a4[v2], a4[a2]):\n                        a4[v2], a4[v1] = (a4[v1], a4[v2])\n                        v1 += 1\n                a4[a2], a4[v1] = (a4[v1], a4[a2])\n                return v1\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = random.randint(v1, v2)\n                v4 = partition_around_pivot(v1, v2, v3, a1, a3)\n                if v4 == a2:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v4 + 1\n        nth_element(a1, (len(a1) - 1) // 2)\n        v1 = a1[(len(a1) - 1) // 2]\n        nth_element(a1, a2, lambda a, b: abs(a - v1) > abs(b - v1) if abs(a - v1) != abs(b - v1) else a > b)\n        return a1[:a2]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def getStrongest(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=lambda a, b: a < b):\n\n            def partition_around_pivot(a1, a2, a3, a4, a5):\n                v1 = a1\n                a4[a3], a4[a2] = (a4[a2], a4[a3])\n                for v2 in range(a1, a2):\n                    if a5(a4[v2], a4[a2]):\n                        a4[v2], a4[v1] = (a4[v1], a4[v2])\n                        v1 += 1\n                a4[a2], a4[v1] = (a4[v1], a4[a2])\n                return v1\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = random.randint(v1, v2)\n                v4 = partition_around_pivot(v1, v2, v3, a1, a3)\n                if v4 == a2:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v4 + 1\n        nth_element(a1, (len(a1) - 1) // 2)\n        v1 = a1[(len(a1) - 1) // 2]\n        nth_element(a1, a2, lambda a, b: abs(a - v1) > abs(b - v1) if abs(a - v1) != abs(b - v1) else a > b)\n        return a1[:a2]\n"}
{"id": "human_code\\kth-largest-element-in-an-array__part2.py", "text": "class C1(object):\n\n    def findKthLargest(self, a1, a2):\n        v1, v2 = (0, len(a1) - 1)\n        while v1 <= v2:\n            v3 = randint(v1, v2)\n            v4 = self.PartitionAroundPivot(v1, v2, v3, a1)\n            if v4 == a2 - 1:\n                return a1[v4]\n            elif v4 > a2 - 1:\n                v2 = v4 - 1\n            else:\n                v1 = v4 + 1\n\n    def PartitionAroundPivot(self, a1, a2, a3, a4):\n        v1 = a4[a3]\n        v2 = a1\n        a4[a3], a4[a2] = (a4[a2], a4[a3])\n        for v3 in range(a1, a2):\n            if a4[v3] > v1:\n                a4[v3], a4[v2] = (a4[v2], a4[v3])\n                v2 += 1\n        a4[a2], a4[v2] = (a4[v2], a4[a2])\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findKthLargest(self, a1, a2):\n        v1, v2 = (0, len(a1) - 1)\n        while v1 <= v2:\n            v3 = randint(v1, v2)\n            v4 = self.PartitionAroundPivot(v1, v2, v3, a1)\n            if v4 == a2 - 1:\n                return a1[v4]\n            elif v4 > a2 - 1:\n                v2 = v4 - 1\n            else:\n                v1 = v4 + 1\n\n    def PartitionAroundPivot(self, a1, a2, a3, a4):\n        v1 = a4[a3]\n        v2 = a1\n        a4[a3], a4[a2] = (a4[a2], a4[a3])\n        for v3 in range(a1, a2):\n            if a4[v3] > v1:\n                a4[v3], a4[v2] = (a4[v2], a4[v3])\n                v2 += 1\n        a4[a2], a4[v2] = (a4[v2], a4[a2])\n        return v2\n"}
{"id": "llm_code\\minimum-number-of-valid-strings-to-form-target-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minValidStrings(self, a1, a2):\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = [None] * 26\n        v1 = TrieNode()\n        for v2 in a1:\n            v3 = v1\n            for v4 in v2:\n                v5 = ord(v4) - ord('a')\n                if v3.children[v5] is None:\n                    v3.children[v5] = TrieNode()\n                v3 = v3.children[v5]\n        v6 = 0\n        v7 = len(a2)\n        v8 = 0\n        while v6 < v7:\n            v3 = v1\n            v9 = v6\n            while v6 < v7:\n                v5 = ord(a2[v6]) - ord('a')\n                if v3.children[v5] is None:\n                    break\n                v3 = v3.children[v5]\n                v6 += 1\n            if v6 == v9:\n                return -1\n            v8 += 1\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minValidStrings(self, a1, a2):\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = [None] * 26\n        v1 = TrieNode()\n        for v2 in a1:\n            v3 = v1\n            for v4 in v2:\n                v5 = ord(v4) - ord('a')\n                if v3.children[v5] is None:\n                    v3.children[v5] = TrieNode()\n                v3 = v3.children[v5]\n        v6 = 0\n        v7 = len(a2)\n        v8 = 0\n        while v6 < v7:\n            v3 = v1\n            v9 = v6\n            while v6 < v7:\n                v5 = ord(a2[v6]) - ord('a')\n                if v3.children[v5] is None:\n                    break\n                v3 = v3.children[v5]\n                v6 += 1\n            if v6 == v9:\n                return -1\n            v8 += 1\n        return v8\n"}
{"id": "llm_code\\minimum-length-of-anagram-concatenation__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minAnagramLength(self, a1):\n        v1 = len(a1)\n        v2 = []\n        v3 = int(v1 ** 0.5) + 1\n        for v4 in range(1, v3):\n            if v1 % v4 == 0:\n                v2.append(v4)\n                v5 = v1 // v4\n                if v4 != v5:\n                    v2.append(v5)\n        v2.sort()\n\n        def char_counts(a1, a2):\n            v1 = [0] * 26\n            for v2 in range(a1, a1 + a2):\n                v1[ord(a1[v2]) - ord('a')] += 1\n            return v1\n\n        def segments_match(a1):\n            v1 = char_counts(0, a1)\n            v2 = a1\n            while v2 < v1:\n                if char_counts(v2, a1) != v1:\n                    return False\n                v2 += a1\n            return True\n        for v6 in v2:\n            if segments_match(v6):\n                return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minAnagramLength(self, a1):\n        v1 = len(a1)\n        v2 = []\n        v3 = int(v1 ** 0.5) + 1\n        for v4 in range(1, v3):\n            if v1 % v4 == 0:\n                v2.append(v4)\n                v5 = v1 // v4\n                if v4 != v5:\n                    v2.append(v5)\n        v2.sort()\n\n        def char_counts(a1, a2):\n            v1 = [0] * 26\n            for v2 in range(a1, a1 + a2):\n                v1[ord(a1[v2]) - ord('a')] += 1\n            return v1\n\n        def segments_match(a1):\n            v1 = char_counts(0, a1)\n            v2 = a1\n            while v2 < v1:\n                if char_counts(v2, a1) != v1:\n                    return False\n                v2 += a1\n            return True\n        for v6 in v2:\n            if segments_match(v6):\n                return v6\n"}
{"id": "human_code\\bus-routes.py", "text": "import collections\n\nclass C1(object):\n\n    def numBusesToDestination(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        if a2 == a3:\n            return 0\n        v1 = collections.defaultdict(set)\n        for v2, v3 in enumerate(a1):\n            for v4 in v3:\n                v1[v4].add(v2)\n        v5 = 1\n        v6 = [a2]\n        v7 = set([a2])\n        while v6:\n            v8 = []\n            for v4 in v6:\n                for v2 in v1[v4]:\n                    for v9 in a1[v2]:\n                        if v9 in v7:\n                            continue\n                        if v9 == a3:\n                            return v5\n                        v8.append(v9)\n                        v1[v9].remove(v2)\n                        v7.add(v9)\n            v6 = v8\n            v5 += 1\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def numBusesToDestination(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        if a2 == a3:\n            return 0\n        v1 = collections.defaultdict(set)\n        for v2, v3 in enumerate(a1):\n            for v4 in v3:\n                v1[v4].add(v2)\n        v5 = 1\n        v6 = [a2]\n        v7 = set([a2])\n        while v6:\n            v8 = []\n            for v4 in v6:\n                for v2 in v1[v4]:\n                    for v9 in a1[v2]:\n                        if v9 in v7:\n                            continue\n                        if v9 == a3:\n                            return v5\n                        v8.append(v9)\n                        v1[v9].remove(v2)\n                        v7.add(v9)\n            v6 = v8\n            v5 += 1\n        return -1\n"}
{"id": "llm_code\\p02733__s953120349.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = [list(map(int, list(input()))) for v5 in range(v1)]\nv6 = []\nfor v7 in range(2 ** (v1 - 1)):\n    v8, v9 = (0, v7)\n    while v9 > 0:\n        v8 += v9 % 2\n        v9 >>= 1\n    v8 = format(v7, '0' + str(v1) + 'b').count('1')\n    v10 = 0\n    v11 = [0 for v5 in range(v8 + 1)]\n    for v12 in range(v2):\n        v9 = v7\n        v13 = 0\n        v14 = [0 for v5 in range(v8 + 1)]\n        for v15 in range(v1):\n            v14[v13] += v4[v15][v12]\n            v13 += v9 % 2\n            v9 = v9 >> 1\n        if all((v14[v15] + v11[v15] <= v3 for v15 in range(v8 + 1))):\n            v11 = [v11[I] + v14[I] for v16 in range(v8 + 1)]\n        else:\n            v10 += 1\n            v11 = v14\n    v6.append(v8 + v10)\nprint(min(v6))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = [list(map(int, list(input()))) for v5 in range(v1)]\nv6 = []\nfor v7 in range(2 ** (v1 - 1)):\n    v8, v9 = (0, v7)\n    while v9 > 0:\n        v8 += v9 % 2\n        v9 >>= 1\n    v8 = format(v7, '0' + str(v1) + 'b').count('1')\n    v10 = 0\n    v11 = [0 for v5 in range(v8 + 1)]\n    for v12 in range(v2):\n        v9 = v7\n        v13 = 0\n        v14 = [0 for v5 in range(v8 + 1)]\n        for v15 in range(v1):\n            v14[v13] += v4[v15][v12]\n            v13 += v9 % 2\n            v9 = v9 >> 1\n        if all((v14[v15] + v11[v15] <= v3 for v15 in range(v8 + 1))):\n            v11 = [v11[I] + v14[I] for v16 in range(v8 + 1)]\n        else:\n            v10 += 1\n            v11 = v14\n    v6.append(v8 + v10)\nprint(min(v6))\n"}
{"id": "llm_code\\flood-fill__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def floodFill(self, a1, a2, a3, a4):\n        v1 = len(a1)\n        if v1 == 0:\n            return a1\n        v2 = len(a1[0])\n        v3 = a1[a2][a3]\n        if v3 == a4:\n            return a1\n        v4 = deque([(a2, a3)])\n        a1[a2][a3] = a4\n        v5 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while v4:\n            v6, v7 = v4.popleft()\n            for v8, v9 in v5:\n                v10, v11 = (v6 + v8, v7 + v9)\n                if 0 <= v10 < v1 and 0 <= v11 < v2 and (a1[v10][v11] == v3):\n                    a1[v10][v11] = a4\n                    v4.append((v10, v11))\n        return a1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def floodFill(self, a1, a2, a3, a4):\n        v1 = len(a1)\n        if v1 == 0:\n            return a1\n        v2 = len(a1[0])\n        v3 = a1[a2][a3]\n        if v3 == a4:\n            return a1\n        v4 = deque([(a2, a3)])\n        a1[a2][a3] = a4\n        v5 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while v4:\n            v6, v7 = v4.popleft()\n            for v8, v9 in v5:\n                v10, v11 = (v6 + v8, v7 + v9)\n                if 0 <= v10 < v1 and 0 <= v11 < v2 and (a1[v10][v11] == v3):\n                    a1[v10][v11] = a4\n                    v4.append((v10, v11))\n        return a1\n"}
{"id": "human_code\\find-minimum-time-to-reach-last-room-i.py", "text": "import heapq\n\nclass C1(object):\n\n    def minTimeToReach(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dijkstra(a1, a2):\n            v1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n            v2 = [[float('inf')] * len(a1[0]) for v3 in range(len(a1))]\n            v2[a1[0]][a1[1]] = 0\n            v4 = [(v2[a1[0]][a1[1]], a1[0], a1[1])]\n            while v4:\n                v5, v6, v7 = heapq.heappop(v4)\n                if v5 != v2[v6][v7]:\n                    continue\n                if (v6, v7) == a2:\n                    break\n                for v8, v9 in v1:\n                    v10, v11 = (v6 + v8, v7 + v9)\n                    v12 = 1\n                    if not (0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (v2[v10][v11] > max(a1[v10][v11], v5) + v12)):\n                        continue\n                    v2[v10][v11] = max(a1[v10][v11], v5) + v12\n                    heapq.heappush(v4, (v2[v10][v11], v10, v11))\n            return v2[a2[0]][a2[1]]\n        return dijkstra((0, 0), (len(a1) - 1, len(a1[0]) - 1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def minTimeToReach(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dijkstra(a1, a2):\n            v1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n            v2 = [[float('inf')] * len(a1[0]) for v3 in range(len(a1))]\n            v2[a1[0]][a1[1]] = 0\n            v4 = [(v2[a1[0]][a1[1]], a1[0], a1[1])]\n            while v4:\n                v5, v6, v7 = heapq.heappop(v4)\n                if v5 != v2[v6][v7]:\n                    continue\n                if (v6, v7) == a2:\n                    break\n                for v8, v9 in v1:\n                    v10, v11 = (v6 + v8, v7 + v9)\n                    v12 = 1\n                    if not (0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (v2[v10][v11] > max(a1[v10][v11], v5) + v12)):\n                        continue\n                    v2[v10][v11] = max(a1[v10][v11], v5) + v12\n                    heapq.heappush(v4, (v2[v10][v11], v10, v11))\n            return v2[a2[0]][a2[1]]\n        return dijkstra((0, 0), (len(a1) - 1, len(a1[0]) - 1))\n"}
{"id": "llm_code\\count-of-smaller-numbers-after-self__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def countSmaller(self, a1):\n        if not a1:\n            return []\n        v1 = sorted(set(a1))\n        v2 = {v: i + 1 for v3, v4 in enumerate(v1)}\n        v5 = len(v1)\n        v6 = [0] * (v5 + 1)\n        v7 = [0] * len(a1)\n\n        def modify(a1, a2):\n            while a1 <= v5:\n                v6[a1] += a2\n                a1 += a1 & -a1\n\n        def prefix_sum(a1):\n            v1 = 0\n            while a1 > 0:\n                v1 += v6[a1]\n                a1 -= a1 & -a1\n            return v1\n        for v8 in range(len(a1) - 1, -1, -1):\n            v9 = v2[a1[v8]]\n            v7[v8] = prefix_sum(v9 - 1)\n            modify(v9, 1)\n        return v7\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def countSmaller(self, a1):\n        if not a1:\n            return []\n        v1 = sorted(set(a1))\n        v2 = {v: i + 1 for v3, v4 in enumerate(v1)}\n        v5 = len(v1)\n        v6 = [0] * (v5 + 1)\n        v7 = [0] * len(a1)\n\n        def modify(a1, a2):\n            while a1 <= v5:\n                v6[a1] += a2\n                a1 += a1 & -a1\n\n        def prefix_sum(a1):\n            v1 = 0\n            while a1 > 0:\n                v1 += v6[a1]\n                a1 -= a1 & -a1\n            return v1\n        for v8 in range(len(a1) - 1, -1, -1):\n            v9 = v2[a1[v8]]\n            v7[v8] = prefix_sum(v9 - 1)\n            modify(v9, 1)\n        return v7\n"}
{"id": "human_code\\minimum-number-of-coins-for-fruits-ii__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def minimumCoins(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [float('inf')] * (len(a1) + 1)\n        v1[0] = 0\n        v2 = collections.deque()\n        v3 = 0\n        for v4 in range(len(a1)):\n            while v2 and v1[v2[-1]] + a1[v2[-1]] >= v1[v4] + a1[v4]:\n                v2.pop()\n            v2.append(v4)\n            while v3 + (v3 + 1) < v4:\n                assert len(v2) != 0\n                if v2[0] == v3:\n                    v2.popleft()\n                v3 += 1\n            v1[v4 + 1] = v1[v2[0]] + a1[v2[0]]\n        return v1[-1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def minimumCoins(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [float('inf')] * (len(a1) + 1)\n        v1[0] = 0\n        v2 = collections.deque()\n        v3 = 0\n        for v4 in range(len(a1)):\n            while v2 and v1[v2[-1]] + a1[v2[-1]] >= v1[v4] + a1[v4]:\n                v2.pop()\n            v2.append(v4)\n            while v3 + (v3 + 1) < v4:\n                assert len(v2) != 0\n                if v2[0] == v3:\n                    v2.popleft()\n                v3 += 1\n            v1[v4 + 1] = v1[v2[0]] + a1[v2[0]]\n        return v1[-1]\n"}
{"id": "llm_code\\maximum-product-of-subsequences-with-an-alternating-sum-equal-to-k__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxProduct(self, a1, a2, a3):\n        v1 = sum(a1)\n        if abs(a2) > v1:\n            return -1\n        v2 = {}\n        for v3 in a1:\n            v4 = v2.copy()\n            if v3 <= a3:\n                v5 = (1, v3)\n                v4[v5] = max(v4.get(v5, 0), v3)\n            for v6, v7 in v2.items():\n                v8, v9 = v6\n                v10 = v3 if v8 == 0 else -v3\n                v11 = v9 + v10\n                v12 = 1 - v8\n                v13 = v7 * v3\n                if v13 <= a3:\n                    v14 = (v12, v11)\n                    v4[v14] = max(v4.get(v14, 0), v13)\n            v2 = v4\n        v15 = -1\n        for v5, v16 in v2.items():\n            v8, v9 = v5\n            if v9 == a2:\n                v15 = max(v15, v16)\n        return v15\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxProduct(self, a1, a2, a3):\n        v1 = sum(a1)\n        if abs(a2) > v1:\n            return -1\n        v2 = {}\n        for v3 in a1:\n            v4 = v2.copy()\n            if v3 <= a3:\n                v5 = (1, v3)\n                v4[v5] = max(v4.get(v5, 0), v3)\n            for v6, v7 in v2.items():\n                v8, v9 = v6\n                v10 = v3 if v8 == 0 else -v3\n                v11 = v9 + v10\n                v12 = 1 - v8\n                v13 = v7 * v3\n                if v13 <= a3:\n                    v14 = (v12, v11)\n                    v4[v14] = max(v4.get(v14, 0), v13)\n            v2 = v4\n        v15 = -1\n        for v5, v16 in v2.items():\n            v8, v9 = v5\n            if v9 == a2:\n                v15 = max(v15, v16)\n        return v15\n"}
{"id": "llm_code\\p03626__s243091597.py", "text": "v1 = 1000000007\nv2 = int(input())\nv3 = input()\nv4 = input()\nv5 = 1\nv6 = 0\nv7 = None\nif v3[v6] == v4[v6]:\n    v5 *= 3\n    v6 += 1\n    v7 = 0\nelse:\n    v5 *= 6\n    v6 += 2\n    v7 = 1\nwhile v6 < len(v3) - 1:\n    if v3[v6] == v4[v6]:\n        if v7:\n            v5 *= 1\n        else:\n            v5 *= 2\n        v6 += 1\n        v7 = 0\n    else:\n        if v7:\n            v5 *= 3\n        else:\n            v5 *= 2\n        v6 += 2\n        v7 = 1\nprint(v5 % v1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = 1000000007\nv2 = int(input())\nv3 = input()\nv4 = input()\nv5 = 1\nv6 = 0\nv7 = None\nif v3[v6] == v4[v6]:\n    v5 *= 3\n    v6 += 1\n    v7 = 0\nelse:\n    v5 *= 6\n    v6 += 2\n    v7 = 1\nwhile v6 < len(v3) - 1:\n    if v3[v6] == v4[v6]:\n        if v7:\n            v5 *= 1\n        else:\n            v5 *= 2\n        v6 += 1\n        v7 = 0\n    else:\n        if v7:\n            v5 *= 3\n        else:\n            v5 *= 2\n        v6 += 2\n        v7 = 1\nprint(v5 % v1)\n"}
{"id": "llm_code\\find-maximum-number-of-non-intersecting-substrings__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxSubstrings(self, a1):\n        v1 = 0\n        v2 = len(a1)\n        v3 = 0\n        while v3 < v2:\n            v4 = {}\n            v5 = v3\n            v6 = False\n            while v5 < v2:\n                v7 = a1[v5]\n                if v7 in v4:\n                    if v5 - v4[v7] + 1 >= 4:\n                        v1 += 1\n                        v3 = v5 + 1\n                        v6 = True\n                        break\n                else:\n                    v4[v7] = v5\n                v5 += 1\n            if not v6:\n                break\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxSubstrings(self, a1):\n        v1 = 0\n        v2 = len(a1)\n        v3 = 0\n        while v3 < v2:\n            v4 = {}\n            v5 = v3\n            v6 = False\n            while v5 < v2:\n                v7 = a1[v5]\n                if v7 in v4:\n                    if v5 - v4[v7] + 1 >= 4:\n                        v1 += 1\n                        v3 = v5 + 1\n                        v6 = True\n                        break\n                else:\n                    v4[v7] = v5\n                v5 += 1\n            if not v6:\n                break\n        return v1\n"}
{"id": "human_code\\minimum-sum-of-values-by-dividing-array__part1.py", "text": "import collections\nfrom functools import reduce\n\nclass C1(object):\n\n    def minimumValueSum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = max(a1).bit_length()\n\n        def update(a1, a2, a3):\n            for v1 in range(v2):\n                if a2 & 1 << v1:\n                    a1[v1] += a3\n\n        def mask(a1, a2):\n            return reduce(lambda accu, i: accu | 1 << i, (i for v1 in range(v2) if a1[v1] == a2), 0)\n        v3 = [v1] * (len(a1) + 1)\n        v3[0] = 0\n        for v4 in range(len(a2)):\n            v5 = [v1] * (len(a1) + 1)\n            v6 = [0] * v2\n            v7 = [0] * len(v3)\n            v8 = collections.deque()\n            v9 = v10 = v4\n            for v11 in range(v4, len(a1)):\n                update(v6, a1[v11], +1)\n                if mask(v6, v11 - v9 + 1) <= a2[v4]:\n                    while v9 <= v11:\n                        if mask(v6, v11 - v9 + 1) > a2[v4]:\n                            break\n                        update(v6, a1[v9], -1)\n                        v9 += 1\n                    v9 -= 1\n                    update(v6, a1[v9], +1)\n                if a2[v4] & a1[v11] == a2[v4]:\n                    v7[v11 + 1] = v7[v11] + 1\n                if mask(v6, v11 - v9 + 1) != a2[v4]:\n                    continue\n                while v10 <= v9:\n                    while v8 and v3[v8[-1]] >= v3[v10]:\n                        v8.pop()\n                    v8.append(v10)\n                    v10 += 1\n                while v8 and v8[0] < v9 - v7[v9]:\n                    v8.popleft()\n                if v8:\n                    v5[v11 + 1] = v3[v8[0]] + a1[v11]\n            v3 = v5\n        return v3[-1] if v3[-1] != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom functools import reduce\n\nclass C1(object):\n\n    def minimumValueSum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('inf')\n        v2 = max(a1).bit_length()\n\n        def update(a1, a2, a3):\n            for v1 in range(v2):\n                if a2 & 1 << v1:\n                    a1[v1] += a3\n\n        def mask(a1, a2):\n            return reduce(lambda accu, i: accu | 1 << i, (i for v1 in range(v2) if a1[v1] == a2), 0)\n        v3 = [v1] * (len(a1) + 1)\n        v3[0] = 0\n        for v4 in range(len(a2)):\n            v5 = [v1] * (len(a1) + 1)\n            v6 = [0] * v2\n            v7 = [0] * len(v3)\n            v8 = collections.deque()\n            v9 = v10 = v4\n            for v11 in range(v4, len(a1)):\n                update(v6, a1[v11], +1)\n                if mask(v6, v11 - v9 + 1) <= a2[v4]:\n                    while v9 <= v11:\n                        if mask(v6, v11 - v9 + 1) > a2[v4]:\n                            break\n                        update(v6, a1[v9], -1)\n                        v9 += 1\n                    v9 -= 1\n                    update(v6, a1[v9], +1)\n                if a2[v4] & a1[v11] == a2[v4]:\n                    v7[v11 + 1] = v7[v11] + 1\n                if mask(v6, v11 - v9 + 1) != a2[v4]:\n                    continue\n                while v10 <= v9:\n                    while v8 and v3[v8[-1]] >= v3[v10]:\n                        v8.pop()\n                    v8.append(v10)\n                    v10 += 1\n                while v8 and v8[0] < v9 - v7[v9]:\n                    v8.popleft()\n                if v8:\n                    v5[v11 + 1] = v3[v8[0]] + a1[v11]\n            v3 = v5\n        return v3[-1] if v3[-1] != v1 else -1\n"}
{"id": "human_code\\compare-version-numbers__part2.py", "text": "class C1(object):\n\n    def compareVersion(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (a1.split('.'), a2.split('.'))\n        if len(v1) > len(v2):\n            v2 += ['0' for v3 in range(len(v1) - len(v2))]\n        elif len(v1) < len(v2):\n            v1 += ['0' for v3 in range(len(v2) - len(v1))]\n        v4 = 0\n        while v4 < len(v1):\n            if int(v1[v4]) > int(v2[v4]):\n                return 1\n            elif int(v1[v4]) < int(v2[v4]):\n                return -1\n            else:\n                v4 += 1\n        return 0\n\n    def compareVersion2(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [int(x) for v2 in a1.split('.')]\n        v3 = [int(v2) for v2 in a2.split('.')]\n        while len(v1) != len(v3):\n            if len(v1) > len(v3):\n                v3.append(0)\n            else:\n                v1.append(0)\n        return cmp(v1, v3)\n\n    def compareVersion3(self, a1, a2):\n        v1 = (list(map(int, v.split('.'))) for v2 in (a1, a2))\n        return cmp(*list(zip(*itertools.zip_longest(*v1, fillvalue=0))))\n\n    def compareVersion4(self, a1, a2):\n        v1, v2, v3 = ('0' + a1).partition('.')\n        v4, v2, v5 = ('0' + a2).partition('.')\n        return cmp(int(v1), int(v4)) or (len(v3 + v5) and self.compareVersion4(v3, v5))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def compareVersion(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (a1.split('.'), a2.split('.'))\n        if len(v1) > len(v2):\n            v2 += ['0' for v3 in range(len(v1) - len(v2))]\n        elif len(v1) < len(v2):\n            v1 += ['0' for v3 in range(len(v2) - len(v1))]\n        v4 = 0\n        while v4 < len(v1):\n            if int(v1[v4]) > int(v2[v4]):\n                return 1\n            elif int(v1[v4]) < int(v2[v4]):\n                return -1\n            else:\n                v4 += 1\n        return 0\n\n    def compareVersion2(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [int(x) for v2 in a1.split('.')]\n        v3 = [int(v2) for v2 in a2.split('.')]\n        while len(v1) != len(v3):\n            if len(v1) > len(v3):\n                v3.append(0)\n            else:\n                v1.append(0)\n        return cmp(v1, v3)\n\n    def compareVersion3(self, a1, a2):\n        v1 = (list(map(int, v.split('.'))) for v2 in (a1, a2))\n        return cmp(*list(zip(*itertools.zip_longest(*v1, fillvalue=0))))\n\n    def compareVersion4(self, a1, a2):\n        v1, v2, v3 = ('0' + a1).partition('.')\n        v4, v2, v5 = ('0' + a2).partition('.')\n        return cmp(int(v1), int(v4)) or (len(v3 + v5) and self.compareVersion4(v3, v5))\n"}
{"id": "human_code\\partition-string.py", "text": "class C1(object):\n\n    def partitionString(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self):\n                self.__nodes = []\n                self.__new_node()\n                self.__curr = 0\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 26)\n                return len(self.__nodes) - 1\n\n            def add(self, a1):\n                v1 = ord(a1) - ord('a')\n                if self.__nodes[self.__curr][v1] == -1:\n                    self.__nodes[self.__curr][v1] = self.__new_node()\n                    self.__curr = 0\n                    return\n                self.__curr = self.__nodes[self.__curr][v1]\n\n            def curr(self):\n                return self.__curr\n        v1 = []\n        v2 = Trie()\n        v3 = []\n        for v4 in a1:\n            v3.append(v4)\n            v2.add(v4)\n            if v2.curr():\n                continue\n            v1.append(''.join(v3))\n            v3 = []\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def partitionString(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self):\n                self.__nodes = []\n                self.__new_node()\n                self.__curr = 0\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 26)\n                return len(self.__nodes) - 1\n\n            def add(self, a1):\n                v1 = ord(a1) - ord('a')\n                if self.__nodes[self.__curr][v1] == -1:\n                    self.__nodes[self.__curr][v1] = self.__new_node()\n                    self.__curr = 0\n                    return\n                self.__curr = self.__nodes[self.__curr][v1]\n\n            def curr(self):\n                return self.__curr\n        v1 = []\n        v2 = Trie()\n        v3 = []\n        for v4 in a1:\n            v3.append(v4)\n            v2.add(v4)\n            if v2.curr():\n                continue\n            v1.append(''.join(v3))\n            v3 = []\n        return v1\n"}
{"id": "llm_code\\add-and-search-word-data-structure-design__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, a1):\n        v1 = self.root\n        for v2 in a1:\n            if v2 not in v1:\n                v1[v2] = {}\n            v1 = v1[v2]\n        v1['end'] = True\n\n    def search(self, a1):\n        v1 = [(0, self.root)]\n        while v1:\n            v2, v3 = v1.pop()\n            if v2 == len(a1):\n                return v3.get('end', False)\n            v4 = a1[v2]\n            if v4 == '.':\n                for v5 in v3:\n                    if v5 != 'end':\n                        v1.append((v2 + 1, v3[v5]))\n            elif v4 in v3:\n                v1.append((v2 + 1, v3[v4]))\n        return False\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, a1):\n        v1 = self.root\n        for v2 in a1:\n            if v2 not in v1:\n                v1[v2] = {}\n            v1 = v1[v2]\n        v1['end'] = True\n\n    def search(self, a1):\n        v1 = [(0, self.root)]\n        while v1:\n            v2, v3 = v1.pop()\n            if v2 == len(a1):\n                return v3.get('end', False)\n            v4 = a1[v2]\n            if v4 == '.':\n                for v5 in v3:\n                    if v5 != 'end':\n                        v1.append((v2 + 1, v3[v5]))\n            elif v4 in v3:\n                v1.append((v2 + 1, v3[v4]))\n        return False\n"}
{"id": "human_code\\minimum-number-of-operations-to-make-all-array-elements-equal-to-1.py", "text": "class C1(object):\n\n    def minOperations(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n        v1 = a1.count(1)\n        if v1:\n            return len(a1) - v1\n        v2 = float('inf')\n        for v3 in range(len(a1)):\n            v4 = a1[v3]\n            for v5 in range(v3 + 1, len(a1)):\n                v4 = gcd(v4, a1[v5])\n                if v4 == 1:\n                    v2 = min(v2, v5 - v3)\n                    break\n        return v2 + (len(a1) - 1) if v2 != float('inf') else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minOperations(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n        v1 = a1.count(1)\n        if v1:\n            return len(a1) - v1\n        v2 = float('inf')\n        for v3 in range(len(a1)):\n            v4 = a1[v3]\n            for v5 in range(v3 + 1, len(a1)):\n                v4 = gcd(v4, a1[v5])\n                if v4 == 1:\n                    v2 = min(v2, v5 - v3)\n                    break\n        return v2 + (len(a1) - 1) if v2 != float('inf') else -1\n"}
{"id": "human_code\\android-unlock-patterns__part2.py", "text": "class C1(object):\n\n    def numberOfPatterns(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def merge(a1, a2):\n            return a1 | 1 << a2\n\n        def number_of_keys(a1):\n            v1 = 0\n            while a1 > 0:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n\n        def exclude(a1, a2):\n            return a1 & ~(1 << a2)\n\n        def contain(a1, a2):\n            return bool(a1 & 1 << a2)\n\n        def convert(a1, a2):\n            return 3 * a1 + a2\n        v1 = [[0] * 9 for v2 in range(1 << 9)]\n        for v3 in range(9):\n            v1[merge(0, v3)][v3] = 1\n        v4 = 0\n        for v5 in range(len(v1)):\n            v6 = number_of_keys(v5)\n            if v6 > a2:\n                continue\n            for v3 in range(9):\n                if not contain(v5, v3):\n                    continue\n                v7, v8 = divmod(v3, 3)\n                for v9 in range(9):\n                    if v3 == v9 or not contain(v5, v9):\n                        continue\n                    v10, v11 = divmod(v9, 3)\n                    if (v7 == v10 and abs(v8 - v11) == 2 or (v8 == v11 and abs(v7 - v10) == 2) or (abs(v7 - v10) == 2 and abs(v8 - v11) == 2)) and (not contain(v5, convert((v7 + v10) // 2, (v8 + v11) // 2))):\n                        continue\n                    v1[v5][v3] += v1[exclude(v5, v3)][v9]\n                if a1 <= v6 <= a2:\n                    v4 += v1[v5][v3]\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numberOfPatterns(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def merge(a1, a2):\n            return a1 | 1 << a2\n\n        def number_of_keys(a1):\n            v1 = 0\n            while a1 > 0:\n                a1 &= a1 - 1\n                v1 += 1\n            return v1\n\n        def exclude(a1, a2):\n            return a1 & ~(1 << a2)\n\n        def contain(a1, a2):\n            return bool(a1 & 1 << a2)\n\n        def convert(a1, a2):\n            return 3 * a1 + a2\n        v1 = [[0] * 9 for v2 in range(1 << 9)]\n        for v3 in range(9):\n            v1[merge(0, v3)][v3] = 1\n        v4 = 0\n        for v5 in range(len(v1)):\n            v6 = number_of_keys(v5)\n            if v6 > a2:\n                continue\n            for v3 in range(9):\n                if not contain(v5, v3):\n                    continue\n                v7, v8 = divmod(v3, 3)\n                for v9 in range(9):\n                    if v3 == v9 or not contain(v5, v9):\n                        continue\n                    v10, v11 = divmod(v9, 3)\n                    if (v7 == v10 and abs(v8 - v11) == 2 or (v8 == v11 and abs(v7 - v10) == 2) or (abs(v7 - v10) == 2 and abs(v8 - v11) == 2)) and (not contain(v5, convert((v7 + v10) // 2, (v8 + v11) // 2))):\n                        continue\n                    v1[v5][v3] += v1[exclude(v5, v3)][v9]\n                if a1 <= v6 <= a2:\n                    v4 += v1[v5][v3]\n        return v4\n"}
{"id": "human_code\\online-majority-element-in-subarray__part1.py", "text": "import collections\nimport random\nimport bisect\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (10000, 0.001)\n        self.__K = int(v1 / v2).bit_length()\n        self.__arr = a1\n        self.__inv_idx = collections.defaultdict(list)\n        for v3, v4 in enumerate(self.__arr):\n            self.__inv_idx[v4].append(v3)\n\n    def query(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def count(a1, a2, a3, a4):\n            return bisect.bisect_right(a1[a2], a4) - bisect.bisect_left(a1[a2], a3)\n        for v1 in range(self.__K):\n            v2 = self.__arr[random.randint(a1, a2)]\n            if count(self.__inv_idx, v2, a1, a2) >= a3:\n                return v2\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport random\nimport bisect\n\nclass C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (10000, 0.001)\n        self.__K = int(v1 / v2).bit_length()\n        self.__arr = a1\n        self.__inv_idx = collections.defaultdict(list)\n        for v3, v4 in enumerate(self.__arr):\n            self.__inv_idx[v4].append(v3)\n\n    def query(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def count(a1, a2, a3, a4):\n            return bisect.bisect_right(a1[a2], a4) - bisect.bisect_left(a1[a2], a3)\n        for v1 in range(self.__K):\n            v2 = self.__arr[random.randint(a1, a2)]\n            if count(self.__inv_idx, v2, a1, a2) >= a3:\n                return v2\n        return -1\n"}
{"id": "llm_code\\maximum-frequency-of-an-element-after-performing-operations-i__grok-4.1-fast__v1.py", "text": "from collections import Counter\nimport bisect\n\nclass C1:\n\n    def maxFrequency(self, a1, a2, a3):\n        if not a1:\n            return 0\n        v1 = sorted(a1)\n        v2 = len(v1)\n        v3 = Counter(a1)\n        v4 = 0\n        for v5 in v3:\n            v6 = bisect.bisect_left(v1, v5 - a2)\n            v7 = bisect.bisect_right(v1, v5 + a2) - 1\n            v8 = v7 - v6 + 1 if v6 <= v7 else 0\n            v9 = v3[v5]\n            v4 = max(v4, v9 + min(v8 - v9, a3))\n        v10 = 0\n        for v11 in range(v2):\n            while v1[v11] - v1[v10] > 2 * a2:\n                v10 += 1\n            v4 = max(v4, min(v11 - v10 + 1, a3))\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import Counter\nimport bisect\n\nclass C1:\n\n    def maxFrequency(self, a1, a2, a3):\n        if not a1:\n            return 0\n        v1 = sorted(a1)\n        v2 = len(v1)\n        v3 = Counter(a1)\n        v4 = 0\n        for v5 in v3:\n            v6 = bisect.bisect_left(v1, v5 - a2)\n            v7 = bisect.bisect_right(v1, v5 + a2) - 1\n            v8 = v7 - v6 + 1 if v6 <= v7 else 0\n            v9 = v3[v5]\n            v4 = max(v4, v9 + min(v8 - v9, a3))\n        v10 = 0\n        for v11 in range(v2):\n            while v1[v11] - v1[v10] > 2 * a2:\n                v10 += 1\n            v4 = max(v4, min(v11 - v10 + 1, a3))\n        return v4\n"}
{"id": "llm_code\\maximize-cyclic-partition-score__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumScore(self, a1, a2):\n        v1 = len(a1)\n        v2 = 0\n        for v3 in range(1, v1):\n            if a1[v3] < a1[v2]:\n                v2 = v3\n\n        def compute(a1):\n            v1 = a1[a1:] + a1[:a1]\n            v2 = [0] * (v1 + 1)\n            v3 = 0\n            for v4 in range(a2):\n                v5 = [float('-inf')] * (v1 + 1)\n                v5[0] = 0\n                v6 = float('-inf')\n                v7 = float('-inf')\n                for v8 in range(v1):\n                    v9 = v1[v8]\n                    v6 = max(v6, v2[v8] - v9)\n                    v7 = max(v7, v2[v8] + v9)\n                    v5[v8 + 1] = max(v5[v8], v6 + v9, v7 - v9)\n                v2 = v5\n                v3 = max(v3, v2[v1])\n            return v3\n        return max(compute(v2), compute((v2 + 1) % v1))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumScore(self, a1, a2):\n        v1 = len(a1)\n        v2 = 0\n        for v3 in range(1, v1):\n            if a1[v3] < a1[v2]:\n                v2 = v3\n\n        def compute(a1):\n            v1 = a1[a1:] + a1[:a1]\n            v2 = [0] * (v1 + 1)\n            v3 = 0\n            for v4 in range(a2):\n                v5 = [float('-inf')] * (v1 + 1)\n                v5[0] = 0\n                v6 = float('-inf')\n                v7 = float('-inf')\n                for v8 in range(v1):\n                    v9 = v1[v8]\n                    v6 = max(v6, v2[v8] - v9)\n                    v7 = max(v7, v2[v8] + v9)\n                    v5[v8 + 1] = max(v5[v8], v6 + v9, v7 - v9)\n                v2 = v5\n                v3 = max(v3, v2[v1])\n            return v3\n        return max(compute(v2), compute((v2 + 1) % v1))\n"}
{"id": "human_code\\find-in-mountain-array.py", "text": "class C1(object):\n\n    def get(self, a1):\n        \"\"\"\n       \"\"\"\n        pass\n\n    def length(self):\n        \"\"\"\n       \"\"\"\n        pass\n\nclass C2(object):\n\n    def findInMountainArray(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binarySearch(a1, a2, a3, a4):\n            while a2 <= a3:\n                v1 = a2 + (a3 - a2) // 2\n                if a4(v1):\n                    a3 = v1 - 1\n                else:\n                    a2 = v1 + 1\n            return a2\n        v1 = binarySearch(a2, 0, a2.length() - 1, lambda x: a2.get(x) >= a2.get(x + 1))\n        v2 = binarySearch(a2, 0, v1, lambda x: a2.get(x) >= a1)\n        if v2 <= v1 and a2.get(v2) == a1:\n            return v2\n        v3 = binarySearch(a2, v1, a2.length() - 1, lambda x: a2.get(x) <= a1)\n        if v3 <= a2.length() - 1 and a2.get(v3) == a1:\n            return v3\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def get(self, a1):\n        \"\"\"\n       \"\"\"\n        pass\n\n    def length(self):\n        \"\"\"\n       \"\"\"\n        pass\n\nclass C2(object):\n\n    def findInMountainArray(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def binarySearch(a1, a2, a3, a4):\n            while a2 <= a3:\n                v1 = a2 + (a3 - a2) // 2\n                if a4(v1):\n                    a3 = v1 - 1\n                else:\n                    a2 = v1 + 1\n            return a2\n        v1 = binarySearch(a2, 0, a2.length() - 1, lambda x: a2.get(x) >= a2.get(x + 1))\n        v2 = binarySearch(a2, 0, v1, lambda x: a2.get(x) >= a1)\n        if v2 <= v1 and a2.get(v2) == a1:\n            return v2\n        v3 = binarySearch(a2, v1, a2.length() - 1, lambda x: a2.get(x) <= a1)\n        if v3 <= a2.length() - 1 and a2.get(v3) == a1:\n            return v3\n        return -1\n"}
{"id": "llm_code\\p02716__s142886053.py", "text": "v1 = int(input())\nv2 = [int(x) for v3 in input().split()]\nv4 = []\nv5 = []\nv6 = 0\nv7 = 0\nfor v8 in range(v1):\n    if v8 % 2 == 0:\n        v6 += v2[v8]\n        v4.append(v6)\n    else:\n        v7 += v2[v8]\n        v5.append(v7)\nv9 = max(v4[-1], v5[-1])\nif v1 % 2 != 0:\n    for v8 in range(v1):\n        if v8 % 2 == 0:\n            v9 = max(v9, v4[-1] - v2[v8])\nfor v8 in range(len(v5)):\n    if v8 >= len(v4) - 2:\n        continue\n    v9 = max(v9, v5[v8] + v4[-1] - v4[v8 + 1])\nfor v8 in range(len(v4)):\n    if v8 >= len(v5) - 2:\n        continue\n    v9 = max(v9, v4[v8] + v5[-1] - v5[v8 + 1])\nif v1 % 2 != 0 and v1 >= 7:\n    v10 = [False] * len(v5)\n    for v8 in range(len(v5)):\n        v10[v8] = v4[v8] - v5[v8]\n    v11 = 0\n    v12 = v10[0]\n    for v8 in range(len(v5)):\n        if v8 >= len(v5) - 2:\n            continue\n        v9 = max(v9, v5[v8] + v4[-1] - v4[v8 + 1])\n        if v12 < v10[v8]:\n            v11 = v8\n            v12 = v10[v8]\n        v9 = max(v9, v5[v8] + v4[-1] - v4[v8 + 1] - v5[v11] + v4[v11])\nprint(v9)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [int(x) for v3 in input().split()]\nv4 = []\nv5 = []\nv6 = 0\nv7 = 0\nfor v8 in range(v1):\n    if v8 % 2 == 0:\n        v6 += v2[v8]\n        v4.append(v6)\n    else:\n        v7 += v2[v8]\n        v5.append(v7)\nv9 = max(v4[-1], v5[-1])\nif v1 % 2 != 0:\n    for v8 in range(v1):\n        if v8 % 2 == 0:\n            v9 = max(v9, v4[-1] - v2[v8])\nfor v8 in range(len(v5)):\n    if v8 >= len(v4) - 2:\n        continue\n    v9 = max(v9, v5[v8] + v4[-1] - v4[v8 + 1])\nfor v8 in range(len(v4)):\n    if v8 >= len(v5) - 2:\n        continue\n    v9 = max(v9, v4[v8] + v5[-1] - v5[v8 + 1])\nif v1 % 2 != 0 and v1 >= 7:\n    v10 = [False] * len(v5)\n    for v8 in range(len(v5)):\n        v10[v8] = v4[v8] - v5[v8]\n    v11 = 0\n    v12 = v10[0]\n    for v8 in range(len(v5)):\n        if v8 >= len(v5) - 2:\n            continue\n        v9 = max(v9, v5[v8] + v4[-1] - v4[v8 + 1])\n        if v12 < v10[v8]:\n            v11 = v8\n            v12 = v10[v8]\n        v9 = max(v9, v5[v8] + v4[-1] - v4[v8 + 1] - v5[v11] + v4[v11])\nprint(v9)\n"}
{"id": "llm_code\\equal-sum-arrays-with-minimum-number-of-operations__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minOperations(self, a1, a2):\n        v1, v2 = (len(a1), len(a2))\n        if v1 > 6 * v2 or v2 > 6 * v1:\n            return -1\n        v3 = sum(a1)\n        v4 = sum(a2)\n        if v3 > v4:\n            a1, a2 = (a2, a1)\n            v3, v4 = (v4, v3)\n        v7 = v4 - v3\n        v8 = []\n        for v9 in a1:\n            v8.append(6 - v9)\n        for v9 in a2:\n            v8.append(v9 - 1)\n        v8.sort(reverse=True)\n        v10 = 0\n        for v11 in v8:\n            if v7 <= 0:\n                break\n            if v11 > 0:\n                v12 = min(v11, v7)\n                v7 -= v12\n                v10 += 1\n        return v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minOperations(self, a1, a2):\n        v1, v2 = (len(a1), len(a2))\n        if v1 > 6 * v2 or v2 > 6 * v1:\n            return -1\n        v3 = sum(a1)\n        v4 = sum(a2)\n        if v3 > v4:\n            a1, a2 = (a2, a1)\n            v3, v4 = (v4, v3)\n        v7 = v4 - v3\n        v8 = []\n        for v9 in a1:\n            v8.append(6 - v9)\n        for v9 in a2:\n            v8.append(v9 - 1)\n        v8.sort(reverse=True)\n        v10 = 0\n        for v11 in v8:\n            if v7 <= 0:\n                break\n            if v11 > 0:\n                v12 = min(v11, v7)\n                v7 -= v12\n                v10 += 1\n        return v10\n"}
{"id": "human_code\\minimum-time-to-complete-all-deliveries.py", "text": "class C1(object):\n\n    def minimumTime(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lcm(a1, a2):\n            return a1 // gcd(a1, a2) * a2\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def check(a1):\n            return a1 - a1 // a2[0] >= a1[0] and a1 - a1 // a2[1] >= a1[1] and (a1 - a1 // l >= a1[0] + a1[1])\n        v1 = lcm(a2[0], a2[1])\n        return binary_search(sum(a1), sum(a1) * 2, check)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumTime(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lcm(a1, a2):\n            return a1 // gcd(a1, a2) * a2\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def check(a1):\n            return a1 - a1 // a2[0] >= a1[0] and a1 - a1 // a2[1] >= a1[1] and (a1 - a1 // l >= a1[0] + a1[1])\n        v1 = lcm(a2[0], a2[1])\n        return binary_search(sum(a1), sum(a1) * 2, check)\n"}
{"id": "human_code\\p03687__s694748910.py", "text": "v1 = input()\nv2 = len(v1)\nv3 = set()\nv4 = v1\nv5 = ''\nv6 = 0\nv7 = float('INF')\nfor v8 in range(v2):\n    if v1[v8] not in v3:\n        v5 = v1[v8]\n        v3.add(v5)\n        while len(set(v4)) != 1:\n            v9 = v4\n            v4 = ''\n            for v10 in range(len(v9) - 1):\n                if v9[v10] == v5 or v9[v10 + 1] == v5:\n                    v4 += v5\n                else:\n                    v4 += v1[v10]\n            v6 += 1\n        if v7 > v6:\n            v7 = v6\n        v6 = 0\n        v4 = v1\nprint(v7)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = input()\nv2 = len(v1)\nv3 = set()\nv4 = v1\nv5 = ''\nv6 = 0\nv7 = float('INF')\nfor v8 in range(v2):\n    if v1[v8] not in v3:\n        v5 = v1[v8]\n        v3.add(v5)\n        while len(set(v4)) != 1:\n            v9 = v4\n            v4 = ''\n            for v10 in range(len(v9) - 1):\n                if v9[v10] == v5 or v9[v10 + 1] == v5:\n                    v4 += v5\n                else:\n                    v4 += v1[v10]\n            v6 += 1\n        if v7 > v6:\n            v7 = v6\n        v6 = 0\n        v4 = v1\nprint(v7)\n"}
{"id": "human_code\\shortest-path-in-a-weighted-tree__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.__bit = [0] * (a1 + 1)\n\n    def add(self, a1, a2):\n        a1 += 1\n        while a1 < len(self.__bit):\n            self.__bit[a1] += a2\n            a1 += a1 & -a1\n\n    def query(self, a1):\n        a1 += 1\n        v2 = 0\n        while a1 > 0:\n            v2 += self.__bit[a1]\n            a1 -= a1 & -a1\n        return v2\n\nclass C2(object):\n\n    def treeQueries(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1, v2, v3, v4 = ([0] * a1, [0] * a1, [0] * a1, [0] * a1)\n            v5 = 0\n            v6 = [(1, (0, -1, 0))]\n            while v6:\n                v7, v8 = v6.pop()\n                if v7 == 1:\n                    v9, v10, v11 = v8\n                    v1[v9] = v5\n                    v5 += 1\n                    v3[v9] = v11\n                    v6.append((2, (v9,)))\n                    for v12, v13 in adj[v9]:\n                        if v12 == v10:\n                            continue\n                        v4[v12] = v13\n                        v6.append((1, (v12, v9, v11 + v13)))\n                elif v7 == 2:\n                    v9 = v8[0]\n                    v2[v9] = v5\n            return (v1, v2, v3, v4)\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v3 -= 1\n            v4 -= 1\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6, v7, v8, v9 = iter_dfs()\n        v10 = C1(a1)\n        v11 = []\n        for v12 in a3:\n            if v12[0] == 1:\n                v2, v3, v4, v5 = v12\n                v3 -= 1\n                v4 -= 1\n                if v6[v3] > v6[v4]:\n                    v3, v4 = (v4, v3)\n                v13 = v5 - v9[v4]\n                v10.add(v6[v4], v13)\n                v10.add(v7[v4], -v13)\n                v9[v4] = v5\n            else:\n                v2, v14 = v12\n                v14 -= 1\n                v11.append(v8[v14] + v10.query(v6[v14]))\n        return v11\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.__bit = [0] * (a1 + 1)\n\n    def add(self, a1, a2):\n        a1 += 1\n        while a1 < len(self.__bit):\n            self.__bit[a1] += a2\n            a1 += a1 & -a1\n\n    def query(self, a1):\n        a1 += 1\n        v2 = 0\n        while a1 > 0:\n            v2 += self.__bit[a1]\n            a1 -= a1 & -a1\n        return v2\n\nclass C2(object):\n\n    def treeQueries(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs():\n            v1, v2, v3, v4 = ([0] * a1, [0] * a1, [0] * a1, [0] * a1)\n            v5 = 0\n            v6 = [(1, (0, -1, 0))]\n            while v6:\n                v7, v8 = v6.pop()\n                if v7 == 1:\n                    v9, v10, v11 = v8\n                    v1[v9] = v5\n                    v5 += 1\n                    v3[v9] = v11\n                    v6.append((2, (v9,)))\n                    for v12, v13 in adj[v9]:\n                        if v12 == v10:\n                            continue\n                        v4[v12] = v13\n                        v6.append((1, (v12, v9, v11 + v13)))\n                elif v7 == 2:\n                    v9 = v8[0]\n                    v2[v9] = v5\n            return (v1, v2, v3, v4)\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v3 -= 1\n            v4 -= 1\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6, v7, v8, v9 = iter_dfs()\n        v10 = C1(a1)\n        v11 = []\n        for v12 in a3:\n            if v12[0] == 1:\n                v2, v3, v4, v5 = v12\n                v3 -= 1\n                v4 -= 1\n                if v6[v3] > v6[v4]:\n                    v3, v4 = (v4, v3)\n                v13 = v5 - v9[v4]\n                v10.add(v6[v4], v13)\n                v10.add(v7[v4], -v13)\n                v9[v4] = v5\n            else:\n                v2, v14 = v12\n                v14 -= 1\n                v11.append(v8[v14] + v10.query(v6[v14]))\n        return v11\n"}
{"id": "human_code\\count-numbers-with-unique-digits-ii__part2.py", "text": "from functools import reduce\n\nclass C1(object):\n\n    def numberCount(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [1] * 2\n\n        def nPr(a1, a2):\n            while len(v1) <= a1:\n                v1.append(v1[-1] * len(v1))\n            return v1[a1] // v1[a1 - a2]\n\n        def popcount(a1):\n            return bin(a1).count('1')\n\n        def count(a1):\n            v1 = list(map(int, str(a1)))\n            v2 = 9 * sum((nPr(9, i) for v3 in range(len(v1) - 1)))\n            v4 = 0\n            for v3, v5 in enumerate(v1):\n                v6 = v4 & (1 << v5) - 1 - int(v3 == 0)\n                v2 += (v5 - int(v3 == 0) - popcount(v6)) * nPr(10 - (v3 + 1), len(v1) - (v3 + 1))\n                if v4 & 1 << v5:\n                    break\n                v4 |= 1 << v5\n            return v2\n        return count(a2 + 1) - count(a1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from functools import reduce\n\nclass C1(object):\n\n    def numberCount(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [1] * 2\n\n        def nPr(a1, a2):\n            while len(v1) <= a1:\n                v1.append(v1[-1] * len(v1))\n            return v1[a1] // v1[a1 - a2]\n\n        def popcount(a1):\n            return bin(a1).count('1')\n\n        def count(a1):\n            v1 = list(map(int, str(a1)))\n            v2 = 9 * sum((nPr(9, i) for v3 in range(len(v1) - 1)))\n            v4 = 0\n            for v3, v5 in enumerate(v1):\n                v6 = v4 & (1 << v5) - 1 - int(v3 == 0)\n                v2 += (v5 - int(v3 == 0) - popcount(v6)) * nPr(10 - (v3 + 1), len(v1) - (v3 + 1))\n                if v4 & 1 << v5:\n                    break\n                v4 |= 1 << v5\n            return v2\n        return count(a2 + 1) - count(a1)\n"}
{"id": "human_code\\design-linked-list.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = self.prev = None\n\nclass C2(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__head = self.__tail = C1(-1)\n        self.__head.next = self.__tail\n        self.__tail.prev = self.__head\n        self.__size = 0\n\n    def get(self, a1):\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        if 0 <= a1 <= self.__size // 2:\n            return self.__forward(0, a1, self.__head.__next__).val\n        elif self.__size // 2 < a1 < self.__size:\n            return self.__backward(self.__size, a1, self.__tail).val\n        return -1\n\n    def addAtHead(self, a1):\n        \"\"\"\n        Add a node of value val before the first element of the linked list.\n        After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        self.__add(self.__head, a1)\n\n    def addAtTail(self, a1):\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        self.__add(self.__tail.prev, a1)\n\n    def addAtIndex(self, a1, a2):\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list.\n        If index equals to the length of linked list,\n        the node will be appended to the end of linked list.\n        If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        if 0 <= a1 <= self.__size // 2:\n            self.__add(self.__forward(0, a1, self.__head.__next__).prev, a2)\n        elif self.__size // 2 < a1 <= self.__size:\n            self.__add(self.__backward(self.__size, a1, self.__tail).prev, a2)\n\n    def deleteAtIndex(self, a1):\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        if 0 <= a1 <= self.__size // 2:\n            self.__remove(self.__forward(0, a1, self.__head.__next__))\n        elif self.__size // 2 < a1 < self.__size:\n            self.__remove(self.__backward(self.__size, a1, self.__tail))\n\n    def __add(self, a1, a2):\n        v1 = C1(a2)\n        v1.prev = a1\n        v1.next = a1.__next__\n        v1.prev.next = v1.next.prev = v1\n        self.__size += 1\n\n    def __remove(self, a1):\n        a1.prev.next = a1.__next__\n        a1.next.prev = a1.prev\n        self.__size -= 1\n\n    def __forward(self, a1, a2, a3):\n        while a1 != a2:\n            a1 += 1\n            a3 = a3.__next__\n        return a3\n\n    def __backward(self, a1, a2, a3):\n        while a1 != a2:\n            a1 -= 1\n            a3 = a3.prev\n        return a3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = self.prev = None\n\nclass C2(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__head = self.__tail = C1(-1)\n        self.__head.next = self.__tail\n        self.__tail.prev = self.__head\n        self.__size = 0\n\n    def get(self, a1):\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        if 0 <= a1 <= self.__size // 2:\n            return self.__forward(0, a1, self.__head.__next__).val\n        elif self.__size // 2 < a1 < self.__size:\n            return self.__backward(self.__size, a1, self.__tail).val\n        return -1\n\n    def addAtHead(self, a1):\n        \"\"\"\n        Add a node of value val before the first element of the linked list.\n        After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        self.__add(self.__head, a1)\n\n    def addAtTail(self, a1):\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        self.__add(self.__tail.prev, a1)\n\n    def addAtIndex(self, a1, a2):\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list.\n        If index equals to the length of linked list,\n        the node will be appended to the end of linked list.\n        If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        if 0 <= a1 <= self.__size // 2:\n            self.__add(self.__forward(0, a1, self.__head.__next__).prev, a2)\n        elif self.__size // 2 < a1 <= self.__size:\n            self.__add(self.__backward(self.__size, a1, self.__tail).prev, a2)\n\n    def deleteAtIndex(self, a1):\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        if 0 <= a1 <= self.__size // 2:\n            self.__remove(self.__forward(0, a1, self.__head.__next__))\n        elif self.__size // 2 < a1 < self.__size:\n            self.__remove(self.__backward(self.__size, a1, self.__tail))\n\n    def __add(self, a1, a2):\n        v1 = C1(a2)\n        v1.prev = a1\n        v1.next = a1.__next__\n        v1.prev.next = v1.next.prev = v1\n        self.__size += 1\n\n    def __remove(self, a1):\n        a1.prev.next = a1.__next__\n        a1.next.prev = a1.prev\n        self.__size -= 1\n\n    def __forward(self, a1, a2, a3):\n        while a1 != a2:\n            a1 += 1\n            a3 = a3.__next__\n        return a3\n\n    def __backward(self, a1, a2, a3):\n        while a1 != a2:\n            a1 -= 1\n            a3 = a3.prev\n        return a3\n"}
{"id": "human_code\\block-placement-queries__part2.py", "text": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def getResults(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: y if x is None else x if y is None else max(x, y), a4=lambda x: x):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(a2)\n                while v1 > 1:\n                    v1 >>= 1\n                    self.tree[v1] = self.query_fn(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def query(self, a1, a2):\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n\n        def update(a1):\n            sl.add(a1)\n            v1 = sl.bisect_left(a1)\n            st.update(val_to_idx[a1], a1 - (sl[v1 - 1] if v1 - 1 >= 0 else 0))\n            if v1 + 1 < len(sl):\n                st.update(val_to_idx[sl[v1 + 1]], sl[v1 + 1] - a1)\n        v1 = {x: i for v2, v3 in enumerate(sorted((q[1] for v4 in a1 if v4[0] == 1)))}\n        v5 = SegmentTree(len(v1))\n        v6 = SortedList()\n        v7 = []\n        for v4 in a1:\n            if v4[0] == 1:\n                update(v4[1])\n            else:\n                v2 = v6.bisect_left(v4[1])\n                v7.append(v4[1] - (v6[v2 - 1] if v2 - 1 >= 0 else 0) >= v4[2] or (v2 - 1 >= 0 and v5.query(0, v1[v6[v2 - 1]]) >= v4[2]))\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def getResults(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class SegmentTree(object):\n\n            def __init__(self, a1, a2=lambda _: None, a3=lambda x, y: y if x is None else x if y is None else max(x, y), a4=lambda x: x):\n                self.tree = [None] * (1 << (a1 - 1).bit_length() + 1)\n                self.base = len(self.tree) >> 1\n                self.query_fn = a3\n                self.update_fn = a4\n                for v1 in range(self.base, self.base + a1):\n                    self.tree[v1] = a2(v1 - self.base)\n                for v1 in reversed(range(1, self.base)):\n                    self.tree[v1] = a3(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def update(self, a1, a2):\n                v1 = self.base + a1\n                self.tree[v1] = self.update_fn(a2)\n                while v1 > 1:\n                    v1 >>= 1\n                    self.tree[v1] = self.query_fn(self.tree[v1 << 1], self.tree[(v1 << 1) + 1])\n\n            def query(self, a1, a2):\n                a1 += self.base\n                a2 += self.base\n                v3 = v4 = None\n                while a1 <= a2:\n                    if a1 & 1:\n                        v3 = self.query_fn(v3, self.tree[a1])\n                        a1 += 1\n                    if a2 & 1 == 0:\n                        v4 = self.query_fn(self.tree[a2], v4)\n                        a2 -= 1\n                    a1 >>= 1\n                    a2 >>= 1\n                return self.query_fn(v3, v4)\n\n        def update(a1):\n            sl.add(a1)\n            v1 = sl.bisect_left(a1)\n            st.update(val_to_idx[a1], a1 - (sl[v1 - 1] if v1 - 1 >= 0 else 0))\n            if v1 + 1 < len(sl):\n                st.update(val_to_idx[sl[v1 + 1]], sl[v1 + 1] - a1)\n        v1 = {x: i for v2, v3 in enumerate(sorted((q[1] for v4 in a1 if v4[0] == 1)))}\n        v5 = SegmentTree(len(v1))\n        v6 = SortedList()\n        v7 = []\n        for v4 in a1:\n            if v4[0] == 1:\n                update(v4[1])\n            else:\n                v2 = v6.bisect_left(v4[1])\n                v7.append(v4[1] - (v6[v2 - 1] if v2 - 1 >= 0 else 0) >= v4[2] or (v2 - 1 >= 0 and v5.query(0, v1[v6[v2 - 1]]) >= v4[2]))\n        return v7\n"}
{"id": "llm_code\\shortest-common-supersequence__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def shortestCommonSupersequence(self, a1, a2):\n        v1, v2 = (len(a1), len(a2))\n        v3 = [[0] * (v2 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(1, v1 + 1):\n            for v6 in range(1, v2 + 1):\n                if a1[v5 - 1] == a2[v6 - 1]:\n                    v3[v5][v6] = v3[v5 - 1][v6 - 1] + 1\n                else:\n                    v3[v5][v6] = max(v3[v5 - 1][v6], v3[v5][v6 - 1])\n        v7 = []\n        v8, v9 = (v1, v2)\n        while v8 or v9:\n            if v8 and v9 and (a1[v8 - 1] == a2[v9 - 1]):\n                v7.append(a1[v8 - 1])\n                v8 -= 1\n                v9 -= 1\n            elif v8 and (not v9 or v3[v8][v9] == v3[v8 - 1][v9]):\n                v7.append(a1[v8 - 1])\n                v8 -= 1\n            else:\n                v7.append(a2[v9 - 1])\n                v9 -= 1\n        return ''.join(v7[::-1])\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def shortestCommonSupersequence(self, a1, a2):\n        v1, v2 = (len(a1), len(a2))\n        v3 = [[0] * (v2 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(1, v1 + 1):\n            for v6 in range(1, v2 + 1):\n                if a1[v5 - 1] == a2[v6 - 1]:\n                    v3[v5][v6] = v3[v5 - 1][v6 - 1] + 1\n                else:\n                    v3[v5][v6] = max(v3[v5 - 1][v6], v3[v5][v6 - 1])\n        v7 = []\n        v8, v9 = (v1, v2)\n        while v8 or v9:\n            if v8 and v9 and (a1[v8 - 1] == a2[v9 - 1]):\n                v7.append(a1[v8 - 1])\n                v8 -= 1\n                v9 -= 1\n            elif v8 and (not v9 or v3[v8][v9] == v3[v8 - 1][v9]):\n                v7.append(a1[v8 - 1])\n                v8 -= 1\n            else:\n                v7.append(a2[v9 - 1])\n                v9 -= 1\n        return ''.join(v7[::-1])\n"}
{"id": "human_code\\count-complete-substrings.py", "text": "class C1(object):\n\n    def countCompleteSubstrings(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = 0\n        v3 = [0] * 26\n        for v4 in range(1, len(set(a1)) + 1):\n            v5 = 0\n            for v6 in range(len(a1)):\n                v3[ord(a1[v6]) - ord('a')] += 1\n                v7 = v3[ord(a1[v6]) - ord('a')]\n                v2 += 1 if v7 == a2 else -1 if v7 == a2 + 1 else 0\n                if v6 - v5 + 1 == v4 * a2 + 1:\n                    v7 = v3[ord(a1[v5]) - ord('a')]\n                    v2 -= 1 if v7 == a2 else -1 if v7 == a2 + 1 else 0\n                    v3[ord(a1[v5]) - ord('a')] -= 1\n                    v5 += 1\n                if v2 == v4:\n                    v1 += 1\n                if v6 + 1 == len(a1) or abs(ord(a1[v6 + 1]) - ord(a1[v6])) > 2:\n                    while v5 < v6 + 1:\n                        v7 = v3[ord(a1[v5]) - ord('a')]\n                        v2 -= 1 if v7 == a2 else -1 if v7 == a2 + 1 else 0\n                        v3[ord(a1[v5]) - ord('a')] -= 1\n                        v5 += 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countCompleteSubstrings(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = 0\n        v3 = [0] * 26\n        for v4 in range(1, len(set(a1)) + 1):\n            v5 = 0\n            for v6 in range(len(a1)):\n                v3[ord(a1[v6]) - ord('a')] += 1\n                v7 = v3[ord(a1[v6]) - ord('a')]\n                v2 += 1 if v7 == a2 else -1 if v7 == a2 + 1 else 0\n                if v6 - v5 + 1 == v4 * a2 + 1:\n                    v7 = v3[ord(a1[v5]) - ord('a')]\n                    v2 -= 1 if v7 == a2 else -1 if v7 == a2 + 1 else 0\n                    v3[ord(a1[v5]) - ord('a')] -= 1\n                    v5 += 1\n                if v2 == v4:\n                    v1 += 1\n                if v6 + 1 == len(a1) or abs(ord(a1[v6 + 1]) - ord(a1[v6])) > 2:\n                    while v5 < v6 + 1:\n                        v7 = v3[ord(a1[v5]) - ord('a')]\n                        v2 -= 1 if v7 == a2 else -1 if v7 == a2 + 1 else 0\n                        v3[ord(a1[v5]) - ord('a')] -= 1\n                        v5 += 1\n        return v1\n"}
{"id": "llm_code\\maximum-number-of-operations-with-the-same-score-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxOperations(self, a1):\n        v1 = len(a1)\n        if v1 < 2:\n            return 0\n        v2 = {a1[0] + a1[1], a1[0] + a1[-1], a1[-2] + a1[-1]}\n        v3 = 0\n        for v4 in v2:\n            v5 = [[0] * v1 for v6 in range(v1)]\n            for v7 in range(2, v1 + 1):\n                for v8 in range(v1 - v7 + 1):\n                    v9 = v8 + v7 - 1\n                    v10 = 0\n                    if a1[v8] + a1[v8 + 1] == v4:\n                        v10 = max(v10, 1 + (v5[v8 + 2][v9] if v8 + 2 <= v9 else 0))\n                    if a1[v8] + a1[v9] == v4:\n                        v10 = max(v10, 1 + (v5[v8 + 1][v9 - 1] if v8 + 1 <= v9 - 1 else 0))\n                    if a1[v9 - 1] + a1[v9] == v4:\n                        v10 = max(v10, 1 + (v5[v8][v9 - 2] if v8 <= v9 - 2 else 0))\n                    v5[v8][v9] = v10\n            v3 = max(v3, v5[0][v1 - 1])\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxOperations(self, a1):\n        v1 = len(a1)\n        if v1 < 2:\n            return 0\n        v2 = {a1[0] + a1[1], a1[0] + a1[-1], a1[-2] + a1[-1]}\n        v3 = 0\n        for v4 in v2:\n            v5 = [[0] * v1 for v6 in range(v1)]\n            for v7 in range(2, v1 + 1):\n                for v8 in range(v1 - v7 + 1):\n                    v9 = v8 + v7 - 1\n                    v10 = 0\n                    if a1[v8] + a1[v8 + 1] == v4:\n                        v10 = max(v10, 1 + (v5[v8 + 2][v9] if v8 + 2 <= v9 else 0))\n                    if a1[v8] + a1[v9] == v4:\n                        v10 = max(v10, 1 + (v5[v8 + 1][v9 - 1] if v8 + 1 <= v9 - 1 else 0))\n                    if a1[v9 - 1] + a1[v9] == v4:\n                        v10 = max(v10, 1 + (v5[v8][v9 - 2] if v8 <= v9 - 2 else 0))\n                    v5[v8][v9] = v10\n            v3 = max(v3, v5[0][v1 - 1])\n        return v3\n"}
{"id": "human_code\\minimize-the-total-price-of-the-trips__part2.py", "text": "class C1(object):\n\n    def minimumTotalPrice(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            lookup[a1] += 1\n            if a1 == a3:\n                return True\n            for v1 in adj[a1]:\n                if v1 == a2:\n                    continue\n                if dfs(v1, a1, a3):\n                    return True\n            lookup[a1] -= 1\n            return False\n\n        def dfs2(a1, a2):\n            v1, v2 = (a3[a1] * lookup[a1], a3[a1] // 2 * lookup[a1])\n            for v3 in adj[a1]:\n                if v3 == a2:\n                    continue\n                v4, v5 = dfs2(v3, a1)\n                v1 += min(v4, v5)\n                v2 += v4\n            return (v1, v2)\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * a1\n        for v3, v4 in a4:\n            dfs(v3, -1, v4)\n        return min(dfs2(0, -1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumTotalPrice(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            lookup[a1] += 1\n            if a1 == a3:\n                return True\n            for v1 in adj[a1]:\n                if v1 == a2:\n                    continue\n                if dfs(v1, a1, a3):\n                    return True\n            lookup[a1] -= 1\n            return False\n\n        def dfs2(a1, a2):\n            v1, v2 = (a3[a1] * lookup[a1], a3[a1] // 2 * lookup[a1])\n            for v3 in adj[a1]:\n                if v3 == a2:\n                    continue\n                v4, v5 = dfs2(v3, a1)\n                v1 += min(v4, v5)\n                v2 += v4\n            return (v1, v2)\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = [0] * a1\n        for v3, v4 in a4:\n            dfs(v3, -1, v4)\n        return min(dfs2(0, -1))\n"}
{"id": "human_code\\maximum-profitable-triplets-with-increasing-prices-i__part2.py", "text": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def maxProfit(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('-inf')\n        v2 = [v1] * len(a1)\n        v3 = SortedList()\n        for v4 in reversed(range(len(a1))):\n            v5 = v3.bisect_left((-a1[v4],))\n            if v5 - 1 >= 0:\n                v2[v4] = v3[v5 - 1][1]\n            if not (v5 - 1 < 0 or v3[v5 - 1][1] < a2[v4]):\n                continue\n            v3.add((-a1[v4], a2[v4]))\n            v5 = v3.bisect_left((-a1[v4], a2[v4]))\n            while v5 + 1 < len(v3) and v3[v5 + 1][1] <= v3[v5][1]:\n                del v3[v5 + 1]\n        v6 = v1\n        v3 = SortedList()\n        for v4 in range(len(a1)):\n            v5 = v3.bisect_left((a1[v4],))\n            if v5 - 1 >= 0:\n                v6 = max(v6, v3[v5 - 1][1] + a2[v4] + v2[v4])\n            if not (v5 - 1 < 0 or v3[v5 - 1][1] < a2[v4]):\n                continue\n            v3.add((a1[v4], a2[v4]))\n            v5 = v3.bisect_left((a1[v4], a2[v4]))\n            while v5 + 1 < len(v3) and v3[v5 + 1][1] <= v3[v5][1]:\n                del v3[v5 + 1]\n        return v6 if v6 != v1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def maxProfit(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = float('-inf')\n        v2 = [v1] * len(a1)\n        v3 = SortedList()\n        for v4 in reversed(range(len(a1))):\n            v5 = v3.bisect_left((-a1[v4],))\n            if v5 - 1 >= 0:\n                v2[v4] = v3[v5 - 1][1]\n            if not (v5 - 1 < 0 or v3[v5 - 1][1] < a2[v4]):\n                continue\n            v3.add((-a1[v4], a2[v4]))\n            v5 = v3.bisect_left((-a1[v4], a2[v4]))\n            while v5 + 1 < len(v3) and v3[v5 + 1][1] <= v3[v5][1]:\n                del v3[v5 + 1]\n        v6 = v1\n        v3 = SortedList()\n        for v4 in range(len(a1)):\n            v5 = v3.bisect_left((a1[v4],))\n            if v5 - 1 >= 0:\n                v6 = max(v6, v3[v5 - 1][1] + a2[v4] + v2[v4])\n            if not (v5 - 1 < 0 or v3[v5 - 1][1] < a2[v4]):\n                continue\n            v3.add((a1[v4], a2[v4]))\n            v5 = v3.bisect_left((a1[v4], a2[v4]))\n            while v5 + 1 < len(v3) and v3[v5 + 1][1] <= v3[v5][1]:\n                del v3[v5 + 1]\n        return v6 if v6 != v1 else -1\n"}
{"id": "llm_code\\number-of-enclaves__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def numEnclaves(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = deque()\n        for v4 in range(v1):\n            if a1[v4][0]:\n                v3.append((v4, 0))\n                a1[v4][0] = 0\n            if a1[v4][v2 - 1]:\n                v3.append((v4, v2 - 1))\n                a1[v4][v2 - 1] = 0\n        for v5 in range(1, v2 - 1):\n            if a1[0][v5]:\n                v3.append((0, v5))\n                a1[0][v5] = 0\n            if a1[v1 - 1][v5]:\n                v3.append((v1 - 1, v5))\n                a1[v1 - 1][v5] = 0\n        v6 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while v3:\n            v7, v8 = v3.popleft()\n            for v9, v10 in v6:\n                v11, v12 = (v7 + v9, v8 + v10)\n                if 0 <= v11 < v1 and 0 <= v12 < v2 and a1[v11][v12]:\n                    a1[v11][v12] = 0\n                    v3.append((v11, v12))\n        return sum((sum(row) for v13 in a1))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def numEnclaves(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = deque()\n        for v4 in range(v1):\n            if a1[v4][0]:\n                v3.append((v4, 0))\n                a1[v4][0] = 0\n            if a1[v4][v2 - 1]:\n                v3.append((v4, v2 - 1))\n                a1[v4][v2 - 1] = 0\n        for v5 in range(1, v2 - 1):\n            if a1[0][v5]:\n                v3.append((0, v5))\n                a1[0][v5] = 0\n            if a1[v1 - 1][v5]:\n                v3.append((v1 - 1, v5))\n                a1[v1 - 1][v5] = 0\n        v6 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while v3:\n            v7, v8 = v3.popleft()\n            for v9, v10 in v6:\n                v11, v12 = (v7 + v9, v8 + v10)\n                if 0 <= v11 < v1 and 0 <= v12 < v2 and a1[v11][v12]:\n                    a1[v11][v12] = 0\n                    v3.append((v11, v12))\n        return sum((sum(row) for v13 in a1))\n"}
{"id": "human_code\\simple-bank-system.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__balance = a1\n\n    def transfer(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        if 1 <= a2 <= len(self.__balance) and self.withdraw(a1, a3):\n            return self.deposit(a2, a3)\n        return False\n\n    def deposit(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if 1 <= a1 <= len(self.__balance):\n            self.__balance[a1 - 1] += a2\n            return True\n        return False\n\n    def withdraw(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if 1 <= a1 <= len(self.__balance) and self.__balance[a1 - 1] >= a2:\n            self.__balance[a1 - 1] -= a2\n            return True\n        return False\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__balance = a1\n\n    def transfer(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        if 1 <= a2 <= len(self.__balance) and self.withdraw(a1, a3):\n            return self.deposit(a2, a3)\n        return False\n\n    def deposit(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if 1 <= a1 <= len(self.__balance):\n            self.__balance[a1 - 1] += a2\n            return True\n        return False\n\n    def withdraw(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if 1 <= a1 <= len(self.__balance) and self.__balance[a1 - 1] >= a2:\n            self.__balance[a1 - 1] -= a2\n            return True\n        return False\n"}
{"id": "human_code\\3sum__part1.py", "text": "class C1(object):\n\n    def threeSum(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        a1.sort()\n        for v2 in reversed(range(2, len(a1))):\n            if v2 + 1 < len(a1) and a1[v2] == a1[v2 + 1]:\n                continue\n            v3 = -a1[v2]\n            v4, v5 = (0, v2 - 1)\n            while v4 < v5:\n                if a1[v4] + a1[v5] < v3:\n                    v4 += 1\n                elif a1[v4] + a1[v5] > v3:\n                    v5 -= 1\n                else:\n                    v1.append([a1[v4], a1[v5], a1[v2]])\n                    v4 += 1\n                    v5 -= 1\n                    while v4 < v5 and a1[v4] == a1[v4 - 1]:\n                        v4 += 1\n                    while v4 < v5 and a1[v5] == a1[v5 + 1]:\n                        v5 -= 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def threeSum(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        a1.sort()\n        for v2 in reversed(range(2, len(a1))):\n            if v2 + 1 < len(a1) and a1[v2] == a1[v2 + 1]:\n                continue\n            v3 = -a1[v2]\n            v4, v5 = (0, v2 - 1)\n            while v4 < v5:\n                if a1[v4] + a1[v5] < v3:\n                    v4 += 1\n                elif a1[v4] + a1[v5] > v3:\n                    v5 -= 1\n                else:\n                    v1.append([a1[v4], a1[v5], a1[v2]])\n                    v4 += 1\n                    v5 -= 1\n                    while v4 < v5 and a1[v4] == a1[v4 - 1]:\n                        v4 += 1\n                    while v4 < v5 and a1[v5] == a1[v5 + 1]:\n                        v5 -= 1\n        return v1\n"}
{"id": "llm_code\\smallest-subarray-to-sort-in-every-sliding-window__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minSubarraySort(self, a1, a2):\n        v1 = len(a1)\n        if a2 == 1:\n            return [0] * v1\n\n        def get_keeps(a1):\n            v1 = [v1] * v1\n            v2 = []\n            for v3 in range(v1 - 1, -1, -1):\n                while v2 and a1[v2[-1]] < a1[v3]:\n                    v2.pop()\n                if v2:\n                    v1[v3] = v2[-1]\n                v2.append(v3)\n            v4 = []\n            v5 = -1\n            v6 = 0\n            for v7 in range(1, v1):\n                if a1[v7] < a1[v7 - 1]:\n                    v5 = v7\n                if v7 < a2 - 1:\n                    continue\n                v8 = max(v6, v7 - a2 + 1)\n                while v8 < v1 and v1[v8] <= v5:\n                    v8 = v1[v8]\n                v9 = max(v7 - v1[v8] + 1, 0)\n                v4.append(v9)\n                v6 = v8\n            return v4\n        v2 = get_keeps(a1)\n        v3 = [-a1[v1 - 1 - p] for v4 in range(v1)]\n        v5 = get_keeps(v3)\n        v6 = v1 - a2 + 1\n        return [max(a2 - v5[v6 - 1 - i] - v2[i], 0) for v7 in range(v6)]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minSubarraySort(self, a1, a2):\n        v1 = len(a1)\n        if a2 == 1:\n            return [0] * v1\n\n        def get_keeps(a1):\n            v1 = [v1] * v1\n            v2 = []\n            for v3 in range(v1 - 1, -1, -1):\n                while v2 and a1[v2[-1]] < a1[v3]:\n                    v2.pop()\n                if v2:\n                    v1[v3] = v2[-1]\n                v2.append(v3)\n            v4 = []\n            v5 = -1\n            v6 = 0\n            for v7 in range(1, v1):\n                if a1[v7] < a1[v7 - 1]:\n                    v5 = v7\n                if v7 < a2 - 1:\n                    continue\n                v8 = max(v6, v7 - a2 + 1)\n                while v8 < v1 and v1[v8] <= v5:\n                    v8 = v1[v8]\n                v9 = max(v7 - v1[v8] + 1, 0)\n                v4.append(v9)\n                v6 = v8\n            return v4\n        v2 = get_keeps(a1)\n        v3 = [-a1[v1 - 1 - p] for v4 in range(v1)]\n        v5 = get_keeps(v3)\n        v6 = v1 - a2 + 1\n        return [max(a2 - v5[v6 - 1 - i] - v2[i], 0) for v7 in range(v6)]\n"}
{"id": "human_code\\count-valid-paths-in-a-tree__part1.py", "text": "class C1(object):\n\n    def countPaths(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def linear_sieve_of_eratosthenes(a1):\n            v1 = []\n            v2 = [-1] * (a1 + 1)\n            for v3 in range(2, a1 + 1):\n                if v2[v3] == -1:\n                    v2[v3] = v3\n                    v1.append(v3)\n                for v4 in v1:\n                    if v3 * v4 > a1 or v4 > v2[v3]:\n                        break\n                    v2[v3 * v4] = v4\n            return v2\n\n        def is_prime(a1):\n            return spf[a1] == a1\n\n        def iter_dfs():\n            v1 = 0\n            v2 = [(1, (0, -1, [0] * 2))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6, v7 = v4\n                    v7[:] = [1 - is_prime(v5 + 1), is_prime(v5 + 1)]\n                    v2.append((2, (v5, v6, v7, 0)))\n                elif v3 == 2:\n                    v5, v6, v7, v8 = v4\n                    if v8 == len(adj[v5]):\n                        continue\n                    v9 = adj[v5][v8]\n                    v2.append((2, (v5, v6, v7, v8 + 1)))\n                    if v9 == v6:\n                        continue\n                    v10 = [0] * 2\n                    v2.append((3, (v5, v6, v10, v7, v8)))\n                    v2.append((1, (v9, v5, v10)))\n                elif v3 == 3:\n                    v5, v6, v10, v7, v8 = v4\n                    v1 += v7[0] * v10[1] + v7[1] * v10[0]\n                    if is_prime(v5 + 1):\n                        v7[1] += v10[0]\n                    else:\n                        v7[0] += v10[0]\n                        v7[1] += v10[1]\n            return v1\n        v1 = linear_sieve_of_eratosthenes(a1)\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5 in a2:\n            v4, v5 = (v4 - 1, v5 - 1)\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        return iter_dfs()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countPaths(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def linear_sieve_of_eratosthenes(a1):\n            v1 = []\n            v2 = [-1] * (a1 + 1)\n            for v3 in range(2, a1 + 1):\n                if v2[v3] == -1:\n                    v2[v3] = v3\n                    v1.append(v3)\n                for v4 in v1:\n                    if v3 * v4 > a1 or v4 > v2[v3]:\n                        break\n                    v2[v3 * v4] = v4\n            return v2\n\n        def is_prime(a1):\n            return spf[a1] == a1\n\n        def iter_dfs():\n            v1 = 0\n            v2 = [(1, (0, -1, [0] * 2))]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    v5, v6, v7 = v4\n                    v7[:] = [1 - is_prime(v5 + 1), is_prime(v5 + 1)]\n                    v2.append((2, (v5, v6, v7, 0)))\n                elif v3 == 2:\n                    v5, v6, v7, v8 = v4\n                    if v8 == len(adj[v5]):\n                        continue\n                    v9 = adj[v5][v8]\n                    v2.append((2, (v5, v6, v7, v8 + 1)))\n                    if v9 == v6:\n                        continue\n                    v10 = [0] * 2\n                    v2.append((3, (v5, v6, v10, v7, v8)))\n                    v2.append((1, (v9, v5, v10)))\n                elif v3 == 3:\n                    v5, v6, v10, v7, v8 = v4\n                    v1 += v7[0] * v10[1] + v7[1] * v10[0]\n                    if is_prime(v5 + 1):\n                        v7[1] += v10[0]\n                    else:\n                        v7[0] += v10[0]\n                        v7[1] += v10[1]\n            return v1\n        v1 = linear_sieve_of_eratosthenes(a1)\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5 in a2:\n            v4, v5 = (v4 - 1, v5 - 1)\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        return iter_dfs()\n"}
{"id": "human_code\\binary-tree-cameras.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def minCameraCover(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = list(range(3))\n\n        def dfs(a1, a2):\n            v1 = dfs(a1.left, a2) if a1.left else v2\n            v2 = dfs(a1.right, a2) if a1.right else v2\n            if v1 == v1 or v2 == v1:\n                a2[0] += 1\n                return v3\n            if v1 == v3 or v2 == v3:\n                return v2\n            return v1\n        v4 = [0]\n        if dfs(a1, v4) == v1:\n            v4[0] += 1\n        return v4[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def minCameraCover(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = list(range(3))\n\n        def dfs(a1, a2):\n            v1 = dfs(a1.left, a2) if a1.left else v2\n            v2 = dfs(a1.right, a2) if a1.right else v2\n            if v1 == v1 or v2 == v1:\n                a2[0] += 1\n                return v3\n            if v1 == v3 or v2 == v3:\n                return v2\n            return v1\n        v4 = [0]\n        if dfs(a1, v4) == v1:\n            v4[0] += 1\n        return v4[0]\n"}
{"id": "llm_code\\p02554__s818375789.py", "text": "import math\nimport itertools\n\ndef f1(a1):\n    if a1 <= 1:\n        return 1\n    return a1 * f1(a1 - 1)\n\ndef f2(a1, a2):\n    return math.floor(f1(a1) / f1(a1 - a2))\nfrom math import *\n\ndef f3(a1, a2):\n    v1 = 1\n    v2 = 1\n    if a1 - a2 < a2:\n        a2 = a1 - a2\n    if a2 != 0:\n        while a2:\n            v1 *= a1\n            v2 *= a2\n            v4 = gcd(v1, v2)\n            v1 //= v4\n            v2 //= v4\n            a1 -= 1\n            a2 -= 1\n    else:\n        v1 = 1\n    print(v1)\nv1 = int(input())\nv2 = 1000000007\nv3 = f2(v1, 2)\nv4 = (10 ** (v1 - 2) - v3) % v2\nprint(v3 * v4 % v2)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import math\nimport itertools\n\ndef f1(a1):\n    if a1 <= 1:\n        return 1\n    return a1 * f1(a1 - 1)\n\ndef f2(a1, a2):\n    return math.floor(f1(a1) / f1(a1 - a2))\nfrom math import *\n\ndef f3(a1, a2):\n    v1 = 1\n    v2 = 1\n    if a1 - a2 < a2:\n        a2 = a1 - a2\n    if a2 != 0:\n        while a2:\n            v1 *= a1\n            v2 *= a2\n            v4 = gcd(v1, v2)\n            v1 //= v4\n            v2 //= v4\n            a1 -= 1\n            a2 -= 1\n    else:\n        v1 = 1\n    print(v1)\nv1 = int(input())\nv2 = 1000000007\nv3 = f2(v1, 2)\nv4 = (10 ** (v1 - 2) - v3) % v2\nprint(v3 * v4 % v2)\n"}
{"id": "human_code\\the-knights-tour__part2.py", "text": "class C1(object):\n\n    def tourOfKnight(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (-2, 1), (2, -1), (-2, -1))\n\n        def backtracking(a1, a2, a3):\n            if a3 == a1 * a2:\n                return True\n            for v1, v2 in v1:\n                v3, v4 = (a1 + v1, a2 + v2)\n                if not (0 <= v3 < a1 and 0 <= v4 < a2 and (result[v3][v4] == -1)):\n                    continue\n                result[v3][v4] = a3\n                if backtracking(v3, v4, a3 + 1):\n                    return True\n                result[v3][v4] = -1\n            return False\n        v2 = [[-1] * a2 for v3 in range(a1)]\n        v2[a3][a4] = 0\n        backtracking(a3, a4, 1)\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def tourOfKnight(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (-2, 1), (2, -1), (-2, -1))\n\n        def backtracking(a1, a2, a3):\n            if a3 == a1 * a2:\n                return True\n            for v1, v2 in v1:\n                v3, v4 = (a1 + v1, a2 + v2)\n                if not (0 <= v3 < a1 and 0 <= v4 < a2 and (result[v3][v4] == -1)):\n                    continue\n                result[v3][v4] = a3\n                if backtracking(v3, v4, a3 + 1):\n                    return True\n                result[v3][v4] = -1\n            return False\n        v2 = [[-1] * a2 for v3 in range(a1)]\n        v2[a3][a4] = 0\n        backtracking(a3, a4, 1)\n        return v2\n"}
{"id": "llm_code\\minimum-time-takes-to-reach-destination-without-drowning__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minimumSeconds(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = 10 ** 9 + 7\n        v4 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v5 = [[v3] * v2 for v6 in range(v1)]\n        v7 = []\n        for v8 in range(v1):\n            for v9 in range(v2):\n                if a1[v8][v9] == '*':\n                    v5[v8][v9] = 0\n                    v7.append((v8, v9))\n        while v7:\n            v10 = []\n            for v8, v9 in v7:\n                for v11, v12 in v4:\n                    v13, v14 = (v8 + v11, v9 + v12)\n                    if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] != 'X') and (a1[v13][v14] != 'D') and (v5[v13][v14] == v3):\n                        v5[v13][v14] = v5[v8][v9] + 1\n                        v10.append((v13, v14))\n            v7 = v10\n        v15, v16 = (0, 0)\n        for v8 in range(v1):\n            for v9 in range(v2):\n                if a1[v8][v9] == 'S':\n                    v15, v16 = (v8, v9)\n                    break\n            else:\n                continue\n            break\n        v17 = [[v3] * v2 for v6 in range(v1)]\n        v18 = []\n        if v5[v15][v16] > 0:\n            v17[v15][v16] = 0\n            v18.append((v15, v16))\n        while v18:\n            v19 = []\n            for v8, v9 in v18:\n                if a1[v8][v9] == 'D':\n                    return v17[v8][v9]\n                v20 = v17[v8][v9]\n                for v11, v12 in v4:\n                    v13, v14 = (v8 + v11, v9 + v12)\n                    if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] != 'X') and (v17[v13][v14] == v3) and (v20 + 1 < v5[v13][v14]):\n                        v17[v13][v14] = v20 + 1\n                        v19.append((v13, v14))\n            v18 = v19\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumSeconds(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = 10 ** 9 + 7\n        v4 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v5 = [[v3] * v2 for v6 in range(v1)]\n        v7 = []\n        for v8 in range(v1):\n            for v9 in range(v2):\n                if a1[v8][v9] == '*':\n                    v5[v8][v9] = 0\n                    v7.append((v8, v9))\n        while v7:\n            v10 = []\n            for v8, v9 in v7:\n                for v11, v12 in v4:\n                    v13, v14 = (v8 + v11, v9 + v12)\n                    if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] != 'X') and (a1[v13][v14] != 'D') and (v5[v13][v14] == v3):\n                        v5[v13][v14] = v5[v8][v9] + 1\n                        v10.append((v13, v14))\n            v7 = v10\n        v15, v16 = (0, 0)\n        for v8 in range(v1):\n            for v9 in range(v2):\n                if a1[v8][v9] == 'S':\n                    v15, v16 = (v8, v9)\n                    break\n            else:\n                continue\n            break\n        v17 = [[v3] * v2 for v6 in range(v1)]\n        v18 = []\n        if v5[v15][v16] > 0:\n            v17[v15][v16] = 0\n            v18.append((v15, v16))\n        while v18:\n            v19 = []\n            for v8, v9 in v18:\n                if a1[v8][v9] == 'D':\n                    return v17[v8][v9]\n                v20 = v17[v8][v9]\n                for v11, v12 in v4:\n                    v13, v14 = (v8 + v11, v9 + v12)\n                    if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] != 'X') and (v17[v13][v14] == v3) and (v20 + 1 < v5[v13][v14]):\n                        v17[v13][v14] = v20 + 1\n                        v19.append((v13, v14))\n            v18 = v19\n        return -1\n"}
{"id": "llm_code\\sum-of-consecutive-subarrays__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def getSum(self, a1):\n        v1 = 10 ** 9 + 7\n\n        def process(a1):\n            v1 = 0\n            v2 = 0\n            v3 = 0\n            for v4 in range(len(a1)):\n                if v2 == 0 or a1[v4] - a1[v4 - 1] != a1:\n                    v2 = 1\n                    v3 = a1[v4] * 1 % v1\n                    v1 = (v1 + v3) % v1\n                else:\n                    v2 += 1\n                    v3 = (v3 + a1[v4] * v2 % v1) % v1\n                    v1 = (v1 + v3) % v1\n            return v1\n        v2 = 0\n        for v3 in a1:\n            v2 = (v2 + v3) % v1\n        v4 = process(1)\n        v5 = process(-1)\n        return (v4 + v5 - v2 + v1) % v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def getSum(self, a1):\n        v1 = 10 ** 9 + 7\n\n        def process(a1):\n            v1 = 0\n            v2 = 0\n            v3 = 0\n            for v4 in range(len(a1)):\n                if v2 == 0 or a1[v4] - a1[v4 - 1] != a1:\n                    v2 = 1\n                    v3 = a1[v4] * 1 % v1\n                    v1 = (v1 + v3) % v1\n                else:\n                    v2 += 1\n                    v3 = (v3 + a1[v4] * v2 % v1) % v1\n                    v1 = (v1 + v3) % v1\n            return v1\n        v2 = 0\n        for v3 in a1:\n            v2 = (v2 + v3) % v1\n        v4 = process(1)\n        v5 = process(-1)\n        return (v4 + v5 - v2 + v1) % v1\n"}
{"id": "llm_code\\p03213__s085834125.py", "text": "import numpy as np\nv1 = int(input())\nv2 = [0] * (v1 + 1)\n\ndef f1(a1):\n    v1 = []\n    v2 = a1\n    for v3 in range(2, int(-(-a1 ** 0.5 // 1)) + 1):\n        if v2 % v3 == 0:\n            v4 = 0\n            while v2 % v3 == 0:\n                v4 += 1\n                v2 //= v3\n            v1.append([v3, v4])\n    if v2 != 1:\n        v1.append([v2, 1])\n    if v1 == []:\n        v1.append([a1, 1])\n    return v1\nfor v3 in range(1, v1 + 1):\n    v4 = f1(v3)\n    for v5, v6 in v4:\n        v2[v5] += v6\nv7 = np.array(v2)\nv8 = v7[v7 >= 2]\nv9 = v7[v7 >= 4]\nv10 = v7[v7 >= 14]\nv11 = v7[v7 >= 24]\nv12 = v7[v7 >= 74]\nv13 = len(v12)\nv14 = len(v11) * (len(v8) - len(v11)) + len(v11) * (len(v11) - 1) // 2\nv15 = len(v10) * (len(v9) - len(v10)) + len(v10) * (len(v10) - 1) // 2\nv16 = len(v9) * (len(v9) - 1) * (len(v8) - len(v9)) // 2 + len(v9) * (len(v9) - 1) * (len(v9) - 2) // 6\nprint(v13 + v14 + v15 + v16 + 1)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import numpy as np\nv1 = int(input())\nv2 = [0] * (v1 + 1)\n\ndef f1(a1):\n    v1 = []\n    v2 = a1\n    for v3 in range(2, int(-(-a1 ** 0.5 // 1)) + 1):\n        if v2 % v3 == 0:\n            v4 = 0\n            while v2 % v3 == 0:\n                v4 += 1\n                v2 //= v3\n            v1.append([v3, v4])\n    if v2 != 1:\n        v1.append([v2, 1])\n    if v1 == []:\n        v1.append([a1, 1])\n    return v1\nfor v3 in range(1, v1 + 1):\n    v4 = f1(v3)\n    for v5, v6 in v4:\n        v2[v5] += v6\nv7 = np.array(v2)\nv8 = v7[v7 >= 2]\nv9 = v7[v7 >= 4]\nv10 = v7[v7 >= 14]\nv11 = v7[v7 >= 24]\nv12 = v7[v7 >= 74]\nv13 = len(v12)\nv14 = len(v11) * (len(v8) - len(v11)) + len(v11) * (len(v11) - 1) // 2\nv15 = len(v10) * (len(v9) - len(v10)) + len(v10) * (len(v10) - 1) // 2\nv16 = len(v9) * (len(v9) - 1) * (len(v8) - len(v9)) // 2 + len(v9) * (len(v9) - 1) * (len(v9) - 2) // 6\nprint(v13 + v14 + v15 + v16 + 1)\n"}
{"id": "llm_code\\sudoku-solver__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def solveSudoku(self, a1):\n        v1 = [0] * 9\n        v2 = [0] * 9\n        v3 = [0] * 9\n        v4 = []\n        for v5 in range(9):\n            for v6 in range(9):\n                v7 = a1[v5][v6]\n                if v7 == '.':\n                    v4.append((v5, v6))\n                else:\n                    v8 = 1 << int(v7) - 1\n                    v1[v5] |= v8\n                    v2[v6] |= v8\n                    v3[v5 // 3 * 3 + v6 // 3] |= v8\n\n        def search(a1):\n            if a1 == len(v4):\n                return True\n            v1, v2 = v4[a1]\n            v3 = v1 // 3 * 3 + v2 // 3\n            for v4 in range(9):\n                v5 = 1 << v4\n                if v1[v1] & v5 == 0 and v2[v2] & v5 == 0 and (v3[v3] & v5 == 0):\n                    a1[v1][v2] = str(v4 + 1)\n                    v1[v1] |= v5\n                    v2[v2] |= v5\n                    v3[v3] |= v5\n                    if search(a1 + 1):\n                        return True\n                    a1[v1][v2] = '.'\n                    v1[v1] &= ~v5\n                    v2[v2] &= ~v5\n                    v3[v3] &= ~v5\n            return False\n        search(0)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def solveSudoku(self, a1):\n        v1 = [0] * 9\n        v2 = [0] * 9\n        v3 = [0] * 9\n        v4 = []\n        for v5 in range(9):\n            for v6 in range(9):\n                v7 = a1[v5][v6]\n                if v7 == '.':\n                    v4.append((v5, v6))\n                else:\n                    v8 = 1 << int(v7) - 1\n                    v1[v5] |= v8\n                    v2[v6] |= v8\n                    v3[v5 // 3 * 3 + v6 // 3] |= v8\n\n        def search(a1):\n            if a1 == len(v4):\n                return True\n            v1, v2 = v4[a1]\n            v3 = v1 // 3 * 3 + v2 // 3\n            for v4 in range(9):\n                v5 = 1 << v4\n                if v1[v1] & v5 == 0 and v2[v2] & v5 == 0 and (v3[v3] & v5 == 0):\n                    a1[v1][v2] = str(v4 + 1)\n                    v1[v1] |= v5\n                    v2[v2] |= v5\n                    v3[v3] |= v5\n                    if search(a1 + 1):\n                        return True\n                    a1[v1][v2] = '.'\n                    v1[v1] &= ~v5\n                    v2[v2] &= ~v5\n                    v3[v3] &= ~v5\n            return False\n        search(0)\n"}
{"id": "human_code\\employee-free-time.py", "text": "import heapq\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=0):\n        self.start = a1\n        self.end = a2\n\nclass C2(object):\n\n    def employeeFreeTime(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        v2 = [(emp[0].start, eid, 0) for v3, v4 in enumerate(a1)]\n        heapq.heapify(v2)\n        v5 = -1\n        while v2:\n            v6, v3, v7 = heapq.heappop(v2)\n            if 0 <= v5 < v6:\n                v1.append(C1(v5, v6))\n            v5 = max(v5, a1[v3][v7].end)\n            if v7 + 1 < len(a1[v3]):\n                heapq.heappush(v2, (a1[v3][v7 + 1].start, v3, v7 + 1))\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def __init__(self, a1=0, a2=0):\n        self.start = a1\n        self.end = a2\n\nclass C2(object):\n\n    def employeeFreeTime(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        v2 = [(emp[0].start, eid, 0) for v3, v4 in enumerate(a1)]\n        heapq.heapify(v2)\n        v5 = -1\n        while v2:\n            v6, v3, v7 = heapq.heappop(v2)\n            if 0 <= v5 < v6:\n                v1.append(C1(v5, v6))\n            v5 = max(v5, a1[v3][v7].end)\n            if v7 + 1 < len(a1[v3]):\n                heapq.heappush(v2, (a1[v3][v7 + 1].start, v3, v7 + 1))\n        return v1\n"}
{"id": "human_code\\parse-lisp-expression.py", "text": "class C1(object):\n\n    def evaluate(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def getval(a1, a2):\n            return a1.get(a2, a2)\n\n        def evaluate(a1, a2):\n            if a1[0] in ('add', 'mult'):\n                v1, v2 = list(map(int, [getval(a2, x) for v3 in a1[1:]]))\n                return str(v1 + v2 if a1[0] == 'add' else v1 * v2)\n            for v4 in range(1, len(a1) - 1, 2):\n                if a1[v4 + 1]:\n                    a2[a1[v4]] = getval(a2, a1[v4 + 1])\n            return getval(a2, a1[-1])\n        v1, v2, v3 = ([''], {}, [])\n        for v4 in a1:\n            if v4 == '(':\n                if v1[0] == 'let':\n                    evaluate(v1, v2)\n                v3.append((v1, dict(v2)))\n                v1 = ['']\n            elif v4 == ' ':\n                v1.append('')\n            elif v4 == ')':\n                v5 = evaluate(v1, v2)\n                v1, v2 = v3.pop()\n                v1[-1] += v5\n            else:\n                v1[-1] += v4\n        return int(v1[0])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def evaluate(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def getval(a1, a2):\n            return a1.get(a2, a2)\n\n        def evaluate(a1, a2):\n            if a1[0] in ('add', 'mult'):\n                v1, v2 = list(map(int, [getval(a2, x) for v3 in a1[1:]]))\n                return str(v1 + v2 if a1[0] == 'add' else v1 * v2)\n            for v4 in range(1, len(a1) - 1, 2):\n                if a1[v4 + 1]:\n                    a2[a1[v4]] = getval(a2, a1[v4 + 1])\n            return getval(a2, a1[-1])\n        v1, v2, v3 = ([''], {}, [])\n        for v4 in a1:\n            if v4 == '(':\n                if v1[0] == 'let':\n                    evaluate(v1, v2)\n                v3.append((v1, dict(v2)))\n                v1 = ['']\n            elif v4 == ' ':\n                v1.append('')\n            elif v4 == ')':\n                v5 = evaluate(v1, v2)\n                v1, v2 = v3.pop()\n                v1[-1] += v5\n            else:\n                v1[-1] += v4\n        return int(v1[0])\n"}
{"id": "llm_code\\minimum-hours-of-training-to-win-a-competition__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minNumberOfHours(self, a1, a2, a3, a4):\n        v1 = 0\n        v2 = a1\n        v3 = a2\n        v4 = len(a3)\n        for v5 in range(v4):\n            v6 = a3[v5]\n            v7 = a4[v5]\n            if v2 <= v6:\n                v8 = v6 + 1 - v2\n                v1 += v8\n                v2 += v8\n            v2 -= v6\n            if v3 <= v7:\n                v8 = v7 + 1 - v3\n                v1 += v8\n                v3 += v8\n            v3 += v7\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minNumberOfHours(self, a1, a2, a3, a4):\n        v1 = 0\n        v2 = a1\n        v3 = a2\n        v4 = len(a3)\n        for v5 in range(v4):\n            v6 = a3[v5]\n            v7 = a4[v5]\n            if v2 <= v6:\n                v8 = v6 + 1 - v2\n                v1 += v8\n                v2 += v8\n            v2 -= v6\n            if v3 <= v7:\n                v8 = v7 + 1 - v3\n                v1 += v8\n                v3 += v8\n            v3 += v7\n        return v1\n"}
{"id": "human_code\\find-k-pairs-with-smallest-sums__part1.py", "text": "from heapq import heappush, heappop\n\nclass C1(object):\n\n    def kSmallestPairs(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        if len(a1) > len(a2):\n            v2 = self.kSmallestPairs(a2, a1, a3)\n            for v3 in v2:\n                v1.append([v3[1], v3[0]])\n            return v1\n        v4 = []\n\n        def push(a1, a2):\n            if a1 < len(a1) and a2 < len(a2):\n                heappush(v4, [a1[a1] + a2[a2], a1, a2])\n        push(0, 0)\n        while v4 and len(v1) < a3:\n            v5, v6, v7 = heappop(v4)\n            v1.append([a1[v6], a2[v7]])\n            push(v6, v7 + 1)\n            if v7 == 0:\n                push(v6 + 1, 0)\n        return v1\nfrom heapq import nsmallest\nfrom itertools import product\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from heapq import heappush, heappop\n\nclass C1(object):\n\n    def kSmallestPairs(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        if len(a1) > len(a2):\n            v2 = self.kSmallestPairs(a2, a1, a3)\n            for v3 in v2:\n                v1.append([v3[1], v3[0]])\n            return v1\n        v4 = []\n\n        def push(a1, a2):\n            if a1 < len(a1) and a2 < len(a2):\n                heappush(v4, [a1[a1] + a2[a2], a1, a2])\n        push(0, 0)\n        while v4 and len(v1) < a3:\n            v5, v6, v7 = heappop(v4)\n            v1.append([a1[v6], a2[v7]])\n            push(v6, v7 + 1)\n            if v7 == 0:\n                push(v6 + 1, 0)\n        return v1\nfrom heapq import nsmallest\nfrom itertools import product\n"}
{"id": "human_code\\design-a-leaderboard.py", "text": "import collections\nimport random\n\nclass C1(object):\n\n    def __init__(self):\n        self.__lookup = collections.Counter()\n\n    def addScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__lookup[a1] += a2\n\n    def top(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def kthElement(a1, a2, a3):\n\n            def PartitionAroundPivot(a1, a2, a3, a4, a5):\n                v1 = a1\n                a4[a3], a4[a2] = (a4[a2], a4[a3])\n                for v2 in range(a1, a2):\n                    if a5(a4[v2], a4[a2]):\n                        a4[v2], a4[v1] = (a4[v1], a4[v2])\n                        v1 += 1\n                a4[a2], a4[v1] = (a4[v1], a4[a2])\n                return v1\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = random.randint(v1, v2)\n                v4 = PartitionAroundPivot(v1, v2, v3, a1, a3)\n                if v4 == a2:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v4 + 1\n        v1 = list(self.__lookup.values())\n        kthElement(v1, a1, lambda a, b: a > b)\n        return sum(v1[:a1])\n\n    def reset(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__lookup[a1] = 0\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport random\n\nclass C1(object):\n\n    def __init__(self):\n        self.__lookup = collections.Counter()\n\n    def addScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__lookup[a1] += a2\n\n    def top(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def kthElement(a1, a2, a3):\n\n            def PartitionAroundPivot(a1, a2, a3, a4, a5):\n                v1 = a1\n                a4[a3], a4[a2] = (a4[a2], a4[a3])\n                for v2 in range(a1, a2):\n                    if a5(a4[v2], a4[a2]):\n                        a4[v2], a4[v1] = (a4[v1], a4[v2])\n                        v1 += 1\n                a4[a2], a4[v1] = (a4[v1], a4[a2])\n                return v1\n            v1, v2 = (0, len(a1) - 1)\n            while v1 <= v2:\n                v3 = random.randint(v1, v2)\n                v4 = PartitionAroundPivot(v1, v2, v3, a1, a3)\n                if v4 == a2:\n                    return\n                elif v4 > a2:\n                    v2 = v4 - 1\n                else:\n                    v1 = v4 + 1\n        v1 = list(self.__lookup.values())\n        kthElement(v1, a1, lambda a, b: a > b)\n        return sum(v1[:a1])\n\n    def reset(self, a1):\n        \"\"\"\n        \"\"\"\n        self.__lookup[a1] = 0\n"}
{"id": "llm_code\\count-subarrays-with-median-k__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def countSubarrays(self, a1, a2):\n        v1 = a1.index(a2)\n\n        def get_score(a1):\n            if a1 == a2:\n                return 0\n            elif a1 < a2:\n                return -1\n            else:\n                return 1\n        v2 = {0: 1}\n        v3 = 0\n        for v4 in range(v1):\n            v3 += get_score(a1[v4])\n            v2[v3] = v2.get(v3, 0) + 1\n        v3 += get_score(a1[v1])\n        v5 = v2.get(v3, 0) + v2.get(v3 - 1, 0)\n        for v4 in range(v1 + 1, len(a1)):\n            v3 += get_score(a1[v4])\n            v5 += v2.get(v3, 0) + v2.get(v3 - 1, 0)\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countSubarrays(self, a1, a2):\n        v1 = a1.index(a2)\n\n        def get_score(a1):\n            if a1 == a2:\n                return 0\n            elif a1 < a2:\n                return -1\n            else:\n                return 1\n        v2 = {0: 1}\n        v3 = 0\n        for v4 in range(v1):\n            v3 += get_score(a1[v4])\n            v2[v3] = v2.get(v3, 0) + 1\n        v3 += get_score(a1[v1])\n        v5 = v2.get(v3, 0) + v2.get(v3 - 1, 0)\n        for v4 in range(v1 + 1, len(a1)):\n            v3 += get_score(a1[v4])\n            v5 += v2.get(v3, 0) + v2.get(v3 - 1, 0)\n        return v5\n"}
{"id": "human_code\\find-servers-that-handled-most-number-of-requests__part1.py", "text": "import itertools\nimport heapq\n\nclass C1(object):\n\n    def busiestServers(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * a1\n        v2 = []\n        v3 = []\n        v4 = list(range(a1))\n        for v5, (v6, v7) in enumerate(zip(a2, a3)):\n            if v5 % a1 == 0:\n                v4, v3 = ([], v4)\n            while v2 and v2[0][0] <= v6:\n                v8, v9 = heapq.heappop(v2)\n                if v9 < v5 % a1:\n                    heapq.heappush(v4, v9)\n                else:\n                    heapq.heappush(v3, v9)\n            v10 = v3 if v3 else v4\n            if not v10:\n                continue\n            v11 = heapq.heappop(v10)\n            v1[v11] += 1\n            heapq.heappush(v2, (v6 + v7, v11))\n        v12 = max(v1)\n        return [v5 for v5 in range(a1) if v1[v5] == v12]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import itertools\nimport heapq\n\nclass C1(object):\n\n    def busiestServers(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * a1\n        v2 = []\n        v3 = []\n        v4 = list(range(a1))\n        for v5, (v6, v7) in enumerate(zip(a2, a3)):\n            if v5 % a1 == 0:\n                v4, v3 = ([], v4)\n            while v2 and v2[0][0] <= v6:\n                v8, v9 = heapq.heappop(v2)\n                if v9 < v5 % a1:\n                    heapq.heappush(v4, v9)\n                else:\n                    heapq.heappush(v3, v9)\n            v10 = v3 if v3 else v4\n            if not v10:\n                continue\n            v11 = heapq.heappop(v10)\n            v1[v11] += 1\n            heapq.heappush(v2, (v6 + v7, v11))\n        v12 = max(v1)\n        return [v5 for v5 in range(a1) if v1[v5] == v12]\n"}
{"id": "human_code\\fizz-buzz-multithreaded.py", "text": "import threading\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.__n = a1\n        self.__curr = 0\n        self.__cv = threading.Condition()\n\n    def fizz(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 0:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 == 0 and v1 % 5 != 0:\n                    a1()\n                self.__cv.notify_all()\n\n    def buzz(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 1:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 != 0 and v1 % 5 == 0:\n                    a1()\n                self.__cv.notify_all()\n\n    def fizzbuzz(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 2:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 == 0 and v1 % 5 == 0:\n                    a1()\n                self.__cv.notify_all()\n\n    def number(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 3:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 != 0 and v1 % 5 != 0:\n                    a1(v1)\n                self.__cv.notify_all()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import threading\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.__n = a1\n        self.__curr = 0\n        self.__cv = threading.Condition()\n\n    def fizz(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 0:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 == 0 and v1 % 5 != 0:\n                    a1()\n                self.__cv.notify_all()\n\n    def buzz(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 1:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 != 0 and v1 % 5 == 0:\n                    a1()\n                self.__cv.notify_all()\n\n    def fizzbuzz(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 2:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 == 0 and v1 % 5 == 0:\n                    a1()\n                self.__cv.notify_all()\n\n    def number(self, a1):\n        \"\"\"\n        \"\"\"\n        for v1 in range(1, self.__n + 1):\n            with self.__cv:\n                while self.__curr % 4 != 3:\n                    self.__cv.wait()\n                self.__curr += 1\n                if v1 % 3 != 0 and v1 % 5 != 0:\n                    a1(v1)\n                self.__cv.notify_all()\n"}
{"id": "human_code\\p03776__s180701000.py", "text": "from collections import Counter\nv1, v2, v3 = map(int, input().split())\nv4 = list(map(int, input().split()))\nv4.sort(reverse=True)\nv5 = Counter(v4)\nv6 = sum(v4[:v2]) / v2\nv7 = 0\nfrom operator import mul\nfrom functools import reduce\n\ndef f1(a1, a2):\n    a2 = min(a1 - a2, a2)\n    if a2 == 0:\n        return 1\n    v2 = reduce(mul, range(a1, a1 - a2, -1))\n    v3 = reduce(mul, range(1, a2 + 1))\n    return v2 // v3\nv8 = v4[v2 - 1]\nv9 = v5[v8]\nv10 = Counter(v4[:v2])\nv11 = v10[v8]\nfor v12 in range(v2 - 1, v3):\n    v13 = v4[v12]\n    if v12 != v2 - 1:\n        if v13 != v4[0]:\n            break\n    v7 += f1(v9, v12 + 1 - (v2 - v11))\nprint(v6)\nprint(v7)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from collections import Counter\nv1, v2, v3 = map(int, input().split())\nv4 = list(map(int, input().split()))\nv4.sort(reverse=True)\nv5 = Counter(v4)\nv6 = sum(v4[:v2]) / v2\nv7 = 0\nfrom operator import mul\nfrom functools import reduce\n\ndef f1(a1, a2):\n    a2 = min(a1 - a2, a2)\n    if a2 == 0:\n        return 1\n    v2 = reduce(mul, range(a1, a1 - a2, -1))\n    v3 = reduce(mul, range(1, a2 + 1))\n    return v2 // v3\nv8 = v4[v2 - 1]\nv9 = v5[v8]\nv10 = Counter(v4[:v2])\nv11 = v10[v8]\nfor v12 in range(v2 - 1, v3):\n    v13 = v4[v12]\n    if v12 != v2 - 1:\n        if v13 != v4[0]:\n            break\n    v7 += f1(v9, v12 + 1 - (v2 - v11))\nprint(v6)\nprint(v7)\n"}
{"id": "llm_code\\construct-quad-tree__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4, a5, a6):\n        self.val = a1\n        self.isLeaf = a2\n        self.topLeft = a3\n        self.topRight = a4\n        self.bottomLeft = a5\n        self.bottomRight = a6\n\nclass C2(object):\n\n    def construct(self, a1):\n\n        def build(a1, a2, a3):\n            v1 = a1[a1][a2] == 1\n            v2 = True\n            for v3 in range(a3):\n                v4 = a1 + v3\n                for v5 in range(a3):\n                    v6 = a2 + v5\n                    if (a1[v4][v6] == 1) != v1:\n                        v2 = False\n                        break\n                if not v2:\n                    break\n            if v2:\n                return C1(v1, True, None, None, None, None)\n            v7 = a3 // 2\n            return C1(True, False, build(a1, a2, v7), build(a1, a2 + v7, v7), build(a1 + v7, a2, v7), build(a1 + v7, a2 + v7, v7))\n        v1 = len(a1)\n        return None if v1 == 0 else build(0, 0, v1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4, a5, a6):\n        self.val = a1\n        self.isLeaf = a2\n        self.topLeft = a3\n        self.topRight = a4\n        self.bottomLeft = a5\n        self.bottomRight = a6\n\nclass C2(object):\n\n    def construct(self, a1):\n\n        def build(a1, a2, a3):\n            v1 = a1[a1][a2] == 1\n            v2 = True\n            for v3 in range(a3):\n                v4 = a1 + v3\n                for v5 in range(a3):\n                    v6 = a2 + v5\n                    if (a1[v4][v6] == 1) != v1:\n                        v2 = False\n                        break\n                if not v2:\n                    break\n            if v2:\n                return C1(v1, True, None, None, None, None)\n            v7 = a3 // 2\n            return C1(True, False, build(a1, a2, v7), build(a1, a2 + v7, v7), build(a1 + v7, a2, v7), build(a1 + v7, a2 + v7, v7))\n        v1 = len(a1)\n        return None if v1 == 0 else build(0, 0, v1)\n"}
{"id": "llm_code\\p03722__s245875537.py", "text": "v1, v2 = map(int, input().split())\nv3 = []\nv4 = ['None' for v5 in range(v1)]\nv4[0] = 0\nfor v5 in range(v2):\n    v6, v7, v8 = map(int, input().split())\n    v3.append([v6 - 1, v7 - 1, v8])\nfor v5 in range(2 * v1):\n    for v9 in v3:\n        if v4[v9[1]] == 'None' and v4[v9[0]] != 'None':\n            v4[v9[1]] = v4[v9[0]] + v9[2]\n        if v4[v9[1]] != 'None' and v4[v9[0]] != 'None':\n            if v4[v9[1]] < v4[v9[0]] + v9[2]:\n                v4[v9[1]] = v4[v9[0]] + v9[2]\n    if v5 == v1 - 1:\n        v10 = v4[v1 - 1]\n    if v5 == 2 * v1 - 1:\n        if v10 != v4[v1 - 1]:\n            v4[v1 - 1] = 1000000000000000.0\nif v4[v1 - 1] < 1000000000000000.0:\n    print(v10)\nelse:\n    print('inf')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = []\nv4 = ['None' for v5 in range(v1)]\nv4[0] = 0\nfor v5 in range(v2):\n    v6, v7, v8 = map(int, input().split())\n    v3.append([v6 - 1, v7 - 1, v8])\nfor v5 in range(2 * v1):\n    for v9 in v3:\n        if v4[v9[1]] == 'None' and v4[v9[0]] != 'None':\n            v4[v9[1]] = v4[v9[0]] + v9[2]\n        if v4[v9[1]] != 'None' and v4[v9[0]] != 'None':\n            if v4[v9[1]] < v4[v9[0]] + v9[2]:\n                v4[v9[1]] = v4[v9[0]] + v9[2]\n    if v5 == v1 - 1:\n        v10 = v4[v1 - 1]\n    if v5 == 2 * v1 - 1:\n        if v10 != v4[v1 - 1]:\n            v4[v1 - 1] = 1000000000000000.0\nif v4[v1 - 1] < 1000000000000000.0:\n    print(v10)\nelse:\n    print('inf')\n"}
{"id": "human_code\\p03253__s242343005.py", "text": "class C1:\n\n    def __init__(self, a1, a2):\n        \"\"\"combination(max_value, all)\"\"\"\n        v1 = [-1] * (a1 + 1)\n        v1[0] = 1\n        v1[1] = 1\n        for v2 in range(2, a1 + 1):\n            v1[v2] = v2 * v1[v2 - 1] % a2\n        v3 = [1] * (a1 + 1)\n        v3[a1] = pow(v1[a1], a2 - 2, a2)\n        for v2 in range(a1 - 1, 0, -1):\n            v3[v2] = v3[v2 + 1] * (v2 + 1) % a2\n        self.fact = v1\n        self.invs = v3\n        self.mod = a2\n\n    def combination(self, a1, a2):\n        if a1 - a2 < a2:\n            return self.combination(a1, a1 - a2)\n        if a2 < 0:\n            return 0\n        if a2 == 0:\n            return 1\n        if a2 == 1:\n            return a1\n        return self.fact[a1] * self.invs[a2] * self.invs[a1 - a2] % self.mod\n\ndef f2(a1):\n    v1 = a1\n    v2 = 2\n    v3 = 0\n    while v1 % v2 == 0:\n        v1 //= v2\n        v3 += 1\n    yield v3\n    v2 = 3\n    v4 = v2 * v2\n    while v4 <= a1:\n        v3 = 0\n        while v1 % v2 == 0:\n            v1 //= v2\n            v3 += 1\n        yield v3\n        v4 += v2 * 4 + 4\n        v2 += 2\n    if v1 > 1:\n        yield 1\n\ndef f3():\n    v1 = 10 ** 9 + 7\n    v2, v3 = map(int, input().split())\n    v4 = C1(max_value=v2 + 30, mod=v1)\n    v5 = 1\n    for v6 in f2(v3):\n        v5 = v5 * v4.combination(v2 + v6 - 1, v6) % v1\n    print(v5)\nif __name__ == '__main__':\n    f3()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1, a2):\n        \"\"\"combination(max_value, all)\"\"\"\n        v1 = [-1] * (a1 + 1)\n        v1[0] = 1\n        v1[1] = 1\n        for v2 in range(2, a1 + 1):\n            v1[v2] = v2 * v1[v2 - 1] % a2\n        v3 = [1] * (a1 + 1)\n        v3[a1] = pow(v1[a1], a2 - 2, a2)\n        for v2 in range(a1 - 1, 0, -1):\n            v3[v2] = v3[v2 + 1] * (v2 + 1) % a2\n        self.fact = v1\n        self.invs = v3\n        self.mod = a2\n\n    def combination(self, a1, a2):\n        if a1 - a2 < a2:\n            return self.combination(a1, a1 - a2)\n        if a2 < 0:\n            return 0\n        if a2 == 0:\n            return 1\n        if a2 == 1:\n            return a1\n        return self.fact[a1] * self.invs[a2] * self.invs[a1 - a2] % self.mod\n\ndef f2(a1):\n    v1 = a1\n    v2 = 2\n    v3 = 0\n    while v1 % v2 == 0:\n        v1 //= v2\n        v3 += 1\n    yield v3\n    v2 = 3\n    v4 = v2 * v2\n    while v4 <= a1:\n        v3 = 0\n        while v1 % v2 == 0:\n            v1 //= v2\n            v3 += 1\n        yield v3\n        v4 += v2 * 4 + 4\n        v2 += 2\n    if v1 > 1:\n        yield 1\n\ndef f3():\n    v1 = 10 ** 9 + 7\n    v2, v3 = map(int, input().split())\n    v4 = C1(max_value=v2 + 30, mod=v1)\n    v5 = 1\n    for v6 in f2(v3):\n        v5 = v5 * v4.combination(v2 + v6 - 1, v6) % v1\n    print(v5)\nif __name__ == '__main__':\n    f3()\n"}
{"id": "human_code\\p03096__s593509291.py", "text": "v1 = int(input())\nv2 = [0]\nv3 = 10 ** 9 + 7\nfor v4 in range(v1):\n    v5 = int(input())\n    if v2[-1] == v5:\n        continue\n    else:\n        v2.append(v5)\nv6 = len(v2)\nv7 = [0] * (2 * 10 ** 5 + 1)\nv8 = [0] * (v6 - 1)\nv8.insert(0, 1)\nfor v4 in range(1, v6):\n    if v7[v2[v4]] == 0:\n        v8[v4] = v8[v4 - 1] % v3\n        v7[v2[v4]] = v4\n    else:\n        v9 = v7[v2[v4]]\n        v8[v4] = (v8[v4 - 1] + v8[v9]) % v3\n        v7[v2[v4]] = v4\nprint(v8[-1])\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [0]\nv3 = 10 ** 9 + 7\nfor v4 in range(v1):\n    v5 = int(input())\n    if v2[-1] == v5:\n        continue\n    else:\n        v2.append(v5)\nv6 = len(v2)\nv7 = [0] * (2 * 10 ** 5 + 1)\nv8 = [0] * (v6 - 1)\nv8.insert(0, 1)\nfor v4 in range(1, v6):\n    if v7[v2[v4]] == 0:\n        v8[v4] = v8[v4 - 1] % v3\n        v7[v2[v4]] = v4\n    else:\n        v9 = v7[v2[v4]]\n        v8[v4] = (v8[v4 - 1] + v8[v9]) % v3\n        v7[v2[v4]] = v4\nprint(v8[-1])\n"}
{"id": "human_code\\maximum-level-sum-of-a-binary-tree__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def maxLevelSum(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            if not a1:\n                return\n            if a2 == len(a3):\n                a3.append(0)\n            a3[a2] += a1.val\n            dfs(a1.left, a2 + 1, a3)\n            dfs(a1.right, a2 + 1, a3)\n        v1 = []\n        dfs(a1, 0, v1)\n        return v1.index(max(v1)) + 1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def maxLevelSum(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            if not a1:\n                return\n            if a2 == len(a3):\n                a3.append(0)\n            a3[a2] += a1.val\n            dfs(a1.left, a2 + 1, a3)\n            dfs(a1.right, a2 + 1, a3)\n        v1 = []\n        dfs(a1, 0, v1)\n        return v1.index(max(v1)) + 1\n"}
{"id": "llm_code\\longest-chunked-palindrome-decomposition__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def longestDecomposition(self, a1):\n\n        def segments_match(a1, a2, a3, a4):\n            for v1 in range(a2):\n                if a1[a3 + v1] != a1[a4 + v1]:\n                    return False\n            return True\n        v1 = a1\n        v2 = len(v1)\n        v3 = 0\n        v4 = 0\n        v5 = v2 - 1\n        v6 = 29\n        v7 = 10 ** 9 + 7\n        while v4 < v5:\n            v8 = (v5 - v4 + 1) // 2\n            v9 = 0\n            v10 = 0\n            v11 = 1\n            v12 = False\n            v13 = 0\n            while v13 < v8:\n                v13 += 1\n                v14 = ord(v1[v4 + v13 - 1]) - ord('a')\n                v9 = (v9 * v6 + v14) % v7\n                v15 = ord(v1[v5 - v13 + 1]) - ord('a')\n                v10 = (v15 * v11 + v10) % v7\n                v11 = v11 * v6 % v7\n                if v9 == v10 and segments_match(v1, v13, v4, v5 - v13 + 1):\n                    v3 += 1\n                    v4 += v13\n                    v5 -= v13\n                    v12 = True\n                    break\n            if not v12:\n                break\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestDecomposition(self, a1):\n\n        def segments_match(a1, a2, a3, a4):\n            for v1 in range(a2):\n                if a1[a3 + v1] != a1[a4 + v1]:\n                    return False\n            return True\n        v1 = a1\n        v2 = len(v1)\n        v3 = 0\n        v4 = 0\n        v5 = v2 - 1\n        v6 = 29\n        v7 = 10 ** 9 + 7\n        while v4 < v5:\n            v8 = (v5 - v4 + 1) // 2\n            v9 = 0\n            v10 = 0\n            v11 = 1\n            v12 = False\n            v13 = 0\n            while v13 < v8:\n                v13 += 1\n                v14 = ord(v1[v4 + v13 - 1]) - ord('a')\n                v9 = (v9 * v6 + v14) % v7\n                v15 = ord(v1[v5 - v13 + 1]) - ord('a')\n                v10 = (v15 * v11 + v10) % v7\n                v11 = v11 * v6 % v7\n                if v9 == v10 and segments_match(v1, v13, v4, v5 - v13 + 1):\n                    v3 += 1\n                    v4 += v13\n                    v5 -= v13\n                    v12 = True\n                    break\n            if not v12:\n                break\n        return v3\n"}
{"id": "llm_code\\p03263__s278139415.py", "text": "import sys\n\ndef f1():\n    input = sys.stdin.readline\n    v1, v2 = map(int, input().split())\n    v3 = [list(map(int, input().split())) for v4 in range(v1)]\n    v5 = 0\n    v6 = []\n    for v7 in range(v1):\n        for v8 in range(v2):\n            if v3[v7][v8] % 2 == 1:\n                if v8 < v2 - 1 and v3[v7][v8 + 1] > 0:\n                    v5 += 1\n                    v6.append([v7 + 1, v8 + 1, v7 + 1, v8 + 2])\n                    v3[v7][v8] -= 1\n                    v3[v7][v8 + 1] -= 1\n                elif v7 < v1 - 1 and v3[v7 + 1][v8] > 0:\n                    v5 += 1\n                    v6.append([v7 + 1, v8 + 1, v7 + 2, v8 + 1])\n                    v3[v7][v8] -= 1\n                    v3[v7 + 1][v8] -= 1\n    print(v5)\n    if v5 > 0:\n        for v9 in v6:\n            print('{} {} {} {}'.format(v9[0], v9[1], v9[2], v9[3]))\nif __name__ == '__main__':\n    f1()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\n\ndef f1():\n    input = sys.stdin.readline\n    v1, v2 = map(int, input().split())\n    v3 = [list(map(int, input().split())) for v4 in range(v1)]\n    v5 = 0\n    v6 = []\n    for v7 in range(v1):\n        for v8 in range(v2):\n            if v3[v7][v8] % 2 == 1:\n                if v8 < v2 - 1 and v3[v7][v8 + 1] > 0:\n                    v5 += 1\n                    v6.append([v7 + 1, v8 + 1, v7 + 1, v8 + 2])\n                    v3[v7][v8] -= 1\n                    v3[v7][v8 + 1] -= 1\n                elif v7 < v1 - 1 and v3[v7 + 1][v8] > 0:\n                    v5 += 1\n                    v6.append([v7 + 1, v8 + 1, v7 + 2, v8 + 1])\n                    v3[v7][v8] -= 1\n                    v3[v7 + 1][v8] -= 1\n    print(v5)\n    if v5 > 0:\n        for v9 in v6:\n            print('{} {} {} {}'.format(v9[0], v9[1], v9[2], v9[3]))\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\longest-palindromic-path-in-graph.py", "text": "class C1(object):\n\n    def maxLen(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def popcount(a1):\n            return bin(a1).count('1')\n        if len(a2) == a1 * (a1 - 1) // 2:\n            v1 = [0] * 26\n            for v2 in a3:\n                v1[ord(v2) - ord('a')] += 1\n            return 2 * sum((c // 2 for v3 in v1)) + 1 * any((v3 % 2 for v3 in v1))\n        v4 = [[] for v5 in range(a1)]\n        for v6, v7 in a2:\n            v4[v6].append(v7)\n            v4[v7].append(v6)\n        v8 = [[[False] * a1 for v5 in range(a1)] for v5 in range(1 << a1)]\n        for v6 in range(a1):\n            v8[1 << v6][v6][v6] = True\n        for v6, v7 in a2:\n            if a3[v6] == a3[v7]:\n                v8[1 << v6 | 1 << v7][min(v6, v7)][max(v6, v7)] = True\n        v9 = 0\n        for v10 in range(1, 1 << a1):\n            for v6 in range(a1):\n                for v7 in range(v6, a1):\n                    if not v8[v10][v6][v7]:\n                        continue\n                    v9 = max(v9, popcount(v10))\n                    for v11 in v4[v6]:\n                        if v10 & 1 << v11:\n                            continue\n                        for v12 in v4[v7]:\n                            if v10 & 1 << v12:\n                                continue\n                            if v11 == v12:\n                                continue\n                            if a3[v11] == a3[v12]:\n                                v8[v10 | 1 << v11 | 1 << v12][min(v11, v12)][max(v11, v12)] = True\n        return v9\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxLen(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def popcount(a1):\n            return bin(a1).count('1')\n        if len(a2) == a1 * (a1 - 1) // 2:\n            v1 = [0] * 26\n            for v2 in a3:\n                v1[ord(v2) - ord('a')] += 1\n            return 2 * sum((c // 2 for v3 in v1)) + 1 * any((v3 % 2 for v3 in v1))\n        v4 = [[] for v5 in range(a1)]\n        for v6, v7 in a2:\n            v4[v6].append(v7)\n            v4[v7].append(v6)\n        v8 = [[[False] * a1 for v5 in range(a1)] for v5 in range(1 << a1)]\n        for v6 in range(a1):\n            v8[1 << v6][v6][v6] = True\n        for v6, v7 in a2:\n            if a3[v6] == a3[v7]:\n                v8[1 << v6 | 1 << v7][min(v6, v7)][max(v6, v7)] = True\n        v9 = 0\n        for v10 in range(1, 1 << a1):\n            for v6 in range(a1):\n                for v7 in range(v6, a1):\n                    if not v8[v10][v6][v7]:\n                        continue\n                    v9 = max(v9, popcount(v10))\n                    for v11 in v4[v6]:\n                        if v10 & 1 << v11:\n                            continue\n                        for v12 in v4[v7]:\n                            if v10 & 1 << v12:\n                                continue\n                            if v11 == v12:\n                                continue\n                            if a3[v11] == a3[v12]:\n                                v8[v10 | 1 << v11 | 1 << v12][min(v11, v12)][max(v11, v12)] = True\n        return v9\n"}
{"id": "human_code\\minimum-incompatibility__part3.py", "text": "import collections\nimport sortedcontainers\n\nclass C1(object):\n\n    def minimumIncompatibility(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def greedy(a1, a2, a3):\n            v1 = collections.Counter(a1)\n            if max(v1.values()) > a2:\n                return -1\n            v2 = sortedcontainers.SortedList(iter(v1.keys()))\n            v3 = collections.defaultdict(collections.OrderedDict)\n            for v4 in v2:\n                v3[v1[v4]][v4] = v1[v4]\n            v5 = [[] for v6 in range(a2)]\n            v7 = 0\n            while v2:\n                if len(v5) - v7 in v3:\n                    for v4 in v3[len(v5) - v7].keys():\n                        for v8 in range(v7, len(v5)):\n                            v5[v8].append(v4)\n                        v1.pop(v4)\n                        v2.remove(v4)\n                    v3.pop(len(v5) - v7)\n                v9 = []\n                v10 = (lambda x: v4) if not a3 else reversed\n                for v4 in v10(v2):\n                    v5[v7].append(v4)\n                    v3[v1[v4]].pop(v4)\n                    if not v3[v1[v4]]:\n                        v3.pop(v1[v4])\n                    v1[v4] -= 1\n                    if not v1[v4]:\n                        v1.pop(v4)\n                        v9.append(v4)\n                    else:\n                        v3[v1[v4]][v4] = v1[v4]\n                    if len(v5[v7]) == len(a1) // a2:\n                        v7 += 1\n                        break\n                for v4 in v9:\n                    v2.remove(v4)\n            return sum([max(stk) - min(stk) for v11 in v5])\n        return min(greedy(a1, a2, False), greedy(a1, a2, True))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nimport sortedcontainers\n\nclass C1(object):\n\n    def minimumIncompatibility(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def greedy(a1, a2, a3):\n            v1 = collections.Counter(a1)\n            if max(v1.values()) > a2:\n                return -1\n            v2 = sortedcontainers.SortedList(iter(v1.keys()))\n            v3 = collections.defaultdict(collections.OrderedDict)\n            for v4 in v2:\n                v3[v1[v4]][v4] = v1[v4]\n            v5 = [[] for v6 in range(a2)]\n            v7 = 0\n            while v2:\n                if len(v5) - v7 in v3:\n                    for v4 in v3[len(v5) - v7].keys():\n                        for v8 in range(v7, len(v5)):\n                            v5[v8].append(v4)\n                        v1.pop(v4)\n                        v2.remove(v4)\n                    v3.pop(len(v5) - v7)\n                v9 = []\n                v10 = (lambda x: v4) if not a3 else reversed\n                for v4 in v10(v2):\n                    v5[v7].append(v4)\n                    v3[v1[v4]].pop(v4)\n                    if not v3[v1[v4]]:\n                        v3.pop(v1[v4])\n                    v1[v4] -= 1\n                    if not v1[v4]:\n                        v1.pop(v4)\n                        v9.append(v4)\n                    else:\n                        v3[v1[v4]][v4] = v1[v4]\n                    if len(v5[v7]) == len(a1) // a2:\n                        v7 += 1\n                        break\n                for v4 in v9:\n                    v2.remove(v4)\n            return sum([max(stk) - min(stk) for v11 in v5])\n        return min(greedy(a1, a2, False), greedy(a1, a2, True))\n"}
{"id": "human_code\\maximum-strong-pair-xor-ii__part1.py", "text": "class C1(object):\n\n    def maximumStrongPairXor(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self, a1):\n                self.__nodes = []\n                self.__cnts = []\n                self.__new_node()\n                self.__bit_length = a1\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 2)\n                self.__cnts.append(0)\n                return len(self.__nodes) - 1\n\n            def update(self, a1, a2):\n                v1 = 0\n                for v2 in reversed(range(self.__bit_length)):\n                    v3 = a1 >> v2\n                    if self.__nodes[v1][v3 & 1] == -1:\n                        self.__nodes[v1][v3 & 1] = self.__new_node()\n                    v1 = self.__nodes[v1][v3 & 1]\n                    self.__cnts[v1] += a2\n\n            def query(self, a1):\n                v1 = v2 = 0\n                for v3 in reversed(range(self.__bit_length)):\n                    v1 <<= 1\n                    v4 = a1 >> v3\n                    if self.__nodes[v2][1 ^ v4 & 1] != -1 and self.__cnts[self.__nodes[v2][1 ^ v4 & 1]]:\n                        v2 = self.__nodes[v2][1 ^ v4 & 1]\n                        v1 |= 1\n                    else:\n                        v2 = self.__nodes[v2][v4 & 1]\n                return v1\n        a1.sort()\n        v1 = Trie(a1[-1].bit_length())\n        v2 = v3 = 0\n        for v4, v5 in enumerate(a1):\n            v1.update(v5, +1)\n            while not a1[v4] <= 2 * a1[v3]:\n                v1.update(a1[v3], -1)\n                v3 += 1\n            v2 = max(v2, v1.query(v5))\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumStrongPairXor(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class Trie(object):\n\n            def __init__(self, a1):\n                self.__nodes = []\n                self.__cnts = []\n                self.__new_node()\n                self.__bit_length = a1\n\n            def __new_node(self):\n                self.__nodes.append([-1] * 2)\n                self.__cnts.append(0)\n                return len(self.__nodes) - 1\n\n            def update(self, a1, a2):\n                v1 = 0\n                for v2 in reversed(range(self.__bit_length)):\n                    v3 = a1 >> v2\n                    if self.__nodes[v1][v3 & 1] == -1:\n                        self.__nodes[v1][v3 & 1] = self.__new_node()\n                    v1 = self.__nodes[v1][v3 & 1]\n                    self.__cnts[v1] += a2\n\n            def query(self, a1):\n                v1 = v2 = 0\n                for v3 in reversed(range(self.__bit_length)):\n                    v1 <<= 1\n                    v4 = a1 >> v3\n                    if self.__nodes[v2][1 ^ v4 & 1] != -1 and self.__cnts[self.__nodes[v2][1 ^ v4 & 1]]:\n                        v2 = self.__nodes[v2][1 ^ v4 & 1]\n                        v1 |= 1\n                    else:\n                        v2 = self.__nodes[v2][v4 & 1]\n                return v1\n        a1.sort()\n        v1 = Trie(a1[-1].bit_length())\n        v2 = v3 = 0\n        for v4, v5 in enumerate(a1):\n            v1.update(v5, +1)\n            while not a1[v4] <= 2 * a1[v3]:\n                v1.update(a1[v3], -1)\n                v3 += 1\n            v2 = max(v2, v1.query(v5))\n        return v2\n"}
{"id": "llm_code\\check-if-there-is-a-valid-parentheses-string-path__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def hasValidPath(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        if (v1 + v2 - 1) % 2 != 0:\n            return False\n        v3 = [set() for v4 in range(v2)]\n        v5 = 1 if a1[0][0] == '(' else -1\n        if v5 >= 0:\n            v3[0].add(v5)\n        for v6 in range(1, v2):\n            v5 = 1 if a1[0][v6] == '(' else -1\n            v7 = set()\n            for v8 in v3[v6 - 1]:\n                v9 = v8 + v5\n                if v9 >= 0:\n                    v7.add(v9)\n            v3[v6] = v7\n        for v10 in range(1, v1):\n            v11 = [set() for v4 in range(v2)]\n            v5 = 1 if a1[v10][0] == '(' else -1\n            v7 = set()\n            for v8 in v3[0]:\n                v9 = v8 + v5\n                if v9 >= 0:\n                    v7.add(v9)\n            v11[0] = v7\n            for v6 in range(1, v2):\n                v5 = 1 if a1[v10][v6] == '(' else -1\n                v7 = set()\n                for v8 in v11[v6 - 1]:\n                    v9 = v8 + v5\n                    if v9 >= 0:\n                        v7.add(v9)\n                for v8 in v3[v6]:\n                    v9 = v8 + v5\n                    if v9 >= 0:\n                        v7.add(v9)\n                v11[v6] = v7\n            v3 = v11\n        return 0 in v3[v2 - 1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def hasValidPath(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        if (v1 + v2 - 1) % 2 != 0:\n            return False\n        v3 = [set() for v4 in range(v2)]\n        v5 = 1 if a1[0][0] == '(' else -1\n        if v5 >= 0:\n            v3[0].add(v5)\n        for v6 in range(1, v2):\n            v5 = 1 if a1[0][v6] == '(' else -1\n            v7 = set()\n            for v8 in v3[v6 - 1]:\n                v9 = v8 + v5\n                if v9 >= 0:\n                    v7.add(v9)\n            v3[v6] = v7\n        for v10 in range(1, v1):\n            v11 = [set() for v4 in range(v2)]\n            v5 = 1 if a1[v10][0] == '(' else -1\n            v7 = set()\n            for v8 in v3[0]:\n                v9 = v8 + v5\n                if v9 >= 0:\n                    v7.add(v9)\n            v11[0] = v7\n            for v6 in range(1, v2):\n                v5 = 1 if a1[v10][v6] == '(' else -1\n                v7 = set()\n                for v8 in v11[v6 - 1]:\n                    v9 = v8 + v5\n                    if v9 >= 0:\n                        v7.add(v9)\n                for v8 in v3[v6]:\n                    v9 = v8 + v5\n                    if v9 >= 0:\n                        v7.add(v9)\n                v11[v6] = v7\n            v3 = v11\n        return 0 in v3[v2 - 1]\n"}
{"id": "human_code\\minimum-moves-to-spread-stones-over-grid__part3.py", "text": "class C1(object):\n\n    def minimumMoves(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dist(a1, a2):\n            return abs(a1[0] - a2[0]) + abs(a1[1] - a2[1])\n\n        def backtracking(a1):\n            if a1 == len(zero):\n                return 0\n            v1 = float('inf')\n            v2, v3 = zero[a1]\n            for v4 in range(len(a1)):\n                for v5 in range(len(a1[0])):\n                    if not a1[v4][v5] >= 2:\n                        continue\n                    a1[v4][v5] -= 1\n                    v1 = min(v1, dist((v2, v3), (v4, v5)) + backtracking(a1 + 1))\n                    a1[v4][v5] += 1\n            return v1\n        v1 = [(i, j) for v2 in range(len(a1)) for v3 in range(len(a1[0])) if a1[v2][v3] == 0]\n        return backtracking(0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumMoves(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def dist(a1, a2):\n            return abs(a1[0] - a2[0]) + abs(a1[1] - a2[1])\n\n        def backtracking(a1):\n            if a1 == len(zero):\n                return 0\n            v1 = float('inf')\n            v2, v3 = zero[a1]\n            for v4 in range(len(a1)):\n                for v5 in range(len(a1[0])):\n                    if not a1[v4][v5] >= 2:\n                        continue\n                    a1[v4][v5] -= 1\n                    v1 = min(v1, dist((v2, v3), (v4, v5)) + backtracking(a1 + 1))\n                    a1[v4][v5] += 1\n            return v1\n        v1 = [(i, j) for v2 in range(len(a1)) for v3 in range(len(a1[0])) if a1[v2][v3] == 0]\n        return backtracking(0)\n"}
{"id": "human_code\\maximum-number-of-potholes-that-can-be-fixed__part1.py", "text": "class C1(object):\n\n    def maxPotholes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def inplace_counting_sort(a1, a2=False):\n            if not a1:\n                return\n            v1 = [0] * (max(a1) + 1)\n            for v2 in a1:\n                v1[v2] += 1\n            for v3 in range(1, len(v1)):\n                v1[v3] += v1[v3 - 1]\n            for v3 in reversed(range(len(a1))):\n                while a1[v3] >= 0:\n                    v1[a1[v3]] -= 1\n                    v4 = v1[a1[v3]]\n                    a1[v3], a1[v4] = (a1[v4], ~a1[v3])\n            for v3 in range(len(a1)):\n                a1[v3] = ~a1[v3]\n            if a2:\n                a1.reverse()\n        v1 = []\n        v2 = 0\n        for v3 in range(len(a1)):\n            v2 += 1\n            if v3 + 1 == len(a1) or a1[v3 + 1] != a1[v3]:\n                if a1[v3] == 'x':\n                    v1.append(v2)\n                v2 = 0\n        inplace_counting_sort(v1)\n        v4 = 0\n        for v2 in reversed(v1):\n            v5 = min(v2 + 1, a2)\n            if v5 - 1 <= 0:\n                break\n            v4 += v5 - 1\n            a2 -= v5\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxPotholes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def inplace_counting_sort(a1, a2=False):\n            if not a1:\n                return\n            v1 = [0] * (max(a1) + 1)\n            for v2 in a1:\n                v1[v2] += 1\n            for v3 in range(1, len(v1)):\n                v1[v3] += v1[v3 - 1]\n            for v3 in reversed(range(len(a1))):\n                while a1[v3] >= 0:\n                    v1[a1[v3]] -= 1\n                    v4 = v1[a1[v3]]\n                    a1[v3], a1[v4] = (a1[v4], ~a1[v3])\n            for v3 in range(len(a1)):\n                a1[v3] = ~a1[v3]\n            if a2:\n                a1.reverse()\n        v1 = []\n        v2 = 0\n        for v3 in range(len(a1)):\n            v2 += 1\n            if v3 + 1 == len(a1) or a1[v3 + 1] != a1[v3]:\n                if a1[v3] == 'x':\n                    v1.append(v2)\n                v2 = 0\n        inplace_counting_sort(v1)\n        v4 = 0\n        for v2 in reversed(v1):\n            v5 = min(v2 + 1, a2)\n            if v5 - 1 <= 0:\n                break\n            v4 += v5 - 1\n            a2 -= v5\n        return v4\n"}
{"id": "llm_code\\minimum-amount-of-time-to-collect-garbage__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def garbageCollection(self, a1, a2):\n        v1 = len(a1)\n        v2 = [0] * v1\n        for v3 in range(1, v1):\n            v2[v3] = v2[v3 - 1] + a2[v3 - 1]\n        v4 = v5 = v6 = -1\n        v7 = 0\n        for v3, v8 in enumerate(a1):\n            v7 += len(v8)\n            for v9 in v8:\n                if v9 == 'G':\n                    v4 = v3\n                elif v9 == 'M':\n                    v5 = v3\n                elif v9 == 'P':\n                    v6 = v3\n        v10 = 0\n        if v4 >= 0:\n            v10 += v2[v4]\n        if v5 >= 0:\n            v10 += v2[v5]\n        if v6 >= 0:\n            v10 += v2[v6]\n        return v7 + v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def garbageCollection(self, a1, a2):\n        v1 = len(a1)\n        v2 = [0] * v1\n        for v3 in range(1, v1):\n            v2[v3] = v2[v3 - 1] + a2[v3 - 1]\n        v4 = v5 = v6 = -1\n        v7 = 0\n        for v3, v8 in enumerate(a1):\n            v7 += len(v8)\n            for v9 in v8:\n                if v9 == 'G':\n                    v4 = v3\n                elif v9 == 'M':\n                    v5 = v3\n                elif v9 == 'P':\n                    v6 = v3\n        v10 = 0\n        if v4 >= 0:\n            v10 += v2[v4]\n        if v5 >= 0:\n            v10 += v2[v5]\n        if v6 >= 0:\n            v10 += v2[v6]\n        return v7 + v10\n"}
{"id": "llm_code\\minimum-moves-to-spread-stones-over-grid__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minimumMoves(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        v4 = []\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v7 = a1[v5][v6]\n                if v7 == 0:\n                    v4.append((v5, v6))\n                elif v7 > 1:\n                    for v8 in range(v7 - 1):\n                        v3.append((v5, v6))\n        import itertools\n        v9 = float('inf')\n        v10 = len(v4)\n        for v11 in itertools.permutations(v4):\n            v12 = sum((abs(v3[t][0] - v11[t][0]) + abs(v3[t][1] - v11[t][1]) for v13 in range(v10)))\n            v9 = min(v9, v12)\n        return int(v9)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumMoves(self, a1):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        v4 = []\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v7 = a1[v5][v6]\n                if v7 == 0:\n                    v4.append((v5, v6))\n                elif v7 > 1:\n                    for v8 in range(v7 - 1):\n                        v3.append((v5, v6))\n        import itertools\n        v9 = float('inf')\n        v10 = len(v4)\n        for v11 in itertools.permutations(v4):\n            v12 = sum((abs(v3[t][0] - v11[t][0]) + abs(v3[t][1] - v11[t][1]) for v13 in range(v10)))\n            v9 = min(v9, v12)\n        return int(v9)\n"}
{"id": "llm_code\\maximum-elegance-of-a-k-length-subsequence__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def findMaximumElegance(self, a1, a2):\n        v1 = sorted(a1, key=lambda x: -x[0])\n        v2 = len(v1)\n        v3 = 0\n        v4 = set()\n        v5 = []\n        for v6 in range(min(a2, v2)):\n            v7, v8 = v1[v6]\n            v3 += v7\n            if v8 in v4:\n                v5.append(v7)\n            v4.add(v8)\n        v9 = len(v4)\n        v10 = v3 + v9 * v9\n        v11 = {}\n        for v6 in range(a2, v2):\n            v7, v8 = v1[v6]\n            if v8 not in v4:\n                v11[v8] = max(v11.get(v8, 0), v7)\n        v12 = sorted(v11.values(), reverse=True)\n        v5.sort()\n        v13 = v3\n        v14 = min(len(v5), len(v12))\n        for v6 in range(v14):\n            v13 += v12[v6] - v5[v6]\n            v15 = v9 + v6 + 1\n            v10 = max(v10, v13 + v15 * v15)\n        return v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def findMaximumElegance(self, a1, a2):\n        v1 = sorted(a1, key=lambda x: -x[0])\n        v2 = len(v1)\n        v3 = 0\n        v4 = set()\n        v5 = []\n        for v6 in range(min(a2, v2)):\n            v7, v8 = v1[v6]\n            v3 += v7\n            if v8 in v4:\n                v5.append(v7)\n            v4.add(v8)\n        v9 = len(v4)\n        v10 = v3 + v9 * v9\n        v11 = {}\n        for v6 in range(a2, v2):\n            v7, v8 = v1[v6]\n            if v8 not in v4:\n                v11[v8] = max(v11.get(v8, 0), v7)\n        v12 = sorted(v11.values(), reverse=True)\n        v5.sort()\n        v13 = v3\n        v14 = min(len(v5), len(v12))\n        for v6 in range(v14):\n            v13 += v12[v6] - v5[v6]\n            v15 = v9 + v6 + 1\n            v10 = max(v10, v13 + v15 * v15)\n        return v10\n"}
{"id": "human_code\\repeated-string-match.py", "text": "class C1(object):\n\n    def repeatedStringMatch(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            return all((a1[(i + a1) % len(a1)] == c for v1, v2 in enumerate(a2)))\n        v1, v2 = (10 ** 9 + 7, 113)\n        v3 = pow(v2, v1 - 2, v1)\n        v4 = (len(a2) + len(a1) - 1) // len(a1)\n        v5, v6 = (0, 1)\n        for v7 in a2:\n            v5 += v6 * ord(v7)\n            v5 %= v1\n            v6 = v6 * v2 % v1\n        v8, v6 = (0, 1)\n        for v9 in range(len(a2)):\n            v8 += v6 * ord(a1[v9 % len(a1)])\n            v8 %= v1\n            v6 = v6 * v2 % v1\n        if v8 == v5 and check(0):\n            return v4\n        v6 = v6 * v3 % v1\n        for v9 in range(len(a2), (v4 + 1) * len(a1)):\n            v8 = (v8 - ord(a1[(v9 - len(a2)) % len(a1)])) * v3\n            v8 += v6 * ord(a1[v9 % len(a1)])\n            v8 %= v1\n            if v8 == v5 and check(v9 - len(a2) + 1):\n                return v4 if v9 < v4 * len(a1) else v4 + 1\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def repeatedStringMatch(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def check(a1):\n            return all((a1[(i + a1) % len(a1)] == c for v1, v2 in enumerate(a2)))\n        v1, v2 = (10 ** 9 + 7, 113)\n        v3 = pow(v2, v1 - 2, v1)\n        v4 = (len(a2) + len(a1) - 1) // len(a1)\n        v5, v6 = (0, 1)\n        for v7 in a2:\n            v5 += v6 * ord(v7)\n            v5 %= v1\n            v6 = v6 * v2 % v1\n        v8, v6 = (0, 1)\n        for v9 in range(len(a2)):\n            v8 += v6 * ord(a1[v9 % len(a1)])\n            v8 %= v1\n            v6 = v6 * v2 % v1\n        if v8 == v5 and check(0):\n            return v4\n        v6 = v6 * v3 % v1\n        for v9 in range(len(a2), (v4 + 1) * len(a1)):\n            v8 = (v8 - ord(a1[(v9 - len(a2)) % len(a1)])) * v3\n            v8 += v6 * ord(a1[v9 % len(a1)])\n            v8 %= v1\n            if v8 == v5 and check(v9 - len(a2) + 1):\n                return v4 if v9 < v4 * len(a1) else v4 + 1\n        return -1\n"}
{"id": "llm_code\\amount-of-new-area-painted-each-day__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def amountPainted(self, a1):\n        v1 = len(a1)\n        v2 = []\n        for v3 in range(v1):\n            v4, v5 = a1[v3]\n            v2.append((v4, 0, v3, v5))\n            v2.append((v5, 1, v3, v5))\n        v2.sort()\n        v6 = [0] * v1\n        v7 = []\n        v8 = None\n        v9 = 0\n        v10 = len(v2)\n        while v9 < v10:\n            v11 = v2[v9][0]\n            if v8 is not None:\n                while v7 and v7[0][1] < v11:\n                    heapq.heappop(v7)\n                if v7:\n                    v6[v7[0][0]] += v11 - v8\n            v8 = v11\n            while v9 < v10 and v2[v9][0] == v11:\n                v12 = v2[v9][1]\n                v13 = v2[v9][2]\n                if v12 == 0:\n                    heapq.heappush(v7, (v13, v2[v9][3]))\n                v9 += 1\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def amountPainted(self, a1):\n        v1 = len(a1)\n        v2 = []\n        for v3 in range(v1):\n            v4, v5 = a1[v3]\n            v2.append((v4, 0, v3, v5))\n            v2.append((v5, 1, v3, v5))\n        v2.sort()\n        v6 = [0] * v1\n        v7 = []\n        v8 = None\n        v9 = 0\n        v10 = len(v2)\n        while v9 < v10:\n            v11 = v2[v9][0]\n            if v8 is not None:\n                while v7 and v7[0][1] < v11:\n                    heapq.heappop(v7)\n                if v7:\n                    v6[v7[0][0]] += v11 - v8\n            v8 = v11\n            while v9 < v10 and v2[v9][0] == v11:\n                v12 = v2[v9][1]\n                v13 = v2[v9][2]\n                if v12 == 0:\n                    heapq.heappush(v7, (v13, v2[v9][3]))\n                v9 += 1\n        return v6\n"}
{"id": "llm_code\\find-first-and-last-position-of-element-in-sorted-array__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def searchRange(self, a1, a2):\n        v1 = len(a1)\n        v2, v3 = (0, v1)\n        while v2 < v3:\n            v4 = (v2 + v3) // 2\n            if a1[v4] < a2:\n                v2 = v4 + 1\n            else:\n                v3 = v4\n        v5 = v2\n        if v5 == v1 or a1[v5] != a2:\n            return [-1, -1]\n        v2, v3 = (0, v1)\n        while v2 < v3:\n            v4 = (v2 + v3) // 2\n            if a1[v4] <= a2:\n                v2 = v4 + 1\n            else:\n                v3 = v4\n        v6 = v2 - 1\n        return [v5, v6]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def searchRange(self, a1, a2):\n        v1 = len(a1)\n        v2, v3 = (0, v1)\n        while v2 < v3:\n            v4 = (v2 + v3) // 2\n            if a1[v4] < a2:\n                v2 = v4 + 1\n            else:\n                v3 = v4\n        v5 = v2\n        if v5 == v1 or a1[v5] != a2:\n            return [-1, -1]\n        v2, v3 = (0, v1)\n        while v2 < v3:\n            v4 = (v2 + v3) // 2\n            if a1[v4] <= a2:\n                v2 = v4 + 1\n            else:\n                v3 = v4\n        v6 = v2 - 1\n        return [v5, v6]\n"}
{"id": "llm_code\\subsequences-with-a-unique-middle-mode-i__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def subsequencesWithMiddleMode(self, a1):\n        v1 = 10 ** 9 + 7\n\n        def c(a1, a2):\n            if a2 < 0 or a2 > a1:\n                return 0\n            if a2 == 0:\n                return 1\n            if a2 == 1:\n                return a1\n            return a1 * (a1 - 1) // 2\n        v2 = len(a1)\n        v3 = collections.Counter(a1)\n        v4 = collections.Counter()\n        v5 = 0\n        v6 = 0\n        v7 = 0\n        v8 = 0\n        v9 = 0\n        v6 = sum((f * f for v10 in v3.values()))\n        v11 = 0\n        for v12 in range(v2):\n            v13 = a1[v12]\n            v5 -= v4[v13] * v4[v13]\n            v6 -= v3[v13] * v3[v13]\n            v7 -= v4[v13] * v3[v13]\n            v8 -= v4[v13] * v4[v13] * v3[v13]\n            v9 -= v4[v13] * v3[v13] * v3[v13]\n            v3[v13] -= 1\n            v14 = v4[v13]\n            v15 = v3[v13]\n            v16 = v12\n            v17 = v2 - v12 - 1\n            v18 = v16 - v14\n            v19 = v17 - v15\n            v20 = 0\n            for v21 in range(3):\n                v22 = c(v14, v21) * c(v18, 2 - v21)\n                for v23 in range(3):\n                    if v21 + v23 < 2:\n                        continue\n                    v24 = c(v15, v23) * c(v19, 2 - v23)\n                    v20 = (v20 + v22 * v24) % v1\n            v11 = (v11 + v20) % v1\n            v25 = v18 * c(v19, 2)\n            v26 = (v6 - v19) // 2\n            v27 = v19 * v7 - v9\n            v28 = v25 - v18 * v26 - v27\n            if v28 > 0:\n                v29 = c(v14, 1) * c(v15, 0) * v28 % v1\n                v11 = (v11 + v29) % v1\n            v30 = v19 * c(v18, 2)\n            v31 = (v5 - v18) // 2\n            v32 = v18 * v7 - v8\n            v33 = v30 - v19 * v31 - v32\n            if v33 > 0:\n                v29 = c(v14, 0) * c(v15, 1) * v33 % v1\n                v11 = (v11 + v29) % v1\n            v4[v13] += 1\n            v5 += v4[v13] * v4[v13]\n            v6 += v3[v13] * v3[v13]\n            v7 += v4[v13] * v3[v13]\n            v8 += v4[v13] * v4[v13] * v3[v13]\n            v9 += v4[v13] * v3[v13] * v3[v13]\n        return v11\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def subsequencesWithMiddleMode(self, a1):\n        v1 = 10 ** 9 + 7\n\n        def c(a1, a2):\n            if a2 < 0 or a2 > a1:\n                return 0\n            if a2 == 0:\n                return 1\n            if a2 == 1:\n                return a1\n            return a1 * (a1 - 1) // 2\n        v2 = len(a1)\n        v3 = collections.Counter(a1)\n        v4 = collections.Counter()\n        v5 = 0\n        v6 = 0\n        v7 = 0\n        v8 = 0\n        v9 = 0\n        v6 = sum((f * f for v10 in v3.values()))\n        v11 = 0\n        for v12 in range(v2):\n            v13 = a1[v12]\n            v5 -= v4[v13] * v4[v13]\n            v6 -= v3[v13] * v3[v13]\n            v7 -= v4[v13] * v3[v13]\n            v8 -= v4[v13] * v4[v13] * v3[v13]\n            v9 -= v4[v13] * v3[v13] * v3[v13]\n            v3[v13] -= 1\n            v14 = v4[v13]\n            v15 = v3[v13]\n            v16 = v12\n            v17 = v2 - v12 - 1\n            v18 = v16 - v14\n            v19 = v17 - v15\n            v20 = 0\n            for v21 in range(3):\n                v22 = c(v14, v21) * c(v18, 2 - v21)\n                for v23 in range(3):\n                    if v21 + v23 < 2:\n                        continue\n                    v24 = c(v15, v23) * c(v19, 2 - v23)\n                    v20 = (v20 + v22 * v24) % v1\n            v11 = (v11 + v20) % v1\n            v25 = v18 * c(v19, 2)\n            v26 = (v6 - v19) // 2\n            v27 = v19 * v7 - v9\n            v28 = v25 - v18 * v26 - v27\n            if v28 > 0:\n                v29 = c(v14, 1) * c(v15, 0) * v28 % v1\n                v11 = (v11 + v29) % v1\n            v30 = v19 * c(v18, 2)\n            v31 = (v5 - v18) // 2\n            v32 = v18 * v7 - v8\n            v33 = v30 - v19 * v31 - v32\n            if v33 > 0:\n                v29 = c(v14, 0) * c(v15, 1) * v33 % v1\n                v11 = (v11 + v29) % v1\n            v4[v13] += 1\n            v5 += v4[v13] * v4[v13]\n            v6 += v3[v13] * v3[v13]\n            v7 += v4[v13] * v3[v13]\n            v8 += v4[v13] * v4[v13] * v3[v13]\n            v9 += v4[v13] * v3[v13] * v3[v13]\n        return v11\n"}
{"id": "llm_code\\dinner-plate-stacks__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def __init__(self, a1):\n        self.plates = []\n        self.limit = a1\n        self.free_slots = []\n\n    def push(self, a1):\n        while self.free_slots and self.free_slots[0] >= len(self.plates):\n            heapq.heappop(self.free_slots)\n        if self.free_slots:\n            v1 = heapq.heappop(self.free_slots)\n            self.plates[v1].append(a1)\n        else:\n            if not self.plates or len(self.plates[-1]) == self.limit:\n                self.plates.append([])\n            self.plates[-1].append(a1)\n\n    def pop(self):\n        while self.plates and (not self.plates[-1]):\n            self.plates.pop()\n        return self.plates[-1].pop() if self.plates else -1\n\n    def popAtStack(self, a1):\n        if a1 >= len(self.plates) or not self.plates[a1]:\n            return -1\n        v1 = self.plates[a1].pop()\n        heapq.heappush(self.free_slots, a1)\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def __init__(self, a1):\n        self.plates = []\n        self.limit = a1\n        self.free_slots = []\n\n    def push(self, a1):\n        while self.free_slots and self.free_slots[0] >= len(self.plates):\n            heapq.heappop(self.free_slots)\n        if self.free_slots:\n            v1 = heapq.heappop(self.free_slots)\n            self.plates[v1].append(a1)\n        else:\n            if not self.plates or len(self.plates[-1]) == self.limit:\n                self.plates.append([])\n            self.plates[-1].append(a1)\n\n    def pop(self):\n        while self.plates and (not self.plates[-1]):\n            self.plates.pop()\n        return self.plates[-1].pop() if self.plates else -1\n\n    def popAtStack(self, a1):\n        if a1 >= len(self.plates) or not self.plates[a1]:\n            return -1\n        v1 = self.plates[a1].pop()\n        heapq.heappush(self.free_slots, a1)\n        return v1\n"}
{"id": "llm_code\\p02662__s982453259.py", "text": "class C1:\n\n    def __init__(a1, a2):\n        a1.MOD = a2\n\n    def modpow(a1, a2, a3):\n        v1 = 1\n        while a3 > 0:\n            if a3 & 1:\n                v1 = v1 * a2 % a1.MOD\n            a2 = a2 * a2 % a1.MOD\n            a3 >>= 1\n        return v1\n\n    def invx(a1, a2):\n        return a1.modpow(a2, a1.MOD - 2)\n\n    def invpowL(a1, a2, a3):\n        v1 = a1.invx(a2)\n        v2 = [1] * (a3 + 1)\n        for v3 in range(1, a3 + 1):\n            v2[v3] = v2[v3 - 1] * v1 % a1.MOD\n        return v2\n\n    def invL(a1, a2):\n        v1 = [0, 1]\n        for v2 in range(2, a2 + 1):\n            v1.append(a1.MOD - v1[a1.MOD % v2] * (a1.MOD // v2) % a1.MOD)\n        return v1\nv1, v2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = 998244353\nv5 = [[0] * (v2 + 1) for v6 in range(v1 + 1)]\nv7 = C1(v4)\nv8 = v7.invx(2)\nv9 = v7.modpow(2, v1 - 1)\nfor v10 in range(1, v1 + 1):\n    v11 = v3[v10 - 1]\n    if v11 > v2:\n        for v12 in range(v2 + 1):\n            v5[v10][v12] = v5[v10 - 1][v12]\n    for v12 in range(v11):\n        v5[v10][v12] = v5[v10 - 1][v12]\n    v5[v10][v11] = (v5[v10 - 1][v11] + v9) % v4\n    for v12 in range(v11 + 1, v2 + 1):\n        v5[v10][v12] = (v5[v10 - 1][v12] + v5[v10 - 1][v12 - v11] * v8) % v4\nfor v10 in v5:\n    print(v10)\nprint(v5[-1][v2])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "class C1:\n\n    def __init__(a1, a2):\n        a1.MOD = a2\n\n    def modpow(a1, a2, a3):\n        v1 = 1\n        while a3 > 0:\n            if a3 & 1:\n                v1 = v1 * a2 % a1.MOD\n            a2 = a2 * a2 % a1.MOD\n            a3 >>= 1\n        return v1\n\n    def invx(a1, a2):\n        return a1.modpow(a2, a1.MOD - 2)\n\n    def invpowL(a1, a2, a3):\n        v1 = a1.invx(a2)\n        v2 = [1] * (a3 + 1)\n        for v3 in range(1, a3 + 1):\n            v2[v3] = v2[v3 - 1] * v1 % a1.MOD\n        return v2\n\n    def invL(a1, a2):\n        v1 = [0, 1]\n        for v2 in range(2, a2 + 1):\n            v1.append(a1.MOD - v1[a1.MOD % v2] * (a1.MOD // v2) % a1.MOD)\n        return v1\nv1, v2 = list(map(int, input().split()))\nv3 = list(map(int, input().split()))\nv4 = 998244353\nv5 = [[0] * (v2 + 1) for v6 in range(v1 + 1)]\nv7 = C1(v4)\nv8 = v7.invx(2)\nv9 = v7.modpow(2, v1 - 1)\nfor v10 in range(1, v1 + 1):\n    v11 = v3[v10 - 1]\n    if v11 > v2:\n        for v12 in range(v2 + 1):\n            v5[v10][v12] = v5[v10 - 1][v12]\n    for v12 in range(v11):\n        v5[v10][v12] = v5[v10 - 1][v12]\n    v5[v10][v11] = (v5[v10 - 1][v11] + v9) % v4\n    for v12 in range(v11 + 1, v2 + 1):\n        v5[v10][v12] = (v5[v10 - 1][v12] + v5[v10 - 1][v12 - v11] * v8) % v4\nfor v10 in v5:\n    print(v10)\nprint(v5[-1][v2])\n"}
{"id": "human_code\\course-schedule__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def canFinish(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        v2 = collections.Counter()\n        for v3, v4 in a2:\n            v2[v3] += 1\n            v1[v4].append(v3)\n        v5 = []\n        v6 = [v3 for v3 in range(a1) if v3 not in v2]\n        while v6:\n            v3 = v6.pop()\n            v5.append(v3)\n            for v4 in v1[v3]:\n                v2[v4] -= 1\n                if v2[v4] == 0:\n                    v6.append(v4)\n        return len(v5) == a1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def canFinish(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        v2 = collections.Counter()\n        for v3, v4 in a2:\n            v2[v3] += 1\n            v1[v4].append(v3)\n        v5 = []\n        v6 = [v3 for v3 in range(a1) if v3 not in v2]\n        while v6:\n            v3 = v6.pop()\n            v5.append(v3)\n            for v4 in v1[v3]:\n                v2[v4] -= 1\n                if v2[v4] == 0:\n                    v6.append(v4)\n        return len(v5) == a1\n"}
{"id": "human_code\\find-if-path-exists-in-graph__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def validPath(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def bi_bfs(a1, a2, a3):\n            v1, v2 = ({a2}, {a3})\n            v3 = set()\n            v4 = 0\n            while v1:\n                for v5 in v1:\n                    v3.add(v5)\n                v6 = set()\n                for v5 in v1:\n                    if v5 in v2:\n                        return v4\n                    for v7 in a1[v5]:\n                        if v7 in v3:\n                            continue\n                        v6.add(v7)\n                v1 = v6\n                v4 += 1\n                if len(v1) > len(v2):\n                    v1, v2 = (v2, v1)\n            return -1\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        return bi_bfs(v1, a3, a4) >= 0\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def validPath(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n\n        def bi_bfs(a1, a2, a3):\n            v1, v2 = ({a2}, {a3})\n            v3 = set()\n            v4 = 0\n            while v1:\n                for v5 in v1:\n                    v3.add(v5)\n                v6 = set()\n                for v5 in v1:\n                    if v5 in v2:\n                        return v4\n                    for v7 in a1[v5]:\n                        if v7 in v3:\n                            continue\n                        v6.add(v7)\n                v1 = v6\n                v4 += 1\n                if len(v1) > len(v2):\n                    v1, v2 = (v2, v1)\n            return -1\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        return bi_bfs(v1, a3, a4) >= 0\n"}
{"id": "llm_code\\p03230__s835916815.py", "text": "v1 = int(input())\nv2 = (v1 - 2) ** 0.5\nif v1 == 3:\n    print('Yes')\n    v3 = [2, 1, 2]\n    print(*v3)\n    v3 = [2, 2, 3]\n    print(*v3)\n    v3 = [2, 3, 1]\n    print(*v3)\n    exit()\nif v2 % 1 != 0:\n    print('No')\n    exit()\nv2 = int(v2)\nv4 = []\nfor v5 in range(v2):\n    v6 = [1] + [2 + j + v2 * v5 for v7 in range(v2)]\n    v4.append(v6)\nfor v5 in range(v2):\n    v6 = [2 + v5 + v2 * v7 for v7 in range(v2)] + [v1]\n    v4.append(v6)\nprint('Yes')\nfor v8 in v4:\n    v9 = [len(v8)] + v8\n    print(*v9)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = (v1 - 2) ** 0.5\nif v1 == 3:\n    print('Yes')\n    v3 = [2, 1, 2]\n    print(*v3)\n    v3 = [2, 2, 3]\n    print(*v3)\n    v3 = [2, 3, 1]\n    print(*v3)\n    exit()\nif v2 % 1 != 0:\n    print('No')\n    exit()\nv2 = int(v2)\nv4 = []\nfor v5 in range(v2):\n    v6 = [1] + [2 + j + v2 * v5 for v7 in range(v2)]\n    v4.append(v6)\nfor v5 in range(v2):\n    v6 = [2 + v5 + v2 * v7 for v7 in range(v2)] + [v1]\n    v4.append(v6)\nprint('Yes')\nfor v8 in v4:\n    v9 = [len(v8)] + v8\n    print(*v9)\n"}
{"id": "llm_code\\once-twice__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def onceTwice(self, a1):\n        v1, v2 = (0, 0)\n        for v3 in a1:\n            v2 |= v1 & v3\n            v1 ^= v3\n            v4 = v1 & v2\n            v1 &= ~v4\n            v2 &= ~v4\n        v5, v6 = (0, 0)\n        for v3 in a1:\n            if v3 & v1 != v1 or v3 & v2:\n                continue\n            v6 |= v5 & v3\n            v5 ^= v3\n            v7 = v5 & v6\n            v5 &= ~v7\n            v6 &= ~v7\n        v8 = v5 ^ v1 | v2\n        return [v5, v8]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def onceTwice(self, a1):\n        v1, v2 = (0, 0)\n        for v3 in a1:\n            v2 |= v1 & v3\n            v1 ^= v3\n            v4 = v1 & v2\n            v1 &= ~v4\n            v2 &= ~v4\n        v5, v6 = (0, 0)\n        for v3 in a1:\n            if v3 & v1 != v1 or v3 & v2:\n                continue\n            v6 |= v5 & v3\n            v5 ^= v3\n            v7 = v5 & v6\n            v5 &= ~v7\n            v6 &= ~v7\n        v8 = v5 ^ v1 | v2\n        return [v5, v8]\n"}
{"id": "human_code\\maximal-square__part3.py", "text": "class C1(object):\n\n    def maximalSquare(self, a1):\n        if not a1:\n            return 0\n        v1, v2 = (0, 1)\n        v3 = [[[0, 0] for v4 in range(len(a1[0]))] for v5 in range(len(a1))]\n        for v5 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[v5]))):\n                if a1[v5][v4] == '1':\n                    v6, v7 = (1, 1)\n                    if v5 + 1 < len(a1):\n                        v6 = v3[v5 + 1][v4][v1] + 1\n                    if v4 + 1 < len(a1[v5]):\n                        v7 = v3[v5][v4 + 1][v2] + 1\n                    v3[v5][v4] = [v6, v7]\n        v8 = [[0 for v4 in range(len(a1[0]))] for v5 in range(len(a1))]\n        v9 = 0\n        for v5 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[v5]))):\n                v10 = min(v3[v5][v4][v1], v3[v5][v4][v2])\n                if a1[v5][v4] == '1':\n                    if v5 + 1 < len(a1) and v4 + 1 < len(a1[v5 + 1]):\n                        v10 = min(v8[v5 + 1][v4 + 1] + 1, v10)\n                    v8[v5][v4] = v10\n                    v9 = max(v9, v10 * v10)\n        return v9\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximalSquare(self, a1):\n        if not a1:\n            return 0\n        v1, v2 = (0, 1)\n        v3 = [[[0, 0] for v4 in range(len(a1[0]))] for v5 in range(len(a1))]\n        for v5 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[v5]))):\n                if a1[v5][v4] == '1':\n                    v6, v7 = (1, 1)\n                    if v5 + 1 < len(a1):\n                        v6 = v3[v5 + 1][v4][v1] + 1\n                    if v4 + 1 < len(a1[v5]):\n                        v7 = v3[v5][v4 + 1][v2] + 1\n                    v3[v5][v4] = [v6, v7]\n        v8 = [[0 for v4 in range(len(a1[0]))] for v5 in range(len(a1))]\n        v9 = 0\n        for v5 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[v5]))):\n                v10 = min(v3[v5][v4][v1], v3[v5][v4][v2])\n                if a1[v5][v4] == '1':\n                    if v5 + 1 < len(a1) and v4 + 1 < len(a1[v5 + 1]):\n                        v10 = min(v8[v5 + 1][v4 + 1] + 1, v10)\n                    v8[v5][v4] = v10\n                    v9 = max(v9, v10 * v10)\n        return v9\n"}
{"id": "human_code\\p02580__s710705564.py", "text": "from collections import Counter\nv1, v2, v3 = map(int, input().split())\nv4 = [tuple(map(int, input().split())) for v5 in range(v3)]\nv6 = set(v4)\nv7 = Counter()\nv8 = Counter()\nfor v9, v10 in v4:\n    v8[v9] += 1\n    v7[v10] += 1\nv11 = 0\nfor v9, v10 in v4:\n    v11 = max(v11, v8[v9] + v7[v10] - 1)\nv12 = v7.most_common()\nv13 = v8.most_common()\nv14 = v12[0][1]\nv15 = v13[0][1]\nfor v16, v17 in v12:\n    if v17 < v14:\n        break\n    for v18, v19 in v13:\n        if v19 < v15:\n            break\n        if (v18, v16) in v6:\n            continue\n        v11 = max(v11, v19 + v17)\n        break\nprint(v11)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from collections import Counter\nv1, v2, v3 = map(int, input().split())\nv4 = [tuple(map(int, input().split())) for v5 in range(v3)]\nv6 = set(v4)\nv7 = Counter()\nv8 = Counter()\nfor v9, v10 in v4:\n    v8[v9] += 1\n    v7[v10] += 1\nv11 = 0\nfor v9, v10 in v4:\n    v11 = max(v11, v8[v9] + v7[v10] - 1)\nv12 = v7.most_common()\nv13 = v8.most_common()\nv14 = v12[0][1]\nv15 = v13[0][1]\nfor v16, v17 in v12:\n    if v17 < v14:\n        break\n    for v18, v19 in v13:\n        if v19 < v15:\n            break\n        if (v18, v16) in v6:\n            continue\n        v11 = max(v11, v19 + v17)\n        break\nprint(v11)\n"}
{"id": "human_code\\find-the-number-of-subsequences-with-equal-gcd__part3.py", "text": "import collections\n\nclass C1(object):\n\n    def subsequencePairCount(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n        v2 = max(a1)\n        v3 = [[0] * (v2 + 1) for v4 in range(v2 + 1)]\n        v3[0][0] = 1\n        for v5 in a1:\n            v6 = [row[:] for v7 in v3]\n            for v8 in reversed(range(v2 + 1)):\n                for v9 in reversed(range(v2 + 1)):\n                    v10, v11 = (gcd(v8, v5), gcd(v9, v5))\n                    v6[v10][v9] = (v6[v10][v9] + v3[v8][v9]) % v1\n                    v6[v8][v11] = (v6[v8][v11] + v3[v8][v9]) % v1\n            v3 = v6\n        return reduce(lambda accu, x: (accu + v5) % v1, (v3[g][g] for v12 in range(1, v2 + 1)), 0)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def subsequencePairCount(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n        v2 = max(a1)\n        v3 = [[0] * (v2 + 1) for v4 in range(v2 + 1)]\n        v3[0][0] = 1\n        for v5 in a1:\n            v6 = [row[:] for v7 in v3]\n            for v8 in reversed(range(v2 + 1)):\n                for v9 in reversed(range(v2 + 1)):\n                    v10, v11 = (gcd(v8, v5), gcd(v9, v5))\n                    v6[v10][v9] = (v6[v10][v9] + v3[v8][v9]) % v1\n                    v6[v8][v11] = (v6[v8][v11] + v3[v8][v9]) % v1\n            v3 = v6\n        return reduce(lambda accu, x: (accu + v5) % v1, (v3[g][g] for v12 in range(1, v2 + 1)), 0)\n"}
{"id": "human_code\\maximum-total-beauty-of-the-gardens__part3.py", "text": "import bisect\n\nclass C1(object):\n\n    def maximumBeauty(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            return a3 and (a2 + a1[a3]) // a3 <= a1[a3 + 1] - a1[a3]\n\n        def binary_search(a1, a2, a3, a4):\n            while a3 <= a4:\n                v1 = a3 + (a4 - a3) // 2\n                if check(a1, a2, v1):\n                    a4 = v1 - 1\n                else:\n                    a3 = v1 + 1\n            return a3\n        a1.sort()\n        v1 = bisect.bisect_left(a1, a3)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n        v4 = sum((a1[v3] for v3 in range(v1)))\n        v5 = v6 = 0\n        for v7 in range(v1 + 1):\n            if v7:\n                v4 -= a1[v7 - 1]\n            v8 = a2 - ((v1 - v7) * a3 - v4)\n            if v8 < 0:\n                continue\n            v6 = binary_search(v2, v8, 0, v7 - 1)\n            v9 = min((v8 + v2[v6]) // v6 if v6 else 0, a3 - 1)\n            v5 = max(v5, v9 * a5 + (len(a1) - v7) * a4)\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def maximumBeauty(self, a1, a2, a3, a4, a5):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            return a3 and (a2 + a1[a3]) // a3 <= a1[a3 + 1] - a1[a3]\n\n        def binary_search(a1, a2, a3, a4):\n            while a3 <= a4:\n                v1 = a3 + (a4 - a3) // 2\n                if check(a1, a2, v1):\n                    a4 = v1 - 1\n                else:\n                    a3 = v1 + 1\n            return a3\n        a1.sort()\n        v1 = bisect.bisect_left(a1, a3)\n        v2 = [0] * (v1 + 1)\n        for v3 in range(v1):\n            v2[v3 + 1] = v2[v3] + a1[v3]\n        v4 = sum((a1[v3] for v3 in range(v1)))\n        v5 = v6 = 0\n        for v7 in range(v1 + 1):\n            if v7:\n                v4 -= a1[v7 - 1]\n            v8 = a2 - ((v1 - v7) * a3 - v4)\n            if v8 < 0:\n                continue\n            v6 = binary_search(v2, v8, 0, v7 - 1)\n            v9 = min((v8 + v2[v6]) // v6 if v6 else 0, a3 - 1)\n            v5 = max(v5, v9 * a5 + (len(a1) - v7) * a4)\n        return v5\n"}
{"id": "llm_code\\make-array-strictly-increasing__grok-4.1-fast__v1.py", "text": "import bisect\n\nclass C1(object):\n\n    def makeArrayIncreasing(self, a1, a2):\n        v1 = sorted(set(a2))\n        v2 = len(a1)\n        v3 = 10 ** 18 + 42\n        v4 = [-1] + [v3] * v2\n        for v5 in a1:\n            v6 = [v3] * (v2 + 1)\n            for v7 in range(v2 + 1):\n                v8 = v4[v7]\n                if v8 == v3:\n                    continue\n                if v8 < v5:\n                    v6[v7] = min(v6[v7], v5)\n                v9 = bisect.bisect_right(v1, v8)\n                if v9 < len(v1):\n                    v10 = v7 + 1\n                    if v10 <= v2:\n                        v6[v10] = min(v6[v10], v1[v9])\n            if all((e == v3 for v11 in v6)):\n                return -1\n            v4 = v6\n        for v7 in range(v2 + 1):\n            if v4[v7] != v3:\n                return v7\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def makeArrayIncreasing(self, a1, a2):\n        v1 = sorted(set(a2))\n        v2 = len(a1)\n        v3 = 10 ** 18 + 42\n        v4 = [-1] + [v3] * v2\n        for v5 in a1:\n            v6 = [v3] * (v2 + 1)\n            for v7 in range(v2 + 1):\n                v8 = v4[v7]\n                if v8 == v3:\n                    continue\n                if v8 < v5:\n                    v6[v7] = min(v6[v7], v5)\n                v9 = bisect.bisect_right(v1, v8)\n                if v9 < len(v1):\n                    v10 = v7 + 1\n                    if v10 <= v2:\n                        v6[v10] = min(v6[v10], v1[v9])\n            if all((e == v3 for v11 in v6)):\n                return -1\n            v4 = v6\n        for v7 in range(v2 + 1):\n            if v4[v7] != v3:\n                return v7\n        return -1\n"}
{"id": "human_code\\p03221__s853711307.py", "text": "from operator import itemgetter\nv1, v2 = map(int, input().split())\nv3 = [list(map(int, input().split())) + [i] for v4 in range(v2)]\nv3.sort(key=itemgetter(1))\nv3.sort(key=itemgetter(0))\nv5 = 0\nv6 = 0\nv7 = 1\nwhile v6 < v2:\n    if v3[v6][0] == v5:\n        v3[v6][1] = v7\n        v7 += 1\n        v6 += 1\n    else:\n        v5 += 1\n        v7 = 1\n        continue\nv3.sort(key=itemgetter(2))\nfor v4 in range(v2):\n    print(str(v3[v4][0]).zfill(6) + str(v3[v4][1]).zfill(6))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from operator import itemgetter\nv1, v2 = map(int, input().split())\nv3 = [list(map(int, input().split())) + [i] for v4 in range(v2)]\nv3.sort(key=itemgetter(1))\nv3.sort(key=itemgetter(0))\nv5 = 0\nv6 = 0\nv7 = 1\nwhile v6 < v2:\n    if v3[v6][0] == v5:\n        v3[v6][1] = v7\n        v7 += 1\n        v6 += 1\n    else:\n        v5 += 1\n        v7 = 1\n        continue\nv3.sort(key=itemgetter(2))\nfor v4 in range(v2):\n    print(str(v3[v4][0]).zfill(6) + str(v3[v4][1]).zfill(6))\n"}
{"id": "human_code\\check-if-dfs-strings-are-palindromes__part1.py", "text": "class C1(object):\n\n    def findAnswer(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def manacher(a1):\n            a1 = '^#' + '#'.join(a1) + '#$'\n            v2 = [0] * len(a1)\n            v3, v4 = (0, 0)\n            for v5 in range(1, len(a1) - 1):\n                v6 = 2 * v3 - v5\n                if v4 > v5:\n                    v2[v5] = min(v4 - v5, v2[v6])\n                while a1[v5 + 1 + v2[v5]] == a1[v5 - 1 - v2[v5]]:\n                    v2[v5] += 1\n                if v5 + v2[v5] > v4:\n                    v3, v4 = (v5, v5 + v2[v5])\n            return v2\n\n        def iter_dfs(a1):\n            v1 = 0\n            v2 = []\n            v3 = [None] * len(adj)\n            v4 = [(1, (0,))]\n            while v4:\n                v5, v6 = v4.pop()\n                if v5 == 1:\n                    a1 = v6[0]\n                    v4.append((2, (a1, v1)))\n                    for v8 in reversed(adj[a1]):\n                        v4.append((1, (v8,)))\n                elif v5 == 2:\n                    a1, v9 = v6\n                    v2.append(a2[a1])\n                    v3[a1] = (v9, v1)\n                    v1 += 1\n            return (v2, v3)\n        v1 = [[] for v2 in range(len(a1))]\n        for v3 in range(1, len(a1)):\n            v1[a1[v3]].append(v3)\n        v4, v5 = iter_dfs(0)\n        v6 = manacher(v4)\n        return [v6[(2 * (left + 1) + 2 * (right + 1)) // 2] >= right - left + 1 for v7, v8 in v5]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findAnswer(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def manacher(a1):\n            a1 = '^#' + '#'.join(a1) + '#$'\n            v2 = [0] * len(a1)\n            v3, v4 = (0, 0)\n            for v5 in range(1, len(a1) - 1):\n                v6 = 2 * v3 - v5\n                if v4 > v5:\n                    v2[v5] = min(v4 - v5, v2[v6])\n                while a1[v5 + 1 + v2[v5]] == a1[v5 - 1 - v2[v5]]:\n                    v2[v5] += 1\n                if v5 + v2[v5] > v4:\n                    v3, v4 = (v5, v5 + v2[v5])\n            return v2\n\n        def iter_dfs(a1):\n            v1 = 0\n            v2 = []\n            v3 = [None] * len(adj)\n            v4 = [(1, (0,))]\n            while v4:\n                v5, v6 = v4.pop()\n                if v5 == 1:\n                    a1 = v6[0]\n                    v4.append((2, (a1, v1)))\n                    for v8 in reversed(adj[a1]):\n                        v4.append((1, (v8,)))\n                elif v5 == 2:\n                    a1, v9 = v6\n                    v2.append(a2[a1])\n                    v3[a1] = (v9, v1)\n                    v1 += 1\n            return (v2, v3)\n        v1 = [[] for v2 in range(len(a1))]\n        for v3 in range(1, len(a1)):\n            v1[a1[v3]].append(v3)\n        v4, v5 = iter_dfs(0)\n        v6 = manacher(v4)\n        return [v6[(2 * (left + 1) + 2 * (right + 1)) // 2] >= right - left + 1 for v7, v8 in v5]\n"}
{"id": "human_code\\design-an-expression-tree-with-evaluate-function__part1.py", "text": "import abc\nfrom abc import ABCMeta, abstractmethod\n\nclass C1(metaclass=ABCMeta):\n\n    @abstractmethod\n    def evaluate(self):\n        pass\nimport operator\n\nclass C2(C1):\n    v1 = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.div}\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\n    def evaluate(self):\n        v1 = [0]\n        v2 = [(1, (self, v1))]\n        while v2:\n            v3, v4 = v2.pop()\n            if v3 == 1:\n                v5, v6 = v4\n                if v5.val.isdigit():\n                    v6[0] = int(v5.val)\n                    continue\n                v7, v8 = ([0], [0])\n                v2.append((2, (v5, v7, v8, v6)))\n                v2.append((1, (v5.right, v8)))\n                v2.append((1, (v5.left, v7)))\n            elif v3 == 2:\n                v5, v7, v8, v6 = v4\n                v6[0] = C2.ops[v5.val](v7[0], v8[0])\n        return v1[0]\n\nclass C3(object):\n\n    def buildTree(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        for v2 in a1:\n            if v2.isdigit():\n                v1.append(C2(v2))\n            else:\n                v3 = C2(v2)\n                v3.right = v1.pop()\n                v3.left = v1.pop()\n                v1.append(v3)\n        return v1.pop()\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import abc\nfrom abc import ABCMeta, abstractmethod\n\nclass C1(metaclass=ABCMeta):\n\n    @abstractmethod\n    def evaluate(self):\n        pass\nimport operator\n\nclass C2(C1):\n    v1 = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.div}\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\n    def evaluate(self):\n        v1 = [0]\n        v2 = [(1, (self, v1))]\n        while v2:\n            v3, v4 = v2.pop()\n            if v3 == 1:\n                v5, v6 = v4\n                if v5.val.isdigit():\n                    v6[0] = int(v5.val)\n                    continue\n                v7, v8 = ([0], [0])\n                v2.append((2, (v5, v7, v8, v6)))\n                v2.append((1, (v5.right, v8)))\n                v2.append((1, (v5.left, v7)))\n            elif v3 == 2:\n                v5, v7, v8, v6 = v4\n                v6[0] = C2.ops[v5.val](v7[0], v8[0])\n        return v1[0]\n\nclass C3(object):\n\n    def buildTree(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        for v2 in a1:\n            if v2.isdigit():\n                v1.append(C2(v2))\n            else:\n                v3 = C2(v2)\n                v3.right = v1.pop()\n                v3.left = v1.pop()\n                v1.append(v3)\n        return v1.pop()\n"}
{"id": "human_code\\p02963__s720701452.py", "text": "import sys\nv1 = sys.stdin.buffer.read\nv2 = sys.stdin.buffer.readline\nv3 = sys.stdin.buffer.readlines\nsys.setrecursionlimit(500000)\nv4 = 1000000007\n\ndef f1(a1, a2):\n    if a1 > a2:\n        return a1\n    else:\n        return a2\n\ndef f2(a1, a2):\n    if a1 < a2:\n        return a1\n    else:\n        return a2\n\ndef f3():\n    v1 = int(v2())\n    if v1 != 10 ** 18:\n        v2 = v1 % 1000000000\n        v3 = v1 // 1000000000\n        v4 = 1000000000\n        v5 = v3\n        v6 = v2\n        v7 = -1\n        print(0, 1, v4, 1 + v7, v6, 1 + v5)\n    else:\n        print(0, 0, 1000000000, 0, 0, 1000000000)\nif __name__ == '__main__':\n    f3()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1 = sys.stdin.buffer.read\nv2 = sys.stdin.buffer.readline\nv3 = sys.stdin.buffer.readlines\nsys.setrecursionlimit(500000)\nv4 = 1000000007\n\ndef f1(a1, a2):\n    if a1 > a2:\n        return a1\n    else:\n        return a2\n\ndef f2(a1, a2):\n    if a1 < a2:\n        return a1\n    else:\n        return a2\n\ndef f3():\n    v1 = int(v2())\n    if v1 != 10 ** 18:\n        v2 = v1 % 1000000000\n        v3 = v1 // 1000000000\n        v4 = 1000000000\n        v5 = v3\n        v6 = v2\n        v7 = -1\n        print(0, 1, v4, 1 + v7, v6, 1 + v5)\n    else:\n        print(0, 0, 1000000000, 0, 0, 1000000000)\nif __name__ == '__main__':\n    f3()\n"}
{"id": "human_code\\find-positive-integer-solution-for-a-given-equation.py", "text": "\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n  \n\"\"\"\n\nclass C1(object):\n\n    def findSolution(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        v2, v3 = (1, 1)\n        while a1.f(v2, v3) < a2:\n            v3 += 1\n        while v3 > 0:\n            while v3 > 0 and a1.f(v2, v3) > a2:\n                v3 -= 1\n            if v3 > 0 and a1.f(v2, v3) == a2:\n                v1.append([v2, v3])\n            v2 += 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n  \n\"\"\"\n\nclass C1(object):\n\n    def findSolution(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        v2, v3 = (1, 1)\n        while a1.f(v2, v3) < a2:\n            v3 += 1\n        while v3 > 0:\n            while v3 > 0 and a1.f(v2, v3) > a2:\n                v3 -= 1\n            if v3 > 0 and a1.f(v2, v3) == a2:\n                v1.append([v2, v3])\n            v2 += 1\n        return v1\n"}
{"id": "llm_code\\maximum-number-of-integers-to-choose-from-a-range-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxCount(self, a1, a2, a3):\n        v1 = sorted((b for v2 in set(a1) if 1 <= v2 <= a2))\n\n        def compute_sum_count(a1):\n            v1 = 0\n            v2 = 0\n            for v3 in v1:\n                if v3 > a1:\n                    break\n                v1 += v3\n                v2 += 1\n            v4 = a1 * (a1 + 1) // 2\n            return (v4 - v1, a1 - v2)\n        v3 = 0\n        v4 = a2\n        while v3 < v4:\n            v5 = (v3 + v4 + 1) // 2\n            v6, v7 = compute_sum_count(v5)\n            if v6 <= a3:\n                v3 = v5\n            else:\n                v4 = v5 - 1\n        v7, v8 = compute_sum_count(v3)\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxCount(self, a1, a2, a3):\n        v1 = sorted((b for v2 in set(a1) if 1 <= v2 <= a2))\n\n        def compute_sum_count(a1):\n            v1 = 0\n            v2 = 0\n            for v3 in v1:\n                if v3 > a1:\n                    break\n                v1 += v3\n                v2 += 1\n            v4 = a1 * (a1 + 1) // 2\n            return (v4 - v1, a1 - v2)\n        v3 = 0\n        v4 = a2\n        while v3 < v4:\n            v5 = (v3 + v4 + 1) // 2\n            v6, v7 = compute_sum_count(v5)\n            if v6 <= a3:\n                v3 = v5\n            else:\n                v4 = v5 - 1\n        v7, v8 = compute_sum_count(v3)\n        return v8\n"}
{"id": "llm_code\\p03013__s126584106.py", "text": "v1 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    v1 = [[0, 0], [0, 0]]\n    v1[0][0] = (a1[0][0] * a2[0][0] + a1[0][1] * a2[1][0]) % v1\n    v1[0][1] = (a1[0][0] * a2[0][1] + a1[0][1] * a2[1][1]) % v1\n    v1[1][0] = (a1[1][0] * a2[0][0] + a1[1][1] * a2[1][0]) % v1\n    v1[1][1] = (a1[1][0] * a2[0][1] + a1[1][1] * a2[1][1]) % v1\n    return v1\nv2 = [[1, 1], [1, 0]]\nv3 = [v2]\nfor v4 in range(20):\n    v3.append(f1(v3[-1], v3[-1]))\nv5, v6 = map(int, input().split())\nv7 = 0\nv8 = 1\nfor v4 in range(v6):\n    v9 = int(input())\n    if v7 == v9:\n        print(0)\n        break\n    else:\n        v10 = bin(v9 - 1 - v7)[2:]\n        v10 = '0' * (21 - len(v10)) + v10\n        v10 = v10[::-1]\n        v11 = [[1, 0], [0, 1]]\n        for v12 in range(21):\n            if v10[v12] == '1':\n                v11 = f1(v11, v3[v12])\n        v8 = v8 * v11[0][0] % v1\n        v7 = v9 + 1\n        if v4 == v6 - 1:\n            v10 = bin(v5 - v7)[2:]\n            v10 = '0' * (21 - len(v10)) + v10\n            v10 = v10[::-1]\n            v11 = [[1, 0], [0, 1]]\n            for v12 in range(21):\n                if v10[v12] == '1':\n                    v11 = f1(v11, v3[v12])\n            v8 = v8 * v11[0][0] % v1\nelse:\n    print(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = 10 ** 9 + 7\n\ndef f1(a1, a2):\n    v1 = [[0, 0], [0, 0]]\n    v1[0][0] = (a1[0][0] * a2[0][0] + a1[0][1] * a2[1][0]) % v1\n    v1[0][1] = (a1[0][0] * a2[0][1] + a1[0][1] * a2[1][1]) % v1\n    v1[1][0] = (a1[1][0] * a2[0][0] + a1[1][1] * a2[1][0]) % v1\n    v1[1][1] = (a1[1][0] * a2[0][1] + a1[1][1] * a2[1][1]) % v1\n    return v1\nv2 = [[1, 1], [1, 0]]\nv3 = [v2]\nfor v4 in range(20):\n    v3.append(f1(v3[-1], v3[-1]))\nv5, v6 = map(int, input().split())\nv7 = 0\nv8 = 1\nfor v4 in range(v6):\n    v9 = int(input())\n    if v7 == v9:\n        print(0)\n        break\n    else:\n        v10 = bin(v9 - 1 - v7)[2:]\n        v10 = '0' * (21 - len(v10)) + v10\n        v10 = v10[::-1]\n        v11 = [[1, 0], [0, 1]]\n        for v12 in range(21):\n            if v10[v12] == '1':\n                v11 = f1(v11, v3[v12])\n        v8 = v8 * v11[0][0] % v1\n        v7 = v9 + 1\n        if v4 == v6 - 1:\n            v10 = bin(v5 - v7)[2:]\n            v10 = '0' * (21 - len(v10)) + v10\n            v10 = v10[::-1]\n            v11 = [[1, 0], [0, 1]]\n            for v12 in range(21):\n                if v10[v12] == '1':\n                    v11 = f1(v11, v3[v12])\n            v8 = v8 * v11[0][0] % v1\nelse:\n    print(v8)\n"}
{"id": "human_code\\p03504__s076337353.py", "text": "v1, v2 = map(int, input().split())\nv3 = 10 ** 5\nv4 = [[0] * (v3 + 1) for v5 in range(v2 + 1)]\nv6 = []\nfor v5 in range(v1):\n    v6.append(list(map(int, input().split())))\nv6 = sorted(v6, key=lambda x: x[0])\nv6 = sorted(v6, key=lambda x: x[2])\nfor v7 in range(v1):\n    v8, v9, v10 = (v6[v7][0], v6[v7][1], v6[v7][2])\n    try:\n        if v6[v7 - 1][2] == v10 and v6[v7 - 1][1] == v8:\n            v4[v10][v8 + 1] += 1\n        else:\n            v4[v10][v8] += 1\n    except IndexError:\n        v4[v10][v8] += 1\n    if v9 + 1 <= v3:\n        v4[v10][v9 + 1] -= 1\nfor v10 in range(v2 + 1):\n    for v7 in range(1, v3 + 1):\n        v4[v10][v7] += v4[v10][v7 - 1]\nimport numpy as np\nprint(np.max(np.sum(v4, axis=0)))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = 10 ** 5\nv4 = [[0] * (v3 + 1) for v5 in range(v2 + 1)]\nv6 = []\nfor v5 in range(v1):\n    v6.append(list(map(int, input().split())))\nv6 = sorted(v6, key=lambda x: x[0])\nv6 = sorted(v6, key=lambda x: x[2])\nfor v7 in range(v1):\n    v8, v9, v10 = (v6[v7][0], v6[v7][1], v6[v7][2])\n    try:\n        if v6[v7 - 1][2] == v10 and v6[v7 - 1][1] == v8:\n            v4[v10][v8 + 1] += 1\n        else:\n            v4[v10][v8] += 1\n    except IndexError:\n        v4[v10][v8] += 1\n    if v9 + 1 <= v3:\n        v4[v10][v9 + 1] -= 1\nfor v10 in range(v2 + 1):\n    for v7 in range(1, v3 + 1):\n        v4[v10][v7] += v4[v10][v7 - 1]\nimport numpy as np\nprint(np.max(np.sum(v4, axis=0)))\n"}
{"id": "human_code\\find-minimum-diameter-after-merging-two-trees__part1.py", "text": "class C1(object):\n\n    def minimumDiameterAfterMerge(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def ceil_divide(a1, a2):\n            return (a1 + a2 - 1) // 2\n\n        def tree_diameter(a1):\n\n            def iter_dfs():\n                v1 = 0\n                v2 = [(1, (0, -1, [0]))]\n                while v2:\n                    v3, v4 = v2.pop()\n                    if v3 == 1:\n                        v5, v6, v7 = v4\n                        for v8 in reversed(adj[v5]):\n                            if v8 == v6:\n                                continue\n                            v9 = [0]\n                            v2.append((2, (v9, v7)))\n                            v2.append((1, (v8, v5, v9)))\n                    elif v3 == 2:\n                        v9, v7 = v4\n                        v1 = max(v1, v7[0] + (v9[0] + 1))\n                        v7[0] = max(v7[0], v9[0] + 1)\n                return v1\n            v1 = [[] for v2 in range(len(a1) + 1)]\n            for v3, v4 in a1:\n                v1[v3].append(v4)\n                v1[v4].append(v3)\n            return iter_dfs()\n        v1 = tree_diameter(a1)\n        v2 = tree_diameter(a2)\n        return max(ceil_divide(v1, 2) + 1 + ceil_divide(v2, 2), v1, v2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumDiameterAfterMerge(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def ceil_divide(a1, a2):\n            return (a1 + a2 - 1) // 2\n\n        def tree_diameter(a1):\n\n            def iter_dfs():\n                v1 = 0\n                v2 = [(1, (0, -1, [0]))]\n                while v2:\n                    v3, v4 = v2.pop()\n                    if v3 == 1:\n                        v5, v6, v7 = v4\n                        for v8 in reversed(adj[v5]):\n                            if v8 == v6:\n                                continue\n                            v9 = [0]\n                            v2.append((2, (v9, v7)))\n                            v2.append((1, (v8, v5, v9)))\n                    elif v3 == 2:\n                        v9, v7 = v4\n                        v1 = max(v1, v7[0] + (v9[0] + 1))\n                        v7[0] = max(v7[0], v9[0] + 1)\n                return v1\n            v1 = [[] for v2 in range(len(a1) + 1)]\n            for v3, v4 in a1:\n                v1[v3].append(v4)\n                v1[v4].append(v3)\n            return iter_dfs()\n        v1 = tree_diameter(a1)\n        v2 = tree_diameter(a2)\n        return max(ceil_divide(v1, 2) + 1 + ceil_divide(v2, 2), v1, v2)\n"}
{"id": "human_code\\p03372__s980518099.py", "text": "def f1():\n    from collections import namedtuple\n    import sys\n    input = sys.stdin.readline\n    v1 = namedtuple('Sushi', 'x cal')\n    v2, v3 = map(int, input().split())\n    v4 = []\n    for v5 in range(v2):\n        v6, v7 = map(int, input().split())\n        v4.append(v1(x=v6, cal=v7))\n    v8 = [0] * (v2 + 1)\n    v9 = [0] * (v2 + 1)\n    v10 = 0\n    v11 = 0\n    v12 = 0\n    for v13, v14 in enumerate(v4, start=1):\n        v12 += v14.cal\n        v10 = max(v10, v12 - v14.x)\n        v11 = max(v11, v12 - v14.x * 2)\n        v8[v13] = v10\n        v9[v13] = v11\n    v15 = [0] * (v2 + 1)\n    v16 = [0] * (v2 + 1)\n    v10 = 0\n    v11 = 0\n    v12 = 0\n    for v13, v14 in zip(range(v2, -1, -1), reversed(v4)):\n        v12 += v14.cal\n        v10 = max(v10, v12 - (v3 - v14.x))\n        v11 = max(v11, v12 - (v3 - v14.x) * 2)\n        v15[v13] = v10\n        v16[v13] = v11\n    v17 = 0\n    for v18 in range(1, v2 + 1):\n        v17 = max(v17, v9[v18 - 1] + v15[v18], v16[(v18 + 1) % (v2 + 1)] + v8[v18])\n    print(v17)\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1():\n    from collections import namedtuple\n    import sys\n    input = sys.stdin.readline\n    v1 = namedtuple('Sushi', 'x cal')\n    v2, v3 = map(int, input().split())\n    v4 = []\n    for v5 in range(v2):\n        v6, v7 = map(int, input().split())\n        v4.append(v1(x=v6, cal=v7))\n    v8 = [0] * (v2 + 1)\n    v9 = [0] * (v2 + 1)\n    v10 = 0\n    v11 = 0\n    v12 = 0\n    for v13, v14 in enumerate(v4, start=1):\n        v12 += v14.cal\n        v10 = max(v10, v12 - v14.x)\n        v11 = max(v11, v12 - v14.x * 2)\n        v8[v13] = v10\n        v9[v13] = v11\n    v15 = [0] * (v2 + 1)\n    v16 = [0] * (v2 + 1)\n    v10 = 0\n    v11 = 0\n    v12 = 0\n    for v13, v14 in zip(range(v2, -1, -1), reversed(v4)):\n        v12 += v14.cal\n        v10 = max(v10, v12 - (v3 - v14.x))\n        v11 = max(v11, v12 - (v3 - v14.x) * 2)\n        v15[v13] = v10\n        v16[v13] = v11\n    v17 = 0\n    for v18 in range(1, v2 + 1):\n        v17 = max(v17, v9[v18 - 1] + v15[v18], v16[(v18 + 1) % (v2 + 1)] + v8[v18])\n    print(v17)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\find-building-where-alice-and-bob-can-meet__part2.py", "text": "import heapq\n\nclass C1(object):\n\n    def leftmostBuildingQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [-1] * len(a2)\n        v2 = [[] for v3 in range(len(a1))]\n        for v4, (v5, v6) in enumerate(a2):\n            if v5 > v6:\n                v5, v6 = (v6, v5)\n            if v5 == v6 or a1[v5] < a1[v6]:\n                v1[v4] = v6\n            else:\n                v2[v6].append((a1[v5], v4))\n        v7 = []\n        for v4, v8 in enumerate(a1):\n            for v9 in v2[v4]:\n                heapq.heappush(v7, v9)\n            while v7 and v7[0][0] < v8:\n                v3, v10 = heapq.heappop(v7)\n                v1[v10] = v4\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def leftmostBuildingQueries(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [-1] * len(a2)\n        v2 = [[] for v3 in range(len(a1))]\n        for v4, (v5, v6) in enumerate(a2):\n            if v5 > v6:\n                v5, v6 = (v6, v5)\n            if v5 == v6 or a1[v5] < a1[v6]:\n                v1[v4] = v6\n            else:\n                v2[v6].append((a1[v5], v4))\n        v7 = []\n        for v4, v8 in enumerate(a1):\n            for v9 in v2[v4]:\n                heapq.heappush(v7, v9)\n            while v7 and v7[0][0] < v8:\n                v3, v10 = heapq.heappop(v7)\n                v1[v10] = v4\n        return v1\n"}
{"id": "llm_code\\max-sum-of-sub-matrix-no-larger-than-k__grok-4.1-fast__v1.py", "text": "from bisect import bisect_left, insort\n\nclass C1:\n\n    def maxSumSubmatrix(self, a1, a2):\n        if not a1 or not a1[0]:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = float('-inf')\n        if v1 > v2:\n            a1 = [list(t) for v5 in zip(*a1)]\n            v1, v2 = (v2, v1)\n        for v6 in range(v1):\n            v7 = [0] * v2\n            for v8 in range(v6, v1):\n                for v9 in range(v2):\n                    v7[v9] += a1[v8][v9]\n                v10 = [0]\n                v11 = 0\n                for v12 in v7:\n                    v11 += v12\n                    v13 = bisect_left(v10, v11 - a2)\n                    if v13 < len(v10):\n                        v3 = max(v3, v11 - v10[v13])\n                    insort(v10, v11)\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from bisect import bisect_left, insort\n\nclass C1:\n\n    def maxSumSubmatrix(self, a1, a2):\n        if not a1 or not a1[0]:\n            return 0\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = float('-inf')\n        if v1 > v2:\n            a1 = [list(t) for v5 in zip(*a1)]\n            v1, v2 = (v2, v1)\n        for v6 in range(v1):\n            v7 = [0] * v2\n            for v8 in range(v6, v1):\n                for v9 in range(v2):\n                    v7[v9] += a1[v8][v9]\n                v10 = [0]\n                v11 = 0\n                for v12 in v7:\n                    v11 += v12\n                    v13 = bisect_left(v10, v11 - a2)\n                    if v13 < len(v10):\n                        v3 = max(v3, v11 - v10[v13])\n                    insort(v10, v11)\n        return v3\n"}
{"id": "human_code\\maximize-subarray-gcd-score__part2.py", "text": "class C1(object):\n\n    def maxGCDScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lower_bit(a1):\n            return a1 & -a1\n        v1 = 0\n        for v2 in range(len(a1)):\n            v3 = float('inf')\n            v4 = v5 = 0\n            for v6 in range(v2, len(a1)):\n                v4 = gcd(v4, a1[v6])\n                v7 = lower_bit(a1[v6])\n                if v7 < v3:\n                    v3 = v7\n                    v5 = 0\n                if v7 == v3:\n                    v5 += 1\n                v1 = max(v1, v4 * (v6 - v2 + 1) * (2 if v5 <= a2 else 1))\n                if v4 * (len(a1) - v2) * 2 <= v1:\n                    break\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxGCDScore(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def gcd(a1, a2):\n            while a2:\n                a1, a2 = (a2, a1 % a2)\n            return a1\n\n        def lower_bit(a1):\n            return a1 & -a1\n        v1 = 0\n        for v2 in range(len(a1)):\n            v3 = float('inf')\n            v4 = v5 = 0\n            for v6 in range(v2, len(a1)):\n                v4 = gcd(v4, a1[v6])\n                v7 = lower_bit(a1[v6])\n                if v7 < v3:\n                    v3 = v7\n                    v5 = 0\n                if v7 == v3:\n                    v5 += 1\n                v1 = max(v1, v4 * (v6 - v2 + 1) * (2 if v5 <= a2 else 1))\n                if v4 * (len(a1) - v2) * 2 <= v1:\n                    break\n        return v1\n"}
{"id": "llm_code\\count-prefix-and-suffix-pairs-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def countPrefixSuffixPairs(self, a1):\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.val = 0\n        v1 = TrieNode()\n        v2 = 0\n        for v3 in a1:\n            v4 = v1\n            v5 = len(v3)\n            for v6 in range(v5):\n                v7 = v3[v6]\n                v8 = v3[v5 - 1 - v6]\n                v9 = (v7, v8)\n                if v9 not in v4.children:\n                    v4.children[v9] = TrieNode()\n                v4 = v4.children[v9]\n                v2 += v4.val\n            v4.val += 1\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def countPrefixSuffixPairs(self, a1):\n\n        class TrieNode:\n\n            def __init__(self):\n                self.children = {}\n                self.val = 0\n        v1 = TrieNode()\n        v2 = 0\n        for v3 in a1:\n            v4 = v1\n            v5 = len(v3)\n            for v6 in range(v5):\n                v7 = v3[v6]\n                v8 = v3[v5 - 1 - v6]\n                v9 = (v7, v8)\n                if v9 not in v4.children:\n                    v4.children[v9] = TrieNode()\n                v4 = v4.children[v9]\n                v2 += v4.val\n            v4.val += 1\n        return v2\n"}
{"id": "human_code\\p02975__s225234038.py", "text": "v1 = int(input())\nv2 = [int(i) for v3 in input().split(' ')]\nv4 = []\nv4.append(v2[0])\nfor v3 in v2:\n    if v3 != v4[0] and len(v4) == 1:\n        v4.append(v3)\n    if v3 != v4[0] and v3 != v4[1]:\n        v4.append(v3)\n        break\nif len(v4) == 1:\n    if v4[0] == 0:\n        print('Yes')\n        exit(0)\n    else:\n        print('No')\n        exit(0)\nif len(v4) == 3:\n    if v2.count(v4[0]) != v2.count(v4[1]):\n        print('No')\n        exit(0)\n    if v2.count(v4[0]) != v2.count(v4[2]):\n        print('No')\n        exit(0)\n    if len(v2) != v2.count(v4[0]) + v2.count(v4[1]) + v2.count(v4[2]):\n        print('No')\n        exit(0)\n    if v4[0] ^ v4[1] == v4[2]:\n        print('Yes')\n        exit(0)\n    elif v4[0] ^ v4[2] == v4[1]:\n        print('Yes')\n        exit(0)\n    elif v4[1] ^ v4[2] == v4[0]:\n        print('Yes')\n        exit(0)\n    else:\n        print('No')\nelse:\n    if len(v2) != v2.count(v4[0]) + v2.count(v4[1]):\n        print('No')\n        exit(0)\n    if v4[0] == 0 or v4[1] == 0:\n        if v4[0] == 0:\n            if v2.count(v4[1]) != 2 * v2.count(v4[0]):\n                print('No')\n                exit(0)\n        elif v2.count(v4[0]) != 2 * v2.count(v4[1]):\n            print('No')\n            exit(0)\n        print('Yes')\n        exit(0)\n    else:\n        print('No')\n        exit(0)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [int(i) for v3 in input().split(' ')]\nv4 = []\nv4.append(v2[0])\nfor v3 in v2:\n    if v3 != v4[0] and len(v4) == 1:\n        v4.append(v3)\n    if v3 != v4[0] and v3 != v4[1]:\n        v4.append(v3)\n        break\nif len(v4) == 1:\n    if v4[0] == 0:\n        print('Yes')\n        exit(0)\n    else:\n        print('No')\n        exit(0)\nif len(v4) == 3:\n    if v2.count(v4[0]) != v2.count(v4[1]):\n        print('No')\n        exit(0)\n    if v2.count(v4[0]) != v2.count(v4[2]):\n        print('No')\n        exit(0)\n    if len(v2) != v2.count(v4[0]) + v2.count(v4[1]) + v2.count(v4[2]):\n        print('No')\n        exit(0)\n    if v4[0] ^ v4[1] == v4[2]:\n        print('Yes')\n        exit(0)\n    elif v4[0] ^ v4[2] == v4[1]:\n        print('Yes')\n        exit(0)\n    elif v4[1] ^ v4[2] == v4[0]:\n        print('Yes')\n        exit(0)\n    else:\n        print('No')\nelse:\n    if len(v2) != v2.count(v4[0]) + v2.count(v4[1]):\n        print('No')\n        exit(0)\n    if v4[0] == 0 or v4[1] == 0:\n        if v4[0] == 0:\n            if v2.count(v4[1]) != 2 * v2.count(v4[0]):\n                print('No')\n                exit(0)\n        elif v2.count(v4[0]) != 2 * v2.count(v4[1]):\n            print('No')\n            exit(0)\n        print('Yes')\n        exit(0)\n    else:\n        print('No')\n        exit(0)\n"}
{"id": "llm_code\\reorganize-string__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def reorganizeString(self, a1):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        if max(v2) > (v1 + 1) // 2:\n            return ''\n        v4 = []\n        v5 = None\n        for v6 in range(v1):\n            v7 = -1\n            v8 = -1\n            for v9 in range(26):\n                v10 = chr(v9 + ord('a'))\n                if v2[v9] > v7 and (v5 is None or v10 != v5):\n                    v7 = v2[v9]\n                    v8 = v9\n            v3 = chr(v8 + ord('a'))\n            v4.append(v3)\n            v2[v8] -= 1\n            v5 = v3\n        return ''.join(v4)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def reorganizeString(self, a1):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a1:\n            v2[ord(v3) - ord('a')] += 1\n        if max(v2) > (v1 + 1) // 2:\n            return ''\n        v4 = []\n        v5 = None\n        for v6 in range(v1):\n            v7 = -1\n            v8 = -1\n            for v9 in range(26):\n                v10 = chr(v9 + ord('a'))\n                if v2[v9] > v7 and (v5 is None or v10 != v5):\n                    v7 = v2[v9]\n                    v8 = v9\n            v3 = chr(v8 + ord('a'))\n            v4.append(v3)\n            v2[v8] -= 1\n            v5 = v3\n        return ''.join(v4)\n"}
{"id": "llm_code\\shortest-subarray-to-be-removed-to-make-array-sorted__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def findLengthOfShortestSubarray(self, a1: list[int]) -> int:\n        v1 = len(a1)\n        if v1 <= 1:\n            return 0\n        v2 = v1\n        for v3 in range(v1 - 2, -1, -1):\n            if a1[v3] > a1[v3 + 1]:\n                v2 = v3 + 1\n                break\n        if v2 == 0:\n            return 0\n        v4 = v2\n        for v5 in range(1, v2):\n            if a1[v5] < a1[v5 - 1]:\n                v4 = v5 - 1\n                break\n        v6 = v2\n        v7 = v2\n        for v8 in range(v4 + 1):\n            while v7 < v1 and a1[v8] > a1[v7]:\n                v7 += 1\n            v6 = min(v6, v7 - v8 - 1)\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def findLengthOfShortestSubarray(self, a1: list[int]) -> int:\n        v1 = len(a1)\n        if v1 <= 1:\n            return 0\n        v2 = v1\n        for v3 in range(v1 - 2, -1, -1):\n            if a1[v3] > a1[v3 + 1]:\n                v2 = v3 + 1\n                break\n        if v2 == 0:\n            return 0\n        v4 = v2\n        for v5 in range(1, v2):\n            if a1[v5] < a1[v5 - 1]:\n                v4 = v5 - 1\n                break\n        v6 = v2\n        v7 = v2\n        for v8 in range(v4 + 1):\n            while v7 < v1 and a1[v8] > a1[v7]:\n                v7 += 1\n            v6 = min(v6, v7 - v8 - 1)\n        return v6\n"}
{"id": "human_code\\friend-circles.py", "text": "class C1(object):\n\n    def findCircleNum(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class UnionFind(object):\n\n            def __init__(self, a1):\n                self.set = list(range(a1))\n                self.count = a1\n\n            def find_set(self, a1):\n                if self.set[a1] != a1:\n                    self.set[a1] = self.find_set(self.set[a1])\n                return self.set[a1]\n\n            def union_set(self, a1, a2):\n                v1, v2 = list(map(self.find_set, (a1, a2)))\n                if v1 != v2:\n                    self.set[min(v1, v2)] = max(v1, v2)\n                    self.count -= 1\n        v1 = UnionFind(len(a1))\n        for v2 in range(len(a1)):\n            for v3 in range(len(a1)):\n                if a1[v2][v3] and v2 != v3:\n                    v1.union_set(v2, v3)\n        return v1.count\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findCircleNum(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class UnionFind(object):\n\n            def __init__(self, a1):\n                self.set = list(range(a1))\n                self.count = a1\n\n            def find_set(self, a1):\n                if self.set[a1] != a1:\n                    self.set[a1] = self.find_set(self.set[a1])\n                return self.set[a1]\n\n            def union_set(self, a1, a2):\n                v1, v2 = list(map(self.find_set, (a1, a2)))\n                if v1 != v2:\n                    self.set[min(v1, v2)] = max(v1, v2)\n                    self.count -= 1\n        v1 = UnionFind(len(a1))\n        for v2 in range(len(a1)):\n            for v3 in range(len(a1)):\n                if a1[v2][v3] and v2 != v3:\n                    v1.union_set(v2, v3)\n        return v1.count\n"}
{"id": "human_code\\collecting-chocolates__part1.py", "text": "class C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def accumulate(a1):\n            for v1 in range(len(a1) - 1):\n                a1[v1 + 1] += a1[v1]\n            return a1\n        v1 = min(range(len(a1)), key=lambda x: a1[a2])\n        a1 = a1[v1:] + a1[:v1]\n        v3, v4 = ([-1] * len(a1), [len(a1)] * len(a1))\n        v5 = []\n        for v1 in range(len(a1)):\n            while v5 and a1[v5[-1]] > a1[v1]:\n                v4[v5.pop()] = v1\n            if v5:\n                v3[v1] = v5[-1]\n            v5.append(v1)\n        v6 = [0] * (len(a1) + 1)\n        v6[0] = +1 * sum(a1)\n        v6[1] = a2\n        v6[-1] += -1 * a1[0]\n        for v1 in range(1, len(a1)):\n            v7, v8 = (v1 - v3[v1], v4[v1] - v1)\n            v6[min(v7, v8)] += -1 * a1[v1]\n            v6[max(v7, v8)] += -1 * a1[v1]\n            v6[v7 + v8] += +1 * a1[v1]\n        return min(accumulate(accumulate(v6)))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minCost(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def accumulate(a1):\n            for v1 in range(len(a1) - 1):\n                a1[v1 + 1] += a1[v1]\n            return a1\n        v1 = min(range(len(a1)), key=lambda x: a1[a2])\n        a1 = a1[v1:] + a1[:v1]\n        v3, v4 = ([-1] * len(a1), [len(a1)] * len(a1))\n        v5 = []\n        for v1 in range(len(a1)):\n            while v5 and a1[v5[-1]] > a1[v1]:\n                v4[v5.pop()] = v1\n            if v5:\n                v3[v1] = v5[-1]\n            v5.append(v1)\n        v6 = [0] * (len(a1) + 1)\n        v6[0] = +1 * sum(a1)\n        v6[1] = a2\n        v6[-1] += -1 * a1[0]\n        for v1 in range(1, len(a1)):\n            v7, v8 = (v1 - v3[v1], v4[v1] - v1)\n            v6[min(v7, v8)] += -1 * a1[v1]\n            v6[max(v7, v8)] += -1 * a1[v1]\n            v6[v7 + v8] += +1 * a1[v1]\n        return min(accumulate(accumulate(v6)))\n"}
{"id": "human_code\\maximum-total-importance-of-roads__part1.py", "text": "class C1(object):\n\n    def maximumImportance(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def inplace_counting_sort(a1, a2=False):\n            v1 = [0] * (max(a1) + 1)\n            for v2 in a1:\n                v1[v2] += 1\n            for v3 in range(1, len(v1)):\n                v1[v3] += v1[v3 - 1]\n            for v3 in reversed(range(len(a1))):\n                while a1[v3] >= 0:\n                    v1[a1[v3]] -= 1\n                    v4 = v1[a1[v3]]\n                    a1[v3], a1[v4] = (a1[v4], ~a1[v3])\n            for v3 in range(len(a1)):\n                a1[v3] = ~a1[v3]\n            if a2:\n                a1.reverse()\n        v1 = [0] * a1\n        for v2, v3 in a2:\n            v1[v2] += 1\n            v1[v3] += 1\n        inplace_counting_sort(v1)\n        return sum((i * x for v4, v5 in enumerate(v1, 1)))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumImportance(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def inplace_counting_sort(a1, a2=False):\n            v1 = [0] * (max(a1) + 1)\n            for v2 in a1:\n                v1[v2] += 1\n            for v3 in range(1, len(v1)):\n                v1[v3] += v1[v3 - 1]\n            for v3 in reversed(range(len(a1))):\n                while a1[v3] >= 0:\n                    v1[a1[v3]] -= 1\n                    v4 = v1[a1[v3]]\n                    a1[v3], a1[v4] = (a1[v4], ~a1[v3])\n            for v3 in range(len(a1)):\n                a1[v3] = ~a1[v3]\n            if a2:\n                a1.reverse()\n        v1 = [0] * a1\n        for v2, v3 in a2:\n            v1[v2] += 1\n            v1[v3] += 1\n        inplace_counting_sort(v1)\n        return sum((i * x for v4, v5 in enumerate(v1, 1)))\n"}
{"id": "human_code\\strong-password-checker.py", "text": "class C1(object):\n\n    def strongPasswordChecker(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 3\n        if any(('a' <= c <= 'z' for v2 in a1)):\n            v1 -= 1\n        if any(('A' <= v2 <= 'Z' for v2 in a1)):\n            v1 -= 1\n        if any((v2.isdigit() for v2 in a1)):\n            v1 -= 1\n        v3 = 0\n        v4, v5, v6 = (0, 0, 0)\n        v7 = 2\n        while v7 < len(a1):\n            if a1[v7] == a1[v7 - 1] == a1[v7 - 2]:\n                v8 = 2\n                while v7 < len(a1) and a1[v7] == a1[v7 - 1]:\n                    v8 += 1\n                    v7 += 1\n                v3 += v8 / 3\n                if v8 % 3 == 0:\n                    v4 += 1\n                elif v8 % 3 == 1:\n                    v5 += 1\n                else:\n                    v6 += 1\n            else:\n                v7 += 1\n        if len(a1) < 6:\n            return max(v1, 6 - len(a1))\n        elif len(a1) <= 20:\n            return max(v1, v3)\n        else:\n            v9 = len(a1) - 20\n            v3 -= min(v9, v4 * 1) / 1\n            v3 -= min(max(v9 - v4, 0), v5 * 2) / 2\n            v3 -= min(max(v9 - v4 - 2 * v5, 0), v6 * 3) / 3\n            return v9 + max(v1, v3)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def strongPasswordChecker(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 3\n        if any(('a' <= c <= 'z' for v2 in a1)):\n            v1 -= 1\n        if any(('A' <= v2 <= 'Z' for v2 in a1)):\n            v1 -= 1\n        if any((v2.isdigit() for v2 in a1)):\n            v1 -= 1\n        v3 = 0\n        v4, v5, v6 = (0, 0, 0)\n        v7 = 2\n        while v7 < len(a1):\n            if a1[v7] == a1[v7 - 1] == a1[v7 - 2]:\n                v8 = 2\n                while v7 < len(a1) and a1[v7] == a1[v7 - 1]:\n                    v8 += 1\n                    v7 += 1\n                v3 += v8 / 3\n                if v8 % 3 == 0:\n                    v4 += 1\n                elif v8 % 3 == 1:\n                    v5 += 1\n                else:\n                    v6 += 1\n            else:\n                v7 += 1\n        if len(a1) < 6:\n            return max(v1, 6 - len(a1))\n        elif len(a1) <= 20:\n            return max(v1, v3)\n        else:\n            v9 = len(a1) - 20\n            v3 -= min(v9, v4 * 1) / 1\n            v3 -= min(max(v9 - v4, 0), v5 * 2) / 2\n            v3 -= min(max(v9 - v4 - 2 * v5, 0), v6 * 3) / 3\n            return v9 + max(v1, v3)\n"}
{"id": "llm_code\\p03476__s336659008.py", "text": "import numpy as np\n\ndef f1(a1):\n    max = int(np.sqrt(a1))\n    v1 = [i for v2 in range(2, a1 + 1)]\n    v3 = []\n    while v1[0] <= max:\n        v3.append(v1[0])\n        v4 = v1[0]\n        v1 = [v2 for v2 in v1 if v2 % v4 != 0]\n    v3.extend(v1)\n    return v3\nfrom itertools import accumulate\nv1 = int(input())\nv2 = [0] * v1\nv3 = [0] * v1\nv4 = f1(10 ** 5)\nv5 = [0] * (10 ** 5 + 1)\nv6 = [0] * (10 ** 5 + 1)\nfor v7 in range(10 ** 5):\n    if v7 in v4:\n        if (v7 + 1) // 2 in v4:\n            v5[v7] = 1\nv6 = list(accumulate(v5))\nfor v7 in range(v1):\n    v2[v7], v3[v7] = map(int, input().split())\nfor v7 in range(v1):\n    print(v6[v3[v7]] - v6[v2[v7] - 1])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import numpy as np\n\ndef f1(a1):\n    max = int(np.sqrt(a1))\n    v1 = [i for v2 in range(2, a1 + 1)]\n    v3 = []\n    while v1[0] <= max:\n        v3.append(v1[0])\n        v4 = v1[0]\n        v1 = [v2 for v2 in v1 if v2 % v4 != 0]\n    v3.extend(v1)\n    return v3\nfrom itertools import accumulate\nv1 = int(input())\nv2 = [0] * v1\nv3 = [0] * v1\nv4 = f1(10 ** 5)\nv5 = [0] * (10 ** 5 + 1)\nv6 = [0] * (10 ** 5 + 1)\nfor v7 in range(10 ** 5):\n    if v7 in v4:\n        if (v7 + 1) // 2 in v4:\n            v5[v7] = 1\nv6 = list(accumulate(v5))\nfor v7 in range(v1):\n    v2[v7], v3[v7] = map(int, input().split())\nfor v7 in range(v1):\n    print(v6[v3[v7]] - v6[v2[v7] - 1])\n"}
{"id": "llm_code\\print-binary-tree__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def printTree(self, a1):\n        if not a1:\n            return []\n\n        def depth(a1):\n            if not a1:\n                return 0\n            return 1 + max(depth(a1.left), depth(a1.right))\n        v1 = depth(a1)\n\n        def span(a1):\n            if not a1:\n                return 0\n            return 1 + 2 * max(span(a1.left), span(a1.right))\n        v2 = span(a1)\n        v3 = [['' for v4 in range(v2)] for v4 in range(v1)]\n        v5 = []\n        v5.append((a1, 0, v2 // 2))\n        while v5:\n            v6, v7, v8 = v5.pop(0)\n            if v6:\n                v3[v7][v8] = str(v6.val)\n                v9 = 1 << v1 - v7 - 2\n                if v6.left:\n                    v5.append((v6.left, v7 + 1, v8 - v9))\n                if v6.right:\n                    v5.append((v6.right, v7 + 1, v8 + v9))\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def printTree(self, a1):\n        if not a1:\n            return []\n\n        def depth(a1):\n            if not a1:\n                return 0\n            return 1 + max(depth(a1.left), depth(a1.right))\n        v1 = depth(a1)\n\n        def span(a1):\n            if not a1:\n                return 0\n            return 1 + 2 * max(span(a1.left), span(a1.right))\n        v2 = span(a1)\n        v3 = [['' for v4 in range(v2)] for v4 in range(v1)]\n        v5 = []\n        v5.append((a1, 0, v2 // 2))\n        while v5:\n            v6, v7, v8 = v5.pop(0)\n            if v6:\n                v3[v7][v8] = str(v6.val)\n                v9 = 1 << v1 - v7 - 2\n                if v6.left:\n                    v5.append((v6.left, v7 + 1, v8 - v9))\n                if v6.right:\n                    v5.append((v6.right, v7 + 1, v8 + v9))\n        return v3\n"}
{"id": "llm_code\\p02733__s084972455.py", "text": "def f1(a1):\n    for v1 in range(g):\n        now[v1] += c[v1][a1]\n    for v1 in range(g):\n        if now[v1] > k:\n            return False\n    return True\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(100000)\nv1 = float('inf')\nv2 = [[0] * 10 for v3 in range(1005)]\nv4, v5, v6 = map(int, input().split())\nv7 = [[int(i) for v8 in input()] for v3 in range(v4)]\nv9 = v1\nfor v10 in range(1 << v4 - 1):\n    v11 = 0\n    id = [0] * v4\n    for v8 in range(v4):\n        id[v8] = v11\n        if v10 >> v8 & 1:\n            v11 += 1\n    v11 += 1\n    for v8 in range(v11):\n        for v12 in range(v5):\n            v2[v8][v12] = 0\n    for v8 in range(v4):\n        for v12 in range(v5):\n            v2[id[v8]][v12] += v7[v8][v12]\n    v13 = True\n    for v8 in range(v11):\n        for v12 in range(v5):\n            if v2[v8][v12] > v6:\n                v13 = False\n                break\n        if not v13:\n            break\n    if not v13:\n        continue\n    v14 = v11 - 1\n    v15 = [0] * v11\n    for v12 in range(v5):\n        if not f1(v12):\n            v14 += 1\n            v15 = [0] * v11\n            f1(v12)\n    v9 = min(v9, v14)\nprint(v9)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1):\n    for v1 in range(g):\n        now[v1] += c[v1][a1]\n    for v1 in range(g):\n        if now[v1] > k:\n            return False\n    return True\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(100000)\nv1 = float('inf')\nv2 = [[0] * 10 for v3 in range(1005)]\nv4, v5, v6 = map(int, input().split())\nv7 = [[int(i) for v8 in input()] for v3 in range(v4)]\nv9 = v1\nfor v10 in range(1 << v4 - 1):\n    v11 = 0\n    id = [0] * v4\n    for v8 in range(v4):\n        id[v8] = v11\n        if v10 >> v8 & 1:\n            v11 += 1\n    v11 += 1\n    for v8 in range(v11):\n        for v12 in range(v5):\n            v2[v8][v12] = 0\n    for v8 in range(v4):\n        for v12 in range(v5):\n            v2[id[v8]][v12] += v7[v8][v12]\n    v13 = True\n    for v8 in range(v11):\n        for v12 in range(v5):\n            if v2[v8][v12] > v6:\n                v13 = False\n                break\n        if not v13:\n            break\n    if not v13:\n        continue\n    v14 = v11 - 1\n    v15 = [0] * v11\n    for v12 in range(v5):\n        if not f1(v12):\n            v14 += 1\n            v15 = [0] * v11\n            f1(v12)\n    v9 = min(v9, v14)\nprint(v9)\n"}
{"id": "llm_code\\number-of-good-paths__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1, a2):\n        self.parents = list(range(a1))\n        self.ranks = [0] * a1\n        self.node_counts = [{} for v1 in range(a1)]\n        for v2, v3 in enumerate(a2):\n            self.node_counts[v2][v3] = 1\n\n    def get_root(self, a1):\n        v1 = a1\n        while self.parents[v1] != v1:\n            v1 = self.parents[v1]\n        v2 = a1\n        while v2 != v1:\n            v3 = self.parents[v2]\n            self.parents[v2] = v1\n            v2 = v3\n        return v1\n\n    def link(self, a1, a2, a3):\n        v1 = self.get_root(a1)\n        v2 = self.get_root(a2)\n        if v1 == v2:\n            return 0\n        if self.ranks[v1] > self.ranks[v2]:\n            v1, v2 = (v2, v1)\n        self.parents[v1] = v2\n        if self.ranks[v1] == self.ranks[v2]:\n            self.ranks[v2] += 1\n        v3 = self.node_counts[v1].get(a3, 0)\n        v4 = self.node_counts[v2].get(a3, 0)\n        self.node_counts[v2][a3] = v3 + v4\n        return v3 * v4\n\nclass C2:\n\n    def numberOfGoodPaths(self, a1, a2):\n        v1 = len(a1)\n        v2 = sorted(a2, key=lambda p: max(a1[p[0]], a1[p[1]]))\n        v3 = C1(v1, a1)\n        v4 = v1\n        for v5, v6 in v2:\n            v7 = max(a1[v5], a1[v6])\n            v4 += v3.link(v5, v6, v7)\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1, a2):\n        self.parents = list(range(a1))\n        self.ranks = [0] * a1\n        self.node_counts = [{} for v1 in range(a1)]\n        for v2, v3 in enumerate(a2):\n            self.node_counts[v2][v3] = 1\n\n    def get_root(self, a1):\n        v1 = a1\n        while self.parents[v1] != v1:\n            v1 = self.parents[v1]\n        v2 = a1\n        while v2 != v1:\n            v3 = self.parents[v2]\n            self.parents[v2] = v1\n            v2 = v3\n        return v1\n\n    def link(self, a1, a2, a3):\n        v1 = self.get_root(a1)\n        v2 = self.get_root(a2)\n        if v1 == v2:\n            return 0\n        if self.ranks[v1] > self.ranks[v2]:\n            v1, v2 = (v2, v1)\n        self.parents[v1] = v2\n        if self.ranks[v1] == self.ranks[v2]:\n            self.ranks[v2] += 1\n        v3 = self.node_counts[v1].get(a3, 0)\n        v4 = self.node_counts[v2].get(a3, 0)\n        self.node_counts[v2][a3] = v3 + v4\n        return v3 * v4\n\nclass C2:\n\n    def numberOfGoodPaths(self, a1, a2):\n        v1 = len(a1)\n        v2 = sorted(a2, key=lambda p: max(a1[p[0]], a1[p[1]]))\n        v3 = C1(v1, a1)\n        v4 = v1\n        for v5, v6 in v2:\n            v7 = max(a1[v5], a1[v6])\n            v4 += v3.link(v5, v6, v7)\n        return v4\n"}
{"id": "llm_code\\count-of-substrings-containing-every-vowel-and-k-consonants-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def countOfSubstrings(self, a1, a2):\n\n        def num_with_all_vowels_ge_cons(a1):\n            v1 = len(a1)\n            v2 = [0] * 26\n            v3 = 0\n            v4 = 0\n            v5 = 0\n            v6 = 0\n            v7 = set('aeiou')\n            for v8 in range(v1):\n                v9 = ord(a1[v8]) - ord('a')\n                if a1[v8] in v7:\n                    if v2[v9] == 0:\n                        v3 += 1\n                    v2[v9] += 1\n                else:\n                    v4 += 1\n                while v3 == 5 and v4 >= a1:\n                    v5 += v1 - v8\n                    v10 = ord(a1[v6]) - ord('a')\n                    if a1[v6] in v7:\n                        v2[v10] -= 1\n                        if v2[v10] == 0:\n                            v3 -= 1\n                    else:\n                        v4 -= 1\n                    v6 += 1\n            return v5\n        return num_with_all_vowels_ge_cons(a2) - num_with_all_vowels_ge_cons(a2 + 1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def countOfSubstrings(self, a1, a2):\n\n        def num_with_all_vowels_ge_cons(a1):\n            v1 = len(a1)\n            v2 = [0] * 26\n            v3 = 0\n            v4 = 0\n            v5 = 0\n            v6 = 0\n            v7 = set('aeiou')\n            for v8 in range(v1):\n                v9 = ord(a1[v8]) - ord('a')\n                if a1[v8] in v7:\n                    if v2[v9] == 0:\n                        v3 += 1\n                    v2[v9] += 1\n                else:\n                    v4 += 1\n                while v3 == 5 and v4 >= a1:\n                    v5 += v1 - v8\n                    v10 = ord(a1[v6]) - ord('a')\n                    if a1[v6] in v7:\n                        v2[v10] -= 1\n                        if v2[v10] == 0:\n                            v3 -= 1\n                    else:\n                        v4 -= 1\n                    v6 += 1\n            return v5\n        return num_with_all_vowels_ge_cons(a2) - num_with_all_vowels_ge_cons(a2 + 1)\n"}
{"id": "human_code\\minimum-operations-to-form-subsequence-with-target-sum__part3.py", "text": "import heapq\n\nclass C1(object):\n\n    def minOperations(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = sum(a1)\n        if v1 < a2:\n            return -1\n        v2 = 0\n        v3 = [-x for v4 in a1]\n        heapq.heapify(v3)\n        while a2:\n            v4 = -heapq.heappop(v3)\n            if v4 <= a2:\n                a2 -= v4\n                v1 -= v4\n            elif v1 - v4 >= a2:\n                v1 -= v4\n            else:\n                heapq.heappush(v3, -v4 // 2)\n                heapq.heappush(v3, -v4 // 2)\n                v2 += 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def minOperations(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = sum(a1)\n        if v1 < a2:\n            return -1\n        v2 = 0\n        v3 = [-x for v4 in a1]\n        heapq.heapify(v3)\n        while a2:\n            v4 = -heapq.heappop(v3)\n            if v4 <= a2:\n                a2 -= v4\n                v1 -= v4\n            elif v1 - v4 >= a2:\n                v1 -= v4\n            else:\n                heapq.heappush(v3, -v4 // 2)\n                heapq.heappush(v3, -v4 // 2)\n                v2 += 1\n        return v2\n"}
{"id": "llm_code\\p03263__s902279913.py", "text": "v1 = list(map(lambda x: int(x), input().strip().split()))\nv2 = v1[0]\nv3 = v1[1]\nv4 = []\nfor v5 in range(v2):\n    v6 = list(map(lambda x: int(x), input().strip().split()))\n    v4.append(v6)\nv7 = 0\nv8 = 0\nv9 = []\nfor v5 in range(v2):\n    if v5 % 2 == 0:\n        for v10 in range(v3):\n            if v4[v5][v10] % 2 == 0:\n                continue\n            if not v10 == v3 - 1:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5][v10 + 1] = v4[v5][v10 + 1] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 1, v10 + 2))\n                v7 += 1\n            elif v5 != v2 - 1:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5 + 1][v10] = v4[v5 + 1][v10] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 2, v10 + 1))\n                v7 += 1\n    else:\n        for v10 in range(v3 - 1, -1, -1):\n            if v4[v5][v10] % 2 == 0:\n                continue\n            if not v10 == 0:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5][v10 - 1] = v4[v5][v10 - 1] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 1, v10))\n                v7 += 1\n            elif v5 != v2 - 1:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5 + 1][v10] = v4[v5 + 1][v10] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 2, v10 + 1))\n                v7 += 1\nprint(v7)\nfor v11 in v9:\n    print(v11)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = list(map(lambda x: int(x), input().strip().split()))\nv2 = v1[0]\nv3 = v1[1]\nv4 = []\nfor v5 in range(v2):\n    v6 = list(map(lambda x: int(x), input().strip().split()))\n    v4.append(v6)\nv7 = 0\nv8 = 0\nv9 = []\nfor v5 in range(v2):\n    if v5 % 2 == 0:\n        for v10 in range(v3):\n            if v4[v5][v10] % 2 == 0:\n                continue\n            if not v10 == v3 - 1:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5][v10 + 1] = v4[v5][v10 + 1] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 1, v10 + 2))\n                v7 += 1\n            elif v5 != v2 - 1:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5 + 1][v10] = v4[v5 + 1][v10] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 2, v10 + 1))\n                v7 += 1\n    else:\n        for v10 in range(v3 - 1, -1, -1):\n            if v4[v5][v10] % 2 == 0:\n                continue\n            if not v10 == 0:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5][v10 - 1] = v4[v5][v10 - 1] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 1, v10))\n                v7 += 1\n            elif v5 != v2 - 1:\n                v4[v5][v10] = v4[v5][v10] - 1\n                v4[v5 + 1][v10] = v4[v5 + 1][v10] + 1\n                v9.append('{} {} {} {}'.format(v5 + 1, v10 + 1, v5 + 2, v10 + 1))\n                v7 += 1\nprint(v7)\nfor v11 in v9:\n    print(v11)\n"}
{"id": "llm_code\\p03326__s783190736.py", "text": "import copy\nv1, v2 = map(int, input().split())\nv3 = []\nfor v4 in range(v1):\n    v5, v6, v7 = map(int, input().split())\n    v3.append([v5, v6, v7])\nv8 = 0\nfor v4 in range(2 ** 3):\n    v9 = [[0] * (v2 + 1) for v10 in range(v1 + 1)]\n    v11 = copy.deepcopy(v3)\n    for v12 in range(3):\n        if v4 >> v12 & 1:\n            for v13 in range(v1):\n                v11[v13][v12] *= -1\n    for v14 in range(1, v1 + 1):\n        for v15 in range(1, v2 + 1):\n            if v15 <= v14:\n                v9[v14][v15] = max([v9[v14 - 1][v15], v9[v14 - 1][v15 - 1] + sum(v11[v14 - 1]), v9[v14][v15]])\n            else:\n                v9[v14][v15] = max([v9[v14 - 1][v15], v9[v14][v15]])\n    v8 = max(v8, v9[v1][v2])\nprint(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import copy\nv1, v2 = map(int, input().split())\nv3 = []\nfor v4 in range(v1):\n    v5, v6, v7 = map(int, input().split())\n    v3.append([v5, v6, v7])\nv8 = 0\nfor v4 in range(2 ** 3):\n    v9 = [[0] * (v2 + 1) for v10 in range(v1 + 1)]\n    v11 = copy.deepcopy(v3)\n    for v12 in range(3):\n        if v4 >> v12 & 1:\n            for v13 in range(v1):\n                v11[v13][v12] *= -1\n    for v14 in range(1, v1 + 1):\n        for v15 in range(1, v2 + 1):\n            if v15 <= v14:\n                v9[v14][v15] = max([v9[v14 - 1][v15], v9[v14 - 1][v15 - 1] + sum(v11[v14 - 1]), v9[v14][v15]])\n            else:\n                v9[v14][v15] = max([v9[v14 - 1][v15], v9[v14][v15]])\n    v8 = max(v8, v9[v1][v2])\nprint(v8)\n"}
{"id": "llm_code\\p03816__s072868416.py", "text": "from collections import Counter\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = Counter(v2)\nv3 = sorted(v3.items())\nv4 = []\nfor v5, v6 in v3:\n    v4.append([v5, v6])\nv3 = v4\nv7 = len(v3)\nv8 = 0\nv9 = v7 - 1\nwhile True:\n    if v3[v8][1] < 2:\n        for v8 in range(v7):\n            if v3[v8][1] > 1:\n                break\n    if v3[v9][1] < 2:\n        for v9 in range(v7):\n            if v3[v7 - v9 - 1][1] > 1:\n                break\n        v9 = v7 - v9 - 1\n    if v3[v8][1] <= 1 and v3[v9][1] <= 1:\n        break\n    if v8 == v9:\n        if v3[v8][1] >= 3:\n            v3[v8][1] -= 2\n        else:\n            v3[v8][1] -= 1\n            for v10 in range(v8 + 1, v7):\n                if v3[v10][1] > 0:\n                    v3[v10][1] -= 1\n                    break\n    else:\n        v3[v8][1] -= 1\n        v3[v9][1] -= 1\nv11 = 0\nfor v5, v6 in v3:\n    v11 += v6\nprint(v11)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from collections import Counter\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = Counter(v2)\nv3 = sorted(v3.items())\nv4 = []\nfor v5, v6 in v3:\n    v4.append([v5, v6])\nv3 = v4\nv7 = len(v3)\nv8 = 0\nv9 = v7 - 1\nwhile True:\n    if v3[v8][1] < 2:\n        for v8 in range(v7):\n            if v3[v8][1] > 1:\n                break\n    if v3[v9][1] < 2:\n        for v9 in range(v7):\n            if v3[v7 - v9 - 1][1] > 1:\n                break\n        v9 = v7 - v9 - 1\n    if v3[v8][1] <= 1 and v3[v9][1] <= 1:\n        break\n    if v8 == v9:\n        if v3[v8][1] >= 3:\n            v3[v8][1] -= 2\n        else:\n            v3[v8][1] -= 1\n            for v10 in range(v8 + 1, v7):\n                if v3[v10][1] > 0:\n                    v3[v10][1] -= 1\n                    break\n    else:\n        v3[v8][1] -= 1\n        v3[v9][1] -= 1\nv11 = 0\nfor v5, v6 in v3:\n    v11 += v6\nprint(v11)\n"}
{"id": "human_code\\escape-the-spreading-fire__part2.py", "text": "class C1(object):\n\n    def maximumMinutes(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v2, v3, v4 = list(range(1, 4))\n        v5 = 10 ** 9\n\n        def bfs(a1):\n            v1 = {v2: [[v5] * len(a1[0]) for v2 in range(len(a1))], v4: [[v5] * len(a1[0]) for v2 in range(len(a1))]}\n            v3 = 0\n            v4 = [(r, c, v2) for v5 in range(len(a1)) for v6 in range(len(a1[0])) if a1[v5][v6] == v2]\n            v4.append((0, 0, v4))\n            for v5, v6, v7 in v4:\n                v1[v7][v5][v6] = v3\n            while v4:\n                v8 = []\n                for v5, v6, v7 in v4:\n                    for v9, v10 in v1:\n                        v11, v12 = (v5 + v9, v6 + v10)\n                        if not (0 <= v11 < len(a1) and 0 <= v12 < len(a1[0]) and (a1[v11][v12] != v3) and (v1[v7][v11][v12] == v5) and (v7 == v2 or v3 + 1 < v1[v2][v11][v12] or (v3 + 1 == v1[v2][v11][v12] and (v11, v12) == (len(a1) - 1, len(a1[0]) - 1)))):\n                            continue\n                        v1[v7][v11][v12] = v3 + 1\n                        v8.append((v11, v12, v7))\n                v4 = v8\n                v3 += 1\n            return v1\n        v6 = bfs(a1)\n        if v6[v4][-1][-1] == v5:\n            return -1\n        if v6[v2][-1][-1] == v5:\n            return v5\n        v7 = v6[v2][-1][-1] - v6[v4][-1][-1]\n        return v7 if v7 + 2 in (v6[v2][-1][-2] - v6[v4][-1][-2], v6[v2][-2][-1] - v6[v4][-2][-1]) else v7 - 1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumMinutes(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v2, v3, v4 = list(range(1, 4))\n        v5 = 10 ** 9\n\n        def bfs(a1):\n            v1 = {v2: [[v5] * len(a1[0]) for v2 in range(len(a1))], v4: [[v5] * len(a1[0]) for v2 in range(len(a1))]}\n            v3 = 0\n            v4 = [(r, c, v2) for v5 in range(len(a1)) for v6 in range(len(a1[0])) if a1[v5][v6] == v2]\n            v4.append((0, 0, v4))\n            for v5, v6, v7 in v4:\n                v1[v7][v5][v6] = v3\n            while v4:\n                v8 = []\n                for v5, v6, v7 in v4:\n                    for v9, v10 in v1:\n                        v11, v12 = (v5 + v9, v6 + v10)\n                        if not (0 <= v11 < len(a1) and 0 <= v12 < len(a1[0]) and (a1[v11][v12] != v3) and (v1[v7][v11][v12] == v5) and (v7 == v2 or v3 + 1 < v1[v2][v11][v12] or (v3 + 1 == v1[v2][v11][v12] and (v11, v12) == (len(a1) - 1, len(a1[0]) - 1)))):\n                            continue\n                        v1[v7][v11][v12] = v3 + 1\n                        v8.append((v11, v12, v7))\n                v4 = v8\n                v3 += 1\n            return v1\n        v6 = bfs(a1)\n        if v6[v4][-1][-1] == v5:\n            return -1\n        if v6[v2][-1][-1] == v5:\n            return v5\n        v7 = v6[v2][-1][-1] - v6[v4][-1][-1]\n        return v7 if v7 + 2 in (v6[v2][-1][-2] - v6[v4][-1][-2], v6[v2][-2][-1] - v6[v4][-2][-1]) else v7 - 1\n"}
{"id": "human_code\\robot-room-cleaner.py", "text": "class C1(object):\n\n    def cleanRoom(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def goBack(a1):\n            a1.turnLeft()\n            a1.turnLeft()\n            a1.move()\n            a1.turnRight()\n            a1.turnRight()\n\n        def dfs(a1, a2, a3, a4):\n            a2.clean()\n            for v1 in v1:\n                v2 = (a1[0] + v1[a3][0], a1[1] + v1[a3][1])\n                if v2 not in a4:\n                    a4.add(v2)\n                    if a2.move():\n                        dfs(v2, a2, a3, a4)\n                        goBack(a2)\n                a2.turnRight()\n                a3 = (a3 + 1) % len(v1)\n        dfs((0, 0), a1, 0, set())\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def cleanRoom(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n        def goBack(a1):\n            a1.turnLeft()\n            a1.turnLeft()\n            a1.move()\n            a1.turnRight()\n            a1.turnRight()\n\n        def dfs(a1, a2, a3, a4):\n            a2.clean()\n            for v1 in v1:\n                v2 = (a1[0] + v1[a3][0], a1[1] + v1[a3][1])\n                if v2 not in a4:\n                    a4.add(v2)\n                    if a2.move():\n                        dfs(v2, a2, a3, a4)\n                        goBack(a2)\n                a2.turnRight()\n                a3 = (a3 + 1) % len(v1)\n        dfs((0, 0), a1, 0, set())\n"}
{"id": "llm_code\\minimum-number-of-taps-to-open-to-water-a-garden__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minTaps(self, a1, a2):\n        v1 = [0] * (a1 + 1)\n        for v2, v3 in enumerate(a2):\n            v4 = max(0, v2 - v3)\n            v5 = min(a1, v2 + v3)\n            v1[v4] = max(v1[v4], v5)\n        v6 = 0\n        v7 = 0\n        v8 = 0\n        for v9 in range(a1 + 1):\n            if v9 > v6:\n                return -1\n            v6 = max(v6, v1[v9])\n            if v9 == v7:\n                v8 += 1\n                v7 = v6\n                if v7 >= a1:\n                    return v8\n        return v8\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minTaps(self, a1, a2):\n        v1 = [0] * (a1 + 1)\n        for v2, v3 in enumerate(a2):\n            v4 = max(0, v2 - v3)\n            v5 = min(a1, v2 + v3)\n            v1[v4] = max(v1[v4], v5)\n        v6 = 0\n        v7 = 0\n        v8 = 0\n        for v9 in range(a1 + 1):\n            if v9 > v6:\n                return -1\n            v6 = max(v6, v1[v9])\n            if v9 == v7:\n                v8 += 1\n                v7 = v6\n                if v7 >= a1:\n                    return v8\n        return v8\n"}
{"id": "human_code\\count-non-decreasing-subarrays-after-k-operations.py", "text": "import collections\n\nclass C1(object):\n\n    def countNonDecreasingSubarrays(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = 0\n        v3 = collections.deque()\n        v4 = len(a1) - 1\n        for v5 in reversed(range(len(a1))):\n            while v3 and a1[v3[-1]] < a1[v5]:\n                v6 = v3.pop()\n                v7 = v3[-1] - 1 if v3 else v4\n                v2 += (v7 - v6 + 1) * (a1[v5] - a1[v6])\n            v3.append(v5)\n            while v2 > a2:\n                v2 -= a1[v3[0]] - a1[v4]\n                if v3[0] == v4:\n                    v3.popleft()\n                v4 -= 1\n            v1 += v4 - v5 + 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def countNonDecreasingSubarrays(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = 0\n        v3 = collections.deque()\n        v4 = len(a1) - 1\n        for v5 in reversed(range(len(a1))):\n            while v3 and a1[v3[-1]] < a1[v5]:\n                v6 = v3.pop()\n                v7 = v3[-1] - 1 if v3 else v4\n                v2 += (v7 - v6 + 1) * (a1[v5] - a1[v6])\n            v3.append(v5)\n            while v2 > a2:\n                v2 -= a1[v3[0]] - a1[v4]\n                if v3[0] == v4:\n                    v3.popleft()\n                v4 -= 1\n            v1 += v4 - v5 + 1\n        return v1\n"}
{"id": "human_code\\continuous-subarrays__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def continuousSubarrays(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = 0\n        v3, v4 = (float('inf'), float('-inf'))\n        for v5 in range(len(a1)):\n            if v3 <= a1[v5] <= v4:\n                v3, v4 = (max(v3, a1[v5] - 2), min(v4, a1[v5] + 2))\n            else:\n                v3, v4 = (a1[v5] - 2, a1[v5] + 2)\n                for v2 in reversed(range(v5)):\n                    if not v3 <= a1[v2] <= v4:\n                        break\n                    v3, v4 = (max(v3, a1[v2] - 2), min(v4, a1[v2] + 2))\n                else:\n                    v2 = -1\n                v2 += 1\n            v1 += v5 - v2 + 1\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def continuousSubarrays(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = 0\n        v3, v4 = (float('inf'), float('-inf'))\n        for v5 in range(len(a1)):\n            if v3 <= a1[v5] <= v4:\n                v3, v4 = (max(v3, a1[v5] - 2), min(v4, a1[v5] + 2))\n            else:\n                v3, v4 = (a1[v5] - 2, a1[v5] + 2)\n                for v2 in reversed(range(v5)):\n                    if not v3 <= a1[v2] <= v4:\n                        break\n                    v3, v4 = (max(v3, a1[v2] - 2), min(v4, a1[v2] + 2))\n                else:\n                    v2 = -1\n                v2 += 1\n            v1 += v5 - v2 + 1\n        return v1\n"}
{"id": "human_code\\minimum-time-takes-to-reach-destination-without-drowning__part2.py", "text": "class C1(object):\n\n    def minimumSeconds(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        v2 = [[0 if a1[i][j] == '*' else -1 for v3 in range(len(a1[0]))] for v4 in range(len(a1))]\n        v5 = [[-1] * len(a1[0]) for v6 in range(len(a1))]\n        v7 = [(v4, v3) for v4 in range(len(a1)) for v3 in range(len(a1[0])) if a1[v4][v3] == '*']\n        v8 = [next(((v4, v3) for v4 in range(len(a1)) for v3 in range(len(a1[0])) if a1[v4][v3] == 'S'))]\n        v5[v8[0][0]][v8[0][1]] = 0\n        while v7 or v8:\n            v9, v10 = ([], [])\n            for v4, v3 in v7:\n                for v11, v12 in v1:\n                    v13, v14 = (v4 + v11, v3 + v12)\n                    if not (0 <= v13 < len(a1) and 0 <= v14 < len(a1[0]) and (a1[v13][v14] != 'X') and (a1[v13][v14] != 'D') and (v2[v13][v14] == -1)):\n                        continue\n                    v2[v13][v14] = 0\n                    v9.append((v13, v14))\n            for v4, v3 in v8:\n                if a1[v4][v3] == 'D':\n                    return v5[v4][v3]\n                for v11, v12 in v1:\n                    v13, v14 = (v4 + v11, v3 + v12)\n                    if not (0 <= v13 < len(a1) and 0 <= v14 < len(a1[0]) and (a1[v13][v14] != 'X') and (v5[v13][v14] == v2[v13][v14] == -1)):\n                        continue\n                    v5[v13][v14] = v5[v4][v3] + 1\n                    v10.append((v13, v14))\n            v7, v8 = (v9, v10)\n        return -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumSeconds(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = ((1, 0), (0, 1), (-1, 0), (0, -1))\n        v2 = [[0 if a1[i][j] == '*' else -1 for v3 in range(len(a1[0]))] for v4 in range(len(a1))]\n        v5 = [[-1] * len(a1[0]) for v6 in range(len(a1))]\n        v7 = [(v4, v3) for v4 in range(len(a1)) for v3 in range(len(a1[0])) if a1[v4][v3] == '*']\n        v8 = [next(((v4, v3) for v4 in range(len(a1)) for v3 in range(len(a1[0])) if a1[v4][v3] == 'S'))]\n        v5[v8[0][0]][v8[0][1]] = 0\n        while v7 or v8:\n            v9, v10 = ([], [])\n            for v4, v3 in v7:\n                for v11, v12 in v1:\n                    v13, v14 = (v4 + v11, v3 + v12)\n                    if not (0 <= v13 < len(a1) and 0 <= v14 < len(a1[0]) and (a1[v13][v14] != 'X') and (a1[v13][v14] != 'D') and (v2[v13][v14] == -1)):\n                        continue\n                    v2[v13][v14] = 0\n                    v9.append((v13, v14))\n            for v4, v3 in v8:\n                if a1[v4][v3] == 'D':\n                    return v5[v4][v3]\n                for v11, v12 in v1:\n                    v13, v14 = (v4 + v11, v3 + v12)\n                    if not (0 <= v13 < len(a1) and 0 <= v14 < len(a1[0]) and (a1[v13][v14] != 'X') and (v5[v13][v14] == v2[v13][v14] == -1)):\n                        continue\n                    v5[v13][v14] = v5[v4][v3] + 1\n                    v10.append((v13, v14))\n            v7, v8 = (v9, v10)\n        return -1\n"}
{"id": "llm_code\\p03786__s053383266.py", "text": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = set(v2)\nif len(v3) == 1:\n    print(len(v2))\n    exit()\nv4 = v2[0]\nv5 = True\nfor v6 in range(1, len(v2)):\n    if v4 * 2 >= v2[v6]:\n        v4 += v2[v6]\n    else:\n        v5 = False\n        break\nif v5:\n    print(len(v2))\n    exit()\nv2 = sorted(v2)\nv7 = 0\nv8 = len(v2) - 1\nv9 = (v7 + v8) // 2\nwhile True:\n    v10 = v9\n    v11 = sum(v2[0:v9 + 1])\n    v12 = True\n    for v6 in range(v9 + 1, len(v2)):\n        if v11 * 2 >= v2[v6]:\n            v11 += v2[v6]\n        else:\n            v12 = False\n            break\n    if v12:\n        v8 = v9\n        v9 = (v7 + v8) // 2\n    else:\n        v7 = v9\n        v9 = (v7 + v8) // 2\n    if v9 == v10:\n        break\nprint(len(v2) - len(v2[0:v9 + 1]))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = set(v2)\nif len(v3) == 1:\n    print(len(v2))\n    exit()\nv4 = v2[0]\nv5 = True\nfor v6 in range(1, len(v2)):\n    if v4 * 2 >= v2[v6]:\n        v4 += v2[v6]\n    else:\n        v5 = False\n        break\nif v5:\n    print(len(v2))\n    exit()\nv2 = sorted(v2)\nv7 = 0\nv8 = len(v2) - 1\nv9 = (v7 + v8) // 2\nwhile True:\n    v10 = v9\n    v11 = sum(v2[0:v9 + 1])\n    v12 = True\n    for v6 in range(v9 + 1, len(v2)):\n        if v11 * 2 >= v2[v6]:\n            v11 += v2[v6]\n        else:\n            v12 = False\n            break\n    if v12:\n        v8 = v9\n        v9 = (v7 + v8) // 2\n    else:\n        v7 = v9\n        v9 = (v7 + v8) // 2\n    if v9 == v10:\n        break\nprint(len(v2) - len(v2[0:v9 + 1]))\n"}
{"id": "human_code\\p03645__s521966549.py", "text": "import bisect\n\ndef f1():\n    v1, v2 = map(int, input().split(' '))\n    v3 = []\n    v4 = []\n    for v5 in range(v2):\n        v6, v7 = map(int, input().split(' '))\n        if v6 == 1:\n            v3.append(v7)\n        if v7 == v1:\n            v4.append(v6)\n    v3 = sorted(v3)\n    for v8 in v4:\n        v5 = bisect.bisect_left(v3, v8)\n        v9 = bisect.bisect_right(v3, v8)\n        if v5 != v9:\n            print('POSSIBLE')\n            exit()\n    print('IMPOSSIBLE')\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import bisect\n\ndef f1():\n    v1, v2 = map(int, input().split(' '))\n    v3 = []\n    v4 = []\n    for v5 in range(v2):\n        v6, v7 = map(int, input().split(' '))\n        if v6 == 1:\n            v3.append(v7)\n        if v7 == v1:\n            v4.append(v6)\n    v3 = sorted(v3)\n    for v8 in v4:\n        v5 = bisect.bisect_left(v3, v8)\n        v9 = bisect.bisect_right(v3, v8)\n        if v5 != v9:\n            print('POSSIBLE')\n            exit()\n    print('IMPOSSIBLE')\nif __name__ == '__main__':\n    f1()\n"}
{"id": "llm_code\\minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def minFlips(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = v1 * v2\n\n        def cell(a1, a2):\n            return a1 * v2 + a2\n        v4 = 0\n        for v5 in range(v1):\n            for v6 in range(v2):\n                if a1[v5][v6]:\n                    v4 |= 1 << cell(v5, v6)\n        v7 = [(-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)]\n        v8 = [0] * v3\n        for v9 in range(v1):\n            for v10 in range(v2):\n                v11 = cell(v9, v10)\n                v12 = 0\n                for v13, v14 in v7:\n                    v15 = v9 + v13\n                    v16 = v10 + v14\n                    if 0 <= v15 < v1 and 0 <= v16 < v2:\n                        v12 |= 1 << cell(v15, v16)\n                v8[v11] = v12\n        v17 = deque([(v4, 0)])\n        v18 = {v4}\n        while v17:\n            v19, v20 = v17.popleft()\n            if v19 == 0:\n                return v20\n            for v21 in v8:\n                v22 = v19 ^ v21\n                if v22 not in v18:\n                    v18.add(v22)\n                    v17.append((v22, v20 + 1))\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def minFlips(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = v1 * v2\n\n        def cell(a1, a2):\n            return a1 * v2 + a2\n        v4 = 0\n        for v5 in range(v1):\n            for v6 in range(v2):\n                if a1[v5][v6]:\n                    v4 |= 1 << cell(v5, v6)\n        v7 = [(-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)]\n        v8 = [0] * v3\n        for v9 in range(v1):\n            for v10 in range(v2):\n                v11 = cell(v9, v10)\n                v12 = 0\n                for v13, v14 in v7:\n                    v15 = v9 + v13\n                    v16 = v10 + v14\n                    if 0 <= v15 < v1 and 0 <= v16 < v2:\n                        v12 |= 1 << cell(v15, v16)\n                v8[v11] = v12\n        v17 = deque([(v4, 0)])\n        v18 = {v4}\n        while v17:\n            v19, v20 = v17.popleft()\n            if v19 == 0:\n                return v20\n            for v21 in v8:\n                v22 = v19 ^ v21\n                if v22 not in v18:\n                    v18.add(v22)\n                    v17.append((v22, v20 + 1))\n        return -1\n"}
{"id": "human_code\\p02684__s102841978.py", "text": "v1, v2 = map(int, input().split())\nv3 = [0] + list(map(int, input().split()))\nv4 = [float('INF') for v5 in range(v1 + 1)]\nv6 = []\nv7 = 0\nv8 = 1\nv9 = 0\nwhile v7 == 0:\n    if v4[v8] == float('INF'):\n        v4[v8] = v9\n        v6.append(v8)\n        v8 = v3[v8]\n        v9 += 1\n    else:\n        v7 = 1\n        v10 = v4[v8]\n        v11 = v9 - v10\nif v2 < v10:\n    print(v6[v2])\nelse:\n    print(v6[(v2 - v10) % v11 + v10])\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = [0] + list(map(int, input().split()))\nv4 = [float('INF') for v5 in range(v1 + 1)]\nv6 = []\nv7 = 0\nv8 = 1\nv9 = 0\nwhile v7 == 0:\n    if v4[v8] == float('INF'):\n        v4[v8] = v9\n        v6.append(v8)\n        v8 = v3[v8]\n        v9 += 1\n    else:\n        v7 = 1\n        v10 = v4[v8]\n        v11 = v9 - v10\nif v2 < v10:\n    print(v6[v2])\nelse:\n    print(v6[(v2 - v10) % v11 + v10])\n"}
{"id": "llm_code\\block-placement-queries__grok-4.1-fast__v1.py", "text": "from sortedcontainers import SortedList\n\nclass C1:\n\n    def getResults(self, a1):\n        v1 = sorted((q[1] for v2 in a1 if v2[0] == 1))\n        v3 = {v: ii for v4, v5 in enumerate(v1)}\n        v6 = len(v1)\n\n        class MaxSegTree:\n\n            def __init__(self, a1):\n                self.nn = a1\n                self.t = [0] * (4 * a1)\n\n            def _upd(self, a1, a2, a3, a4, a5):\n                if a2 == a3:\n                    self.t[a1] = a5\n                    return\n                v1 = (a2 + a3) // 2\n                if a4 <= v1:\n                    self._upd(2 * a1, a2, v1, a4, a5)\n                else:\n                    self._upd(2 * a1 + 1, v1 + 1, a3, a4, a5)\n                self.t[a1] = max(self.t[2 * a1], self.t[2 * a1 + 1])\n\n            def upd(self, a1, a2):\n                self._upd(1, 0, self.nn - 1, a1, a2)\n\n            def _qry(self, a1, a2, a3, a4, a5):\n                if a5 < a2 or a3 < a4:\n                    return 0\n                if a4 <= a2 and a3 <= a5:\n                    return self.t[a1]\n                v1 = (a2 + a3) // 2\n                return max(self._qry(2 * a1, a2, v1, a4, a5), self._qry(2 * a1 + 1, v1 + 1, a3, a4, a5))\n\n            def qry(self, a1, a2):\n                return self._qry(1, 0, self.nn - 1, a1, a2)\n        v7 = MaxSegTree(v6) if v6 > 0 else None\n        v8 = SortedList()\n        v9 = []\n        for v10 in a1:\n            v11 = v10[0]\n            v12 = v10[1]\n            v13 = v8.bisect_left(v12)\n            v14 = v8[v13 - 1] if v13 > 0 else 0\n            if v11 == 1:\n                v8.add(v12)\n                v7.upd(v3[v12], v12 - v14)\n                if v13 + 1 < len(v8):\n                    v15 = v8[v13 + 1]\n                    v7.upd(v3[v15], v15 - v12)\n            else:\n                v16 = v10[2]\n                v17 = v12 - v14\n                v18 = v17 >= v16\n                if not v18 and v13 > 0:\n                    v19 = v3[v8[v13 - 1]]\n                    v18 = v7.qry(0, v19) >= v16\n                v9.append(v18)\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from sortedcontainers import SortedList\n\nclass C1:\n\n    def getResults(self, a1):\n        v1 = sorted((q[1] for v2 in a1 if v2[0] == 1))\n        v3 = {v: ii for v4, v5 in enumerate(v1)}\n        v6 = len(v1)\n\n        class MaxSegTree:\n\n            def __init__(self, a1):\n                self.nn = a1\n                self.t = [0] * (4 * a1)\n\n            def _upd(self, a1, a2, a3, a4, a5):\n                if a2 == a3:\n                    self.t[a1] = a5\n                    return\n                v1 = (a2 + a3) // 2\n                if a4 <= v1:\n                    self._upd(2 * a1, a2, v1, a4, a5)\n                else:\n                    self._upd(2 * a1 + 1, v1 + 1, a3, a4, a5)\n                self.t[a1] = max(self.t[2 * a1], self.t[2 * a1 + 1])\n\n            def upd(self, a1, a2):\n                self._upd(1, 0, self.nn - 1, a1, a2)\n\n            def _qry(self, a1, a2, a3, a4, a5):\n                if a5 < a2 or a3 < a4:\n                    return 0\n                if a4 <= a2 and a3 <= a5:\n                    return self.t[a1]\n                v1 = (a2 + a3) // 2\n                return max(self._qry(2 * a1, a2, v1, a4, a5), self._qry(2 * a1 + 1, v1 + 1, a3, a4, a5))\n\n            def qry(self, a1, a2):\n                return self._qry(1, 0, self.nn - 1, a1, a2)\n        v7 = MaxSegTree(v6) if v6 > 0 else None\n        v8 = SortedList()\n        v9 = []\n        for v10 in a1:\n            v11 = v10[0]\n            v12 = v10[1]\n            v13 = v8.bisect_left(v12)\n            v14 = v8[v13 - 1] if v13 > 0 else 0\n            if v11 == 1:\n                v8.add(v12)\n                v7.upd(v3[v12], v12 - v14)\n                if v13 + 1 < len(v8):\n                    v15 = v8[v13 + 1]\n                    v7.upd(v3[v15], v15 - v12)\n            else:\n                v16 = v10[2]\n                v17 = v12 - v14\n                v18 = v17 >= v16\n                if not v18 and v13 > 0:\n                    v19 = v3[v8[v13 - 1]]\n                    v18 = v7.qry(0, v19) >= v16\n                v9.append(v18)\n        return v9\n"}
{"id": "llm_code\\p02683__s427208526.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = []\nv5 = []\nfor v6 in range(v1):\n    v7 = list(map(int, input().split()))\n    v4.append(v7[0])\n    v5.append(v7[1:])\nv8 = 10 ** 10\nfor v6 in range(2 ** v1):\n    v9 = [0 for v10 in range(v2)]\n    v11 = '{:b}'.format(v6)\n    v12 = v11.zfill(v1)\n    v13 = 0\n    for v14 in range(len(v12)):\n        if v12[v14] == '1':\n            for v15 in range(v2):\n                v9[v15] += v5[v14][v15]\n            v13 += v4[v14]\n    if all((u >= v3 for v16 in v9)):\n        v8 = min(v8, v13)\nif v8 == 10 ** 10:\n    print(-1)\nelse:\n    print(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = []\nv5 = []\nfor v6 in range(v1):\n    v7 = list(map(int, input().split()))\n    v4.append(v7[0])\n    v5.append(v7[1:])\nv8 = 10 ** 10\nfor v6 in range(2 ** v1):\n    v9 = [0 for v10 in range(v2)]\n    v11 = '{:b}'.format(v6)\n    v12 = v11.zfill(v1)\n    v13 = 0\n    for v14 in range(len(v12)):\n        if v12[v14] == '1':\n            for v15 in range(v2):\n                v9[v15] += v5[v14][v15]\n            v13 += v4[v14]\n    if all((u >= v3 for v16 in v9)):\n        v8 = min(v8, v13)\nif v8 == 10 ** 10:\n    print(-1)\nelse:\n    print(v8)\n"}
{"id": "human_code\\minimum-path-cost-in-a-hidden-grid.py", "text": "class C1(object):\n\n    def canMove(self, a1):\n        pass\n\n    def move(self, a1):\n        pass\n\n    def isTarget(self):\n        pass\nimport collections\nimport heapq\n\nclass C2(object):\n\n    def findShortestPath(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        v2 = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(a1, a2, a3, a4, a5):\n            if a2[0] is None and a3.isTarget():\n                a2[0] = a1\n            a4.add(a1)\n            for v1, (v2, v3) in v1.items():\n                if not a3.canMove(v1):\n                    continue\n                v4 = (a1[0] + v2, a1[1] + v3)\n                if v4 in a5[a1]:\n                    continue\n                a5[a1][v4] = a3.move(v1)\n                if v4 not in a4:\n                    dfs(v4, a2, a3, a4, a5)\n                a5[v4][a1] = a3.move(v2[v1])\n\n        def dijkstra(a1, a2, a3):\n            v1 = {a2: 0}\n            v2 = [(0, a2)]\n            while v2:\n                v3, v4 = heapq.heappop(v2)\n                if v1[v4] < v3:\n                    continue\n                for v5, v6 in a1[v4].items():\n                    if v5 in v1 and v1[v5] <= v3 + v6:\n                        continue\n                    v1[v5] = v3 + v6\n                    heapq.heappush(v2, (v3 + v6, v5))\n            return v1[a3] if a3 in v1 else -1\n        v3 = (0, 0)\n        v4 = [None]\n        v5 = collections.defaultdict(dict)\n        dfs(v3, v4, a1, set(), v5)\n        if not v4[0]:\n            return -1\n        return dijkstra(v5, v3, v4[0])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def canMove(self, a1):\n        pass\n\n    def move(self, a1):\n        pass\n\n    def isTarget(self):\n        pass\nimport collections\nimport heapq\n\nclass C2(object):\n\n    def findShortestPath(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        v2 = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(a1, a2, a3, a4, a5):\n            if a2[0] is None and a3.isTarget():\n                a2[0] = a1\n            a4.add(a1)\n            for v1, (v2, v3) in v1.items():\n                if not a3.canMove(v1):\n                    continue\n                v4 = (a1[0] + v2, a1[1] + v3)\n                if v4 in a5[a1]:\n                    continue\n                a5[a1][v4] = a3.move(v1)\n                if v4 not in a4:\n                    dfs(v4, a2, a3, a4, a5)\n                a5[v4][a1] = a3.move(v2[v1])\n\n        def dijkstra(a1, a2, a3):\n            v1 = {a2: 0}\n            v2 = [(0, a2)]\n            while v2:\n                v3, v4 = heapq.heappop(v2)\n                if v1[v4] < v3:\n                    continue\n                for v5, v6 in a1[v4].items():\n                    if v5 in v1 and v1[v5] <= v3 + v6:\n                        continue\n                    v1[v5] = v3 + v6\n                    heapq.heappush(v2, (v3 + v6, v5))\n            return v1[a3] if a3 in v1 else -1\n        v3 = (0, 0)\n        v4 = [None]\n        v5 = collections.defaultdict(dict)\n        dfs(v3, v4, a1, set(), v5)\n        if not v4[0]:\n            return -1\n        return dijkstra(v5, v3, v4[0])\n"}
{"id": "human_code\\determine-if-a-simple-graph-exists.py", "text": "class C1(object):\n\n    def simpleGraphExists(self, a1):\n        \"\"\"\n        \"\"\"\n        if sum(a1) % 2:\n            return False\n        a1.sort(reverse=True)\n        v1 = 0\n        v2 = sum(a1)\n        v3 = 0\n        v4 = len(a1) - 1\n        for v5 in range(1, len(a1) + 1):\n            v1 += a1[v5 - 1]\n            v2 -= a1[v5 - 1]\n            while v4 >= 0 and a1[v4] < v5:\n                v3 += a1[v4]\n                v4 -= 1\n            if not v1 <= v5 * (v5 - 1) + ((v4 - v5 + 1) * v5 + v3 if v4 - v5 + 1 > 0 else v2):\n                return False\n        return True\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def simpleGraphExists(self, a1):\n        \"\"\"\n        \"\"\"\n        if sum(a1) % 2:\n            return False\n        a1.sort(reverse=True)\n        v1 = 0\n        v2 = sum(a1)\n        v3 = 0\n        v4 = len(a1) - 1\n        for v5 in range(1, len(a1) + 1):\n            v1 += a1[v5 - 1]\n            v2 -= a1[v5 - 1]\n            while v4 >= 0 and a1[v4] < v5:\n                v3 += a1[v4]\n                v4 -= 1\n            if not v1 <= v5 * (v5 - 1) + ((v4 - v5 + 1) * v5 + v3 if v4 - v5 + 1 > 0 else v2):\n                return False\n        return True\n"}
{"id": "human_code\\subsequences-with-a-unique-middle-mode-i.py", "text": "import collections\n\nclass C1(object):\n\n    def subsequencesWithMiddleMode(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nC2(a1):\n            return a1 * (a1 - 1) // 2\n        v1 = 10 ** 9 + 7\n        v2 = 0\n        v3 = collections.defaultdict(int)\n        v4 = collections.defaultdict(int)\n        for v5 in a1:\n            v4[v5] += 1\n        v6 = 0\n        v7 = sum((v ** 2 for v8 in v4.values()))\n        v9 = 0\n        v10 = 0\n        v11 = 0\n        for v12, v8 in enumerate(a1):\n            v6 -= v3[v8] ** 2\n            v7 -= v4[v8] ** 2\n            v9 -= v3[v8] * v4[v8]\n            v10 -= v3[v8] ** 2 * v4[v8]\n            v11 -= v3[v8] * v4[v8] ** 2\n            v4[v8] -= 1\n            v13, v14 = (v12, len(a1) - (v12 + 1))\n            v2 += nC2(v13) * nC2(v14)\n            v2 -= nC2(v13 - v3[v8]) * nC2(v14 - v4[v8])\n            v2 -= ((v6 - (v13 - v3[v8])) * (v14 - v4[v8]) - (v10 - v9)) * v4[v8] // 2\n            v2 -= ((v7 - (v14 - v4[v8])) * (v13 - v3[v8]) - (v11 - v9)) * v3[v8] // 2\n            v2 -= v3[v8] * v9 * (v14 - v4[v8]) - v3[v8] * v11\n            v2 -= v4[v8] * v9 * (v13 - v3[v8]) - v4[v8] * v10\n            v2 -= v4[v8] * (v10 - v9) // 2\n            v2 -= v3[v8] * (v11 - v9) // 2\n            v3[v8] += 1\n            v6 += v3[v8] ** 2\n            v7 += v4[v8] ** 2\n            v9 += v3[v8] * v4[v8]\n            v10 += v3[v8] ** 2 * v4[v8]\n            v11 += v3[v8] * v4[v8] ** 2\n        return v2 % v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def subsequencesWithMiddleMode(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nC2(a1):\n            return a1 * (a1 - 1) // 2\n        v1 = 10 ** 9 + 7\n        v2 = 0\n        v3 = collections.defaultdict(int)\n        v4 = collections.defaultdict(int)\n        for v5 in a1:\n            v4[v5] += 1\n        v6 = 0\n        v7 = sum((v ** 2 for v8 in v4.values()))\n        v9 = 0\n        v10 = 0\n        v11 = 0\n        for v12, v8 in enumerate(a1):\n            v6 -= v3[v8] ** 2\n            v7 -= v4[v8] ** 2\n            v9 -= v3[v8] * v4[v8]\n            v10 -= v3[v8] ** 2 * v4[v8]\n            v11 -= v3[v8] * v4[v8] ** 2\n            v4[v8] -= 1\n            v13, v14 = (v12, len(a1) - (v12 + 1))\n            v2 += nC2(v13) * nC2(v14)\n            v2 -= nC2(v13 - v3[v8]) * nC2(v14 - v4[v8])\n            v2 -= ((v6 - (v13 - v3[v8])) * (v14 - v4[v8]) - (v10 - v9)) * v4[v8] // 2\n            v2 -= ((v7 - (v14 - v4[v8])) * (v13 - v3[v8]) - (v11 - v9)) * v3[v8] // 2\n            v2 -= v3[v8] * v9 * (v14 - v4[v8]) - v3[v8] * v11\n            v2 -= v4[v8] * v9 * (v13 - v3[v8]) - v4[v8] * v10\n            v2 -= v4[v8] * (v10 - v9) // 2\n            v2 -= v3[v8] * (v11 - v9) // 2\n            v3[v8] += 1\n            v6 += v3[v8] ** 2\n            v7 += v4[v8] ** 2\n            v9 += v3[v8] * v4[v8]\n            v10 += v3[v8] ** 2 * v4[v8]\n            v11 += v3[v8] * v4[v8] ** 2\n        return v2 % v1\n"}
{"id": "llm_code\\minimum-moves-to-move-a-box-to-their-target-location__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1(object):\n\n    def minPushBox(self, a1):\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def player_can_reach(a1, a2, a3, a4, a5, a6):\n            if a1 == a3 and a2 == a4:\n                return True\n            v1 = [(a1, a2)]\n            v2 = set([(a1, a2)])\n            while v1:\n                v3, v4 = v1.pop()\n                for v5, v6 in v3:\n                    v7 = v3 + v5\n                    v8 = v4 + v6\n                    v9 = (v7, v8)\n                    if 0 <= v7 < v1 and 0 <= v8 < v2 and (a1[v7][v8] != '#') and (v9 != (a5, a6)) and (v9 not in v2):\n                        if v7 == a3 and v8 == a4:\n                            return True\n                        v2.add(v9)\n                        v1.append(v9)\n            return False\n        v4 = v5 = v6 = v7 = v8 = v9 = None\n        for v10 in range(v1):\n            for v11 in range(v2):\n                if a1[v10][v11] == 'B':\n                    v4, v5 = (v10, v11)\n                elif a1[v10][v11] == 'S':\n                    v6, v7 = (v10, v11)\n                elif a1[v10][v11] == 'T':\n                    v8, v9 = (v10, v11)\n        v12 = deque([(v4, v5, v6, v7, 0)])\n        v13 = set([(v4, v5, v6, v7)])\n        while v12:\n            v14, v15, v16, v17, v18 = v12.popleft()\n            if v14 == v8 and v15 == v9:\n                return v18\n            for v19, v20 in v3:\n                v21 = v14 + v19\n                v22 = v15 + v20\n                if not (0 <= v21 < v1 and 0 <= v22 < v2 and (a1[v21][v22] != '#')):\n                    continue\n                v23 = v14 - v19\n                v24 = v15 - v20\n                if not (0 <= v23 < v1 and 0 <= v24 < v2 and (a1[v23][v24] != '#')):\n                    continue\n                if player_can_reach(v16, v17, v23, v24, v14, v15):\n                    v25 = v14\n                    v26 = v15\n                    v27 = (v21, v22, v25, v26)\n                    if v27 not in v13:\n                        v13.add(v27)\n                        v12.append((v21, v22, v25, v26, v18 + 1))\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1(object):\n\n    def minPushBox(self, a1):\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        def player_can_reach(a1, a2, a3, a4, a5, a6):\n            if a1 == a3 and a2 == a4:\n                return True\n            v1 = [(a1, a2)]\n            v2 = set([(a1, a2)])\n            while v1:\n                v3, v4 = v1.pop()\n                for v5, v6 in v3:\n                    v7 = v3 + v5\n                    v8 = v4 + v6\n                    v9 = (v7, v8)\n                    if 0 <= v7 < v1 and 0 <= v8 < v2 and (a1[v7][v8] != '#') and (v9 != (a5, a6)) and (v9 not in v2):\n                        if v7 == a3 and v8 == a4:\n                            return True\n                        v2.add(v9)\n                        v1.append(v9)\n            return False\n        v4 = v5 = v6 = v7 = v8 = v9 = None\n        for v10 in range(v1):\n            for v11 in range(v2):\n                if a1[v10][v11] == 'B':\n                    v4, v5 = (v10, v11)\n                elif a1[v10][v11] == 'S':\n                    v6, v7 = (v10, v11)\n                elif a1[v10][v11] == 'T':\n                    v8, v9 = (v10, v11)\n        v12 = deque([(v4, v5, v6, v7, 0)])\n        v13 = set([(v4, v5, v6, v7)])\n        while v12:\n            v14, v15, v16, v17, v18 = v12.popleft()\n            if v14 == v8 and v15 == v9:\n                return v18\n            for v19, v20 in v3:\n                v21 = v14 + v19\n                v22 = v15 + v20\n                if not (0 <= v21 < v1 and 0 <= v22 < v2 and (a1[v21][v22] != '#')):\n                    continue\n                v23 = v14 - v19\n                v24 = v15 - v20\n                if not (0 <= v23 < v1 and 0 <= v24 < v2 and (a1[v23][v24] != '#')):\n                    continue\n                if player_can_reach(v16, v17, v23, v24, v14, v15):\n                    v25 = v14\n                    v26 = v15\n                    v27 = (v21, v22, v25, v26)\n                    if v27 not in v13:\n                        v13.add(v27)\n                        v12.append((v21, v22, v25, v26, v18 + 1))\n        return -1\n"}
{"id": "human_code\\maximum-number-of-non-overlapping-substrings__part1.py", "text": "class C1(object):\n\n    def maxNumOfSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def find_right_from_left(a1, a2, a3, a4):\n            v1, v2 = (a3[ord(a1[a4]) - ord('a')], a4)\n            while v2 <= v1:\n                if a2[ord(a1[v2]) - ord('a')] < a4:\n                    return -1\n                v1 = max(v1, a3[ord(a1[v2]) - ord('a')])\n                v2 += 1\n            return v1\n        v1, v2 = ([float('inf')] * 26, [float('-inf')] * 26)\n        for v3, v4 in enumerate(a1):\n            v1[ord(v4) - ord('a')] = min(v1[ord(v4) - ord('a')], v3)\n            v2[ord(v4) - ord('a')] = max(v2[ord(v4) - ord('a')], v3)\n        v5 = ['']\n        v6 = float('inf')\n        for v7, v4 in enumerate(a1):\n            if v7 != v1[ord(v4) - ord('a')]:\n                continue\n            v8 = find_right_from_left(a1, v1, v2, v7)\n            if v8 == -1:\n                continue\n            if v7 > v6:\n                v5.append('')\n            v6 = v8\n            v5[-1] = a1[v7:v6 + 1]\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxNumOfSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def find_right_from_left(a1, a2, a3, a4):\n            v1, v2 = (a3[ord(a1[a4]) - ord('a')], a4)\n            while v2 <= v1:\n                if a2[ord(a1[v2]) - ord('a')] < a4:\n                    return -1\n                v1 = max(v1, a3[ord(a1[v2]) - ord('a')])\n                v2 += 1\n            return v1\n        v1, v2 = ([float('inf')] * 26, [float('-inf')] * 26)\n        for v3, v4 in enumerate(a1):\n            v1[ord(v4) - ord('a')] = min(v1[ord(v4) - ord('a')], v3)\n            v2[ord(v4) - ord('a')] = max(v2[ord(v4) - ord('a')], v3)\n        v5 = ['']\n        v6 = float('inf')\n        for v7, v4 in enumerate(a1):\n            if v7 != v1[ord(v4) - ord('a')]:\n                continue\n            v8 = find_right_from_left(a1, v1, v2, v7)\n            if v8 == -1:\n                continue\n            if v7 > v6:\n                v5.append('')\n            v6 = v8\n            v5[-1] = a1[v7:v6 + 1]\n        return v5\n"}
{"id": "llm_code\\minimum-operations-to-remove-adjacent-ones-in-matrix__grok-4.1-fast__v1.py", "text": "import sys\nsys.setrecursionlimit(10 ** 6)\n\nclass C1:\n\n    def minimumOperations(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v4 = []\n        v5 = []\n        for v6 in range(v1):\n            for v7 in range(v2):\n                if a1[v6][v7] == 1:\n                    v8 = v6 * v2 + v7\n                    if (v6 + v7) % 2 == 0:\n                        v4.append(v8)\n                    else:\n                        v5.append(v8)\n        v9 = v4 if len(v4) <= len(v5) else v5\n        v10 = v5 if len(v4) <= len(v5) else v4\n        v11 = len(v9)\n        v12 = len(v10)\n        if v11 == 0:\n            return 0\n        v13 = {v10[k]: k for v14 in range(v12)}\n        v15 = [[] for v16 in range(v11)]\n        for v17 in range(v11):\n            v18 = v9[v17]\n            v19, v20 = divmod(v18, v2)\n            for v21, v22 in v3:\n                v23 = v19 + v21\n                v24 = v20 + v22\n                if 0 <= v23 < v1 and 0 <= v24 < v2 and (a1[v23][v24] == 1):\n                    v25 = v23 * v2 + v24\n                    if v25 in v13:\n                        v15[v17].append(v13[v25])\n        v26 = [-1] * v11\n        v27 = [-1] * v12\n\n        def try_augment(a1, a2):\n            for v1 in v15[a1]:\n                if a2[v1]:\n                    continue\n                a2[v1] = True\n                if v27[v1] == -1 or try_augment(v27[v1], a2):\n                    v26[a1] = v1\n                    v27[v1] = a1\n                    return True\n            return False\n        v28 = 0\n        v29 = True\n        while v29:\n            v29 = False\n            v30 = [False] * v12\n            for v31 in range(v11):\n                if v26[v31] == -1 and try_augment(v31, v30):\n                    v28 += 1\n                    v29 = True\n        return v28\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\nclass C1:\n\n    def minimumOperations(self, a1):\n        if not a1 or not a1[0]:\n            return 0\n        v1 = len(a1)\n        v2 = len(a1[0])\n        v3 = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        v4 = []\n        v5 = []\n        for v6 in range(v1):\n            for v7 in range(v2):\n                if a1[v6][v7] == 1:\n                    v8 = v6 * v2 + v7\n                    if (v6 + v7) % 2 == 0:\n                        v4.append(v8)\n                    else:\n                        v5.append(v8)\n        v9 = v4 if len(v4) <= len(v5) else v5\n        v10 = v5 if len(v4) <= len(v5) else v4\n        v11 = len(v9)\n        v12 = len(v10)\n        if v11 == 0:\n            return 0\n        v13 = {v10[k]: k for v14 in range(v12)}\n        v15 = [[] for v16 in range(v11)]\n        for v17 in range(v11):\n            v18 = v9[v17]\n            v19, v20 = divmod(v18, v2)\n            for v21, v22 in v3:\n                v23 = v19 + v21\n                v24 = v20 + v22\n                if 0 <= v23 < v1 and 0 <= v24 < v2 and (a1[v23][v24] == 1):\n                    v25 = v23 * v2 + v24\n                    if v25 in v13:\n                        v15[v17].append(v13[v25])\n        v26 = [-1] * v11\n        v27 = [-1] * v12\n\n        def try_augment(a1, a2):\n            for v1 in v15[a1]:\n                if a2[v1]:\n                    continue\n                a2[v1] = True\n                if v27[v1] == -1 or try_augment(v27[v1], a2):\n                    v26[a1] = v1\n                    v27[v1] = a1\n                    return True\n            return False\n        v28 = 0\n        v29 = True\n        while v29:\n            v29 = False\n            v30 = [False] * v12\n            for v31 in range(v11):\n                if v26[v31] == -1 and try_augment(v31, v30):\n                    v28 += 1\n                    v29 = True\n        return v28\n"}
{"id": "llm_code\\p02603__s125991244.py", "text": "import copy, sys\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = []\nfor v4 in range(v1 - 1):\n    if v2[v4] != v2[v4 + 1]:\n        v3.append(v2[v4])\nif v2[-1] != v2[-2]:\n    v3.append(v2[-1])\nif not v3:\n    print(1000)\n    sys.exit()\nv5 = [v3[0]]\nfor v4 in range(1, len(v3) - 1):\n    if not (v3[v4 - 1] < v3[v4] < v3[v4 + 1] or v3[v4 - 1] > v3[v4] > v3[v4 + 1]):\n        v5.append(v3[v4])\nv5.append(v3[-1])\nv6 = 1000\nv7 = 0\nv8 = len(v5)\nfor v4 in range(v8 - 1):\n    if v5[v4] < v5[v4 + 1]:\n        v6 += v5[v4] * v7\n        v7 = 0\n    elif v6 > 0:\n        v7, v6 = divmod(v6, v5[v4])\nif len(v5) > 1 and v5[-1] > v5[-2]:\n    v6 += v5[-1] * v7\nprint(v6)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import copy, sys\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = []\nfor v4 in range(v1 - 1):\n    if v2[v4] != v2[v4 + 1]:\n        v3.append(v2[v4])\nif v2[-1] != v2[-2]:\n    v3.append(v2[-1])\nif not v3:\n    print(1000)\n    sys.exit()\nv5 = [v3[0]]\nfor v4 in range(1, len(v3) - 1):\n    if not (v3[v4 - 1] < v3[v4] < v3[v4 + 1] or v3[v4 - 1] > v3[v4] > v3[v4 + 1]):\n        v5.append(v3[v4])\nv5.append(v3[-1])\nv6 = 1000\nv7 = 0\nv8 = len(v5)\nfor v4 in range(v8 - 1):\n    if v5[v4] < v5[v4 + 1]:\n        v6 += v5[v4] * v7\n        v7 = 0\n    elif v6 > 0:\n        v7, v6 = divmod(v6, v5[v4])\nif len(v5) > 1 and v5[-1] > v5[-2]:\n    v6 += v5[-1] * v7\nprint(v6)\n"}
{"id": "llm_code\\count-the-number-of-k-free-subsets__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1(object):\n\n    def countTheNumOfKFreeSubsets(self, a1, a2):\n        v1 = collections.Counter(a1)\n        v2 = set(v1)\n        v3 = sorted(v1)\n        v4 = 1\n        for v5 in v3:\n            if v5 - a2 in v2:\n                continue\n            v6 = 1\n            v7 = 0\n            v8 = v5\n            while v8 in v1:\n                v9 = v1[v8]\n                v10 = 2 ** v9 - 1\n                v11 = v6 + v7\n                v12 = v6 * v10\n                v6 = v11\n                v7 = v12\n                v8 += a2\n            v13 = v6 + v7\n            v4 *= v13\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def countTheNumOfKFreeSubsets(self, a1, a2):\n        v1 = collections.Counter(a1)\n        v2 = set(v1)\n        v3 = sorted(v1)\n        v4 = 1\n        for v5 in v3:\n            if v5 - a2 in v2:\n                continue\n            v6 = 1\n            v7 = 0\n            v8 = v5\n            while v8 in v1:\n                v9 = v1[v8]\n                v10 = 2 ** v9 - 1\n                v11 = v6 + v7\n                v12 = v6 * v10\n                v6 = v11\n                v7 = v12\n                v8 += a2\n            v13 = v6 + v7\n            v4 *= v13\n        return v4\n"}
{"id": "human_code\\largest-divisible-subset.py", "text": "class C1(object):\n\n    def largestDivisibleSubset(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1:\n            return []\n        a1.sort()\n        v1 = [1] * len(a1)\n        v2 = [-1] * len(a1)\n        v3 = 0\n        for v4 in range(len(a1)):\n            for v5 in range(v4):\n                if a1[v4] % a1[v5] == 0:\n                    if v1[v4] < v1[v5] + 1:\n                        v1[v4] = v1[v5] + 1\n                        v2[v4] = v5\n            if v1[v3] < v1[v4]:\n                v3 = v4\n        v6 = []\n        v4 = v3\n        while v4 != -1:\n            v6.append(a1[v4])\n            v4 = v2[v4]\n        return v6[::-1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def largestDivisibleSubset(self, a1):\n        \"\"\"\n        \"\"\"\n        if not a1:\n            return []\n        a1.sort()\n        v1 = [1] * len(a1)\n        v2 = [-1] * len(a1)\n        v3 = 0\n        for v4 in range(len(a1)):\n            for v5 in range(v4):\n                if a1[v4] % a1[v5] == 0:\n                    if v1[v4] < v1[v5] + 1:\n                        v1[v4] = v1[v5] + 1\n                        v2[v4] = v5\n            if v1[v3] < v1[v4]:\n                v3 = v4\n        v6 = []\n        v4 = v3\n        while v4 != -1:\n            v6.append(a1[v4])\n            v4 = v2[v4]\n        return v6[::-1]\n"}
{"id": "llm_code\\n-ary-tree-level-order-traversal__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a1\n        self.children = a2\n\nclass C2(object):\n\n    def levelOrder(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        v2 = [a1]\n        while v2:\n            v3 = []\n            v4 = len(v2)\n            for v5 in range(v4):\n                v6 = v2.pop(0)\n                v3.append(v6.val)\n                for v7 in v6.children:\n                    if v7:\n                        v2.append(v7)\n            v1.append(v3)\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a1\n        self.children = a2\n\nclass C2(object):\n\n    def levelOrder(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        v2 = [a1]\n        while v2:\n            v3 = []\n            v4 = len(v2)\n            for v5 in range(v4):\n                v6 = v2.pop(0)\n                v3.append(v6.val)\n                for v7 in v6.children:\n                    if v7:\n                        v2.append(v7)\n            v1.append(v3)\n        return v1\n"}
{"id": "llm_code\\stamping-the-sequence__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1(object):\n\n    def movesToStamp(self, a1, a2):\n        v1 = len(a1)\n        v2 = len(a2)\n        if v1 == 0:\n            return []\n        v3 = v2 - v1 + 1\n        v4 = [0] * v3\n        v5 = [[] for v6 in range(v3)]\n        v7 = [[] for v6 in range(v2)]\n        for v8 in range(v3):\n            for v9 in range(v1):\n                v10 = v8 + v9\n                if a2[v10] == a1[v9]:\n                    v5[v8].append(v10)\n                else:\n                    v4[v8] += 1\n                    v7[v10].append(v8)\n        v11 = deque()\n        v12 = [False] * v2\n        v13 = []\n        for v8 in range(v3):\n            if v4[v8] == 0:\n                v13.append(v8)\n                for v10 in v5[v8]:\n                    if not v12[v10]:\n                        v12[v10] = True\n                        v11.append(v10)\n        while v11:\n            v14 = v11.popleft()\n            for v8 in v7[v14]:\n                v4[v8] -= 1\n                if v4[v8] == 0:\n                    v13.append(v8)\n                    for v10 in v5[v8]:\n                        if not v12[v10]:\n                            v12[v10] = True\n                            v11.append(v10)\n        return v13[::-1] if all(v12) else []\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1(object):\n\n    def movesToStamp(self, a1, a2):\n        v1 = len(a1)\n        v2 = len(a2)\n        if v1 == 0:\n            return []\n        v3 = v2 - v1 + 1\n        v4 = [0] * v3\n        v5 = [[] for v6 in range(v3)]\n        v7 = [[] for v6 in range(v2)]\n        for v8 in range(v3):\n            for v9 in range(v1):\n                v10 = v8 + v9\n                if a2[v10] == a1[v9]:\n                    v5[v8].append(v10)\n                else:\n                    v4[v8] += 1\n                    v7[v10].append(v8)\n        v11 = deque()\n        v12 = [False] * v2\n        v13 = []\n        for v8 in range(v3):\n            if v4[v8] == 0:\n                v13.append(v8)\n                for v10 in v5[v8]:\n                    if not v12[v10]:\n                        v12[v10] = True\n                        v11.append(v10)\n        while v11:\n            v14 = v11.popleft()\n            for v8 in v7[v14]:\n                v4[v8] -= 1\n                if v4[v8] == 0:\n                    v13.append(v8)\n                    for v10 in v5[v8]:\n                        if not v12[v10]:\n                            v12[v10] = True\n                            v11.append(v10)\n        return v13[::-1] if all(v12) else []\n"}
{"id": "human_code\\minimize-hamming-distance-after-swap-operations__part1.py", "text": "class C1(object):\n\n    def minimumHammingDistance(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def iter_flood_fill(a1, a2, a3, a4):\n            v1 = [a2]\n            while v1:\n                a2 = v1.pop()\n                if a2 in a3:\n                    continue\n                a3.add(a2)\n                a4.append(a2)\n                for v3 in a1[a2]:\n                    v1.append(v3)\n        v1 = [set() for v2 in range(len(a1))]\n        for v2, v3 in a3:\n            v1[v2].add(v3)\n            v1[v3].add(v2)\n        v4 = 0\n        v5 = set()\n        for v2 in range(len(a1)):\n            if v2 in v5:\n                continue\n            v6 = []\n            iter_flood_fill(v1, v2, v5, v6)\n            v7 = collections.Counter([a1[v2] for v2 in v6])\n            v8 = collections.Counter([a2[v2] for v2 in v6])\n            v9 = v7 - v8\n            v4 += sum(v9.values())\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumHammingDistance(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def iter_flood_fill(a1, a2, a3, a4):\n            v1 = [a2]\n            while v1:\n                a2 = v1.pop()\n                if a2 in a3:\n                    continue\n                a3.add(a2)\n                a4.append(a2)\n                for v3 in a1[a2]:\n                    v1.append(v3)\n        v1 = [set() for v2 in range(len(a1))]\n        for v2, v3 in a3:\n            v1[v2].add(v3)\n            v1[v3].add(v2)\n        v4 = 0\n        v5 = set()\n        for v2 in range(len(a1)):\n            if v2 in v5:\n                continue\n            v6 = []\n            iter_flood_fill(v1, v2, v5, v6)\n            v7 = collections.Counter([a1[v2] for v2 in v6])\n            v8 = collections.Counter([a2[v2] for v2 in v6])\n            v9 = v7 - v8\n            v4 += sum(v9.values())\n        return v4\n"}
{"id": "llm_code\\robot-collisions__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def survivedRobotsHealths(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = sorted(range(v1), key=a1.__getitem__)\n        v3 = []\n        for v4 in v2:\n            if a3[v4] == 'R':\n                v3.append(v4)\n                continue\n            while v3:\n                v5 = v3.pop()\n                v6 = a2[v5]\n                v7 = a2[v4]\n                if v6 > v7:\n                    a2[v5] = v6 - 1\n                    v3.append(v5)\n                    a2[v4] = 0\n                    break\n                if v6 < v7:\n                    a2[v5] = 0\n                    a2[v4] = v7 - 1\n                else:\n                    a2[v5] = 0\n                    a2[v4] = 0\n                    break\n        return [hp for v8 in a2 if v8 > 0]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def survivedRobotsHealths(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = sorted(range(v1), key=a1.__getitem__)\n        v3 = []\n        for v4 in v2:\n            if a3[v4] == 'R':\n                v3.append(v4)\n                continue\n            while v3:\n                v5 = v3.pop()\n                v6 = a2[v5]\n                v7 = a2[v4]\n                if v6 > v7:\n                    a2[v5] = v6 - 1\n                    v3.append(v5)\n                    a2[v4] = 0\n                    break\n                if v6 < v7:\n                    a2[v5] = 0\n                    a2[v4] = v7 - 1\n                else:\n                    a2[v5] = 0\n                    a2[v4] = 0\n                    break\n        return [hp for v8 in a2 if v8 > 0]\n"}
{"id": "human_code\\sequence-reconstruction__part2.py", "text": "class C1(object):\n\n    def sequenceReconstruction(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(set)\n        v2 = collections.defaultdict(int)\n        v3 = set()\n        for v4 in a2:\n            for v5 in v4:\n                v3.add(v5)\n            if len(v4) == 1:\n                if v4[0] not in v2:\n                    v2[v4[0]] = 0\n                continue\n            for v5 in range(len(v4) - 1):\n                if v4[v5] not in v2:\n                    v2[v4[v5]] = 0\n                if v4[v5 + 1] not in v1[v4[v5]]:\n                    v1[v4[v5]].add(v4[v5 + 1])\n                    v2[v4[v5 + 1]] += 1\n        v6 = 0\n        v7 = []\n        v8 = []\n        for v5 in v2:\n            if v2[v5] == 0:\n                v6 += 1\n                if v6 > 1:\n                    return False\n                v8.append(v5)\n        while v8:\n            v5 = v8.pop()\n            v7.append(v5)\n            v6 = 0\n            for v9 in v1[v5]:\n                v2[v9] -= 1\n                if v2[v9] == 0:\n                    v6 += 1\n                    if v6 > 1:\n                        return False\n                    v8.append(v9)\n        return v7 == a1 and len(a1) == len(v3)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def sequenceReconstruction(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(set)\n        v2 = collections.defaultdict(int)\n        v3 = set()\n        for v4 in a2:\n            for v5 in v4:\n                v3.add(v5)\n            if len(v4) == 1:\n                if v4[0] not in v2:\n                    v2[v4[0]] = 0\n                continue\n            for v5 in range(len(v4) - 1):\n                if v4[v5] not in v2:\n                    v2[v4[v5]] = 0\n                if v4[v5 + 1] not in v1[v4[v5]]:\n                    v1[v4[v5]].add(v4[v5 + 1])\n                    v2[v4[v5 + 1]] += 1\n        v6 = 0\n        v7 = []\n        v8 = []\n        for v5 in v2:\n            if v2[v5] == 0:\n                v6 += 1\n                if v6 > 1:\n                    return False\n                v8.append(v5)\n        while v8:\n            v5 = v8.pop()\n            v7.append(v5)\n            v6 = 0\n            for v9 in v1[v5]:\n                v2[v9] -= 1\n                if v2[v9] == 0:\n                    v6 += 1\n                    if v6 > 1:\n                        return False\n                    v8.append(v9)\n        return v7 == a1 and len(a1) == len(v3)\n"}
{"id": "llm_code\\count-pairs-of-points-with-distance-k__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1(object):\n\n    def countPairs(self, a1, a2):\n        v1 = collections.Counter((tuple(p) for v2 in a1))\n        v3 = 0\n        for v4 in v1:\n            v5, v6 = v4\n            for v7 in range(a2 + 1):\n                v8 = v5 ^ v7\n                v9 = v6 ^ a2 - v7\n                v10 = (v8, v9)\n                if v10 < v4:\n                    continue\n                v11 = v1[v4]\n                v12 = v1[v10]\n                if v10 == v4:\n                    v3 += v11 * (v11 - 1) // 2\n                else:\n                    v3 += v11 * v12\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def countPairs(self, a1, a2):\n        v1 = collections.Counter((tuple(p) for v2 in a1))\n        v3 = 0\n        for v4 in v1:\n            v5, v6 = v4\n            for v7 in range(a2 + 1):\n                v8 = v5 ^ v7\n                v9 = v6 ^ a2 - v7\n                v10 = (v8, v9)\n                if v10 < v4:\n                    continue\n                v11 = v1[v4]\n                v12 = v1[v10]\n                if v10 == v4:\n                    v3 += v11 * (v11 - 1) // 2\n                else:\n                    v3 += v11 * v12\n        return v3\n"}
{"id": "llm_code\\design-excel-sum-formula__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def __init__(self, a1, a2):\n        v1 = ord(a2) - ord('A') + 1\n        self.cells = [[0] * v1 for v2 in range(a1 + 1)]\n        self.outgoing = collections.defaultdict(lambda: collections.defaultdict(int))\n        self.incoming = collections.defaultdict(set)\n\n    def set(self, a1, a2, a3):\n        v1 = ord(a2) - ord('A')\n        self._unlink(a1, v1)\n        v2 = self.cells[a1][v1]\n        self.cells[a1][v1] = a3\n        self._ripple(a1, v1, a3 - v2)\n\n    def get(self, a1, a2):\n        return self.cells[a1][ord(a2) - ord('A')]\n\n    def sum(self, a1, a2, a3):\n        v1 = ord(a2) - ord('A')\n        self._unlink(a1, v1)\n        v2 = 0\n        v3 = set()\n        for v4 in a3:\n            v5 = v4.split(':')\n            v6 = v5[0]\n            v7 = v5[1] if len(v5) > 1 else v6\n            v8 = ord(v6[0]) - ord('A')\n            v9 = int(v6[1:])\n            v10 = ord(v7[0]) - ord('A')\n            v11 = int(v7[1:])\n            for v12 in range(v9, v11 + 1):\n                for v13 in range(v8, v10 + 1):\n                    v2 += self.cells[v12][v13]\n                    v14 = (v12, v13)\n                    self.outgoing[v14][a1, v1] += 1\n                    v3.add(v14)\n        self.incoming[a1, v1] = v3\n        v15 = self.cells[a1][v1]\n        self.cells[a1][v1] = v2\n        self._ripple(a1, v1, v2 - v15)\n        return v2\n\n    def _unlink(self, a1, a2):\n        v1 = self.incoming[a1, a2]\n        for v2, v3 in v1:\n            self.outgoing[v2, v3].pop((a1, a2), None)\n        self.incoming[a1, a2].clear()\n\n    def _ripple(self, a1, a2, a3):\n        if not a3:\n            return\n        v1 = collections.deque([((a1, a2), a3)])\n        while v1:\n            v2, v3 = v1.popleft()\n            for v4, v5 in self.outgoing[v2].items():\n                v6 = v3 * v5\n                v7, v8 = v4\n                self.cells[v7][v8] += v6\n                v1.append((v4, v6))\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def __init__(self, a1, a2):\n        v1 = ord(a2) - ord('A') + 1\n        self.cells = [[0] * v1 for v2 in range(a1 + 1)]\n        self.outgoing = collections.defaultdict(lambda: collections.defaultdict(int))\n        self.incoming = collections.defaultdict(set)\n\n    def set(self, a1, a2, a3):\n        v1 = ord(a2) - ord('A')\n        self._unlink(a1, v1)\n        v2 = self.cells[a1][v1]\n        self.cells[a1][v1] = a3\n        self._ripple(a1, v1, a3 - v2)\n\n    def get(self, a1, a2):\n        return self.cells[a1][ord(a2) - ord('A')]\n\n    def sum(self, a1, a2, a3):\n        v1 = ord(a2) - ord('A')\n        self._unlink(a1, v1)\n        v2 = 0\n        v3 = set()\n        for v4 in a3:\n            v5 = v4.split(':')\n            v6 = v5[0]\n            v7 = v5[1] if len(v5) > 1 else v6\n            v8 = ord(v6[0]) - ord('A')\n            v9 = int(v6[1:])\n            v10 = ord(v7[0]) - ord('A')\n            v11 = int(v7[1:])\n            for v12 in range(v9, v11 + 1):\n                for v13 in range(v8, v10 + 1):\n                    v2 += self.cells[v12][v13]\n                    v14 = (v12, v13)\n                    self.outgoing[v14][a1, v1] += 1\n                    v3.add(v14)\n        self.incoming[a1, v1] = v3\n        v15 = self.cells[a1][v1]\n        self.cells[a1][v1] = v2\n        self._ripple(a1, v1, v2 - v15)\n        return v2\n\n    def _unlink(self, a1, a2):\n        v1 = self.incoming[a1, a2]\n        for v2, v3 in v1:\n            self.outgoing[v2, v3].pop((a1, a2), None)\n        self.incoming[a1, a2].clear()\n\n    def _ripple(self, a1, a2, a3):\n        if not a3:\n            return\n        v1 = collections.deque([((a1, a2), a3)])\n        while v1:\n            v2, v3 = v1.popleft()\n            for v4, v5 in self.outgoing[v2].items():\n                v6 = v3 * v5\n                v7, v8 = v4\n                self.cells[v7][v8] += v6\n                v1.append((v4, v6))\n"}
{"id": "llm_code\\design-compressed-string-iterator__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.s = a1\n        self.ptr = 0\n        self.letter = ' '\n        self.remaining = 0\n\n    def __next__(self):\n        if self.remaining == 0:\n            if self.ptr >= len(self.s):\n                return ' '\n            self.letter = self.s[self.ptr]\n            self.ptr += 1\n            v1 = 0\n            while self.ptr < len(self.s) and self.s[self.ptr].isdigit():\n                v1 = v1 * 10 + int(self.s[self.ptr])\n                self.ptr += 1\n            self.remaining = v1\n        self.remaining -= 1\n        return self.letter\n\n    def hasNext(self):\n        return self.remaining > 0 or self.ptr < len(self.s)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.s = a1\n        self.ptr = 0\n        self.letter = ' '\n        self.remaining = 0\n\n    def __next__(self):\n        if self.remaining == 0:\n            if self.ptr >= len(self.s):\n                return ' '\n            self.letter = self.s[self.ptr]\n            self.ptr += 1\n            v1 = 0\n            while self.ptr < len(self.s) and self.s[self.ptr].isdigit():\n                v1 = v1 * 10 + int(self.s[self.ptr])\n                self.ptr += 1\n            self.remaining = v1\n        self.remaining -= 1\n        return self.letter\n\n    def hasNext(self):\n        return self.remaining > 0 or self.ptr < len(self.s)\n"}
{"id": "human_code\\p03806__s167386631.py", "text": "import sys\n\ndef f1():\n\n    def dfs(a1, a2, a3, a4, a5):\n        if a1 == a2:\n            if a4 == 0:\n                return\n            if a3 not in a5:\n                a5[a3] = a4\n            else:\n                a5[a3] = min(a5[a3], a4)\n            return\n        v1, v2, v3 = table[a1]\n        dfs(a1 + 1, a2, a3 + v2 * Ma - v1 * Mb, a4 + v3, a5)\n        dfs(a1 + 1, a2, a3, a4, a5)\n    v1, v2, v3 = map(int, input().split())\n    v4 = [tuple(map(int, input().split())) for v5 in range(v1)]\n    v6, v7 = (dict(), dict())\n    dfs(0, v1 // 2, 0, 0, v6)\n    dfs(v1 // 2, v1, 0, 0, v7)\n    v8 = 100 * 40 + 1\n    v9 = v8\n    if 0 in v6:\n        v9 = min(v9, v6[0])\n    if 0 in v7:\n        v9 = min(v9, v7[0])\n    for v10, v11 in v6.items():\n        if -v10 in v7:\n            v12 = v11 + v7[-v10]\n            v9 = min(v9, v12)\n    if v9 < v8:\n        print(v9)\n    else:\n        print(-1)\n\ndef f3(a1, a2):\n    for v1, v2 in a2.items():\n        if a1 is v2:\n            print('DEBUG:{} -> {}'.format(v1, v2), file=sys.stderr)\n            return None\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\n\ndef f1():\n\n    def dfs(a1, a2, a3, a4, a5):\n        if a1 == a2:\n            if a4 == 0:\n                return\n            if a3 not in a5:\n                a5[a3] = a4\n            else:\n                a5[a3] = min(a5[a3], a4)\n            return\n        v1, v2, v3 = table[a1]\n        dfs(a1 + 1, a2, a3 + v2 * Ma - v1 * Mb, a4 + v3, a5)\n        dfs(a1 + 1, a2, a3, a4, a5)\n    v1, v2, v3 = map(int, input().split())\n    v4 = [tuple(map(int, input().split())) for v5 in range(v1)]\n    v6, v7 = (dict(), dict())\n    dfs(0, v1 // 2, 0, 0, v6)\n    dfs(v1 // 2, v1, 0, 0, v7)\n    v8 = 100 * 40 + 1\n    v9 = v8\n    if 0 in v6:\n        v9 = min(v9, v6[0])\n    if 0 in v7:\n        v9 = min(v9, v7[0])\n    for v10, v11 in v6.items():\n        if -v10 in v7:\n            v12 = v11 + v7[-v10]\n            v9 = min(v9, v12)\n    if v9 < v8:\n        print(v9)\n    else:\n        print(-1)\n\ndef f3(a1, a2):\n    for v1, v2 in a2.items():\n        if a1 is v2:\n            print('DEBUG:{} -> {}'.format(v1, v2), file=sys.stderr)\n            return None\nif __name__ == '__main__':\n    f1()\n"}
{"id": "llm_code\\range-xor-queries-with-subarray-reversals__grok-4.1-fast__v1.py", "text": "import random\n\nclass C1:\n\n    class Node:\n\n        def __init__(self, a1):\n            self.val = a1\n            self.prio = random.randrange(1 << 31)\n            self.sz = 1\n            self.xsum = a1\n            self.flip = False\n            self.lc = None\n            self.rc = None\n\n    def __init__(self, a1):\n        self.root = self._build(a1, 0, len(a1))\n\n    def _build(self, a1, a2, a3):\n        if a2 == a3:\n            return None\n        v1 = (a2 + a3) // 2\n        v2 = self.Node(a1[v1])\n        v2.lc = self._build(a1, a2, v1)\n        v2.rc = self._build(a1, v1 + 1, a3)\n        self._update_node(v2)\n        return v2\n\n    def _get_size(self, a1):\n        return a1.sz if a1 else 0\n\n    def _get_xor(self, a1):\n        return a1.xsum if a1 else 0\n\n    def _push(self, a1):\n        if not a1 or not a1.flip:\n            return\n        a1.flip = False\n        a1.lc, a1.rc = (a1.rc, a1.lc)\n        if a1.lc:\n            a1.lc.flip = not a1.lc.flip\n        if a1.rc:\n            a1.rc.flip = not a1.rc.flip\n\n    def _update_node(self, a1):\n        if a1:\n            a1.sz = 1 + self._get_size(a1.lc) + self._get_size(a1.rc)\n            a1.xsum = a1.val ^ self._get_xor(a1.lc) ^ self._get_xor(a1.rc)\n\n    def _split(self, a1, a2):\n        if a1 is None:\n            return (None, None)\n        self._push(a1)\n        v1 = self._get_size(a1.lc)\n        if v1 >= a2:\n            v2, a1.lc = self._split(a1.lc, a2)\n            self._update_node(a1)\n            return (v2, a1)\n        else:\n            a1.rc, v3 = self._split(a1.rc, a2 - v1 - 1)\n            self._update_node(a1)\n            return (a1, v3)\n\n    def _merge(self, a1, a2):\n        self._push(a1)\n        self._push(a2)\n        if a1 is None:\n            return a2\n        if a2 is None:\n            return a1\n        if a1.prio > a2.prio:\n            a1.rc = self._merge(a1.rc, a2)\n            self._update_node(a1)\n            return a1\n        a2.lc = self._merge(a1, a2.lc)\n        self._update_node(a2)\n        return a2\n\n    def update(self, a1, a2):\n        v1, v2 = self._split(self.root, a1 - 1)\n        v2, v3 = self._split(v2, 1)\n        if v2:\n            v2.val = a2\n            self._update_node(v2)\n        self.root = self._merge(self._merge(v1, v2), v3)\n\n    def query(self, a1, a2):\n        v1, v2 = self._split(self.root, a1 - 1)\n        v2, v3 = self._split(v2, a2 - a1 + 1)\n        v4 = self._get_xor(v2)\n        self.root = self._merge(self._merge(v1, v2), v3)\n        return v4\n\n    def reverse(self, a1, a2):\n        v1, v2 = self._split(self.root, a1 - 1)\n        v2, v3 = self._split(v2, a2 - a1 + 1)\n        if v2:\n            v2.flip = not v2.flip\n        self.root = self._merge(self._merge(v1, v2), v3)\n\nclass C3:\n\n    def getResults(self, a1, a2):\n        v1 = C1(a1)\n        v2 = []\n        for v3 in a2:\n            v4, v5, v6 = v3\n            if v4 == 1:\n                v1.update(v5, v6)\n            elif v4 == 2:\n                v2.append(v1.query(v5, v6))\n            elif v4 == 3:\n                v1.reverse(v5, v6)\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1:\n\n    class Node:\n\n        def __init__(self, a1):\n            self.val = a1\n            self.prio = random.randrange(1 << 31)\n            self.sz = 1\n            self.xsum = a1\n            self.flip = False\n            self.lc = None\n            self.rc = None\n\n    def __init__(self, a1):\n        self.root = self._build(a1, 0, len(a1))\n\n    def _build(self, a1, a2, a3):\n        if a2 == a3:\n            return None\n        v1 = (a2 + a3) // 2\n        v2 = self.Node(a1[v1])\n        v2.lc = self._build(a1, a2, v1)\n        v2.rc = self._build(a1, v1 + 1, a3)\n        self._update_node(v2)\n        return v2\n\n    def _get_size(self, a1):\n        return a1.sz if a1 else 0\n\n    def _get_xor(self, a1):\n        return a1.xsum if a1 else 0\n\n    def _push(self, a1):\n        if not a1 or not a1.flip:\n            return\n        a1.flip = False\n        a1.lc, a1.rc = (a1.rc, a1.lc)\n        if a1.lc:\n            a1.lc.flip = not a1.lc.flip\n        if a1.rc:\n            a1.rc.flip = not a1.rc.flip\n\n    def _update_node(self, a1):\n        if a1:\n            a1.sz = 1 + self._get_size(a1.lc) + self._get_size(a1.rc)\n            a1.xsum = a1.val ^ self._get_xor(a1.lc) ^ self._get_xor(a1.rc)\n\n    def _split(self, a1, a2):\n        if a1 is None:\n            return (None, None)\n        self._push(a1)\n        v1 = self._get_size(a1.lc)\n        if v1 >= a2:\n            v2, a1.lc = self._split(a1.lc, a2)\n            self._update_node(a1)\n            return (v2, a1)\n        else:\n            a1.rc, v3 = self._split(a1.rc, a2 - v1 - 1)\n            self._update_node(a1)\n            return (a1, v3)\n\n    def _merge(self, a1, a2):\n        self._push(a1)\n        self._push(a2)\n        if a1 is None:\n            return a2\n        if a2 is None:\n            return a1\n        if a1.prio > a2.prio:\n            a1.rc = self._merge(a1.rc, a2)\n            self._update_node(a1)\n            return a1\n        a2.lc = self._merge(a1, a2.lc)\n        self._update_node(a2)\n        return a2\n\n    def update(self, a1, a2):\n        v1, v2 = self._split(self.root, a1 - 1)\n        v2, v3 = self._split(v2, 1)\n        if v2:\n            v2.val = a2\n            self._update_node(v2)\n        self.root = self._merge(self._merge(v1, v2), v3)\n\n    def query(self, a1, a2):\n        v1, v2 = self._split(self.root, a1 - 1)\n        v2, v3 = self._split(v2, a2 - a1 + 1)\n        v4 = self._get_xor(v2)\n        self.root = self._merge(self._merge(v1, v2), v3)\n        return v4\n\n    def reverse(self, a1, a2):\n        v1, v2 = self._split(self.root, a1 - 1)\n        v2, v3 = self._split(v2, a2 - a1 + 1)\n        if v2:\n            v2.flip = not v2.flip\n        self.root = self._merge(self._merge(v1, v2), v3)\n\nclass C3:\n\n    def getResults(self, a1, a2):\n        v1 = C1(a1)\n        v2 = []\n        for v3 in a2:\n            v4, v5, v6 = v3\n            if v4 == 1:\n                v1.update(v5, v6)\n            elif v4 == 2:\n                v2.append(v1.query(v5, v6))\n            elif v4 == 3:\n                v1.reverse(v5, v6)\n        return v2\n"}
{"id": "llm_code\\connecting-cities-with-minimum-cost__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n        self.rank = [0] * a1\n        self.components = a1\n\n    def find(self, a1):\n        if self.parent[a1] != a1:\n            self.parent[a1] = self.find(self.parent[a1])\n        return self.parent[a1]\n\n    def merge(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.parent[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.parent[v2] = v1\n        else:\n            self.parent[v2] = v1\n            self.rank[v1] += 1\n        self.components -= 1\n        return True\n\nclass C2:\n\n    def minimumCost(self, a1, a2):\n        v1 = sorted(a2, key=lambda edge: edge[2])\n        v2 = C1(a1)\n        v3 = 0\n        for v4, v5, v6 in v1:\n            if v2.merge(v4 - 1, v5 - 1):\n                v3 += v6\n        return v3 if v2.components == 1 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n        self.rank = [0] * a1\n        self.components = a1\n\n    def find(self, a1):\n        if self.parent[a1] != a1:\n            self.parent[a1] = self.find(self.parent[a1])\n        return self.parent[a1]\n\n    def merge(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.parent[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.parent[v2] = v1\n        else:\n            self.parent[v2] = v1\n            self.rank[v1] += 1\n        self.components -= 1\n        return True\n\nclass C2:\n\n    def minimumCost(self, a1, a2):\n        v1 = sorted(a2, key=lambda edge: edge[2])\n        v2 = C1(a1)\n        v3 = 0\n        for v4, v5, v6 in v1:\n            if v2.merge(v4 - 1, v5 - 1):\n                v3 += v6\n        return v3 if v2.components == 1 else -1\n"}
{"id": "llm_code\\stamping-the-grid__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def possibleToStamp(self, a1, a2, a3):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [[0] * (v2 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v3[v5 + 1][v6 + 1] = v3[v5 + 1][v6] + v3[v5][v6 + 1] - v3[v5][v6] + (1 - a1[v5][v6])\n        v7 = [[0] * v2 for v4 in range(v1)]\n        for v5 in range(a2 - 1, v1):\n            for v6 in range(a3 - 1, v2):\n                v8 = v5 - a2 + 1\n                v9 = v6 - a3 + 1\n                v10 = v3[v5 + 1][v6 + 1] - v3[v8][v6 + 1] - v3[v5 + 1][v9] + v3[v8][v9]\n                if v10 == a2 * a3:\n                    v7[v5][v6] = 1\n        v11 = [[0] * (v2 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v11[v5 + 1][v6 + 1] = v11[v5 + 1][v6] + v11[v5][v6 + 1] - v11[v5][v6] + v7[v5][v6]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                if a1[v5][v6] == 0:\n                    v12 = min(v5 + a2, v1)\n                    v13 = min(v6 + a3, v2)\n                    v14 = v11[v12][v13] - v11[v5][v13] - v11[v12][v6] + v11[v5][v6]\n                    if v14 == 0:\n                        return False\n        return True\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def possibleToStamp(self, a1, a2, a3):\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = [[0] * (v2 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v3[v5 + 1][v6 + 1] = v3[v5 + 1][v6] + v3[v5][v6 + 1] - v3[v5][v6] + (1 - a1[v5][v6])\n        v7 = [[0] * v2 for v4 in range(v1)]\n        for v5 in range(a2 - 1, v1):\n            for v6 in range(a3 - 1, v2):\n                v8 = v5 - a2 + 1\n                v9 = v6 - a3 + 1\n                v10 = v3[v5 + 1][v6 + 1] - v3[v8][v6 + 1] - v3[v5 + 1][v9] + v3[v8][v9]\n                if v10 == a2 * a3:\n                    v7[v5][v6] = 1\n        v11 = [[0] * (v2 + 1) for v4 in range(v1 + 1)]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v11[v5 + 1][v6 + 1] = v11[v5 + 1][v6] + v11[v5][v6 + 1] - v11[v5][v6] + v7[v5][v6]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                if a1[v5][v6] == 0:\n                    v12 = min(v5 + a2, v1)\n                    v13 = min(v6 + a3, v2)\n                    v14 = v11[v12][v13] - v11[v5][v13] - v11[v12][v6] + v11[v5][v6]\n                    if v14 == 0:\n                        return False\n        return True\n"}
{"id": "human_code\\lexicographically-smallest-generated-string__part2.py", "text": "import collections\n\nclass C1(object):\n\n    def generateString(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def z_function(a1):\n            v1 = [0] * len(a1)\n            v2, v3 = (0, 0)\n            for v4 in range(1, len(v1)):\n                if v4 <= v3:\n                    v1[v4] = min(v3 - v4 + 1, v1[v4 - v2])\n                while v4 + v1[v4] < len(v1) and a1[v1[v4]] == a1[v4 + v1[v4]]:\n                    v1[v4] += 1\n                if v4 + v1[v4] - 1 > v3:\n                    v2, v3 = (v4, v4 + v1[v4] - 1)\n            return v1\n        v1, v2 = (len(a1), len(a2))\n        v3 = ['*'] * (v1 + v2 - 1)\n        v4 = z_function(a2)\n        v5 = -v2\n        for v6, v7 in enumerate(a1):\n            if v7 != 'T':\n                continue\n            v8 = v6 - v5\n            if v8 < v2:\n                if v4[v8] == v2 - v8:\n                    v3[v5 + v2:v6 + v2] = a2[v2 - v8:]\n                else:\n                    return ''\n            else:\n                v3[v6:v6 + v2] = a2\n            v5 = v6\n        v9 = list(a2) + ['#'] + v3\n        v10 = []\n        for v6 in range(v2 + 1, len(v9)):\n            if v9[v6] == '*':\n                v9[v6] = 'a'\n                v10.append(v6)\n        v4 = z_function(v9)\n        v11 = collections.deque()\n        v6, v12 = (v2 + 1, 0)\n        while v6 - (v2 + 1) < v1:\n            while v11 and v11[0] < v6:\n                v11.popleft()\n            while v12 < len(v10) and v10[v12] <= v6 + (v2 - 1):\n                v11.append(v10[v12])\n                v12 += 1\n            if a1[v6 - (v2 + 1)] == 'F' and v4[v6] == v2:\n                if not v11:\n                    return ''\n                v9[v11[-1]] = 'b'\n                v6 += v2\n            else:\n                v6 += 1\n        return ''.join(v9[v2 + 1:])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def generateString(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def z_function(a1):\n            v1 = [0] * len(a1)\n            v2, v3 = (0, 0)\n            for v4 in range(1, len(v1)):\n                if v4 <= v3:\n                    v1[v4] = min(v3 - v4 + 1, v1[v4 - v2])\n                while v4 + v1[v4] < len(v1) and a1[v1[v4]] == a1[v4 + v1[v4]]:\n                    v1[v4] += 1\n                if v4 + v1[v4] - 1 > v3:\n                    v2, v3 = (v4, v4 + v1[v4] - 1)\n            return v1\n        v1, v2 = (len(a1), len(a2))\n        v3 = ['*'] * (v1 + v2 - 1)\n        v4 = z_function(a2)\n        v5 = -v2\n        for v6, v7 in enumerate(a1):\n            if v7 != 'T':\n                continue\n            v8 = v6 - v5\n            if v8 < v2:\n                if v4[v8] == v2 - v8:\n                    v3[v5 + v2:v6 + v2] = a2[v2 - v8:]\n                else:\n                    return ''\n            else:\n                v3[v6:v6 + v2] = a2\n            v5 = v6\n        v9 = list(a2) + ['#'] + v3\n        v10 = []\n        for v6 in range(v2 + 1, len(v9)):\n            if v9[v6] == '*':\n                v9[v6] = 'a'\n                v10.append(v6)\n        v4 = z_function(v9)\n        v11 = collections.deque()\n        v6, v12 = (v2 + 1, 0)\n        while v6 - (v2 + 1) < v1:\n            while v11 and v11[0] < v6:\n                v11.popleft()\n            while v12 < len(v10) and v10[v12] <= v6 + (v2 - 1):\n                v11.append(v10[v12])\n                v12 += 1\n            if a1[v6 - (v2 + 1)] == 'F' and v4[v6] == v2:\n                if not v11:\n                    return ''\n                v9[v11[-1]] = 'b'\n                v6 += v2\n            else:\n                v6 += 1\n        return ''.join(v9[v2 + 1:])\n"}
{"id": "human_code\\find-the-minimum-area-to-cover-all-ones-ii__part6.py", "text": "class C1(object):\n\n    def minimumSum(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def binary_search_right(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if not a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a2\n\n        def minimumArea(a1, a2, a3, a4):\n\n            def count(a1, a2, a3, a4):\n                v1 = a1[a3][a4]\n                if a1 - 1 >= 0:\n                    v1 -= a1[a1 - 1][a4]\n                if a2 - 1 >= 0:\n                    v1 -= a1[a3][a2 - 1]\n                if a1 - 1 >= 0 and a2 - 1 >= 0:\n                    v1 += a1[a1 - 1][a2 - 1]\n                return v1\n            v1 = binary_search(a1, a2, lambda i: count(a1, a3, i, a4))\n            v2 = binary_search_right(a1, a2, lambda i: count(i, a3, a2, a4))\n            v3 = binary_search(a3, a4, lambda j: count(a1, a3, a2, j))\n            v4 = binary_search_right(a3, a4, lambda j: count(a1, j, a2, a4))\n            return (v2 - v1 + 1) * (v4 - v3 + 1) if v1 <= a2 else 0\n        for v1 in range(len(a1)):\n            for v2 in range(len(a1[0])):\n                if v1 - 1 >= 0:\n                    a1[v1][v2] += a1[v1 - 1][v2]\n                if v2 - 1 >= 0:\n                    a1[v1][v2] += a1[v1][v2 - 1]\n                if v1 - 1 >= 0 and v2 - 1 >= 0:\n                    a1[v1][v2] -= a1[v1 - 1][v2 - 1]\n        v3 = float('inf')\n        v3 = float('inf')\n        for v1 in range(len(a1) - 1):\n            v4 = minimumArea(v1 + 1, len(a1) - 1, 0, len(a1[0]) - 1)\n            for v2 in range(len(a1[0]) - 1):\n                v5 = minimumArea(0, v1, 0, v2)\n                v6 = minimumArea(0, v1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v1 in range(len(a1) - 1):\n            v4 = minimumArea(0, v1, 0, len(a1[0]) - 1)\n            for v2 in range(len(a1[0]) - 1):\n                v5 = minimumArea(v1 + 1, len(a1) - 1, 0, v2)\n                v6 = minimumArea(v1 + 1, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v2 in range(len(a1[0]) - 1):\n            v4 = minimumArea(0, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n            for v1 in range(len(a1) - 1):\n                v5 = minimumArea(0, v1, 0, v2)\n                v6 = minimumArea(v1 + 1, len(a1) - 1, 0, v2)\n                v3 = min(v3, v4 + v5 + v6)\n        for v2 in range(len(a1[0]) - 1):\n            v4 = minimumArea(0, len(a1) - 1, 0, v2)\n            for v1 in range(len(a1) - 1):\n                v5 = minimumArea(0, v1, v2 + 1, len(a1[0]) - 1)\n                v6 = minimumArea(v1 + 1, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v1 in range(len(a1) - 2):\n            v4 = minimumArea(0, v1, 0, len(a1[0]) - 1)\n            for v2 in range(v1 + 1, len(a1) - 1):\n                v5 = minimumArea(v1 + 1, v2, 0, len(a1[0]) - 1)\n                v6 = minimumArea(v2 + 1, len(a1) - 1, 0, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v1 in range(len(a1[0]) - 2):\n            v4 = minimumArea(0, len(a1) - 1, 0, v1)\n            for v2 in range(v1 + 1, len(a1[0]) - 1):\n                v5 = minimumArea(0, len(a1) - 1, v1 + 1, v2)\n                v6 = minimumArea(0, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumSum(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def binary_search(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a1\n\n        def binary_search_right(a1, a2, a3):\n            while a1 <= a2:\n                v1 = a1 + (a2 - a1) // 2\n                if not a3(v1):\n                    a2 = v1 - 1\n                else:\n                    a1 = v1 + 1\n            return a2\n\n        def minimumArea(a1, a2, a3, a4):\n\n            def count(a1, a2, a3, a4):\n                v1 = a1[a3][a4]\n                if a1 - 1 >= 0:\n                    v1 -= a1[a1 - 1][a4]\n                if a2 - 1 >= 0:\n                    v1 -= a1[a3][a2 - 1]\n                if a1 - 1 >= 0 and a2 - 1 >= 0:\n                    v1 += a1[a1 - 1][a2 - 1]\n                return v1\n            v1 = binary_search(a1, a2, lambda i: count(a1, a3, i, a4))\n            v2 = binary_search_right(a1, a2, lambda i: count(i, a3, a2, a4))\n            v3 = binary_search(a3, a4, lambda j: count(a1, a3, a2, j))\n            v4 = binary_search_right(a3, a4, lambda j: count(a1, j, a2, a4))\n            return (v2 - v1 + 1) * (v4 - v3 + 1) if v1 <= a2 else 0\n        for v1 in range(len(a1)):\n            for v2 in range(len(a1[0])):\n                if v1 - 1 >= 0:\n                    a1[v1][v2] += a1[v1 - 1][v2]\n                if v2 - 1 >= 0:\n                    a1[v1][v2] += a1[v1][v2 - 1]\n                if v1 - 1 >= 0 and v2 - 1 >= 0:\n                    a1[v1][v2] -= a1[v1 - 1][v2 - 1]\n        v3 = float('inf')\n        v3 = float('inf')\n        for v1 in range(len(a1) - 1):\n            v4 = minimumArea(v1 + 1, len(a1) - 1, 0, len(a1[0]) - 1)\n            for v2 in range(len(a1[0]) - 1):\n                v5 = minimumArea(0, v1, 0, v2)\n                v6 = minimumArea(0, v1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v1 in range(len(a1) - 1):\n            v4 = minimumArea(0, v1, 0, len(a1[0]) - 1)\n            for v2 in range(len(a1[0]) - 1):\n                v5 = minimumArea(v1 + 1, len(a1) - 1, 0, v2)\n                v6 = minimumArea(v1 + 1, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v2 in range(len(a1[0]) - 1):\n            v4 = minimumArea(0, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n            for v1 in range(len(a1) - 1):\n                v5 = minimumArea(0, v1, 0, v2)\n                v6 = minimumArea(v1 + 1, len(a1) - 1, 0, v2)\n                v3 = min(v3, v4 + v5 + v6)\n        for v2 in range(len(a1[0]) - 1):\n            v4 = minimumArea(0, len(a1) - 1, 0, v2)\n            for v1 in range(len(a1) - 1):\n                v5 = minimumArea(0, v1, v2 + 1, len(a1[0]) - 1)\n                v6 = minimumArea(v1 + 1, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v1 in range(len(a1) - 2):\n            v4 = minimumArea(0, v1, 0, len(a1[0]) - 1)\n            for v2 in range(v1 + 1, len(a1) - 1):\n                v5 = minimumArea(v1 + 1, v2, 0, len(a1[0]) - 1)\n                v6 = minimumArea(v2 + 1, len(a1) - 1, 0, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        for v1 in range(len(a1[0]) - 2):\n            v4 = minimumArea(0, len(a1) - 1, 0, v1)\n            for v2 in range(v1 + 1, len(a1[0]) - 1):\n                v5 = minimumArea(0, len(a1) - 1, v1 + 1, v2)\n                v6 = minimumArea(0, len(a1) - 1, v2 + 1, len(a1[0]) - 1)\n                v3 = min(v3, v4 + v5 + v6)\n        return v3\n"}
{"id": "human_code\\count-of-smaller-numbers-after-self__part2.py", "text": "class C1(object):\n\n    def countSmaller(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class BIT(object):\n\n            def __init__(self, a1):\n                self.__bit = [0] * (a1 + 1)\n\n            def add(self, a1, a2):\n                a1 += 1\n                while a1 < len(self.__bit):\n                    self.__bit[a1] += a2\n                    a1 += a1 & -a1\n\n            def query(self, a1):\n                a1 += 1\n                v2 = 0\n                while a1 > 0:\n                    v2 += self.__bit[a1]\n                    a1 -= a1 & -a1\n                return v2\n        v1 = sorted(zip(a1, list(range(len(a1)))))\n        v2 = {i: new_i for v3, (v4, v5) in enumerate(v1)}\n        v6, v7 = ([0] * len(a1), BIT(len(a1)))\n        for v5 in reversed(range(len(a1))):\n            v6[v5] = v7.query(v2[v5] - 1)\n            v7.add(v2[v5], 1)\n        return v6\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countSmaller(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class BIT(object):\n\n            def __init__(self, a1):\n                self.__bit = [0] * (a1 + 1)\n\n            def add(self, a1, a2):\n                a1 += 1\n                while a1 < len(self.__bit):\n                    self.__bit[a1] += a2\n                    a1 += a1 & -a1\n\n            def query(self, a1):\n                a1 += 1\n                v2 = 0\n                while a1 > 0:\n                    v2 += self.__bit[a1]\n                    a1 -= a1 & -a1\n                return v2\n        v1 = sorted(zip(a1, list(range(len(a1)))))\n        v2 = {i: new_i for v3, (v4, v5) in enumerate(v1)}\n        v6, v7 = ([0] * len(a1), BIT(len(a1)))\n        for v5 in reversed(range(len(a1))):\n            v6[v5] = v7.query(v2[v5] - 1)\n            v7.add(v2[v5], 1)\n        return v6\n"}
{"id": "human_code\\p03291__s034463876.py", "text": "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return [int(x) for v1 in input().split()]\nv1 = 10 ** 9 + 7\nv2 = input()\nv3 = len(v2)\nv4 = [0] + list(accumulate((c == 'A' for v5 in v2)))\nv6 = [0] + list(accumulate((v5 == 'C' for v5 in v2)))\nv7 = [0] + list(accumulate((v5 == '?' for v5 in v2)))\nv8 = v7[v3]\nv9 = 0\nfor v10 in range(1, v3 - 1):\n    if v2[v10] == 'B':\n        v9 += v4[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8, v1) % v1\n        if v8 >= 1:\n            v9 += v7[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8 - 1, v1) % v1\n            v9 += v4[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 1, v1) % v1\n        if v8 >= 2:\n            v9 += v7[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 2, v1) % v1\n    if v2[v10] == '?':\n        v9 += v4[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8 - 1, v1) % v1\n        if v8 >= 2:\n            v9 += v7[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8 - 2, v1) % v1\n            v9 += v4[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 2, v1) % v1\n        if v8 >= 3:\n            v9 += v7[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 3, v1) % v1\nprint(v9 % v1)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import defaultdict\nfrom bisect import bisect\n\ndef f1():\n    return int(input())\n\ndef f2():\n    return [int(x) for v1 in input().split()]\nv1 = 10 ** 9 + 7\nv2 = input()\nv3 = len(v2)\nv4 = [0] + list(accumulate((c == 'A' for v5 in v2)))\nv6 = [0] + list(accumulate((v5 == 'C' for v5 in v2)))\nv7 = [0] + list(accumulate((v5 == '?' for v5 in v2)))\nv8 = v7[v3]\nv9 = 0\nfor v10 in range(1, v3 - 1):\n    if v2[v10] == 'B':\n        v9 += v4[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8, v1) % v1\n        if v8 >= 1:\n            v9 += v7[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8 - 1, v1) % v1\n            v9 += v4[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 1, v1) % v1\n        if v8 >= 2:\n            v9 += v7[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 2, v1) % v1\n    if v2[v10] == '?':\n        v9 += v4[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8 - 1, v1) % v1\n        if v8 >= 2:\n            v9 += v7[v10] * (v6[v3] - v6[v10 + 1]) % v1 * pow(3, v8 - 2, v1) % v1\n            v9 += v4[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 2, v1) % v1\n        if v8 >= 3:\n            v9 += v7[v10] * (v7[v3] - v7[v10 + 1]) % v1 * pow(3, v8 - 3, v1) % v1\nprint(v9 % v1)\n"}
{"id": "human_code\\count-almost-equal-pairs-i__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def countPairs(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 7\n        v2 = [0] * v1\n        v2[0] = 1\n        for v3 in range(v1 - 1):\n            v2[v3 + 1] = v2[v3] * 10\n        v4 = collections.Counter(a1)\n        v5 = collections.Counter()\n        for v6, v7 in v4.items():\n            for v3 in range(v1):\n                v8 = v6 // v2[v3] % 10\n                for v9 in range(v3 + 1, v1):\n                    v10 = v6 // v2[v9] % 10\n                    if v8 == v10 or v6 - v8 * (v2[v3] - v2[v9]) + v10 * (v2[v3] - v2[v9]) not in v4:\n                        continue\n                    v5[v6 - v8 * (v2[v3] - v2[v9]) + v10 * (v2[v3] - v2[v9])] += v7\n        return sum((v7 * (v7 - 1) // 2 for v7 in v4.values())) + sum((v7 * v5[v6] for v6, v7 in v4.items())) // 2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def countPairs(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 7\n        v2 = [0] * v1\n        v2[0] = 1\n        for v3 in range(v1 - 1):\n            v2[v3 + 1] = v2[v3] * 10\n        v4 = collections.Counter(a1)\n        v5 = collections.Counter()\n        for v6, v7 in v4.items():\n            for v3 in range(v1):\n                v8 = v6 // v2[v3] % 10\n                for v9 in range(v3 + 1, v1):\n                    v10 = v6 // v2[v9] % 10\n                    if v8 == v10 or v6 - v8 * (v2[v3] - v2[v9]) + v10 * (v2[v3] - v2[v9]) not in v4:\n                        continue\n                    v5[v6 - v8 * (v2[v3] - v2[v9]) + v10 * (v2[v3] - v2[v9])] += v7\n        return sum((v7 * (v7 - 1) // 2 for v7 in v4.values())) + sum((v7 * v5[v6] for v6, v7 in v4.items())) // 2\n"}
{"id": "llm_code\\p02781__s396523841.py", "text": "from functools import lru_cache\nv1 = int(input())\nv2 = int(input())\nv3 = [[0] * (v2 + 1) for v4 in range(len(str(v1)) + 1)]\n\n@lru_cache(None)\ndef f1(a1, a2):\n    if a1 < 10:\n        if a2 == 0:\n            return 1\n        if a2 == 1:\n            return a1\n        else:\n            return 0\n    if v3[a1][a2] != 0:\n        return v3[a1][a2]\n    v1 = a1 % 10\n    if a2 >= 1:\n        v2 = v1 * f1(a1 // 10, a2 - 1) + (9 - v1) * f1(a1 // 10 - 1, a2 - 1)\n    else:\n        v2 = 0\n    v2 += f1(a1 // 10, a2)\n    v3[a1][a2] = v2\n    return v2\nprint(f1(v1, v2))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from functools import lru_cache\nv1 = int(input())\nv2 = int(input())\nv3 = [[0] * (v2 + 1) for v4 in range(len(str(v1)) + 1)]\n\n@lru_cache(None)\ndef f1(a1, a2):\n    if a1 < 10:\n        if a2 == 0:\n            return 1\n        if a2 == 1:\n            return a1\n        else:\n            return 0\n    if v3[a1][a2] != 0:\n        return v3[a1][a2]\n    v1 = a1 % 10\n    if a2 >= 1:\n        v2 = v1 * f1(a1 // 10, a2 - 1) + (9 - v1) * f1(a1 // 10 - 1, a2 - 1)\n    else:\n        v2 = 0\n    v2 += f1(a1 // 10, a2)\n    v3[a1][a2] = v2\n    return v2\nprint(f1(v1, v2))\n"}
{"id": "llm_code\\coloring-a-border__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def colorBorder(self, a1, a2, a3, a4):\n        v1 = len(a1)\n        if v1 == 0:\n            return a1\n        v2 = len(a1[0])\n        v3 = a1[a2][a3]\n        v4 = set([(a2, a3)])\n        v5 = [(a2, a3)]\n        v6 = []\n        v7 = [-1, 0, 1, 0]\n        v8 = [0, 1, 0, -1]\n        while v5:\n            v9, v10 = v5.pop()\n            v11 = 0\n            for v12 in range(4):\n                v13 = v9 + v7[v12]\n                v14 = v10 + v8[v12]\n                if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] == v3):\n                    v11 += 1\n                v15 = (v13, v14)\n                if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] == v3) and (v15 not in v4):\n                    v4.add(v15)\n                    v5.append(v15)\n            if v11 < 4:\n                v6.append((v9, v10))\n        for v9, v10 in v6:\n            a1[v9][v10] = a4\n        return a1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def colorBorder(self, a1, a2, a3, a4):\n        v1 = len(a1)\n        if v1 == 0:\n            return a1\n        v2 = len(a1[0])\n        v3 = a1[a2][a3]\n        v4 = set([(a2, a3)])\n        v5 = [(a2, a3)]\n        v6 = []\n        v7 = [-1, 0, 1, 0]\n        v8 = [0, 1, 0, -1]\n        while v5:\n            v9, v10 = v5.pop()\n            v11 = 0\n            for v12 in range(4):\n                v13 = v9 + v7[v12]\n                v14 = v10 + v8[v12]\n                if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] == v3):\n                    v11 += 1\n                v15 = (v13, v14)\n                if 0 <= v13 < v1 and 0 <= v14 < v2 and (a1[v13][v14] == v3) and (v15 not in v4):\n                    v4.add(v15)\n                    v5.append(v15)\n            if v11 < 4:\n                v6.append((v9, v10))\n        for v9, v10 in v6:\n            a1[v9][v10] = a4\n        return a1\n"}
{"id": "llm_code\\lonely-pixel-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def findBlackPixel(self, a1, a2):\n        v1, v2 = (len(a1), len(a1[0]) if a1 else 0)\n        if v1 == 0 or v2 == 0:\n            return 0\n        v3 = [0] * v2\n        for v4 in a1:\n            for v5, v6 in enumerate(v4):\n                if v6 == 'B':\n                    v3[v5] += 1\n        v7 = {}\n        for v8 in a1:\n            if v8 not in v7:\n                v7[v8] = [0, v8.count('B')]\n            v7[v8][0] += 1\n        v9 = 0\n        for v8, (v10, v11) in v7.items():\n            if v10 == a2 and v11 == a2:\n                v12 = 0\n                for v5 in range(v2):\n                    if v8[v5] == 'B' and v3[v5] == a2:\n                        v12 += 1\n                v9 += v12 * a2\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findBlackPixel(self, a1, a2):\n        v1, v2 = (len(a1), len(a1[0]) if a1 else 0)\n        if v1 == 0 or v2 == 0:\n            return 0\n        v3 = [0] * v2\n        for v4 in a1:\n            for v5, v6 in enumerate(v4):\n                if v6 == 'B':\n                    v3[v5] += 1\n        v7 = {}\n        for v8 in a1:\n            if v8 not in v7:\n                v7[v8] = [0, v8.count('B')]\n            v7[v8][0] += 1\n        v9 = 0\n        for v8, (v10, v11) in v7.items():\n            if v10 == a2 and v11 == a2:\n                v12 = 0\n                for v5 in range(v2):\n                    if v8[v5] == 'B' and v3[v5] == a2:\n                        v12 += 1\n                v9 += v12 * a2\n        return v9\n"}
{"id": "human_code\\sentence-screen-fitting.py", "text": "class C1(object):\n\n    def wordsTyping(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def words_fit(a1, a2, a3):\n            if len(a1[a2]) > a3:\n                return 0\n            v1, v2 = (len(a1[a2]), 1)\n            v3 = (a2 + 1) % len(a1)\n            while v1 + 1 + len(a1[v3]) <= a3:\n                v1 += 1 + len(a1[v3])\n                v2 += 1\n                v3 = (v3 + 1) % len(a1)\n            return v2\n        v1 = [0] * len(a1)\n        for v2 in range(len(a1)):\n            v1[v2] = words_fit(a1, v2, a3)\n        v3, v4 = (0, 0)\n        for v2 in range(a2):\n            v3 += v1[v4]\n            v4 = (v4 + v1[v4]) % len(a1)\n        return v3 / len(a1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def wordsTyping(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def words_fit(a1, a2, a3):\n            if len(a1[a2]) > a3:\n                return 0\n            v1, v2 = (len(a1[a2]), 1)\n            v3 = (a2 + 1) % len(a1)\n            while v1 + 1 + len(a1[v3]) <= a3:\n                v1 += 1 + len(a1[v3])\n                v2 += 1\n                v3 = (v3 + 1) % len(a1)\n            return v2\n        v1 = [0] * len(a1)\n        for v2 in range(len(a1)):\n            v1[v2] = words_fit(a1, v2, a3)\n        v3, v4 = (0, 0)\n        for v2 in range(a2):\n            v3 += v1[v4]\n            v4 = (v4 + v1[v4]) % len(a1)\n        return v3 / len(a1)\n"}
{"id": "llm_code\\minimum-cost-to-change-the-final-value-of-expression__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def minOperationsToFlip(self, a1):\n\n        def parse_primary(a1):\n            if a1[a1].isdigit():\n                v1 = a1[a1]\n                v2 = int(v1 != '0')\n                v3 = int(v1 != '1')\n                return ([v2, v3], a1 + 1)\n            a1 += 1\n            v5, a1 = parse_expression(a1)\n            a1 += 1\n            return (v5, a1)\n\n        def parse_expression(a1):\n            v1, a1 = parse_primary(a1)\n            while a1 < len(a1) and a1[a1] in '&|':\n                v3 = a1[a1]\n                a1 += 1\n                v4, a1 = parse_primary(a1)\n                v5, v6 = v1\n                v7, v8 = v4\n                if v3 == '&':\n                    v9 = min(v5, v7)\n                    v10 = min(v6 + v8, 1 + min(v6, v8))\n                else:\n                    v9 = min(v5 + v7, 1 + min(v5, v7))\n                    v10 = min(v6, v8)\n                v1 = [v9, v10]\n            return (v1, a1)\n        v1, v2 = parse_expression(0)\n        return max(v1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minOperationsToFlip(self, a1):\n\n        def parse_primary(a1):\n            if a1[a1].isdigit():\n                v1 = a1[a1]\n                v2 = int(v1 != '0')\n                v3 = int(v1 != '1')\n                return ([v2, v3], a1 + 1)\n            a1 += 1\n            v5, a1 = parse_expression(a1)\n            a1 += 1\n            return (v5, a1)\n\n        def parse_expression(a1):\n            v1, a1 = parse_primary(a1)\n            while a1 < len(a1) and a1[a1] in '&|':\n                v3 = a1[a1]\n                a1 += 1\n                v4, a1 = parse_primary(a1)\n                v5, v6 = v1\n                v7, v8 = v4\n                if v3 == '&':\n                    v9 = min(v5, v7)\n                    v10 = min(v6 + v8, 1 + min(v6, v8))\n                else:\n                    v9 = min(v5 + v7, 1 + min(v5, v7))\n                    v10 = min(v6, v8)\n                v1 = [v9, v10]\n            return (v1, a1)\n        v1, v2 = parse_expression(0)\n        return max(v1)\n"}
{"id": "human_code\\split-two-strings-to-make-palindrome.py", "text": "class C1(object):\n\n    def checkPalindromeFormation(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def is_palindrome(a1, a2, a3):\n            while a2 < a3:\n                if a1[a2] != a1[a3]:\n                    return False\n                a2 += 1\n                a3 -= 1\n            return True\n\n        def check(a1, a2):\n            v1, v2 = (0, len(a2) - 1)\n            while v1 < v2:\n                if a1[v1] != a2[v2]:\n                    return is_palindrome(a1, v1, v2) or is_palindrome(a2, v1, v2)\n                v1 += 1\n                v2 -= 1\n            return True\n        return check(a1, a2) or check(a2, a1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def checkPalindromeFormation(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def is_palindrome(a1, a2, a3):\n            while a2 < a3:\n                if a1[a2] != a1[a3]:\n                    return False\n                a2 += 1\n                a3 -= 1\n            return True\n\n        def check(a1, a2):\n            v1, v2 = (0, len(a2) - 1)\n            while v1 < v2:\n                if a1[v1] != a2[v2]:\n                    return is_palindrome(a1, v1, v2) or is_palindrome(a2, v1, v2)\n                v1 += 1\n                v2 -= 1\n            return True\n        return check(a1, a2) or check(a2, a1)\n"}
{"id": "llm_code\\find-servers-that-handled-most-number-of-requests__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def __init__(self, a1):\n        self.n = a1\n        self.inf = a1 + 10\n        self.tree = [self.inf] * (4 * a1)\n        self._build(1, 0, a1 - 1)\n\n    def _build(self, a1, a2, a3):\n        if a2 == a3:\n            self.tree[a1] = a2\n            return\n        v1 = (a2 + a3) // 2\n        self._build(2 * a1, a2, v1)\n        self._build(2 * a1 + 1, v1 + 1, a3)\n        self.tree[a1] = min(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n    def update(self, a1, a2):\n        self._update(1, 0, self.n - 1, a1, a2)\n\n    def _update(self, a1, a2, a3, a4, a5):\n        if a2 == a3:\n            self.tree[a1] = a5\n            return\n        v1 = (a2 + a3) // 2\n        if a4 <= v1:\n            self._update(2 * a1, a2, v1, a4, a5)\n        else:\n            self._update(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        self.tree[a1] = min(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n    def query(self, a1, a2):\n        return self._query(1, 0, self.n - 1, a1, a2)\n\n    def _query(self, a1, a2, a3, a4, a5):\n        if a5 < a2 or a3 < a4:\n            return self.inf\n        if a4 <= a2 and a3 <= a5:\n            return self.tree[a1]\n        v1 = (a2 + a3) // 2\n        v2 = self._query(2 * a1, a2, v1, a4, a5)\n        v3 = self._query(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        return min(v2, v3)\n\nclass C2:\n\n    def busiestServers(self, a1, a2, a3):\n        if a1 == 0:\n            return []\n        v1 = [0] * a1\n        v2 = C1(a1)\n        v3 = []\n        for v4 in range(len(a2)):\n            v5, v6 = (a2[v4], a3[v4])\n            v7 = v4 % a1\n            while v3 and v3[0][0] <= v5:\n                v8, v9 = heapq.heappop(v3)\n                v2.update(v9, v9)\n            v9 = v2.query(v7, a1 - 1)\n            if v9 == v2.inf:\n                v9 = v2.query(0, a1 - 1)\n            if v9 == v2.inf:\n                continue\n            v1[v9] += 1\n            v2.update(v9, v2.inf)\n            heapq.heappush(v3, (v5 + v6, v9))\n        v10 = max(v1)\n        return [j for v11 in range(a1) if v1[v11] == v10]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def __init__(self, a1):\n        self.n = a1\n        self.inf = a1 + 10\n        self.tree = [self.inf] * (4 * a1)\n        self._build(1, 0, a1 - 1)\n\n    def _build(self, a1, a2, a3):\n        if a2 == a3:\n            self.tree[a1] = a2\n            return\n        v1 = (a2 + a3) // 2\n        self._build(2 * a1, a2, v1)\n        self._build(2 * a1 + 1, v1 + 1, a3)\n        self.tree[a1] = min(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n    def update(self, a1, a2):\n        self._update(1, 0, self.n - 1, a1, a2)\n\n    def _update(self, a1, a2, a3, a4, a5):\n        if a2 == a3:\n            self.tree[a1] = a5\n            return\n        v1 = (a2 + a3) // 2\n        if a4 <= v1:\n            self._update(2 * a1, a2, v1, a4, a5)\n        else:\n            self._update(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        self.tree[a1] = min(self.tree[2 * a1], self.tree[2 * a1 + 1])\n\n    def query(self, a1, a2):\n        return self._query(1, 0, self.n - 1, a1, a2)\n\n    def _query(self, a1, a2, a3, a4, a5):\n        if a5 < a2 or a3 < a4:\n            return self.inf\n        if a4 <= a2 and a3 <= a5:\n            return self.tree[a1]\n        v1 = (a2 + a3) // 2\n        v2 = self._query(2 * a1, a2, v1, a4, a5)\n        v3 = self._query(2 * a1 + 1, v1 + 1, a3, a4, a5)\n        return min(v2, v3)\n\nclass C2:\n\n    def busiestServers(self, a1, a2, a3):\n        if a1 == 0:\n            return []\n        v1 = [0] * a1\n        v2 = C1(a1)\n        v3 = []\n        for v4 in range(len(a2)):\n            v5, v6 = (a2[v4], a3[v4])\n            v7 = v4 % a1\n            while v3 and v3[0][0] <= v5:\n                v8, v9 = heapq.heappop(v3)\n                v2.update(v9, v9)\n            v9 = v2.query(v7, a1 - 1)\n            if v9 == v2.inf:\n                v9 = v2.query(0, a1 - 1)\n            if v9 == v2.inf:\n                continue\n            v1[v9] += 1\n            v2.update(v9, v2.inf)\n            heapq.heappush(v3, (v5 + v6, v9))\n        v10 = max(v1)\n        return [j for v11 in range(a1) if v1[v11] == v10]\n"}
{"id": "llm_code\\minimum-edge-reversals-so-every-node-is-reachable__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minEdgeReversals(self, a1, a2):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append((v4, 0))\n            v1[v4].append((v3, 1))\n\n        def get_total(a1, a2):\n            v1 = 0\n            for v2, v3 in v1[a1]:\n                if v2 != a2:\n                    v1 += v3 + get_total(v2, a1)\n            return v1\n        v5 = [0] * a1\n        v6 = get_total(0, -1)\n        v5[0] = v6\n\n        def reroot(a1, a2, a3):\n            for v1, v2 in v1[a1]:\n                if v1 != a2:\n                    v5[v1] = a3 - v2 + 1 - v2\n                    reroot(v1, a1, v5[v1])\n        reroot(0, -1, v6)\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minEdgeReversals(self, a1, a2):\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append((v4, 0))\n            v1[v4].append((v3, 1))\n\n        def get_total(a1, a2):\n            v1 = 0\n            for v2, v3 in v1[a1]:\n                if v2 != a2:\n                    v1 += v3 + get_total(v2, a1)\n            return v1\n        v5 = [0] * a1\n        v6 = get_total(0, -1)\n        v5[0] = v6\n\n        def reroot(a1, a2, a3):\n            for v1, v2 in v1[a1]:\n                if v1 != a2:\n                    v5[v1] = a3 - v2 + 1 - v2\n                    reroot(v1, a1, v5[v1])\n        reroot(0, -1, v6)\n        return v5\n"}
{"id": "llm_code\\count-complete-tree-nodes__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        pass\n\nclass C2(object):\n\n    def countNodes(self, a1):\n\n        def left_depth(a1):\n            v1 = -1\n            while a1:\n                v1 += 1\n                a1 = a1.left\n            return v1\n\n        def total_nodes(a1):\n            if not a1:\n                return 0\n            v1 = left_depth(a1.left)\n            v2 = left_depth(a1.right)\n            if v1 == v2:\n                return (1 << v1 + 2) - 1\n            return 1 + total_nodes(a1.left) + total_nodes(a1.right)\n        return total_nodes(a1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        pass\n\nclass C2(object):\n\n    def countNodes(self, a1):\n\n        def left_depth(a1):\n            v1 = -1\n            while a1:\n                v1 += 1\n                a1 = a1.left\n            return v1\n\n        def total_nodes(a1):\n            if not a1:\n                return 0\n            v1 = left_depth(a1.left)\n            v2 = left_depth(a1.right)\n            if v1 == v2:\n                return (1 << v1 + 2) - 1\n            return 1 + total_nodes(a1.left) + total_nodes(a1.right)\n        return total_nodes(a1)\n"}
{"id": "human_code\\encode-n-ary-tree-to-binary-tree.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a1\n        self.children = a2\n\nclass C2(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C3(object):\n\n    def encode(self, a1):\n        \"\"\"Encodes an n-ary tree to a binary tree.\n        \n        \"\"\"\n\n        def encodeHelper(a1, a2, a3):\n            if not a1:\n                return None\n            v1 = C2(a1.val)\n            if a3 + 1 < len(a2.children):\n                v1.left = encodeHelper(a2.children[a3 + 1], a2, a3 + 1)\n            if a1.children:\n                v1.right = encodeHelper(a1.children[0], a1, 0)\n            return v1\n        if not a1:\n            return None\n        v1 = C2(a1.val)\n        if a1.children:\n            v1.right = encodeHelper(a1.children[0], a1, 0)\n        return v1\n\n    def decode(self, a1):\n        \"\"\"Decodes your binary tree to an n-ary tree.\n        \n        \"\"\"\n\n        def decodeHelper(a1, a2):\n            if not a1:\n                return\n            v1 = []\n            v2 = C1(a1.val, v1)\n            decodeHelper(a1.right, v2)\n            a2.children.append(v2)\n            decodeHelper(a1.left, a2)\n        if not a1:\n            return None\n        v1 = []\n        v2 = C1(a1.val, v1)\n        decodeHelper(a1.right, v2)\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2):\n        self.val = a1\n        self.children = a2\n\nclass C2(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C3(object):\n\n    def encode(self, a1):\n        \"\"\"Encodes an n-ary tree to a binary tree.\n        \n        \"\"\"\n\n        def encodeHelper(a1, a2, a3):\n            if not a1:\n                return None\n            v1 = C2(a1.val)\n            if a3 + 1 < len(a2.children):\n                v1.left = encodeHelper(a2.children[a3 + 1], a2, a3 + 1)\n            if a1.children:\n                v1.right = encodeHelper(a1.children[0], a1, 0)\n            return v1\n        if not a1:\n            return None\n        v1 = C2(a1.val)\n        if a1.children:\n            v1.right = encodeHelper(a1.children[0], a1, 0)\n        return v1\n\n    def decode(self, a1):\n        \"\"\"Decodes your binary tree to an n-ary tree.\n        \n        \"\"\"\n\n        def decodeHelper(a1, a2):\n            if not a1:\n                return\n            v1 = []\n            v2 = C1(a1.val, v1)\n            decodeHelper(a1.right, v2)\n            a2.children.append(v2)\n            decodeHelper(a1.left, a2)\n        if not a1:\n            return None\n        v1 = []\n        v2 = C1(a1.val, v1)\n        decodeHelper(a1.right, v2)\n        return v2\n"}
{"id": "human_code\\p02855__s234674532.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = [[0 for v5 in range(v2)] for v5 in range(v1)]\nv6 = []\nv7 = []\nv8 = 0\nfor v9 in range(v1):\n    v10 = list(input())\n    if '#' not in v10:\n        v6.append(v9)\n        continue\n    v7.append(v9)\n    v11 = 0\n    v8 += 1\n    for v12 in range(v2):\n        if v10[v12] == '#':\n            if not v11:\n                v11 = 1\n            else:\n                v8 += 1\n        v4[v9][v12] = v8\nfor v9 in v6:\n    v13 = v9\n    v11 = 0\n    while v13 in v6:\n        if v13 == v1 - 1:\n            v11 = 1\n        if v11:\n            v13 -= 1\n        else:\n            v13 += 1\n    v4[v9] = v4[v13].copy()\nfor v14 in v4:\n    print(*v14)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = [[0 for v5 in range(v2)] for v5 in range(v1)]\nv6 = []\nv7 = []\nv8 = 0\nfor v9 in range(v1):\n    v10 = list(input())\n    if '#' not in v10:\n        v6.append(v9)\n        continue\n    v7.append(v9)\n    v11 = 0\n    v8 += 1\n    for v12 in range(v2):\n        if v10[v12] == '#':\n            if not v11:\n                v11 = 1\n            else:\n                v8 += 1\n        v4[v9][v12] = v8\nfor v9 in v6:\n    v13 = v9\n    v11 = 0\n    while v13 in v6:\n        if v13 == v1 - 1:\n            v11 = 1\n        if v11:\n            v13 -= 1\n        else:\n            v13 += 1\n    v4[v9] = v4[v13].copy()\nfor v14 in v4:\n    print(*v14)\n"}
{"id": "llm_code\\p02844__s418216206.py", "text": "from bisect import bisect_right\nv1 = int(input())\nv2 = input()\nv3 = 0\nv4 = [[] for v5 in range(10)]\n\ndef f1(a1, a2):\n    \"\"\"Find leftmost value greater than x\"\"\"\n    v1 = bisect_right(a1, a2)\n    if v1 != len(a1):\n        return a1[v1]\n    return None\nfor v6 in range(v1):\n    v4[int(v2[v6])].append(v6)\nfor v7 in range(1000):\n    v8 = '000' + str(v7)\n    v8 = v8[-3:]\n    v9, v10, v11 = map(int, tuple(v8))\n    v12 = -1\n    v12 = f1(v4[v9], v12)\n    if v12 is None:\n        continue\n    v13 = f1(v4[v10], v12)\n    if v13 is None:\n        continue\n    v14 = f1(v4[v11], v13)\n    if v14 is None:\n        continue\n    v3 += 1\nprint(v3)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from bisect import bisect_right\nv1 = int(input())\nv2 = input()\nv3 = 0\nv4 = [[] for v5 in range(10)]\n\ndef f1(a1, a2):\n    \"\"\"Find leftmost value greater than x\"\"\"\n    v1 = bisect_right(a1, a2)\n    if v1 != len(a1):\n        return a1[v1]\n    return None\nfor v6 in range(v1):\n    v4[int(v2[v6])].append(v6)\nfor v7 in range(1000):\n    v8 = '000' + str(v7)\n    v8 = v8[-3:]\n    v9, v10, v11 = map(int, tuple(v8))\n    v12 = -1\n    v12 = f1(v4[v9], v12)\n    if v12 is None:\n        continue\n    v13 = f1(v4[v10], v12)\n    if v13 is None:\n        continue\n    v14 = f1(v4[v11], v13)\n    if v14 is None:\n        continue\n    v3 += 1\nprint(v3)\n"}
{"id": "llm_code\\p03263__unrelated.py", "text": "v1 = int(input())\nv2 = int(input())\nv3 = []\nfor v4 in range(v1):\n    v3.append(list(map(int, input().split())))\n\ndef f1(a1):\n    return a1 % 2 == 0\n\ndef f2(a1, a2, a3, a4, a5):\n    if 0 <= a2 + a4 < v1 and 0 <= a3 + a5 < v2:\n        a1[a2 + a4][a3 + a5] += 1\n        a1[a2][a3] -= 1\n\ndef f3(a1):\n    v1 = 0\n    for v2 in range(v1):\n        for v3 in range(v2):\n            if f1(a1[v2][v3]):\n                v1 += 1\n    return v1\n\ndef f4(a1):\n    v1 = 0\n    for v2 in range(v1):\n        for v3 in range(v2):\n            if a1[v2][v3] > 0:\n                for v4 in range(-1, 2):\n                    for v5 in range(-1, 2):\n                        if abs(v4) + abs(v5) == 1:\n                            f2(a1, v2, v3, v4, v5)\n                            v1 += 1\n                            if f3(a1) == v1 * v2:\n                                return v1\n                            f2(a1, v2, v3, -v4, -v5)\n    return -1\nprint(f4(v3))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = int(input())\nv3 = []\nfor v4 in range(v1):\n    v3.append(list(map(int, input().split())))\n\ndef f1(a1):\n    return a1 % 2 == 0\n\ndef f2(a1, a2, a3, a4, a5):\n    if 0 <= a2 + a4 < v1 and 0 <= a3 + a5 < v2:\n        a1[a2 + a4][a3 + a5] += 1\n        a1[a2][a3] -= 1\n\ndef f3(a1):\n    v1 = 0\n    for v2 in range(v1):\n        for v3 in range(v2):\n            if f1(a1[v2][v3]):\n                v1 += 1\n    return v1\n\ndef f4(a1):\n    v1 = 0\n    for v2 in range(v1):\n        for v3 in range(v2):\n            if a1[v2][v3] > 0:\n                for v4 in range(-1, 2):\n                    for v5 in range(-1, 2):\n                        if abs(v4) + abs(v5) == 1:\n                            f2(a1, v2, v3, v4, v5)\n                            v1 += 1\n                            if f3(a1) == v1 * v2:\n                                return v1\n                            f2(a1, v2, v3, -v4, -v5)\n    return -1\nprint(f4(v3))\n"}
{"id": "llm_code\\maximum-number-of-non-overlapping-substrings__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxNumOfSubstrings(self, a1):\n        v1 = len(a1)\n        v2 = [v1] * 26\n        v3 = [-1] * 26\n        for v4, v5 in enumerate(a1):\n            v6 = ord(v5) - ord('a')\n            v2[v6] = min(v2[v6], v4)\n            v3[v6] = max(v3[v6], v4)\n\n        def compute_end(a1):\n            v1 = v3[ord(a1[a1]) - ord('a')]\n            v2 = a1\n            while v2 <= v1:\n                v3 = ord(a1[v2]) - ord('a')\n                if v2[v3] < a1:\n                    return -1\n                v1 = max(v1, v3[v3])\n                v2 += 1\n            return v1\n        v7 = []\n        for v4 in range(26):\n            v8 = v2[v4]\n            if v8 < v1:\n                v9 = compute_end(v8)\n                if v9 != -1:\n                    v7.append((v9, v8))\n        v7.sort()\n        v10 = []\n        v11 = -1\n        for v9, v8 in v7:\n            if v8 > v11:\n                v10.append(a1[v8:v9 + 1])\n                v11 = v9\n        return v10\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxNumOfSubstrings(self, a1):\n        v1 = len(a1)\n        v2 = [v1] * 26\n        v3 = [-1] * 26\n        for v4, v5 in enumerate(a1):\n            v6 = ord(v5) - ord('a')\n            v2[v6] = min(v2[v6], v4)\n            v3[v6] = max(v3[v6], v4)\n\n        def compute_end(a1):\n            v1 = v3[ord(a1[a1]) - ord('a')]\n            v2 = a1\n            while v2 <= v1:\n                v3 = ord(a1[v2]) - ord('a')\n                if v2[v3] < a1:\n                    return -1\n                v1 = max(v1, v3[v3])\n                v2 += 1\n            return v1\n        v7 = []\n        for v4 in range(26):\n            v8 = v2[v4]\n            if v8 < v1:\n                v9 = compute_end(v8)\n                if v9 != -1:\n                    v7.append((v9, v8))\n        v7.sort()\n        v10 = []\n        v11 = -1\n        for v9, v8 in v7:\n            if v8 > v11:\n                v10.append(a1[v8:v9 + 1])\n                v11 = v9\n        return v10\n"}
{"id": "llm_code\\p03600__s897344359.py", "text": "v1 = int(input())\nv2 = [list(map(int, input().split())) for v3 in range(v1)]\n\ndef f1():\n    for v1 in range(v1):\n        for v2 in range(v1):\n            for v3 in range(v1):\n                v4 = v2[v2][v1] + v2[v1][v3]\n                if v4 < v2[v2][v3]:\n                    return -1\n    v5 = 10 ** 18\n    v6 = 0\n    for v2 in range(v1):\n        for v3 in range(v2 + 1, v1):\n            for v1 in range(v1):\n                if v1 == v2 or v1 == v3:\n                    continue\n                v4 = v2[v2][v1] + v2[v1][v3]\n                if v4 == v2[v2][v3]:\n                    v6 += v2[v2][v3]\n                    v2[v2][v3] = v5\n                    v2[v3][v2] = v5\n                    break\n    return v6\nprint(sum((sum(a) for v4 in v2)) // 2 - f1())\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = [list(map(int, input().split())) for v3 in range(v1)]\n\ndef f1():\n    for v1 in range(v1):\n        for v2 in range(v1):\n            for v3 in range(v1):\n                v4 = v2[v2][v1] + v2[v1][v3]\n                if v4 < v2[v2][v3]:\n                    return -1\n    v5 = 10 ** 18\n    v6 = 0\n    for v2 in range(v1):\n        for v3 in range(v2 + 1, v1):\n            for v1 in range(v1):\n                if v1 == v2 or v1 == v3:\n                    continue\n                v4 = v2[v2][v1] + v2[v1][v3]\n                if v4 == v2[v2][v3]:\n                    v6 += v2[v2][v3]\n                    v2[v2][v3] = v5\n                    v2[v3][v2] = v5\n                    break\n    return v6\nprint(sum((sum(a) for v4 in v2)) // 2 - f1())\n"}
{"id": "human_code\\closest-nodes-queries-in-a-binary-search-tree__part2.py", "text": "import bisect\n\nclass C1(object):\n\n    def closestNodes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1):\n            if not a1:\n                return\n            dfs(a1.left)\n            inorder.append(a1.val)\n            dfs(a1.right)\n        v1 = []\n        dfs(a1)\n        v2 = []\n        for v3 in a2:\n            v4 = bisect.bisect_left(v1, v3)\n            if v4 == len(v1):\n                v2.append([v1[v4 - 1], -1])\n            elif v1[v4] == v3:\n                v2.append([v1[v4], v1[v4]])\n            elif v4 - 1 >= 0:\n                v2.append([v1[v4 - 1], v1[v4]])\n            else:\n                v2.append([-1, v1[v4]])\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def closestNodes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1):\n            if not a1:\n                return\n            dfs(a1.left)\n            inorder.append(a1.val)\n            dfs(a1.right)\n        v1 = []\n        dfs(a1)\n        v2 = []\n        for v3 in a2:\n            v4 = bisect.bisect_left(v1, v3)\n            if v4 == len(v1):\n                v2.append([v1[v4 - 1], -1])\n            elif v1[v4] == v3:\n                v2.append([v1[v4], v1[v4]])\n            elif v4 - 1 >= 0:\n                v2.append([v1[v4 - 1], v1[v4]])\n            else:\n                v2.append([-1, v1[v4]])\n        return v2\n"}
{"id": "llm_code\\the-most-similar-path-in-a-graph__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def mostSimilar(self, a1, a2, a3, a4):\n        v1 = len(a4)\n        v2 = v1 + 1\n        v3 = [[] for v4 in range(a1)]\n        for v5, v6 in a2:\n            v3[v5].append(v6)\n            v3[v6].append(v5)\n        v7 = [[v2] * a1 for v4 in range(v1)]\n        v8 = [[-1] * a1 for v4 in range(v1)]\n        for v9 in range(a1):\n            v7[0][v9] = 0 if a3[v9] == a4[0] else 1\n        for v10 in range(1, v1):\n            for v9 in range(a1):\n                v11 = 0 if a3[v9] == a4[v10] else 1\n                v12 = v2\n                v13 = -1\n                for v14 in v3[v9]:\n                    if v7[v10 - 1][v14] < v12:\n                        v12 = v7[v10 - 1][v14]\n                        v13 = v14\n                if v13 != -1:\n                    v7[v10][v9] = v11 + v12\n                    v8[v10][v9] = v13\n        v15 = v2\n        v16 = -1\n        for v9 in range(a1):\n            if v7[v1 - 1][v9] < v15:\n                v15 = v7[v1 - 1][v9]\n                v16 = v9\n        v17 = []\n        v18 = v16\n        for v10 in range(v1 - 1, -1, -1):\n            v17.append(v18)\n            if v10 > 0:\n                v18 = v8[v10][v18]\n        v17.reverse()\n        return v17\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def mostSimilar(self, a1, a2, a3, a4):\n        v1 = len(a4)\n        v2 = v1 + 1\n        v3 = [[] for v4 in range(a1)]\n        for v5, v6 in a2:\n            v3[v5].append(v6)\n            v3[v6].append(v5)\n        v7 = [[v2] * a1 for v4 in range(v1)]\n        v8 = [[-1] * a1 for v4 in range(v1)]\n        for v9 in range(a1):\n            v7[0][v9] = 0 if a3[v9] == a4[0] else 1\n        for v10 in range(1, v1):\n            for v9 in range(a1):\n                v11 = 0 if a3[v9] == a4[v10] else 1\n                v12 = v2\n                v13 = -1\n                for v14 in v3[v9]:\n                    if v7[v10 - 1][v14] < v12:\n                        v12 = v7[v10 - 1][v14]\n                        v13 = v14\n                if v13 != -1:\n                    v7[v10][v9] = v11 + v12\n                    v8[v10][v9] = v13\n        v15 = v2\n        v16 = -1\n        for v9 in range(a1):\n            if v7[v1 - 1][v9] < v15:\n                v15 = v7[v1 - 1][v9]\n                v16 = v9\n        v17 = []\n        v18 = v16\n        for v10 in range(v1 - 1, -1, -1):\n            v17.append(v18)\n            if v10 > 0:\n                v18 = v8[v10][v18]\n        v17.reverse()\n        return v17\n"}
{"id": "human_code\\shortest-path-in-a-hidden-grid__part2.py", "text": "class C1(object):\n\n    def findShortestPath(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        v2 = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(a1, a2, a3, a4, a5):\n            if a2[0] is None and a3.isTarget():\n                a2[0] = a1\n            a4.add(a1)\n            for v1, (v2, v3) in v1.items():\n                if not a3.canMove(v1):\n                    continue\n                v4 = (a1[0] + v2, a1[1] + v3)\n                a5[a1].add(v4)\n                a5[v4].add(a1)\n                if v4 in a4:\n                    continue\n                a3.move(v1)\n                dfs(v4, a2, a3, a4, a5)\n                a3.move(v2[v1])\n\n        def bfs(a1, a2, a3):\n            v1 = [a2]\n            v2 = set(v1)\n            v3 = 0\n            while v1:\n                v4 = []\n                for v5 in v1:\n                    if v5 == a3:\n                        return v3\n                    for v6 in a1[v5]:\n                        if v6 in v2:\n                            continue\n                        v2.add(v6)\n                        v4.append(v6)\n                v1 = v4\n                v3 += 1\n            return -1\n        v3 = (0, 0)\n        v4 = [None]\n        v5 = collections.defaultdict(set)\n        dfs(v3, v4, a1, set(), v5)\n        if not v4[0]:\n            return -1\n        return bfs(v5, v3, v4[0])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findShortestPath(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n        v2 = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}\n\n        def dfs(a1, a2, a3, a4, a5):\n            if a2[0] is None and a3.isTarget():\n                a2[0] = a1\n            a4.add(a1)\n            for v1, (v2, v3) in v1.items():\n                if not a3.canMove(v1):\n                    continue\n                v4 = (a1[0] + v2, a1[1] + v3)\n                a5[a1].add(v4)\n                a5[v4].add(a1)\n                if v4 in a4:\n                    continue\n                a3.move(v1)\n                dfs(v4, a2, a3, a4, a5)\n                a3.move(v2[v1])\n\n        def bfs(a1, a2, a3):\n            v1 = [a2]\n            v2 = set(v1)\n            v3 = 0\n            while v1:\n                v4 = []\n                for v5 in v1:\n                    if v5 == a3:\n                        return v3\n                    for v6 in a1[v5]:\n                        if v6 in v2:\n                            continue\n                        v2.add(v6)\n                        v4.append(v6)\n                v1 = v4\n                v3 += 1\n            return -1\n        v3 = (0, 0)\n        v4 = [None]\n        v5 = collections.defaultdict(set)\n        dfs(v3, v4, a1, set(), v5)\n        if not v4[0]:\n            return -1\n        return bfs(v5, v3, v4[0])\n"}
{"id": "llm_code\\p03311__s936142289.py", "text": "import numpy as np\nv1 = int(input())\nv2 = list(map(int, input().split(' ')))\nv3 = [i for v4 in range(1, v1 + 1, 1)]\nv2 = np.array(v2)\nv3 = np.array(v3)\nv2 -= v3\nv5 = sum(abs(v2))\nwhile True:\n    v6 = v2 < 0\n    v7 = v2 > 0\n    v6 = v6 * v2\n    v7 = v7 * v2\n    if abs(sum(v6)) > abs(sum(v7)):\n        v2 += (abs(sum(v6)) - abs(sum(v7))) // v1 + 1\n    else:\n        v2 -= (abs(sum(v7)) - abs(sum(v6))) // v1 + 1\n    if v5 <= sum(abs(v2)):\n        break\n    else:\n        v5 = sum(abs(v2))\nprint(v5)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import numpy as np\nv1 = int(input())\nv2 = list(map(int, input().split(' ')))\nv3 = [i for v4 in range(1, v1 + 1, 1)]\nv2 = np.array(v2)\nv3 = np.array(v3)\nv2 -= v3\nv5 = sum(abs(v2))\nwhile True:\n    v6 = v2 < 0\n    v7 = v2 > 0\n    v6 = v6 * v2\n    v7 = v7 * v2\n    if abs(sum(v6)) > abs(sum(v7)):\n        v2 += (abs(sum(v6)) - abs(sum(v7))) // v1 + 1\n    else:\n        v2 -= (abs(sum(v7)) - abs(sum(v6))) // v1 + 1\n    if v5 <= sum(abs(v2)):\n        break\n    else:\n        v5 = sum(abs(v2))\nprint(v5)\n"}
{"id": "llm_code\\check-if-digits-are-equal-in-string-after-operations-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def hasSameDigits(self, a1):\n        v1 = len(a1)\n        if v1 < 2:\n            return True\n        v2 = [int(c) for v3 in a1]\n        v4 = [v2[j] - v2[j + 1] for v5 in range(v1 - 1)]\n        v6 = v1 - 2\n\n        def sum_mod_prime(a1):\n            v1 = 0\n            for v2 in range(v6 + 1):\n                v3 = lucas(v6, v2, a1)\n                v1 = (v1 + v3 * (v4[v2] % a1)) % a1\n            return v1\n\n        def lucas(a1, a2, a3):\n            if a2 < 0 or a2 > a1:\n                return 0\n            v1 = 1\n            while a1 or a2:\n                v2 = a1 % a3\n                v3 = a2 % a3\n                if v3 > v2:\n                    return 0\n                v1 = v1 * small_binom(v2, v3) % a3\n                a1 //= a3\n                a2 //= a3\n            return v1\n\n        def small_binom(a1, a2):\n            if a2 > a1 - a2:\n                a2 = a1 - a2\n            if a2 == 0:\n                return 1\n            v2 = 1\n            for v3 in range(1, a2 + 1):\n                v2 *= a1 - v3 + 1\n                v2 //= v3\n            return v2\n        return sum_mod_prime(2) == 0 and sum_mod_prime(5) == 0\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def hasSameDigits(self, a1):\n        v1 = len(a1)\n        if v1 < 2:\n            return True\n        v2 = [int(c) for v3 in a1]\n        v4 = [v2[j] - v2[j + 1] for v5 in range(v1 - 1)]\n        v6 = v1 - 2\n\n        def sum_mod_prime(a1):\n            v1 = 0\n            for v2 in range(v6 + 1):\n                v3 = lucas(v6, v2, a1)\n                v1 = (v1 + v3 * (v4[v2] % a1)) % a1\n            return v1\n\n        def lucas(a1, a2, a3):\n            if a2 < 0 or a2 > a1:\n                return 0\n            v1 = 1\n            while a1 or a2:\n                v2 = a1 % a3\n                v3 = a2 % a3\n                if v3 > v2:\n                    return 0\n                v1 = v1 * small_binom(v2, v3) % a3\n                a1 //= a3\n                a2 //= a3\n            return v1\n\n        def small_binom(a1, a2):\n            if a2 > a1 - a2:\n                a2 = a1 - a2\n            if a2 == 0:\n                return 1\n            v2 = 1\n            for v3 in range(1, a2 + 1):\n                v2 *= a1 - v3 + 1\n                v2 //= v3\n            return v2\n        return sum_mod_prime(2) == 0 and sum_mod_prime(5) == 0\n"}
{"id": "llm_code\\p02715__s391490622.py", "text": "v1 = int(input())\nv2 = list(map(int, input().split()))\nif v1 % 2 == 0:\n    v3 = sum(v2[::2])\n    print(max(sum(v2) - v3, v3))\nelif v1 == 3:\n    print(v2[0] + v2[2])\nelse:\n    v4 = -10 ** 12\n    v5 = [[v4 for v6 in range(3)] for v7 in range(v1)]\n    v5[0][0] = v2[0]\n    v5[1][1] = v2[1]\n    v5[2][2] = v2[2]\n    v5[2][0] = v2[0] + v2[2]\n    for v6 in range(3, v1):\n        v5[v6][0] = v5[v6 - 2][0] + v2[v6]\n        v5[v6][1] = max(v5[v6 - 3][0] + v2[v6], v5[v6 - 2][1] + v2[v6])\n        if v6 >= 4:\n            v5[v6][2] = max([v5[v6 - 3][1] + v2[v6], v5[v6 - 4][0] + v2[v6], v5[v6 - 2][2] + v2[v6]])\n        else:\n            v5[v6][2] = max([v5[v6 - 3][1] + v2[v6], v5[v6 - 2][2] + v2[v6]])\n    print(max(v5[-1][2], v5[-2][1], v5[-3][0]))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = list(map(int, input().split()))\nif v1 % 2 == 0:\n    v3 = sum(v2[::2])\n    print(max(sum(v2) - v3, v3))\nelif v1 == 3:\n    print(v2[0] + v2[2])\nelse:\n    v4 = -10 ** 12\n    v5 = [[v4 for v6 in range(3)] for v7 in range(v1)]\n    v5[0][0] = v2[0]\n    v5[1][1] = v2[1]\n    v5[2][2] = v2[2]\n    v5[2][0] = v2[0] + v2[2]\n    for v6 in range(3, v1):\n        v5[v6][0] = v5[v6 - 2][0] + v2[v6]\n        v5[v6][1] = max(v5[v6 - 3][0] + v2[v6], v5[v6 - 2][1] + v2[v6])\n        if v6 >= 4:\n            v5[v6][2] = max([v5[v6 - 3][1] + v2[v6], v5[v6 - 4][0] + v2[v6], v5[v6 - 2][2] + v2[v6]])\n        else:\n            v5[v6][2] = max([v5[v6 - 3][1] + v2[v6], v5[v6 - 2][2] + v2[v6]])\n    print(max(v5[-1][2], v5[-2][1], v5[-3][0]))\n"}
{"id": "human_code\\minimum-deletions-to-make-string-k-special__part2.py", "text": "class C1(object):\n\n    def minimumDeletions(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * 26\n        for v2 in a1:\n            v1[ord(v2) - ord('a')] += 1\n        v3 = sorted((v2 for v2 in v1 if v2))\n        v4 = float('inf')\n        v5 = v6 = 0\n        v7 = len(a1)\n        v8 = -1\n        for v9 in range(len(v3)):\n            if v9 + 1 < len(v3) and v3[v9 + 1] == v3[v9]:\n                continue\n            while v5 < len(v3) and v3[v5] <= v3[v9] + a2:\n                v7 -= v3[v5]\n                v5 += 1\n            v4 = min(v4, v6 + (v7 - (v3[v9] + a2) * (len(v3) - v5)))\n            v6 += v3[v9] * (v9 - v8)\n            v8 = v9\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minimumDeletions(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * 26\n        for v2 in a1:\n            v1[ord(v2) - ord('a')] += 1\n        v3 = sorted((v2 for v2 in v1 if v2))\n        v4 = float('inf')\n        v5 = v6 = 0\n        v7 = len(a1)\n        v8 = -1\n        for v9 in range(len(v3)):\n            if v9 + 1 < len(v3) and v3[v9 + 1] == v3[v9]:\n                continue\n            while v5 < len(v3) and v3[v5] <= v3[v9] + a2:\n                v7 -= v3[v5]\n                v5 += 1\n            v4 = min(v4, v6 + (v7 - (v3[v9] + a2) * (len(v3) - v5)))\n            v6 += v3[v9] * (v9 - v8)\n            v8 = v9\n        return v4\n"}
{"id": "llm_code\\the-skyline-problem__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def getSkyline(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        for v2, v3, v4 in a1:\n            v1.append((v2, -v4, v3))\n            v1.append((v3, 0, 0))\n        v1.sort(key=lambda p: (p[0], p[1]))\n        v5 = []\n        v6 = []\n        v7 = 0\n        v8 = 0\n        v9 = len(v1)\n        while v8 < v9:\n            v10 = v1[v8][0]\n            while v8 < v9 and v1[v8][0] == v10 and (v1[v8][1] < 0):\n                v11, v12, v13 = v1[v8]\n                heapq.heappush(v5, (v12, v13))\n                v8 += 1\n            while v8 < v9 and v1[v8][0] == v10:\n                v8 += 1\n            while v5 and v5[0][1] <= v10:\n                heapq.heappop(v5)\n            v14 = -v5[0][0] if v5 else 0\n            if v14 != v7:\n                v6.append([v10, v14])\n                v7 = v14\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def getSkyline(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        for v2, v3, v4 in a1:\n            v1.append((v2, -v4, v3))\n            v1.append((v3, 0, 0))\n        v1.sort(key=lambda p: (p[0], p[1]))\n        v5 = []\n        v6 = []\n        v7 = 0\n        v8 = 0\n        v9 = len(v1)\n        while v8 < v9:\n            v10 = v1[v8][0]\n            while v8 < v9 and v1[v8][0] == v10 and (v1[v8][1] < 0):\n                v11, v12, v13 = v1[v8]\n                heapq.heappush(v5, (v12, v13))\n                v8 += 1\n            while v8 < v9 and v1[v8][0] == v10:\n                v8 += 1\n            while v5 and v5[0][1] <= v10:\n                heapq.heappop(v5)\n            v14 = -v5[0][0] if v5 else 0\n            if v14 != v7:\n                v6.append([v10, v14])\n                v7 = v14\n        return v6\n"}
{"id": "human_code\\number-of-distinct-subarrays-with-at-most-k-odd-integers__part2.py", "text": "class C1(object):\n\n    def distinctSubarraysWithAtMostKOddIntegers(self, a1, a2):\n\n        def countDistinct(a1, a2, a3, a4):\n            v1 = 0\n            for v2 in range(a2, a3 + 1):\n                if a1[v2] not in a4:\n                    v1 += 1\n                a4 = a4[a1[v2]]\n            return v1\n        v1 = lambda: collections.defaultdict(v1)\n        v2 = v1()\n        v3 = 0\n        for v4 in range(len(a1)):\n            v5 = 0\n            for v6 in range(v4, len(a1)):\n                v5 += a1[v6] % 2\n                if v5 > a2:\n                    v6 -= 1\n                    break\n            v3 += countDistinct(a1, v4, v6, v2)\n        return v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def distinctSubarraysWithAtMostKOddIntegers(self, a1, a2):\n\n        def countDistinct(a1, a2, a3, a4):\n            v1 = 0\n            for v2 in range(a2, a3 + 1):\n                if a1[v2] not in a4:\n                    v1 += 1\n                a4 = a4[a1[v2]]\n            return v1\n        v1 = lambda: collections.defaultdict(v1)\n        v2 = v1()\n        v3 = 0\n        for v4 in range(len(a1)):\n            v5 = 0\n            for v6 in range(v4, len(a1)):\n                v5 += a1[v6] % 2\n                if v5 > a2:\n                    v6 -= 1\n                    break\n            v3 += countDistinct(a1, v4, v6, v2)\n        return v3\n"}
{"id": "llm_code\\count-substrings-that-can-be-rearranged-to-contain-a-string-i__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def validSubstringCount(self, a1, a2):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a2:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = sum((v > 0 for v5 in v2))\n        v6 = [0] * 26\n        v7 = 0\n        v8 = 0\n        v9 = 0\n        for v10 in range(v1):\n            while v8 < v1 and v7 < v4:\n                v11 = ord(a1[v8]) - ord('a')\n                v12 = v6[v11]\n                v6[v11] += 1\n                if v2[v11] > 0 and v12 < v2[v11] <= v6[v11]:\n                    v7 += 1\n                v8 += 1\n            if v7 == v4:\n                v13 = max(v10, v8 - 1)\n                v9 += v1 - v13\n            v11 = ord(a1[v10]) - ord('a')\n            v12 = v6[v11]\n            v6[v11] -= 1\n            if v2[v11] > 0 and v12 == v2[v11]:\n                v7 -= 1\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def validSubstringCount(self, a1, a2):\n        v1 = len(a1)\n        v2 = [0] * 26\n        for v3 in a2:\n            v2[ord(v3) - ord('a')] += 1\n        v4 = sum((v > 0 for v5 in v2))\n        v6 = [0] * 26\n        v7 = 0\n        v8 = 0\n        v9 = 0\n        for v10 in range(v1):\n            while v8 < v1 and v7 < v4:\n                v11 = ord(a1[v8]) - ord('a')\n                v12 = v6[v11]\n                v6[v11] += 1\n                if v2[v11] > 0 and v12 < v2[v11] <= v6[v11]:\n                    v7 += 1\n                v8 += 1\n            if v7 == v4:\n                v13 = max(v10, v8 - 1)\n                v9 += v1 - v13\n            v11 = ord(a1[v10]) - ord('a')\n            v12 = v6[v11]\n            v6[v11] -= 1\n            if v2[v11] > 0 and v12 == v2[v11]:\n                v7 -= 1\n        return v9\n"}
{"id": "human_code\\contain-virus.py", "text": "class C1(object):\n\n    def containVirus(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n\n        def dfs(a1, a2, a3, a4, a5, a6, a7):\n            if (a2, a3) in a4:\n                return\n            a4.add((a2, a3))\n            a5[-1].add((a2, a3))\n            for v1 in v1:\n                v2, v3 = (a2 + v1[0], a3 + v1[1])\n                if not (0 <= v2 < len(a1) and 0 <= v3 < len(a1[a2])):\n                    continue\n                if a1[v2][v3] == 1:\n                    dfs(a1, v2, v3, a4, a5, a6, a7)\n                elif a1[v2][v3] == 0:\n                    a6[-1].add((v2, v3))\n                    a7[-1] += 1\n        v2 = 0\n        while True:\n            v3, v4, v5, v6 = (set(), [], [], [])\n            for v7, v8 in enumerate(a1):\n                for v9, v10 in enumerate(v8):\n                    if v10 == 1 and (v7, v9) not in v3:\n                        v4.append(set())\n                        v5.append(set())\n                        v6.append(0)\n                        dfs(a1, v7, v9, v3, v4, v5, v6)\n            if not v4:\n                break\n            v11 = v5.index(max(v5, key=len))\n            for v12, v13 in enumerate(v4):\n                if v12 == v11:\n                    v2 += v6[v12]\n                    for v7, v9 in v13:\n                        a1[v7][v9] = -1\n                    continue\n                for v7, v9 in v13:\n                    for v14 in v1:\n                        v15, v16 = (v7 + v14[0], v9 + v14[1])\n                        if not (0 <= v15 < len(a1) and 0 <= v16 < len(a1[v7])):\n                            continue\n                        if a1[v15][v16] == 0:\n                            a1[v15][v16] = 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def containVirus(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n\n        def dfs(a1, a2, a3, a4, a5, a6, a7):\n            if (a2, a3) in a4:\n                return\n            a4.add((a2, a3))\n            a5[-1].add((a2, a3))\n            for v1 in v1:\n                v2, v3 = (a2 + v1[0], a3 + v1[1])\n                if not (0 <= v2 < len(a1) and 0 <= v3 < len(a1[a2])):\n                    continue\n                if a1[v2][v3] == 1:\n                    dfs(a1, v2, v3, a4, a5, a6, a7)\n                elif a1[v2][v3] == 0:\n                    a6[-1].add((v2, v3))\n                    a7[-1] += 1\n        v2 = 0\n        while True:\n            v3, v4, v5, v6 = (set(), [], [], [])\n            for v7, v8 in enumerate(a1):\n                for v9, v10 in enumerate(v8):\n                    if v10 == 1 and (v7, v9) not in v3:\n                        v4.append(set())\n                        v5.append(set())\n                        v6.append(0)\n                        dfs(a1, v7, v9, v3, v4, v5, v6)\n            if not v4:\n                break\n            v11 = v5.index(max(v5, key=len))\n            for v12, v13 in enumerate(v4):\n                if v12 == v11:\n                    v2 += v6[v12]\n                    for v7, v9 in v13:\n                        a1[v7][v9] = -1\n                    continue\n                for v7, v9 in v13:\n                    for v14 in v1:\n                        v15, v16 = (v7 + v14[0], v9 + v14[1])\n                        if not (0 <= v15 < len(a1) and 0 <= v16 < len(a1[v7])):\n                            continue\n                        if a1[v15][v16] == 0:\n                            a1[v15][v16] = 1\n        return v2\n"}
{"id": "human_code\\p02997__s413480791.py", "text": "import sys\ninput = sys.stdin.buffer.readline\n\ndef f1():\n    return sys.stdin.read()\n\ndef f2():\n    return int(input())\n\ndef f3():\n    return map(int, input().split())\n\ndef f4():\n    return map(float, input().split())\n\ndef f5():\n    return list(map(int, input().split()))\n\ndef f6():\n    return list(map(float, input().split()))\n\ndef f7():\n    return tuple(map(int, input().split()))\n\ndef f8():\n    v1, v2 = f3()\n    v3 = (v1 - 1) * (v1 - 2) // 2 - v2\n    if v3 < 0:\n        print(-1)\n        exit()\n    v4 = []\n    for v5 in range(1, v1):\n        v4.append([v5, v1])\n    for v5 in range(1, v1):\n        for v6 in range(v5 + 1, v1):\n            if v3 > 0:\n                v3 -= 1\n                v4.append([v5, v6])\n    print(len(v4))\n    for v5, v6 in v4:\n        print(v5, v6)\nif __name__ == '__main__':\n    f8()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\ninput = sys.stdin.buffer.readline\n\ndef f1():\n    return sys.stdin.read()\n\ndef f2():\n    return int(input())\n\ndef f3():\n    return map(int, input().split())\n\ndef f4():\n    return map(float, input().split())\n\ndef f5():\n    return list(map(int, input().split()))\n\ndef f6():\n    return list(map(float, input().split()))\n\ndef f7():\n    return tuple(map(int, input().split()))\n\ndef f8():\n    v1, v2 = f3()\n    v3 = (v1 - 1) * (v1 - 2) // 2 - v2\n    if v3 < 0:\n        print(-1)\n        exit()\n    v4 = []\n    for v5 in range(1, v1):\n        v4.append([v5, v1])\n    for v5 in range(1, v1):\n        for v6 in range(v5 + 1, v1):\n            if v3 > 0:\n                v3 -= 1\n                v4.append([v5, v6])\n    print(len(v4))\n    for v5, v6 in v4:\n        print(v5, v6)\nif __name__ == '__main__':\n    f8()\n"}
{"id": "human_code\\p03472__s954142849.py", "text": "import math\nv1, v2 = map(int, input().split())\nv3, v4 = ([], [])\nfor v5 in range(v1):\n    v6, v7 = map(int, input().split())\n    v3.append(v6)\n    v4.append(v7)\nv8 = max(v3)\nv9 = [x for v10 in v4 if v8 < v10]\nif sum(v9) >= v2:\n    v11 = 0\n    v12 = 0\n    for v13 in sorted(v9)[::-1]:\n        v11 += v13\n        v12 += 1\n        if v11 >= v2:\n            print(v12)\n            exit()\nv2 -= sum(v9)\nv14 = len(v9) + math.ceil(v2 / v8)\nprint(v14)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math\nv1, v2 = map(int, input().split())\nv3, v4 = ([], [])\nfor v5 in range(v1):\n    v6, v7 = map(int, input().split())\n    v3.append(v6)\n    v4.append(v7)\nv8 = max(v3)\nv9 = [x for v10 in v4 if v8 < v10]\nif sum(v9) >= v2:\n    v11 = 0\n    v12 = 0\n    for v13 in sorted(v9)[::-1]:\n        v11 += v13\n        v12 += 1\n        if v11 >= v2:\n            print(v12)\n            exit()\nv2 -= sum(v9)\nv14 = len(v9) + math.ceil(v2 / v8)\nprint(v14)\n"}
{"id": "llm_code\\p02955__s068116857.py", "text": "import sys\nfrom math import sqrt\nfrom collections import deque\n\ndef f1():\n    return sys.stdin.readline().strip()\n\ndef f2(a1, a2, a3):\n    return [[a3] * a2 for v1 in range(a1)]\n\ndef f3(a1, a2, a3, a4):\n    return [[[a4] * a3 for v1 in range(a2)] for v2 in range(a1)]\n\ndef f4(a1, a2=1):\n    return int(-(-a1 // a2))\n\ndef f5():\n    return int(f1())\n\ndef f6():\n    return map(int, f1().split())\n\ndef f7():\n    return list(map(int, f1().split()))\n\ndef f8():\n    print('Yes')\n\ndef f9():\n    print('No')\n\ndef f10():\n    print('YES')\n\ndef f11():\n    print('NO')\nsys.setrecursionlimit(10 ** 9)\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3, v4 = f6()\nv5 = f7()\nv6 = sum(v5)\n\ndef f12(a1: int) -> set:\n    \"\"\"  \"\"\"\n    v1 = {1, a1}\n    for v2 in range(2, int(sqrt(a1)) + 1):\n        if a1 % v2 == 0:\n            v1.add(v2)\n            v1.add(a1 // v2)\n    return v1\nv7 = sorted(f12(v6), reverse=True)\nfor v8 in v7:\n    v9 = []\n    for v10 in range(v3):\n        if v5[v10] % v8 != 0:\n            v9.append(v5[v10] % v8)\n    v9.sort()\n    v9 = deque(v9)\n    v11 = 0\n    while len(v9):\n        v12 = v9[0] % v8\n        v13 = v8 - v9[-1] % v8\n        if v12 > v13:\n            v9[0] -= v13\n            v9.pop()\n            v11 += v13\n        elif v12 < v13:\n            v9[-1] -= v12\n            v9.popleft()\n            v11 += v12\n        else:\n            v9.pop()\n            v9.popleft()\n            v11 += v12\n    if v11 <= v4:\n        print(v8)\n        exit()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\nfrom math import sqrt\nfrom collections import deque\n\ndef f1():\n    return sys.stdin.readline().strip()\n\ndef f2(a1, a2, a3):\n    return [[a3] * a2 for v1 in range(a1)]\n\ndef f3(a1, a2, a3, a4):\n    return [[[a4] * a3 for v1 in range(a2)] for v2 in range(a1)]\n\ndef f4(a1, a2=1):\n    return int(-(-a1 // a2))\n\ndef f5():\n    return int(f1())\n\ndef f6():\n    return map(int, f1().split())\n\ndef f7():\n    return list(map(int, f1().split()))\n\ndef f8():\n    print('Yes')\n\ndef f9():\n    print('No')\n\ndef f10():\n    print('YES')\n\ndef f11():\n    print('NO')\nsys.setrecursionlimit(10 ** 9)\nv1 = float('inf')\nv2 = 10 ** 9 + 7\nv3, v4 = f6()\nv5 = f7()\nv6 = sum(v5)\n\ndef f12(a1: int) -> set:\n    \"\"\"  \"\"\"\n    v1 = {1, a1}\n    for v2 in range(2, int(sqrt(a1)) + 1):\n        if a1 % v2 == 0:\n            v1.add(v2)\n            v1.add(a1 // v2)\n    return v1\nv7 = sorted(f12(v6), reverse=True)\nfor v8 in v7:\n    v9 = []\n    for v10 in range(v3):\n        if v5[v10] % v8 != 0:\n            v9.append(v5[v10] % v8)\n    v9.sort()\n    v9 = deque(v9)\n    v11 = 0\n    while len(v9):\n        v12 = v9[0] % v8\n        v13 = v8 - v9[-1] % v8\n        if v12 > v13:\n            v9[0] -= v13\n            v9.pop()\n            v11 += v13\n        elif v12 < v13:\n            v9[-1] -= v12\n            v9.popleft()\n            v11 += v12\n        else:\n            v9.pop()\n            v9.popleft()\n            v11 += v12\n    if v11 <= v4:\n        print(v8)\n        exit()\n"}
{"id": "llm_code\\maximum-path-quality-of-a-graph__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maximalPathQuality(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5, v6 in a2:\n            v2[v4].append((v5, v6))\n            v2[v5].append((v4, v6))\n        v7 = [0] * v1\n\n        def traverse(a1, a2, a3):\n            v7[a1] += 1\n            v1 = a3 + (a1[a1] if v7[a1] == 1 else 0)\n            v2 = v1 if a1 == 0 else 0\n            for v3, v4 in v2[a1]:\n                v5 = (a1, v3)\n                if a2 < v4 or v5 in used_edges:\n                    continue\n                used_edges.add(v5)\n                v2 = max(v2, traverse(v3, a2 - v4, v1))\n                used_edges.remove(v5)\n            v7[a1] -= 1\n            return v2\n        v8 = set()\n        return traverse(0, a3, 0)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximalPathQuality(self, a1, a2, a3):\n        v1 = len(a1)\n        v2 = [[] for v3 in range(v1)]\n        for v4, v5, v6 in a2:\n            v2[v4].append((v5, v6))\n            v2[v5].append((v4, v6))\n        v7 = [0] * v1\n\n        def traverse(a1, a2, a3):\n            v7[a1] += 1\n            v1 = a3 + (a1[a1] if v7[a1] == 1 else 0)\n            v2 = v1 if a1 == 0 else 0\n            for v3, v4 in v2[a1]:\n                v5 = (a1, v3)\n                if a2 < v4 or v5 in used_edges:\n                    continue\n                used_edges.add(v5)\n                v2 = max(v2, traverse(v3, a2 - v4, v1))\n                used_edges.remove(v5)\n            v7[a1] -= 1\n            return v2\n        v8 = set()\n        return traverse(0, a3, 0)\n"}
{"id": "llm_code\\apply-operations-on-array-to-maximize-sum-of-squares__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maxSum(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        if not a1:\n            return 0\n        v2 = max(a1)\n        v3 = 0\n        v4 = 1\n        while v4 <= v2:\n            v3 += 1\n            v4 <<= 1\n        v5 = [0] * v3\n        for v6 in a1:\n            v7 = 0\n            v8 = v6\n            while v8 > 0:\n                if v8 & 1:\n                    v5[v7] += 1\n                v7 += 1\n                v8 >>= 1\n        v9 = 0\n        for v10 in range(1, a2 + 1):\n            v11 = 0\n            for v7 in range(v3):\n                if v5[v7] >= v10:\n                    v11 += 1 << v7\n            v9 = (v9 + v11 * v11) % v1\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxSum(self, a1, a2):\n        v1 = 10 ** 9 + 7\n        if not a1:\n            return 0\n        v2 = max(a1)\n        v3 = 0\n        v4 = 1\n        while v4 <= v2:\n            v3 += 1\n            v4 <<= 1\n        v5 = [0] * v3\n        for v6 in a1:\n            v7 = 0\n            v8 = v6\n            while v8 > 0:\n                if v8 & 1:\n                    v5[v7] += 1\n                v7 += 1\n                v8 >>= 1\n        v9 = 0\n        for v10 in range(1, a2 + 1):\n            v11 = 0\n            for v7 in range(v3):\n                if v5[v7] >= v10:\n                    v11 += 1 << v7\n            v9 = (v9 + v11 * v11) % v1\n        return v9\n"}
{"id": "human_code\\maximum-area-rectangle-with-point-constraints-i__part1.py", "text": "class C1(object):\n\n    def maxRectangleArea(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class BIT(object):\n\n            def __init__(self, a1):\n                self.__bit = [0] * (a1 + 1)\n\n            def add(self, a1, a2):\n                a1 += 1\n                while a1 < len(self.__bit):\n                    self.__bit[a1] += a2\n                    a1 += a1 & -a1\n\n            def query(self, a1):\n                a1 += 1\n                v2 = 0\n                while a1 > 0:\n                    v2 += self.__bit[a1]\n                    a1 -= a1 & -a1\n                return v2\n        a1.sort()\n        v1 = {y: idx for v2, v3 in enumerate(sorted(set((v3 for v4, v3 in a1))))}\n        v5 = BIT(len(v1))\n        v6 = {}\n        v7 = -1\n        for v8, (v9, v3) in enumerate(a1):\n            v10 = v1[v3]\n            v5.add(v10, +1)\n            if not (v8 - 1 >= 0 and a1[v8 - 1][0] == v9):\n                continue\n            v11 = v1[a1[v8 - 1][1]]\n            v12 = v5.query(v10) - v5.query(v11 - 1)\n            if (v11, v10) in v6 and v6[v11, v10][0] == v12 - 2:\n                v7 = max(v7, (v9 - v6[v11, v10][1]) * (v3 - a1[v8 - 1][1]))\n            v6[v11, v10] = (v12, v9)\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maxRectangleArea(self, a1):\n        \"\"\"\n        \"\"\"\n\n        class BIT(object):\n\n            def __init__(self, a1):\n                self.__bit = [0] * (a1 + 1)\n\n            def add(self, a1, a2):\n                a1 += 1\n                while a1 < len(self.__bit):\n                    self.__bit[a1] += a2\n                    a1 += a1 & -a1\n\n            def query(self, a1):\n                a1 += 1\n                v2 = 0\n                while a1 > 0:\n                    v2 += self.__bit[a1]\n                    a1 -= a1 & -a1\n                return v2\n        a1.sort()\n        v1 = {y: idx for v2, v3 in enumerate(sorted(set((v3 for v4, v3 in a1))))}\n        v5 = BIT(len(v1))\n        v6 = {}\n        v7 = -1\n        for v8, (v9, v3) in enumerate(a1):\n            v10 = v1[v3]\n            v5.add(v10, +1)\n            if not (v8 - 1 >= 0 and a1[v8 - 1][0] == v9):\n                continue\n            v11 = v1[a1[v8 - 1][1]]\n            v12 = v5.query(v10) - v5.query(v11 - 1)\n            if (v11, v10) in v6 and v6[v11, v10][0] == v12 - 2:\n                v7 = max(v7, (v9 - v6[v11, v10][1]) * (v3 - a1[v8 - 1][1]))\n            v6[v11, v10] = (v12, v9)\n        return v7\n"}
{"id": "llm_code\\minimum-stability-factor-of-array__grok-4.1-fast__v1.py", "text": "from math import gcd\n\nclass C1:\n\n    def minStable(self, a1, a2):\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = v1.bit_length()\n        v3 = [[0] * v1 for v4 in range(v2)]\n        for v5 in range(v1):\n            v3[0][v5] = a1[v5]\n        for v6 in range(1, v2):\n            v7 = 1 << v6 - 1\n            for v8 in range(v1 - (1 << v6) + 1):\n                v3[v6][v8] = gcd(v3[v6 - 1][v8], v3[v6 - 1][v8 + v7])\n\n        def get_gcd(a1, a2):\n            v1 = a2 - a1 + 1\n            v2 = v1.bit_length() - 1\n            v3 = 1 << v2\n            return gcd(v3[v2][a1], v3[v2][a2 - v3 + 1])\n\n        def valid_length(a1):\n            v1 = 0\n            v2 = 0\n            while v2 + a1 <= v1:\n                if get_gcd(v2, v2 + a1 - 1) >= 2:\n                    v1 += 1\n                    v2 += a1\n                else:\n                    v2 += 1\n            return v1 > a2\n        v9, v10 = (0, v1)\n        while v9 < v10:\n            v11 = (v9 + v10 + 1) // 2\n            if valid_length(v11):\n                v9 = v11\n            else:\n                v10 = v11 - 1\n        return v9\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from math import gcd\n\nclass C1:\n\n    def minStable(self, a1, a2):\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = v1.bit_length()\n        v3 = [[0] * v1 for v4 in range(v2)]\n        for v5 in range(v1):\n            v3[0][v5] = a1[v5]\n        for v6 in range(1, v2):\n            v7 = 1 << v6 - 1\n            for v8 in range(v1 - (1 << v6) + 1):\n                v3[v6][v8] = gcd(v3[v6 - 1][v8], v3[v6 - 1][v8 + v7])\n\n        def get_gcd(a1, a2):\n            v1 = a2 - a1 + 1\n            v2 = v1.bit_length() - 1\n            v3 = 1 << v2\n            return gcd(v3[v2][a1], v3[v2][a2 - v3 + 1])\n\n        def valid_length(a1):\n            v1 = 0\n            v2 = 0\n            while v2 + a1 <= v1:\n                if get_gcd(v2, v2 + a1 - 1) >= 2:\n                    v1 += 1\n                    v2 += a1\n                else:\n                    v2 += 1\n            return v1 > a2\n        v9, v10 = (0, v1)\n        while v9 < v10:\n            v11 = (v9 + v10 + 1) // 2\n            if valid_length(v11):\n                v9 = v11\n            else:\n                v10 = v11 - 1\n        return v9\n"}
{"id": "human_code\\p03230__s895095567.py", "text": "import sys\nv1 = ['clipboard', 'file', 'key']\nv2 = 1\nv3 = v1[v2]\nv4 = lambda: map(int, input().split())\nv5 = lambda: list(v4())\nv6 = 1000000007\n\ndef f1(a1):\n    for v1 in range(a1 + 1):\n        if 2 * a1 == v1 * (v1 + 1):\n            return v1 + 1\n        if 2 * a1 < v1 * (v1 + 1):\n            return -1\n    return -1\n\ndef f2():\n    v1 = int(input())\n    v2 = f1(v1)\n    if v2 == -1:\n        return 'No'\n    print('Yes')\n    print(v2)\n    v3 = v2 - 1\n    v4 = []\n    v4.append(list(range(1, v3 + 1)))\n    next = v3 + 1\n    for v5 in range(v2 - 1):\n        v6 = []\n        for v7, v8 in enumerate(v4):\n            v6.append(v8[len(v4) - 1])\n        while len(v6) < v3:\n            v6.append(next)\n            next += 1\n        v4.append(v6)\n    for v8 in v4:\n        print(v3, *v8)\nv7 = False\n\ndef f3(a1):\n    if v7:\n        print(a1)\n\ndef f4():\n    import clipboard\n    v1 = clipboard.get()\n    v2 = v1.splitlines()\n    for v3 in v2:\n        yield v3\nif __name__ == '__main__':\n    if sys.platform == 'ios':\n        if v3 == v1[0]:\n            v8 = f4()\n            input = lambda: v8.__next__()\n        elif v3 == v1[1]:\n            sys.stdin = open('inputFile.txt')\n        else:\n            pass\n        v7 = True\n    else:\n        pass\n    v9 = f2()\n    if v9 is not None:\n        print(v9)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1 = ['clipboard', 'file', 'key']\nv2 = 1\nv3 = v1[v2]\nv4 = lambda: map(int, input().split())\nv5 = lambda: list(v4())\nv6 = 1000000007\n\ndef f1(a1):\n    for v1 in range(a1 + 1):\n        if 2 * a1 == v1 * (v1 + 1):\n            return v1 + 1\n        if 2 * a1 < v1 * (v1 + 1):\n            return -1\n    return -1\n\ndef f2():\n    v1 = int(input())\n    v2 = f1(v1)\n    if v2 == -1:\n        return 'No'\n    print('Yes')\n    print(v2)\n    v3 = v2 - 1\n    v4 = []\n    v4.append(list(range(1, v3 + 1)))\n    next = v3 + 1\n    for v5 in range(v2 - 1):\n        v6 = []\n        for v7, v8 in enumerate(v4):\n            v6.append(v8[len(v4) - 1])\n        while len(v6) < v3:\n            v6.append(next)\n            next += 1\n        v4.append(v6)\n    for v8 in v4:\n        print(v3, *v8)\nv7 = False\n\ndef f3(a1):\n    if v7:\n        print(a1)\n\ndef f4():\n    import clipboard\n    v1 = clipboard.get()\n    v2 = v1.splitlines()\n    for v3 in v2:\n        yield v3\nif __name__ == '__main__':\n    if sys.platform == 'ios':\n        if v3 == v1[0]:\n            v8 = f4()\n            input = lambda: v8.__next__()\n        elif v3 == v1[1]:\n            sys.stdin = open('inputFile.txt')\n        else:\n            pass\n        v7 = True\n    else:\n        pass\n    v9 = f2()\n    if v9 is not None:\n        print(v9)\n"}
{"id": "human_code\\minimum-edge-weight-equilibrium-queries-in-a-tree__part2.py", "text": "import collections\nfrom functools import partial\n\nclass C1(object):\n\n    def __init__(self, a1):\n\n        def preprocess(a1, a2, a3):\n            D[a1] = 1 if a2 == -1 else D[a2] + 1\n            if a2 != -1:\n                P[a1].append(a2)\n            v1 = 0\n            while v1 < len(P[a1]) and v1 < len(P[P[a1][v1]]):\n                P[a1].append(P[P[a1][v1]][v1])\n                v1 += 1\n            C[0] += 1\n            L[a1] = C[0]\n            if a3 != -1:\n                cnt[a3] += 1\n            CNT[a1] = cnt[:]\n\n        def divide(a1, a2, a3):\n            stk.append(partial(postprocess, a1, a3))\n            for v1 in reversed(range(len(a1[a1]))):\n                v2, v3 = a1[a1][v1]\n                if v2 == a2:\n                    continue\n                stk.append(partial(divide, v2, a1, v3))\n            stk.append(partial(preprocess, a1, a2, a3))\n\n        def postprocess(a1, a2):\n            R[a1] = C[0]\n            if a2 != -1:\n                cnt[a2] -= 1\n        v1 = len(a1)\n        v2, v3, v4, v5, v6 = ([0] * v1, [0] * v1, [0] * v1, [[] for v7 in range(v1)], [-1])\n        v8 = [[0] * MAX_W for v7 in range(v1)]\n        v9 = [0] * MAX_W\n        v10 = []\n        v10.append(partial(divide, 0, -1, -1))\n        while v10:\n            v10.pop()()\n        assert v6[0] == v1 - 1\n        self.L, self.R, self.D, self.P = (v2, v3, v4, v5)\n        self.CNT = v8\n\n    def is_ancestor(self, a1, a2):\n        return self.L[a1] <= self.L[a2] <= self.R[a2] <= self.R[a1]\n\n    def lca(self, a1, a2):\n        if self.D[a1] > self.D[a2]:\n            a1, a2 = (a2, a1)\n        if self.is_ancestor(a1, a2):\n            return a1\n        for v3 in reversed(range(len(self.P[a1]))):\n            if v3 < len(self.P[a1]) and (not self.is_ancestor(self.P[a1][v3], a2)):\n                a1 = self.P[a1][v3]\n        return self.P[a1][0]\nv1 = 26\n\nclass C2(object):\n\n    def minOperationsQueries(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v5 -= 1\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = C1(v1)\n        v7 = [0] * len(a3)\n        for v8, (v9, v10) in enumerate(a3):\n            v11 = v6.lca(v9, v10)\n            v7[v8] = v6.D[v9] + v6.D[v10] - 2 * v6.D[v11] - max((v6.CNT[v9][v5] + v6.CNT[v10][v5] - 2 * v6.CNT[v11][v5] for v5 in range(v1)))\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom functools import partial\n\nclass C1(object):\n\n    def __init__(self, a1):\n\n        def preprocess(a1, a2, a3):\n            D[a1] = 1 if a2 == -1 else D[a2] + 1\n            if a2 != -1:\n                P[a1].append(a2)\n            v1 = 0\n            while v1 < len(P[a1]) and v1 < len(P[P[a1][v1]]):\n                P[a1].append(P[P[a1][v1]][v1])\n                v1 += 1\n            C[0] += 1\n            L[a1] = C[0]\n            if a3 != -1:\n                cnt[a3] += 1\n            CNT[a1] = cnt[:]\n\n        def divide(a1, a2, a3):\n            stk.append(partial(postprocess, a1, a3))\n            for v1 in reversed(range(len(a1[a1]))):\n                v2, v3 = a1[a1][v1]\n                if v2 == a2:\n                    continue\n                stk.append(partial(divide, v2, a1, v3))\n            stk.append(partial(preprocess, a1, a2, a3))\n\n        def postprocess(a1, a2):\n            R[a1] = C[0]\n            if a2 != -1:\n                cnt[a2] -= 1\n        v1 = len(a1)\n        v2, v3, v4, v5, v6 = ([0] * v1, [0] * v1, [0] * v1, [[] for v7 in range(v1)], [-1])\n        v8 = [[0] * MAX_W for v7 in range(v1)]\n        v9 = [0] * MAX_W\n        v10 = []\n        v10.append(partial(divide, 0, -1, -1))\n        while v10:\n            v10.pop()()\n        assert v6[0] == v1 - 1\n        self.L, self.R, self.D, self.P = (v2, v3, v4, v5)\n        self.CNT = v8\n\n    def is_ancestor(self, a1, a2):\n        return self.L[a1] <= self.L[a2] <= self.R[a2] <= self.R[a1]\n\n    def lca(self, a1, a2):\n        if self.D[a1] > self.D[a2]:\n            a1, a2 = (a2, a1)\n        if self.is_ancestor(a1, a2):\n            return a1\n        for v3 in reversed(range(len(self.P[a1]))):\n            if v3 < len(self.P[a1]) and (not self.is_ancestor(self.P[a1][v3], a2)):\n                a1 = self.P[a1][v3]\n        return self.P[a1][0]\nv1 = 26\n\nclass C2(object):\n\n    def minOperationsQueries(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4, v5 in a2:\n            v5 -= 1\n            v1[v3].append((v4, v5))\n            v1[v4].append((v3, v5))\n        v6 = C1(v1)\n        v7 = [0] * len(a3)\n        for v8, (v9, v10) in enumerate(a3):\n            v11 = v6.lca(v9, v10)\n            v7[v8] = v6.D[v9] + v6.D[v10] - 2 * v6.D[v11] - max((v6.CNT[v9][v5] + v6.CNT[v10][v5] - 2 * v6.CNT[v11][v5] for v5 in range(v1)))\n        return v7\n"}
{"id": "llm_code\\p02901__s259403713.py", "text": "import copy\nv1, v2 = map(int, input().split())\n\ndef f1(a1):\n    return int(a1) - 1\nv3 = []\nv4 = []\nfor v5 in range(v2):\n    v6, v7 = map(int, input().split())\n    v3.append(v6)\n    v4.append(list(map(f1, input().split())))\n\ndef f2(a1, a2, a3):\n    \"\"\"\n    \n    cost = 0\n    still_closed = [1]*N\n    d = 0\n    \"\"\"\n    if a3 == v2:\n        if sum(a2) == 0:\n            return a1\n        else:\n            return -1\n    v1 = copy.copy(a2)\n    v2 = copy.copy(a2)\n    v3 = f2(a1, v1, a3 + 1)\n    for v4 in v4[a3]:\n        a2[v4] = 0\n    v5 = f2(a1 + v3[a3], a2, a3 + 1)\n    if v3 == -1 or v5 == -1:\n        return max(v3, v5)\n    else:\n        return min(v3, v5)\nprint(f2(0, [1] * v1, 0))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import copy\nv1, v2 = map(int, input().split())\n\ndef f1(a1):\n    return int(a1) - 1\nv3 = []\nv4 = []\nfor v5 in range(v2):\n    v6, v7 = map(int, input().split())\n    v3.append(v6)\n    v4.append(list(map(f1, input().split())))\n\ndef f2(a1, a2, a3):\n    \"\"\"\n    \n    cost = 0\n    still_closed = [1]*N\n    d = 0\n    \"\"\"\n    if a3 == v2:\n        if sum(a2) == 0:\n            return a1\n        else:\n            return -1\n    v1 = copy.copy(a2)\n    v2 = copy.copy(a2)\n    v3 = f2(a1, v1, a3 + 1)\n    for v4 in v4[a3]:\n        a2[v4] = 0\n    v5 = f2(a1 + v3[a3], a2, a3 + 1)\n    if v3 == -1 or v5 == -1:\n        return max(v3, v5)\n    else:\n        return min(v3, v5)\nprint(f2(0, [1] * v1, 0))\n"}
{"id": "human_code\\create-components-with-same-value__part3.py", "text": "class C1(object):\n\n    def componentValue(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            v1 = a1[a1]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 += dfs(v2, a1, a3)\n            return v1 if v1 != a3 else 0\n        v1 = 0\n        v2 = [[] for v3 in range(len(a1))]\n        for v4, v5 in a2:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = sum(a1)\n        for v7 in reversed(range(2, len(a1) + 1)):\n            if v6 % v7 == 0 and dfs(0, -1, v6 // v7) == 0:\n                return v7 - 1\n        return 0\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def componentValue(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def dfs(a1, a2, a3):\n            v1 = a1[a1]\n            for v2 in adj[a1]:\n                if v2 == a2:\n                    continue\n                v1 += dfs(v2, a1, a3)\n            return v1 if v1 != a3 else 0\n        v1 = 0\n        v2 = [[] for v3 in range(len(a1))]\n        for v4, v5 in a2:\n            v2[v4].append(v5)\n            v2[v5].append(v4)\n        v6 = sum(a1)\n        for v7 in reversed(range(2, len(a1) + 1)):\n            if v6 % v7 == 0 and dfs(0, -1, v6 // v7) == 0:\n                return v7 - 1\n        return 0\n"}
{"id": "llm_code\\minimum-time-to-visit-disappearing-nodes__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def minimumTime(self, a1, a2, a3):\n        v1 = float('inf')\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5, v6 in a2:\n            v2[v4].append((v5, v6))\n            v2[v5].append((v4, v6))\n        v7 = [v1] * a1\n        v7[0] = 0\n        v8 = [(0, 0)]\n        while v8:\n            v9, v10 = heapq.heappop(v8)\n            if v9 > v7[v10]:\n                continue\n            for v11, v12 in v2[v10]:\n                v13 = v9 + v12\n                if v13 < v7[v11] and v13 < a3[v11]:\n                    v7[v11] = v13\n                    heapq.heappush(v8, (v13, v11))\n        return [-1 if d == v1 else int(d) for v14 in v7]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def minimumTime(self, a1, a2, a3):\n        v1 = float('inf')\n        v2 = [[] for v3 in range(a1)]\n        for v4, v5, v6 in a2:\n            v2[v4].append((v5, v6))\n            v2[v5].append((v4, v6))\n        v7 = [v1] * a1\n        v7[0] = 0\n        v8 = [(0, 0)]\n        while v8:\n            v9, v10 = heapq.heappop(v8)\n            if v9 > v7[v10]:\n                continue\n            for v11, v12 in v2[v10]:\n                v13 = v9 + v12\n                if v13 < v7[v11] and v13 < a3[v11]:\n                    v7[v11] = v13\n                    heapq.heappush(v8, (v13, v11))\n        return [-1 if d == v1 else int(d) for v14 in v7]\n"}
{"id": "human_code\\construct-2d-grid-matching-graph-layout.py", "text": "class C1(object):\n\n    def constructGridLayout(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def bfs(a1):\n            v1 = [0] * a1\n            v1[a1] = 1\n            v2 = [a1]\n            while v2:\n                v3 = []\n                for a1 in v2:\n                    for v5 in adj[a1]:\n                        if v1[v5]:\n                            continue\n                        v1[v5] = v1[a1] + 1\n                        v3.append(v5)\n                v2 = v3\n            return v1\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = min((len(x) for v6 in v1))\n        v7 = [v3 for v3 in range(a1) if len(v1[v3]) == v5]\n        v8 = bfs(v7[0])\n        v7.sort(key=lambda x: v8[v6])\n        v9 = bfs(v7[1])\n        v10 = v8[v7[1]]\n        v11 = a1 // v10\n        v12 = [[0] * v10 for v2 in range(v11)]\n        for v3 in range(a1):\n            v13 = (v8[v3] + v9[v3] - (1 + v10)) // 2\n            v14 = v8[v3] - 1 - v13\n            v12[v13][v14] = v3\n        return v12\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def constructGridLayout(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def bfs(a1):\n            v1 = [0] * a1\n            v1[a1] = 1\n            v2 = [a1]\n            while v2:\n                v3 = []\n                for a1 in v2:\n                    for v5 in adj[a1]:\n                        if v1[v5]:\n                            continue\n                        v1[v5] = v1[a1] + 1\n                        v3.append(v5)\n                v2 = v3\n            return v1\n        v1 = [[] for v2 in range(a1)]\n        for v3, v4 in a2:\n            v1[v3].append(v4)\n            v1[v4].append(v3)\n        v5 = min((len(x) for v6 in v1))\n        v7 = [v3 for v3 in range(a1) if len(v1[v3]) == v5]\n        v8 = bfs(v7[0])\n        v7.sort(key=lambda x: v8[v6])\n        v9 = bfs(v7[1])\n        v10 = v8[v7[1]]\n        v11 = a1 // v10\n        v12 = [[0] * v10 for v2 in range(v11)]\n        for v3 in range(a1):\n            v13 = (v8[v3] + v9[v3] - (1 + v10)) // 2\n            v14 = v8[v3] - 1 - v13\n            v12[v13][v14] = v3\n        return v12\n"}
{"id": "human_code\\recover-the-original-array.py", "text": "import collections\n\nclass C1(object):\n\n    def recoverArray(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            for v1 in a1:\n                if a2[v1] == 0:\n                    continue\n                if a2[v1 + 2 * a1] == 0:\n                    return False\n                a2[v1] -= 1\n                a2[v1 + 2 * a1] -= 1\n                a3.append(v1 + a1)\n            return True\n        a1.sort()\n        v1 = collections.Counter(a1)\n        for v2 in range(1, len(a1) // 2 + 1):\n            v3 = a1[v2] - a1[0]\n            if v3 == 0 or v3 % 2:\n                continue\n            v3 //= 2\n            v4 = []\n            if check(v3, collections.Counter(v1), v4):\n                return v4\n        return []\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def recoverArray(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3):\n            for v1 in a1:\n                if a2[v1] == 0:\n                    continue\n                if a2[v1 + 2 * a1] == 0:\n                    return False\n                a2[v1] -= 1\n                a2[v1 + 2 * a1] -= 1\n                a3.append(v1 + a1)\n            return True\n        a1.sort()\n        v1 = collections.Counter(a1)\n        for v2 in range(1, len(a1) // 2 + 1):\n            v3 = a1[v2] - a1[0]\n            if v3 == 0 or v3 % 2:\n                continue\n            v3 //= 2\n            v4 = []\n            if check(v3, collections.Counter(v1), v4):\n                return v4\n        return []\n"}
{"id": "human_code\\p02997__s890373375.py", "text": "v1, v2 = map(int, input().split())\nv3 = v1 - 2\nfor v4 in range(3, v1):\n    v3 += v1 - v4\nif v3 < v2:\n    print(-1)\nelse:\n    v5 = []\n    v5.append([1, 2])\n    for v4 in range(3, v1 + 1):\n        v5.append([2, v4])\n    v6 = v3 - v2\n    for v4 in range(3, v1 + 1):\n        if v6 > 0:\n            v5.append([1, v4])\n            v6 -= 1\n        else:\n            break\n    for v4 in range(3, v1):\n        if not v6 > 0:\n            break\n        for v7 in range(v4 + 1, v1 + 1):\n            if not v6 > 0:\n                break\n            v5.append([v4, v7])\n            v6 -= 1\n    v8 = len(v5)\n    print(v8)\n    for v9 in v5:\n        print(*v9)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = v1 - 2\nfor v4 in range(3, v1):\n    v3 += v1 - v4\nif v3 < v2:\n    print(-1)\nelse:\n    v5 = []\n    v5.append([1, 2])\n    for v4 in range(3, v1 + 1):\n        v5.append([2, v4])\n    v6 = v3 - v2\n    for v4 in range(3, v1 + 1):\n        if v6 > 0:\n            v5.append([1, v4])\n            v6 -= 1\n        else:\n            break\n    for v4 in range(3, v1):\n        if not v6 > 0:\n            break\n        for v7 in range(v4 + 1, v1 + 1):\n            if not v6 > 0:\n                break\n            v5.append([v4, v7])\n            v6 -= 1\n    v8 = len(v5)\n    print(v8)\n    for v9 in v5:\n        print(*v9)\n"}
{"id": "llm_code\\optimize-water-distribution-in-a-village__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n        self.rank = [0] * a1\n        self.components = a1\n\n    def find(self, a1):\n        if self.parent[a1] != a1:\n            self.parent[a1] = self.find(self.parent[a1])\n        return self.parent[a1]\n\n    def merge(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.parent[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.parent[v2] = v1\n        else:\n            self.parent[v2] = v1\n            self.rank[v1] += 1\n        self.components -= 1\n        return True\n\nclass C2:\n\n    def minCostToSupplyWater(self, a1, a2, a3):\n        v1 = C1(a1 + 1)\n        v2 = []\n        for v3 in range(1, a1 + 1):\n            v2.append((a2[v3 - 1], 0, v3))\n        for v4, v5, v6 in a3:\n            v2.append((v6, v4, v5))\n        v2.sort()\n        v7 = 0\n        for v6, v8, v9 in v2:\n            if v1.merge(v8, v9):\n                v7 += v6\n                if v1.components == 1:\n                    return v7\n        return v7\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.parent = list(range(a1))\n        self.rank = [0] * a1\n        self.components = a1\n\n    def find(self, a1):\n        if self.parent[a1] != a1:\n            self.parent[a1] = self.find(self.parent[a1])\n        return self.parent[a1]\n\n    def merge(self, a1, a2):\n        v1 = self.find(a1)\n        v2 = self.find(a2)\n        if v1 == v2:\n            return False\n        if self.rank[v1] < self.rank[v2]:\n            self.parent[v1] = v2\n        elif self.rank[v1] > self.rank[v2]:\n            self.parent[v2] = v1\n        else:\n            self.parent[v2] = v1\n            self.rank[v1] += 1\n        self.components -= 1\n        return True\n\nclass C2:\n\n    def minCostToSupplyWater(self, a1, a2, a3):\n        v1 = C1(a1 + 1)\n        v2 = []\n        for v3 in range(1, a1 + 1):\n            v2.append((a2[v3 - 1], 0, v3))\n        for v4, v5, v6 in a3:\n            v2.append((v6, v4, v5))\n        v2.sort()\n        v7 = 0\n        for v6, v8, v9 in v2:\n            if v1.merge(v8, v9):\n                v7 += v6\n                if v1.components == 1:\n                    return v7\n        return v7\n"}
{"id": "llm_code\\recover-a-tree-from-preorder-traversal__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def recoverFromPreorder(self, a1):\n\n        def construct(a1, a2):\n            if a2 >= len(a1):\n                return (None, a2)\n            v1 = a2\n            v2 = 0\n            while v1 < len(a1) and a1[v1] == '-':\n                v2 += 1\n                v1 += 1\n            if v2 != a1:\n                return (None, a2)\n            v3 = v1\n            while v1 < len(a1) and a1[v1] != '-':\n                v1 += 1\n            v4 = C1(int(a1[v3:v1]))\n            v5, a2 = construct(a1 + 1, v1)\n            v4.left = v5\n            v7, a2 = construct(a1 + 1, a2)\n            v4.right = v7\n            return (v4, a2)\n        v1, v2 = construct(0, 0)\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def recoverFromPreorder(self, a1):\n\n        def construct(a1, a2):\n            if a2 >= len(a1):\n                return (None, a2)\n            v1 = a2\n            v2 = 0\n            while v1 < len(a1) and a1[v1] == '-':\n                v2 += 1\n                v1 += 1\n            if v2 != a1:\n                return (None, a2)\n            v3 = v1\n            while v1 < len(a1) and a1[v1] != '-':\n                v1 += 1\n            v4 = C1(int(a1[v3:v1]))\n            v5, a2 = construct(a1 + 1, v1)\n            v4.left = v5\n            v7, a2 = construct(a1 + 1, a2)\n            v4.right = v7\n            return (v4, a2)\n        v1, v2 = construct(0, 0)\n        return v1\n"}
{"id": "llm_code\\next-special-palindrome-number__grok-4.1-fast__v1.py", "text": "import bisect\nimport itertools\nv1 = 16\nv2 = []\n\ndef f1():\n    v1 = set()\n    for v2 in range(1, 512):\n        v3 = []\n        v4 = None\n        v5 = True\n        for v6 in range(9):\n            if v2 & 1 << v6 != 0:\n                v7 = v6 + 1\n                v8 = v7 // 2\n                v3 += [str(v7)] * v8\n                if v7 % 2 != 0:\n                    if v4 is not None:\n                        v5 = False\n                        break\n                    v4 = str(v7)\n        if not v5:\n            continue\n        v9 = len(v3)\n        v10 = 2 * v9 + (1 if v4 else 0)\n        if v10 > v1:\n            continue\n        for v11 in set(itertools.permutations(v3)):\n            v12 = ''.join(v11)\n            v13 = v12 + (v4 or '') + v12[::-1]\n            v1.add(int(v13))\n    global SPECIAL_NUMBERS\n    v2[:] = sorted(v1)\nf1()\n\nclass C1(object):\n\n    def specialPalindrome(self, a1):\n        v1 = bisect.bisect_right(v2, a1)\n        return v2[v1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import bisect\nimport itertools\nv1 = 16\nv2 = []\n\ndef f1():\n    v1 = set()\n    for v2 in range(1, 512):\n        v3 = []\n        v4 = None\n        v5 = True\n        for v6 in range(9):\n            if v2 & 1 << v6 != 0:\n                v7 = v6 + 1\n                v8 = v7 // 2\n                v3 += [str(v7)] * v8\n                if v7 % 2 != 0:\n                    if v4 is not None:\n                        v5 = False\n                        break\n                    v4 = str(v7)\n        if not v5:\n            continue\n        v9 = len(v3)\n        v10 = 2 * v9 + (1 if v4 else 0)\n        if v10 > v1:\n            continue\n        for v11 in set(itertools.permutations(v3)):\n            v12 = ''.join(v11)\n            v13 = v12 + (v4 or '') + v12[::-1]\n            v1.add(int(v13))\n    global SPECIAL_NUMBERS\n    v2[:] = sorted(v1)\nf1()\n\nclass C1(object):\n\n    def specialPalindrome(self, a1):\n        v1 = bisect.bisect_right(v2, a1)\n        return v2[v1]\n"}
{"id": "human_code\\logical-or-of-two-binary-grids-represented-as-quad-trees.py", "text": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4, a5, a6):\n        self.val = a1\n        self.isLeaf = a2\n        self.topLeft = a3\n        self.topRight = a4\n        self.bottomLeft = a5\n        self.bottomRight = a6\n\nclass C2(object):\n\n    def intersect(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if a1.isLeaf:\n            return a1 if a1.val else a2\n        elif a2.isLeaf:\n            return a2 if a2.val else a1\n        v1 = self.intersect(a1.topLeft, a2.topLeft)\n        v2 = self.intersect(a1.topRight, a2.topRight)\n        v3 = self.intersect(a1.bottomLeft, a2.bottomLeft)\n        v4 = self.intersect(a1.bottomRight, a2.bottomRight)\n        if v1.isLeaf and v2.isLeaf and v3.isLeaf and v4.isLeaf and (v1.val == v2.val == v3.val == v4.val):\n            return C1(v1.val, True, None, None, None, None)\n        return C1(True, False, v1, v2, v3, v4)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1, a2, a3, a4, a5, a6):\n        self.val = a1\n        self.isLeaf = a2\n        self.topLeft = a3\n        self.topRight = a4\n        self.bottomLeft = a5\n        self.bottomRight = a6\n\nclass C2(object):\n\n    def intersect(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        if a1.isLeaf:\n            return a1 if a1.val else a2\n        elif a2.isLeaf:\n            return a2 if a2.val else a1\n        v1 = self.intersect(a1.topLeft, a2.topLeft)\n        v2 = self.intersect(a1.topRight, a2.topRight)\n        v3 = self.intersect(a1.bottomLeft, a2.bottomLeft)\n        v4 = self.intersect(a1.bottomRight, a2.bottomRight)\n        if v1.isLeaf and v2.isLeaf and v3.isLeaf and v4.isLeaf and (v1.val == v2.val == v3.val == v4.val):\n            return C1(v1.val, True, None, None, None, None)\n        return C1(True, False, v1, v2, v3, v4)\n"}
{"id": "human_code\\campus-bikes.py", "text": "import heapq\n\nclass C1(object):\n\n    def assignBikes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def manhattan(a1, a2):\n            return abs(a1[0] - a2[0]) + abs(a1[1] - a2[1])\n        v1 = [[] for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            for v4 in range(len(a2)):\n                v1[v3].append((manhattan(a1[v3], a2[v4]), v3, v4))\n            v1[v3].sort(reverse=True)\n        v5 = [None] * len(a1)\n        v6 = set()\n        v7 = []\n        for v3 in range(len(a1)):\n            heapq.heappush(v7, v1[v3].pop())\n        while len(v6) < len(a1):\n            v2, v8, v9 = heapq.heappop(v7)\n            if v9 not in v6:\n                v5[v8] = v9\n                v6.add(v9)\n            else:\n                heapq.heappush(v7, v1[v8].pop())\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def assignBikes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def manhattan(a1, a2):\n            return abs(a1[0] - a2[0]) + abs(a1[1] - a2[1])\n        v1 = [[] for v2 in range(len(a1))]\n        for v3 in range(len(a1)):\n            for v4 in range(len(a2)):\n                v1[v3].append((manhattan(a1[v3], a2[v4]), v3, v4))\n            v1[v3].sort(reverse=True)\n        v5 = [None] * len(a1)\n        v6 = set()\n        v7 = []\n        for v3 in range(len(a1)):\n            heapq.heappush(v7, v1[v3].pop())\n        while len(v6) < len(a1):\n            v2, v8, v9 = heapq.heappop(v7)\n            if v9 not in v6:\n                v5[v8] = v9\n                v6.add(v9)\n            else:\n                heapq.heappush(v7, v1[v8].pop())\n        return v5\n"}
{"id": "human_code\\p03346__s356410129.py", "text": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, copy, functools, random\nfrom collections import deque\nfrom heapq import heappush, heappop\nsys.setrecursionlimit(10 ** 7)\nv1 = 0\nv2 = 0\nv3 = 10 ** 20\nv4 = float('INF')\nv5 = 1.0 / 10 ** 10\nv6 = 10 ** 9 + 7\nv7 = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nv8 = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    return [int(x) - 1 for v1 in sys.stdin.readline().split()]\n\ndef f3():\n    return sys.stdin.readline().split()\n\ndef f4():\n    return int(sys.stdin.readline())\n\ndef f5():\n    return input()\n\ndef f6(a1):\n    return [f4() for v1 in range(a1)]\n\ndef f7(a1):\n    return [f4() - 1 for v1 in range(a1)]\n\ndef f8(a1):\n    return [f5() for v1 in range(a1)]\n\ndef f9(a1):\n    return [f1() for v1 in range(a1)]\n\ndef f10(a1):\n    return [f2() for v1 in range(a1)]\n\ndef f11(a1):\n    return [f3() for v1 in range(a1)]\nv9 = f4()\nv10 = f7(v9)\nv11 = set()\nv12 = [0] * v9\nfor v13 in range(v9):\n    if v10[v13] - 1 in v11:\n        if v10[v13] != 0:\n            v12[v10[v13] - 1] = 1\n    v11.add(v10[v13])\nv14 = 1 if v12[0] == 1 else 0\nv2 = 1 if v12[0] == 1 else 0\nfor v13 in range(1, v9):\n    if v14 == 1:\n        if v12[v13] == 1:\n            v2 += 1\n        else:\n            v14 = 0\n            v1 = max(v1, v2)\n            v2 = 0\n    elif v12[v13] == 1:\n        v2 += 1\n        v14 = 1\n    else:\n        pass\nv1 = max(v1, v2) + 1\nprint(v9 - v1)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, copy, functools, random\nfrom collections import deque\nfrom heapq import heappush, heappop\nsys.setrecursionlimit(10 ** 7)\nv1 = 0\nv2 = 0\nv3 = 10 ** 20\nv4 = float('INF')\nv5 = 1.0 / 10 ** 10\nv6 = 10 ** 9 + 7\nv7 = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nv8 = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    return [int(x) - 1 for v1 in sys.stdin.readline().split()]\n\ndef f3():\n    return sys.stdin.readline().split()\n\ndef f4():\n    return int(sys.stdin.readline())\n\ndef f5():\n    return input()\n\ndef f6(a1):\n    return [f4() for v1 in range(a1)]\n\ndef f7(a1):\n    return [f4() - 1 for v1 in range(a1)]\n\ndef f8(a1):\n    return [f5() for v1 in range(a1)]\n\ndef f9(a1):\n    return [f1() for v1 in range(a1)]\n\ndef f10(a1):\n    return [f2() for v1 in range(a1)]\n\ndef f11(a1):\n    return [f3() for v1 in range(a1)]\nv9 = f4()\nv10 = f7(v9)\nv11 = set()\nv12 = [0] * v9\nfor v13 in range(v9):\n    if v10[v13] - 1 in v11:\n        if v10[v13] != 0:\n            v12[v10[v13] - 1] = 1\n    v11.add(v10[v13])\nv14 = 1 if v12[0] == 1 else 0\nv2 = 1 if v12[0] == 1 else 0\nfor v13 in range(1, v9):\n    if v14 == 1:\n        if v12[v13] == 1:\n            v2 += 1\n        else:\n            v14 = 0\n            v1 = max(v1, v2)\n            v2 = 0\n    elif v12[v13] == 1:\n        v2 += 1\n        v14 = 1\n    else:\n        pass\nv1 = max(v1, v2) + 1\nprint(v9 - v1)\n"}
{"id": "llm_code\\p03426__s886923662.py", "text": "def f1():\n    import sys\n    v1 = sys.stdin.readline\n    v2 = sys.stdout.write\n    v3 = sys.stderr.write\n    v4, v5, v6 = map(int, v1().split())\n    v7 = [[]] * (v4 * v5)\n    for v8 in range(v4):\n        v9 = list(map(int, v1().split()))\n        for v10 in range(v5):\n            v7[v9[v10] - 1] = [v8, v10]\n    v11 = int(v1())\n    for v12 in range(v11):\n        v13, v14 = map(int, v1().split())\n        v15 = (v14 - v13) // v6\n        v16 = 0\n        v17 = v13 - 1\n        for v18 in range(v15):\n            v19 = v13 + v18 * v6 - 1\n            v16 += abs(v7[v17][0] - v7[v19][0]) + abs(v7[v17][1] - v7[v19][1])\n            v17 = v19\n        print(v16)\n    return\nf1()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1():\n    import sys\n    v1 = sys.stdin.readline\n    v2 = sys.stdout.write\n    v3 = sys.stderr.write\n    v4, v5, v6 = map(int, v1().split())\n    v7 = [[]] * (v4 * v5)\n    for v8 in range(v4):\n        v9 = list(map(int, v1().split()))\n        for v10 in range(v5):\n            v7[v9[v10] - 1] = [v8, v10]\n    v11 = int(v1())\n    for v12 in range(v11):\n        v13, v14 = map(int, v1().split())\n        v15 = (v14 - v13) // v6\n        v16 = 0\n        v17 = v13 - 1\n        for v18 in range(v15):\n            v19 = v13 + v18 * v6 - 1\n            v16 += abs(v7[v17][0] - v7[v19][0]) + abs(v7[v17][1] - v7[v19][1])\n            v17 = v19\n        print(v16)\n    return\nf1()\n"}
{"id": "llm_code\\longest-nice-substring__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def longestNiceSubstring(self, a1):\n        v1 = len(a1)\n        v2 = ''\n        v3 = 0\n        for v4 in range(v1):\n            v5 = 0\n            v6 = 0\n            for v7 in range(v4, v1):\n                v8 = a1[v7].lower()\n                v9 = ord(v8) - ord('a')\n                v10 = 1 << v9\n                if a1[v7].islower():\n                    v5 |= v10\n                else:\n                    v6 |= v10\n                v11 = v7 - v4 + 1\n                if v5 == v6 and v11 > v3:\n                    v3 = v11\n                    v2 = a1[v4:v7 + 1]\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def longestNiceSubstring(self, a1):\n        v1 = len(a1)\n        v2 = ''\n        v3 = 0\n        for v4 in range(v1):\n            v5 = 0\n            v6 = 0\n            for v7 in range(v4, v1):\n                v8 = a1[v7].lower()\n                v9 = ord(v8) - ord('a')\n                v10 = 1 << v9\n                if a1[v7].islower():\n                    v5 |= v10\n                else:\n                    v6 |= v10\n                v11 = v7 - v4 + 1\n                if v5 == v6 and v11 > v3:\n                    v3 = v11\n                    v2 = a1[v4:v7 + 1]\n        return v2\n"}
{"id": "human_code\\probability-of-a-two-boxes-having-the-same-number-of-distinct-balls.py", "text": "import collections\n\nclass C1(object):\n\n    def getProbability(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nCrs(a1):\n            v1 = 1\n            for v2 in range(a1 + 1):\n                yield v1\n                v1 *= a1 - (v2 + 1) + 1\n                v1 //= v2 + 1\n\n        def nCr(a1, a2):\n            if a1 - a2 < a2:\n                return nCr(a1, a1 - a2)\n            v1 = 1\n            for v2 in range(1, a2 + 1):\n                v1 *= a1 - v2 + 1\n                v1 //= v2\n            return v1\n        v1 = collections.defaultdict(int)\n        v1[0, 0] = 1\n        for v2 in a1:\n            v3 = collections.defaultdict(int)\n            for (v4, v5), v6 in v1.items():\n                for v7, v8 in enumerate(nCrs(v2)):\n                    v9 = v4 + (v7 - (v2 - v7))\n                    v10 = v5 - 1 if v7 == 0 else v5 + 1 if v7 == v2 else v5\n                    v3[v9, v10] += v6 * v8\n            v1 = v3\n        v11 = sum(a1)\n        return float(v1[0, 0]) / nCr(v11, v11 // 2)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def getProbability(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nCrs(a1):\n            v1 = 1\n            for v2 in range(a1 + 1):\n                yield v1\n                v1 *= a1 - (v2 + 1) + 1\n                v1 //= v2 + 1\n\n        def nCr(a1, a2):\n            if a1 - a2 < a2:\n                return nCr(a1, a1 - a2)\n            v1 = 1\n            for v2 in range(1, a2 + 1):\n                v1 *= a1 - v2 + 1\n                v1 //= v2\n            return v1\n        v1 = collections.defaultdict(int)\n        v1[0, 0] = 1\n        for v2 in a1:\n            v3 = collections.defaultdict(int)\n            for (v4, v5), v6 in v1.items():\n                for v7, v8 in enumerate(nCrs(v2)):\n                    v9 = v4 + (v7 - (v2 - v7))\n                    v10 = v5 - 1 if v7 == 0 else v5 + 1 if v7 == v2 else v5\n                    v3[v9, v10] += v6 * v8\n            v1 = v3\n        v11 = sum(a1)\n        return float(v1[0, 0]) / nCr(v11, v11 // 2)\n"}
{"id": "llm_code\\minimum-time-to-revert-word-to-initial-state-ii__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minimumTimeToInitialState(self, a1, a2):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = 0\n        v4 = 0\n        for v5 in range(1, v1):\n            if v5 <= v4:\n                v2[v5] = min(v4 - v5 + 1, v2[v5 - v3])\n            while v5 + v2[v5] < v1 and a1[v2[v5]] == a1[v5 + v2[v5]]:\n                v2[v5] += 1\n            if v5 + v2[v5] - 1 > v4:\n                v3 = v5\n                v4 = v5 + v2[v5] - 1\n        v6 = 1\n        while v6 * a2 < v1:\n            v7 = v6 * a2\n            v8 = v1 - v7\n            if v2[v7] >= v8:\n                return v6\n            v6 += 1\n        return v6\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minimumTimeToInitialState(self, a1, a2):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = 0\n        v4 = 0\n        for v5 in range(1, v1):\n            if v5 <= v4:\n                v2[v5] = min(v4 - v5 + 1, v2[v5 - v3])\n            while v5 + v2[v5] < v1 and a1[v2[v5]] == a1[v5 + v2[v5]]:\n                v2[v5] += 1\n            if v5 + v2[v5] - 1 > v4:\n                v3 = v5\n                v4 = v5 + v2[v5] - 1\n        v6 = 1\n        while v6 * a2 < v1:\n            v7 = v6 * a2\n            v8 = v1 - v7\n            if v2[v7] >= v8:\n                return v6\n            v6 += 1\n        return v6\n"}
{"id": "llm_code\\beautiful-towers-ii__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def maximumSumOfHeights(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = [-1]\n        v4 = 0\n        for v5 in range(v1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v5]:\n                v6 = v3.pop()\n                v4 -= a1[v6] * (v6 - v3[-1])\n            v7 = v5 - v3[-1]\n            v4 += a1[v5] * v7\n            v3.append(v5)\n            v2[v5] = v4\n        v8 = [0] * v1\n        v3 = [v1]\n        v9 = 0\n        for v10 in range(v1 - 1, -1, -1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v10]:\n                v6 = v3.pop()\n                v9 -= a1[v6] * (v3[-1] - v6)\n            v7 = v3[-1] - v10\n            v9 += a1[v10] * v7\n            v3.append(v10)\n            v8[v10] = v9\n        v11 = 0\n        for v5 in range(v1):\n            v11 = max(v11, v2[v5] + v8[v5] - a1[v5])\n        return v11\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def maximumSumOfHeights(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = [-1]\n        v4 = 0\n        for v5 in range(v1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v5]:\n                v6 = v3.pop()\n                v4 -= a1[v6] * (v6 - v3[-1])\n            v7 = v5 - v3[-1]\n            v4 += a1[v5] * v7\n            v3.append(v5)\n            v2[v5] = v4\n        v8 = [0] * v1\n        v3 = [v1]\n        v9 = 0\n        for v10 in range(v1 - 1, -1, -1):\n            while len(v3) > 1 and a1[v3[-1]] >= a1[v10]:\n                v6 = v3.pop()\n                v9 -= a1[v6] * (v3[-1] - v6)\n            v7 = v3[-1] - v10\n            v9 += a1[v10] * v7\n            v3.append(v10)\n            v8[v10] = v9\n        v11 = 0\n        for v5 in range(v1):\n            v11 = max(v11, v2[v5] + v8[v5] - a1[v5])\n        return v11\n"}
{"id": "human_code\\maximize-spanning-tree-stability-with-upgrades.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        return True\n\nclass C2(object):\n\n    def maxStability(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = C1(a1)\n        v2 = 0\n        v3 = float('inf')\n        for v4, v5, v6, v7 in a2:\n            if not v7:\n                continue\n            if not v1.union_set(v4, v5):\n                return -1\n            v2 += 1\n            v3 = min(v3, v6)\n        a2.sort(key=lambda x: -x[2])\n        for v4, v5, v6, v7 in a2:\n            if v7:\n                continue\n            if not v1.union_set(v4, v5):\n                continue\n            v2 += 1\n            if v2 == a1 - 1 - a3:\n                v3 = min(v3, v6)\n            elif v2 == a1 - 1:\n                v3 = min(v3, 2 * v6)\n        return v3 if v2 == a1 - 1 else -1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.rank = [0] * a1\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        return True\n\nclass C2(object):\n\n    def maxStability(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = C1(a1)\n        v2 = 0\n        v3 = float('inf')\n        for v4, v5, v6, v7 in a2:\n            if not v7:\n                continue\n            if not v1.union_set(v4, v5):\n                return -1\n            v2 += 1\n            v3 = min(v3, v6)\n        a2.sort(key=lambda x: -x[2])\n        for v4, v5, v6, v7 in a2:\n            if v7:\n                continue\n            if not v1.union_set(v4, v5):\n                continue\n            v2 += 1\n            if v2 == a1 - 1 - a3:\n                v3 = min(v3, v6)\n            elif v2 == a1 - 1:\n                v3 = min(v3, 2 * v6)\n        return v3 if v2 == a1 - 1 else -1\n"}
{"id": "llm_code\\number-of-spaces-cleaning-robot-cleaned__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def numberOfCleanRooms(self, a1):\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = len(a1[0])\n        v3 = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n        v4 = v5 = v6 = v7 = 0\n        while True:\n            v8 = 1 << v7 + 1\n            if a1[v5][v6] & v8:\n                return v4\n            if a1[v5][v6] & ~1 == 0:\n                v4 += 1\n            a1[v5][v6] |= v8\n            v9, v10 = v3[v7]\n            v11, v12 = (v5 + v9, v6 + v10)\n            if 0 <= v11 < v1 and 0 <= v12 < v2 and (a1[v11][v12] % 2 == 0):\n                v5, v6 = (v11, v12)\n            else:\n                v7 = (v7 + 1) % 4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numberOfCleanRooms(self, a1):\n        v1 = len(a1)\n        if v1 == 0:\n            return 0\n        v2 = len(a1[0])\n        v3 = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n        v4 = v5 = v6 = v7 = 0\n        while True:\n            v8 = 1 << v7 + 1\n            if a1[v5][v6] & v8:\n                return v4\n            if a1[v5][v6] & ~1 == 0:\n                v4 += 1\n            a1[v5][v6] |= v8\n            v9, v10 = v3[v7]\n            v11, v12 = (v5 + v9, v6 + v10)\n            if 0 <= v11 < v1 and 0 <= v12 < v2 and (a1[v11][v12] % 2 == 0):\n                v5, v6 = (v11, v12)\n            else:\n                v7 = (v7 + 1) % 4\n"}
{"id": "human_code\\count-the-number-of-substrings-with-dominant-ones__part3.py", "text": "class C1(object):\n\n    def numberOfSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        for v2 in range(int((-1 + (1 + 4 * len(a1)) ** 0.5) / 2) + 1):\n            v3 = [0] * 2\n            v4 = v5 = 0\n            for v6 in range(len(a1)):\n                v3[a1[v6] == '1'] += 1\n                while v3[0] == v2 + 1:\n                    v3[a1[v4] == '1'] -= 1\n                    v4 += 1\n                if not (v3[0] == v2 and v3[1] >= v2 ** 2):\n                    continue\n                for v5 in range(max(v5, v4), v6):\n                    if a1[v5] == '0':\n                        break\n                else:\n                    v5 = v6\n                v1 += min(v5 - v4 + 1, v3[1] - v2 ** 2 + 1)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numberOfSubstrings(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        for v2 in range(int((-1 + (1 + 4 * len(a1)) ** 0.5) / 2) + 1):\n            v3 = [0] * 2\n            v4 = v5 = 0\n            for v6 in range(len(a1)):\n                v3[a1[v6] == '1'] += 1\n                while v3[0] == v2 + 1:\n                    v3[a1[v4] == '1'] -= 1\n                    v4 += 1\n                if not (v3[0] == v2 and v3[1] >= v2 ** 2):\n                    continue\n                for v5 in range(max(v5, v4), v6):\n                    if a1[v5] == '0':\n                        break\n                else:\n                    v5 = v6\n                v1 += min(v5 - v4 + 1, v3[1] - v2 ** 2 + 1)\n        return v1\n"}
{"id": "llm_code\\p03032__s374805688.py", "text": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nfrom collections import deque\nv3 = deque(v3)\nimport copy\nv4 = -10 ** 18\nfor v5 in range(v2 + 1):\n    for v6 in range(v2 + 1):\n        if v5 + v6 > v2:\n            continue\n        if v5 + v6 < v2 - (v5 + v6):\n            continue\n        if v5 + v6 > v1:\n            continue\n        v7 = copy.copy(v3)\n        v8 = []\n        for v9 in range(v5):\n            v8.append(v7.popleft())\n        for v10 in range(v6):\n            v8.append(v7.pop())\n        v8.sort()\n        v11 = sum(v8)\n        v12 = v2 - v5 - v6\n        for v13 in range(v12):\n            if v8[v13] < 0:\n                v11 -= v8[v13]\n        v4 = max(v4, v11)\nprint(v4)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = list(map(int, input().split()))\nfrom collections import deque\nv3 = deque(v3)\nimport copy\nv4 = -10 ** 18\nfor v5 in range(v2 + 1):\n    for v6 in range(v2 + 1):\n        if v5 + v6 > v2:\n            continue\n        if v5 + v6 < v2 - (v5 + v6):\n            continue\n        if v5 + v6 > v1:\n            continue\n        v7 = copy.copy(v3)\n        v8 = []\n        for v9 in range(v5):\n            v8.append(v7.popleft())\n        for v10 in range(v6):\n            v8.append(v7.pop())\n        v8.sort()\n        v11 = sum(v8)\n        v12 = v2 - v5 - v6\n        for v13 in range(v12):\n            if v8[v13] < 0:\n                v11 -= v8[v13]\n        v4 = max(v4, v11)\nprint(v4)\n"}
{"id": "llm_code\\longest-substring-with-at-least-k-repeating-characters__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def longestSubstring(self, a1, a2):\n        v1 = 0\n        v2 = [(0, len(a1))]\n        while v2:\n            v3, v4 = v2.pop()\n            if v4 - v3 <= v1:\n                continue\n            v5 = [0] * 26\n            for v6 in range(v3, v4):\n                v5[ord(a1[v6]) - ord('a')] += 1\n            v6 = v3\n            while v6 < v4:\n                while v6 < v4 and v5[ord(a1[v6]) - ord('a')] < a2:\n                    v6 += 1\n                if v6 == v4:\n                    break\n                v7 = v6\n                while v7 < v4 and v5[ord(a1[v7]) - ord('a')] >= a2:\n                    v7 += 1\n                v8 = v7 - v6\n                if v6 == v3 and v7 == v4:\n                    v1 = max(v1, v8)\n                else:\n                    v2.append((v6, v7))\n                v6 = v7\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def longestSubstring(self, a1, a2):\n        v1 = 0\n        v2 = [(0, len(a1))]\n        while v2:\n            v3, v4 = v2.pop()\n            if v4 - v3 <= v1:\n                continue\n            v5 = [0] * 26\n            for v6 in range(v3, v4):\n                v5[ord(a1[v6]) - ord('a')] += 1\n            v6 = v3\n            while v6 < v4:\n                while v6 < v4 and v5[ord(a1[v6]) - ord('a')] < a2:\n                    v6 += 1\n                if v6 == v4:\n                    break\n                v7 = v6\n                while v7 < v4 and v5[ord(a1[v7]) - ord('a')] >= a2:\n                    v7 += 1\n                v8 = v7 - v6\n                if v6 == v3 and v7 == v4:\n                    v1 = max(v1, v8)\n                else:\n                    v2.append((v6, v7))\n                v6 = v7\n        return v1\n"}
{"id": "human_code\\best-meeting-point.py", "text": "from random import randint\n\nclass C1(object):\n\n    def minTotalDistance(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [i for v2, v3 in enumerate(a1) for v4 in v3 if v4 == 1]\n        v5 = [j for v3 in a1 for v6, v4 in enumerate(v3) if v4 == 1]\n        v7 = self.findKthLargest(v1, len(v1) / 2 + 1)\n        v8 = self.findKthLargest(v5, len(v5) / 2 + 1)\n        return sum([abs(v7 - v2) + abs(v8 - v6) for v2, v3 in enumerate(a1) for v6, v4 in enumerate(v3) if v4 == 1])\n\n    def findKthLargest(self, a1, a2):\n        v1, v2 = (0, len(a1) - 1)\n        while v1 <= v2:\n            v3 = randint(v1, v2)\n            v4 = self.PartitionAroundPivot(v1, v2, v3, a1)\n            if v4 == a2 - 1:\n                return a1[v4]\n            elif v4 > a2 - 1:\n                v2 = v4 - 1\n            else:\n                v1 = v4 + 1\n\n    def PartitionAroundPivot(self, a1, a2, a3, a4):\n        v1 = a4[a3]\n        v2 = a1\n        a4[a3], a4[a2] = (a4[a2], a4[a3])\n        for v3 in range(a1, a2):\n            if a4[v3] > v1:\n                a4[v3], a4[v2] = (a4[v2], a4[v3])\n                v2 += 1\n        a4[a2], a4[v2] = (a4[v2], a4[a2])\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from random import randint\n\nclass C1(object):\n\n    def minTotalDistance(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [i for v2, v3 in enumerate(a1) for v4 in v3 if v4 == 1]\n        v5 = [j for v3 in a1 for v6, v4 in enumerate(v3) if v4 == 1]\n        v7 = self.findKthLargest(v1, len(v1) / 2 + 1)\n        v8 = self.findKthLargest(v5, len(v5) / 2 + 1)\n        return sum([abs(v7 - v2) + abs(v8 - v6) for v2, v3 in enumerate(a1) for v6, v4 in enumerate(v3) if v4 == 1])\n\n    def findKthLargest(self, a1, a2):\n        v1, v2 = (0, len(a1) - 1)\n        while v1 <= v2:\n            v3 = randint(v1, v2)\n            v4 = self.PartitionAroundPivot(v1, v2, v3, a1)\n            if v4 == a2 - 1:\n                return a1[v4]\n            elif v4 > a2 - 1:\n                v2 = v4 - 1\n            else:\n                v1 = v4 + 1\n\n    def PartitionAroundPivot(self, a1, a2, a3, a4):\n        v1 = a4[a3]\n        v2 = a1\n        a4[a3], a4[a2] = (a4[a2], a4[a3])\n        for v3 in range(a1, a2):\n            if a4[v3] > v1:\n                a4[v3], a4[v2] = (a4[v2], a4[v3])\n                v2 += 1\n        a4[a2], a4[v2] = (a4[v2], a4[a2])\n        return v2\n"}
{"id": "llm_code\\p03007__s539211562.py", "text": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv2.sort(reverse=True)\nfor v3 in range(v1):\n    if v2[v3] < 0:\n        v4 = v2[:v3]\n        v5 = v2[v3:]\n        break\n    if v3 == v1 - 1:\n        v4 = v2\n        v5 = []\nv6 = 0\nv7 = len(v4)\nif v7 > 1:\n    if v7 % 2 == 0:\n        print(abs(sum(v4[:v7 // 2])) - abs(sum(v4[v7 // 2:])) - sum(v5))\n        print(v4[0], v4[-1])\n        v6 = v4[0] - v4[-1]\n        for v3 in range(1, v7 // 2):\n            print(v4[-(v3 + 1)], v6)\n            v6 = v4[-(v3 + 1)] - v6\n            print(v4[v3], v6)\n            v6 = v4[v3] - v6\n    else:\n        print(sum(v4[:v7 // 2]) - sum(v4[v7 // 2 + 1:]) + abs(v4[v7 // 2]) - sum(v5))\n        print(v4[-1], v4[0])\n        v6 = v4[-1] - v4[0]\n        for v3 in range(1, v7 // 2):\n            print(v4[v3], v6)\n            v6 = v4[v3] - v6\n            print(v4[-(v3 + 1)], v6)\n            v6 = v4[-(v3 + 1)] - v6\n        print(v4[v7 // 2], v6)\nelif v7 == 1:\n    print(v4[0] - sum(v5))\n    print(v4[0], v5[0])\n    v6 = v4[0] - v5[0]\nelse:\n    print(-sum(v5) + v5[0] * 2)\n    v6 = v5[0]\nfor v3 in range(len(v5) - 1):\n    print(v6, v5[v3 + 1])\n    v6 -= v5[v3 + 1]\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = list(map(int, input().split()))\nv2.sort(reverse=True)\nfor v3 in range(v1):\n    if v2[v3] < 0:\n        v4 = v2[:v3]\n        v5 = v2[v3:]\n        break\n    if v3 == v1 - 1:\n        v4 = v2\n        v5 = []\nv6 = 0\nv7 = len(v4)\nif v7 > 1:\n    if v7 % 2 == 0:\n        print(abs(sum(v4[:v7 // 2])) - abs(sum(v4[v7 // 2:])) - sum(v5))\n        print(v4[0], v4[-1])\n        v6 = v4[0] - v4[-1]\n        for v3 in range(1, v7 // 2):\n            print(v4[-(v3 + 1)], v6)\n            v6 = v4[-(v3 + 1)] - v6\n            print(v4[v3], v6)\n            v6 = v4[v3] - v6\n    else:\n        print(sum(v4[:v7 // 2]) - sum(v4[v7 // 2 + 1:]) + abs(v4[v7 // 2]) - sum(v5))\n        print(v4[-1], v4[0])\n        v6 = v4[-1] - v4[0]\n        for v3 in range(1, v7 // 2):\n            print(v4[v3], v6)\n            v6 = v4[v3] - v6\n            print(v4[-(v3 + 1)], v6)\n            v6 = v4[-(v3 + 1)] - v6\n        print(v4[v7 // 2], v6)\nelif v7 == 1:\n    print(v4[0] - sum(v5))\n    print(v4[0], v5[0])\n    v6 = v4[0] - v5[0]\nelse:\n    print(-sum(v5) + v5[0] * 2)\n    v6 = v5[0]\nfor v3 in range(len(v5) - 1):\n    print(v6, v5[v3 + 1])\n    v6 -= v5[v3 + 1]\n"}
{"id": "human_code\\guess-the-majority-in-a-hidden-array.py", "text": "class C1(object):\n\n    def query(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        pass\n\n    def length(self):\n        \"\"\"\n        \"\"\"\n        pass\n\nclass C2(object):\n\n    def guessMajority(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = (1, 0, None)\n        v4 = a1.query(0, 1, 2, 3)\n        for v5 in reversed(range(4, a1.length())):\n            v6 = a1.query(0, 1, 2, v5)\n            if v6 == v4:\n                v1 = v1 + 1\n            else:\n                v2, v3 = (v2 + 1, v5)\n        v7 = v6\n        for v5 in range(3):\n            v8 = a1.query(*[v for v9 in [0, 1, 2, 3, 4] if v9 != v5])\n            if v8 == v7:\n                v1 = v1 + 1\n            else:\n                v2, v3 = (v2 + 1, v5)\n        if v1 == v2:\n            return -1\n        return 3 if v1 > v2 else v3\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def query(self, a1, a2, a3, a4):\n        \"\"\"\n        \"\"\"\n        pass\n\n    def length(self):\n        \"\"\"\n        \"\"\"\n        pass\n\nclass C2(object):\n\n    def guessMajority(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2, v3 = (1, 0, None)\n        v4 = a1.query(0, 1, 2, 3)\n        for v5 in reversed(range(4, a1.length())):\n            v6 = a1.query(0, 1, 2, v5)\n            if v6 == v4:\n                v1 = v1 + 1\n            else:\n                v2, v3 = (v2 + 1, v5)\n        v7 = v6\n        for v5 in range(3):\n            v8 = a1.query(*[v for v9 in [0, 1, 2, 3, 4] if v9 != v5])\n            if v8 == v7:\n                v1 = v1 + 1\n            else:\n                v2, v3 = (v2 + 1, v5)\n        if v1 == v2:\n            return -1\n        return 3 if v1 > v2 else v3\n"}
{"id": "llm_code\\text-justification__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def fullJustify(self, a1, a2):\n        v1 = []\n        v2 = 0\n        v3 = len(a1)\n        while v2 < v3:\n            v4 = v2 + 1\n            v5 = len(a1[v2])\n            while v4 < v3 and v5 + len(a1[v4]) + 1 <= a2:\n                v5 += len(a1[v4]) + 1\n                v4 += 1\n            v6 = v4 - v2\n            v7 = sum((len(w) for v8 in a1[v2:v4]))\n            if v6 == 1 or v4 == v3:\n                v9 = ' '.join(a1[v2:v4])\n                v9 += ' ' * (a2 - len(v9))\n            else:\n                v10 = a2 - v7\n                v11 = v10 // (v6 - 1)\n                v12 = v10 % (v6 - 1)\n                v13 = []\n                for v14 in range(v6):\n                    v13.append(a1[v2 + v14])\n                    if v14 < v6 - 1:\n                        v15 = v11 + (1 if v14 < v12 else 0)\n                        v13.append(' ' * v15)\n                v9 = ''.join(v13)\n            v1.append(v9)\n            v2 = v4\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def fullJustify(self, a1, a2):\n        v1 = []\n        v2 = 0\n        v3 = len(a1)\n        while v2 < v3:\n            v4 = v2 + 1\n            v5 = len(a1[v2])\n            while v4 < v3 and v5 + len(a1[v4]) + 1 <= a2:\n                v5 += len(a1[v4]) + 1\n                v4 += 1\n            v6 = v4 - v2\n            v7 = sum((len(w) for v8 in a1[v2:v4]))\n            if v6 == 1 or v4 == v3:\n                v9 = ' '.join(a1[v2:v4])\n                v9 += ' ' * (a2 - len(v9))\n            else:\n                v10 = a2 - v7\n                v11 = v10 // (v6 - 1)\n                v12 = v10 % (v6 - 1)\n                v13 = []\n                for v14 in range(v6):\n                    v13.append(a1[v2 + v14])\n                    if v14 < v6 - 1:\n                        v15 = v11 + (1 if v14 < v12 else 0)\n                        v13.append(' ' * v15)\n                v9 = ''.join(v13)\n            v1.append(v9)\n            v2 = v4\n        return v1\n"}
{"id": "human_code\\longest-cycle-in-a-graph.py", "text": "class C1(object):\n\n    def longestCycle(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = -1\n        v2 = [-1] * len(a1)\n        v3 = 0\n        for v4 in range(len(a1)):\n            if v2[v4] != -1:\n                continue\n            v5 = v3\n            while v4 != -1:\n                if v2[v4] != -1:\n                    break\n                v2[v4] = v3\n                v3 += 1\n                v4 = a1[v4]\n            if v4 != -1 and v2[v4] >= v5:\n                v1 = max(v1, v3 - v2[v4])\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def longestCycle(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = -1\n        v2 = [-1] * len(a1)\n        v3 = 0\n        for v4 in range(len(a1)):\n            if v2[v4] != -1:\n                continue\n            v5 = v3\n            while v4 != -1:\n                if v2[v4] != -1:\n                    break\n                v2[v4] = v3\n                v3 += 1\n                v4 = a1[v4]\n            if v4 != -1 and v2[v4] >= v5:\n                v1 = max(v1, v3 - v2[v4])\n        return v1\n"}
{"id": "llm_code\\binary-tree-zigzag-level-order-traversal__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2:\n\n    def zigzagLevelOrder(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        v2 = [a1]\n        v3 = True\n        while v2:\n            v4 = []\n            v5 = []\n            for v6 in v2:\n                v4.append(v6.val)\n                if v3:\n                    if v6.left:\n                        v5.append(v6.left)\n                    if v6.right:\n                        v5.append(v6.right)\n                else:\n                    if v6.right:\n                        v5.append(v6.right)\n                    if v6.left:\n                        v5.append(v6.left)\n            v1.append(v4)\n            v2 = v5\n            v3 = not v3\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2:\n\n    def zigzagLevelOrder(self, a1):\n        if not a1:\n            return []\n        v1 = []\n        v2 = [a1]\n        v3 = True\n        while v2:\n            v4 = []\n            v5 = []\n            for v6 in v2:\n                v4.append(v6.val)\n                if v3:\n                    if v6.left:\n                        v5.append(v6.left)\n                    if v6.right:\n                        v5.append(v6.right)\n                else:\n                    if v6.right:\n                        v5.append(v6.right)\n                    if v6.left:\n                        v5.append(v6.left)\n            v1.append(v4)\n            v2 = v5\n            v3 = not v3\n        return v1\n"}
{"id": "human_code\\p03776__s891562926.py", "text": "def f1(a1, a2):\n    v1 = 1\n    for v2 in range(a2):\n        v1 = int(v1 * (a1 - v2) / (v2 + 1))\n    return v1\nv1, v2, v3 = map(int, input().split())\nv4 = list(map(int, input().split()))\nv4.sort(reverse=True)\nv5 = v4[v2 - 1]\nif v4[0] == v5:\n    v6 = 0\n    for v7 in range(v2, min(v4.count(v4[0]), v3) + 1):\n        v6 += f1(v4.count(v4[0]), v7)\n    print(v4[0])\n    print(v6)\nelif v5 > v4[v2]:\n    print(sum(v4[:v2]) / v2)\n    print(1)\nelse:\n    v8 = v4.index(v5)\n    v9 = v4.count(v5)\n    print((sum(v4[:v8]) + v5 * (v2 - v8)) / v2)\n    print(f1(v9, v2 - v8))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1, a2):\n    v1 = 1\n    for v2 in range(a2):\n        v1 = int(v1 * (a1 - v2) / (v2 + 1))\n    return v1\nv1, v2, v3 = map(int, input().split())\nv4 = list(map(int, input().split()))\nv4.sort(reverse=True)\nv5 = v4[v2 - 1]\nif v4[0] == v5:\n    v6 = 0\n    for v7 in range(v2, min(v4.count(v4[0]), v3) + 1):\n        v6 += f1(v4.count(v4[0]), v7)\n    print(v4[0])\n    print(v6)\nelif v5 > v4[v2]:\n    print(sum(v4[:v2]) / v2)\n    print(1)\nelse:\n    v8 = v4.index(v5)\n    v9 = v4.count(v5)\n    print((sum(v4[:v8]) + v5 * (v2 - v8)) / v2)\n    print(f1(v9, v2 - v8))\n"}
{"id": "llm_code\\p02855__s745810723.py", "text": "import numpy as np\nv1, v2, v3 = map(int, input().split())\nv4 = [list(input()) for v5 in range(v1)]\nv6 = ((1, 0), (-1, 0), (0, 1), (0, -1))\nv7 = [[0] * v2 for v5 in range(v1)]\n\ndef f1(a1, a2, a3):\n    v7[a1][a2] = a3\n    for v1, v2 in v6:\n        v3 = a1 + v1\n        v4 = a2 + v2\n        if 0 <= v3 < v1 and 0 <= v4 < v2 and (v7[v3][v4] == 0) and (v4[v3][v4] == '.'):\n            f1(v3, v4, a3)\nv8 = 1\nfor v9 in range(v1):\n    for v10 in range(v2):\n        if v4[v9][v10] == '#':\n            f1(v9, v10, v8)\n            v8 += 1\nfor v9 in range(v1):\n    if v7[v9][0] == 0:\n        v7[v9][0] = v7[v9][1]\n    for v10 in range(1, v2):\n        if v7[v9][v10] == 0:\n            v7[v9][v10] = v7[v9][v10 - 1]\nfor v9 in range(v1):\n    for v10 in range(v2):\n        print(v7[v9][v10], end=' ')\n    print()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import numpy as np\nv1, v2, v3 = map(int, input().split())\nv4 = [list(input()) for v5 in range(v1)]\nv6 = ((1, 0), (-1, 0), (0, 1), (0, -1))\nv7 = [[0] * v2 for v5 in range(v1)]\n\ndef f1(a1, a2, a3):\n    v7[a1][a2] = a3\n    for v1, v2 in v6:\n        v3 = a1 + v1\n        v4 = a2 + v2\n        if 0 <= v3 < v1 and 0 <= v4 < v2 and (v7[v3][v4] == 0) and (v4[v3][v4] == '.'):\n            f1(v3, v4, a3)\nv8 = 1\nfor v9 in range(v1):\n    for v10 in range(v2):\n        if v4[v9][v10] == '#':\n            f1(v9, v10, v8)\n            v8 += 1\nfor v9 in range(v1):\n    if v7[v9][0] == 0:\n        v7[v9][0] = v7[v9][1]\n    for v10 in range(1, v2):\n        if v7[v9][v10] == 0:\n            v7[v9][v10] = v7[v9][v10 - 1]\nfor v9 in range(v1):\n    for v10 in range(v2):\n        print(v7[v9][v10], end=' ')\n    print()\n"}
{"id": "human_code\\p03281__s456382625.py", "text": "import sys\nv1 = sys.stdin.buffer.read\ninput = sys.stdin.buffer.readline\nv2 = sys.stdin.buffer.readlines\n\ndef f1():\n    v1 = int(input())\n    v2 = 0\n    if v1 >= 105:\n        v2 += 1\n    if v1 >= 135:\n        v2 += 1\n    if v1 >= 165:\n        v2 += 1\n    if v1 >= 189:\n        v2 += 1\n    if v1 >= 195:\n        v2 += 1\n    print(v2)\nif __name__ == '__main__':\n    f1()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nv1 = sys.stdin.buffer.read\ninput = sys.stdin.buffer.readline\nv2 = sys.stdin.buffer.readlines\n\ndef f1():\n    v1 = int(input())\n    v2 = 0\n    if v1 >= 105:\n        v2 += 1\n    if v1 >= 135:\n        v2 += 1\n    if v1 >= 165:\n        v2 += 1\n    if v1 >= 189:\n        v2 += 1\n    if v1 >= 195:\n        v2 += 1\n    print(v2)\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\p02985__s270375639.py", "text": "import sys\nsys.setrecursionlimit(10 ** 7)\nv1 = 10 ** 18\nv2 = 10 ** 9 + 7\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    v1, v2 = f1()\n    v3 = [[] for v4 in range(v1 + 1)]\n    for v4 in range(v1 - 1):\n        v5, v6 = f1()\n        v3[v5].append(v6)\n        v3[v6].append(v5)\n    v7 = 1\n    v8 = [v7]\n    v9 = v2\n    v10 = v8.append\n    v11 = [0] * (v1 + 1)\n    v11[v7] = 1\n    while len(v8) != 0:\n        v12 = 1\n        v13 = v8.pop()\n        if v13 == v7:\n            v14 = v2 - 1\n        else:\n            v14 = v2 - 2\n        for v4 in v3[v13]:\n            if v11[v4] == 1:\n                continue\n            v11[v4] = 1\n            v12 = v12 * v14 % v2\n            v14 -= 1\n            v10(v4)\n        v9 = v9 * v12 % v2\n    print(v9 % v2)\nif __name__ == '__main__':\n    f2()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nv1 = 10 ** 18\nv2 = 10 ** 9 + 7\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    v1, v2 = f1()\n    v3 = [[] for v4 in range(v1 + 1)]\n    for v4 in range(v1 - 1):\n        v5, v6 = f1()\n        v3[v5].append(v6)\n        v3[v6].append(v5)\n    v7 = 1\n    v8 = [v7]\n    v9 = v2\n    v10 = v8.append\n    v11 = [0] * (v1 + 1)\n    v11[v7] = 1\n    while len(v8) != 0:\n        v12 = 1\n        v13 = v8.pop()\n        if v13 == v7:\n            v14 = v2 - 1\n        else:\n            v14 = v2 - 2\n        for v4 in v3[v13]:\n            if v11[v4] == 1:\n                continue\n            v11[v4] = 1\n            v12 = v12 * v14 % v2\n            v14 -= 1\n            v10(v4)\n        v9 = v9 * v12 % v2\n    print(v9 % v2)\nif __name__ == '__main__':\n    f2()\n"}
{"id": "llm_code\\reverse-nodes-in-even-length-groups__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.next = a2\n\nclass C2:\n\n    def reverseEvenLengthGroups(self, a1):\n        v1 = a1\n        v2 = 2\n        while v1 and v1.next:\n            v3 = v1\n            v4 = 0\n            for v5 in range(v2):\n                if not v3.next:\n                    break\n                v4 += 1\n                v3 = v3.next\n            v2 += 1\n            if v4 % 2 != 0:\n                v1 = v3\n                continue\n            v6 = v1.next\n            v7 = None\n            v8 = v6\n            for v5 in range(v4):\n                v9 = v8.next\n                v8.next = v7\n                v7 = v8\n                v8 = v9\n            v6.next = v8\n            v1.next = v7\n            v1 = v6\n        return a1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1=0, a2=None):\n        self.val = a1\n        self.next = a2\n\nclass C2:\n\n    def reverseEvenLengthGroups(self, a1):\n        v1 = a1\n        v2 = 2\n        while v1 and v1.next:\n            v3 = v1\n            v4 = 0\n            for v5 in range(v2):\n                if not v3.next:\n                    break\n                v4 += 1\n                v3 = v3.next\n            v2 += 1\n            if v4 % 2 != 0:\n                v1 = v3\n                continue\n            v6 = v1.next\n            v7 = None\n            v8 = v6\n            for v5 in range(v4):\n                v9 = v8.next\n                v8.next = v7\n                v7 = v8\n                v8 = v9\n            v6.next = v8\n            v1.next = v7\n            v1 = v6\n        return a1\n"}
{"id": "llm_code\\p03439__s144394084.py", "text": "v1 = int(input())\nv2 = float('inf')\nprint(0)\nv3 = input()\nif v3 == 'Male':\n    v4 = 1\nelif v3 == 'Female':\n    v4 = 0\nelse:\n    v2 = 0\nif v2 == 0:\n    exit(0)\nv5 = [0, v1 - 1]\nfor v6 in range(19):\n    v7 = (v5[1] - v5[0]) // 2\n    print(v5[0] + v7)\n    v3 = input()\n    if v3 == 'Male':\n        v8 = 1\n    elif v3 == 'Female':\n        v8 = 0\n    else:\n        exit(0)\n    if v8 + v7 % 2 != v4:\n        v5[1] = v5[0] + v7 - 1\n    else:\n        v5[0] = v5[0] + v7 + 1\n        v4 = v8\n    if v5[0] == v5[1]:\n        print(v5[0])\n        exit(0)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = float('inf')\nprint(0)\nv3 = input()\nif v3 == 'Male':\n    v4 = 1\nelif v3 == 'Female':\n    v4 = 0\nelse:\n    v2 = 0\nif v2 == 0:\n    exit(0)\nv5 = [0, v1 - 1]\nfor v6 in range(19):\n    v7 = (v5[1] - v5[0]) // 2\n    print(v5[0] + v7)\n    v3 = input()\n    if v3 == 'Male':\n        v8 = 1\n    elif v3 == 'Female':\n        v8 = 0\n    else:\n        exit(0)\n    if v8 + v7 % 2 != v4:\n        v5[1] = v5[0] + v7 - 1\n    else:\n        v5[0] = v5[0] + v7 + 1\n        v4 = v8\n    if v5[0] == v5[1]:\n        print(v5[0])\n        exit(0)\n"}
{"id": "human_code\\p03762__s756761676.py", "text": "from collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return list(map(list, sys.stdin.readline().split()))\n\ndef f4():\n    return list(sys.stdin.readline())[:-1]\n\ndef f5(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f2()\n    return v1\n\ndef f6(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f1()\n    return v1\n\ndef f7(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f4()\n    return v1\n\ndef f8(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f7()\n    return v1\nv1 = 1000000007\n'\\nn = I()\\ns = SR(n)\\nfor i in range(n):\\n    for j in range(len(s[i])):\\n        while s[i][j] in s[i][:j]:\\n            s[i][j] = \"0\"+s[i][j]\\nans = set(s[0])\\nfor i in range(1,n):\\n    ans &= set(s[i])\\nans = sorted(list(ans))\\nif len(ans) == 0:print()\\nelse:\\n    for i in range(len(ans)):\\n        ans[i] = ans[i][-1]\\n    ans.sort()\\n    for i in range(len(ans)-1):\\n        print(ans[i],end = \"\")\\n    print(ans[-1])\\n'\nv2, v3 = f1()\nv4 = [v2 - 1]\nv5 = [v3 - 1]\nv6 = v2 - 1\nv7 = v3 - 1\nwhile v6 > 2:\n    v6 -= 2\n    v4.append(v4[-1] + v6)\nwhile v7 > 2:\n    v7 -= 2\n    v5.append(v5[-1] + v7)\nv8 = len(v4)\nv9 = len(v5)\nfor v10 in range(v8):\n    if v10 or v6 == 2:\n        v4.append(v4[v8 - v10 - 1])\nfor v10 in range(v9):\n    if v10 or v7 == 2:\n        v5.append(v5[v9 - v10 - 1])\nv11, v12 = f6(2)\nv13 = 0\nv14 = 0\nfor v10 in range(v2 - 1):\n    v13 += v4[v10] * (v11[v10 + 1] - v11[v10]) % v1\n    v13 %= v1\nfor v10 in range(v3 - 1):\n    v14 += v5[v10] * (v12[v10 + 1] - v12[v10]) % v1\n    v14 %= v1\nv15 = v13 * v14 % v1\nprint(v15)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\n\ndef f1():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return list(map(list, sys.stdin.readline().split()))\n\ndef f4():\n    return list(sys.stdin.readline())[:-1]\n\ndef f5(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f2()\n    return v1\n\ndef f6(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f1()\n    return v1\n\ndef f7(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f4()\n    return v1\n\ndef f8(a1):\n    v1 = [None for v2 in range(a1)]\n    for v2 in range(a1):\n        v1[v2] = f7()\n    return v1\nv1 = 1000000007\n'\\nn = I()\\ns = SR(n)\\nfor i in range(n):\\n    for j in range(len(s[i])):\\n        while s[i][j] in s[i][:j]:\\n            s[i][j] = \"0\"+s[i][j]\\nans = set(s[0])\\nfor i in range(1,n):\\n    ans &= set(s[i])\\nans = sorted(list(ans))\\nif len(ans) == 0:print()\\nelse:\\n    for i in range(len(ans)):\\n        ans[i] = ans[i][-1]\\n    ans.sort()\\n    for i in range(len(ans)-1):\\n        print(ans[i],end = \"\")\\n    print(ans[-1])\\n'\nv2, v3 = f1()\nv4 = [v2 - 1]\nv5 = [v3 - 1]\nv6 = v2 - 1\nv7 = v3 - 1\nwhile v6 > 2:\n    v6 -= 2\n    v4.append(v4[-1] + v6)\nwhile v7 > 2:\n    v7 -= 2\n    v5.append(v5[-1] + v7)\nv8 = len(v4)\nv9 = len(v5)\nfor v10 in range(v8):\n    if v10 or v6 == 2:\n        v4.append(v4[v8 - v10 - 1])\nfor v10 in range(v9):\n    if v10 or v7 == 2:\n        v5.append(v5[v9 - v10 - 1])\nv11, v12 = f6(2)\nv13 = 0\nv14 = 0\nfor v10 in range(v2 - 1):\n    v13 += v4[v10] * (v11[v10 + 1] - v11[v10]) % v1\n    v13 %= v1\nfor v10 in range(v3 - 1):\n    v14 += v5[v10] * (v12[v10 + 1] - v12[v10]) % v1\n    v14 %= v1\nv15 = v13 * v14 % v1\nprint(v15)\n"}
{"id": "human_code\\minimum-operations-to-make-median-of-array-equal-to-k__part1.py", "text": "import random\n\nclass C1(object):\n\n    def minOperationsToMakeMedianK(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=0, a4=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1 = len(a1) - 1\n            while a3 <= v1:\n                v2 = random.randint(a3, v1)\n                v3, v4 = tri_partition(a1, a3, v1, a1[v2], a4)\n                if v3 <= a2 <= v4:\n                    return\n                elif v3 > a2:\n                    v1 = v3 - 1\n                else:\n                    a3 = v4 + 1\n        nth_element(a1, len(a1) // 2)\n        return sum((max(a1[i] - a2, 0) for v1 in range(len(a1) // 2 + 1))) + sum((max(a2 - a1[v1], 0) for v1 in range(len(a1) // 2, len(a1))))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def minOperationsToMakeMedianK(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=0, a4=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1 = len(a1) - 1\n            while a3 <= v1:\n                v2 = random.randint(a3, v1)\n                v3, v4 = tri_partition(a1, a3, v1, a1[v2], a4)\n                if v3 <= a2 <= v4:\n                    return\n                elif v3 > a2:\n                    v1 = v3 - 1\n                else:\n                    a3 = v4 + 1\n        nth_element(a1, len(a1) // 2)\n        return sum((max(a1[i] - a2, 0) for v1 in range(len(a1) // 2 + 1))) + sum((max(a2 - a1[v1], 0) for v1 in range(len(a1) // 2, len(a1))))\n"}
{"id": "human_code\\sum-of-k-mirror-numbers__part1.py", "text": "class C1(object):\n\n    def kMirror(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def mirror(a1, a2, a3):\n            v1 = a1\n            if a3:\n                a1 //= a2\n            while a1:\n                v1 = v1 * a2 + a1 % a2\n                a1 //= a2\n            return v1\n\n        def num_gen(a1):\n            v1, v2 = ([1] * 2, [a1] * 2)\n            v3 = 1\n            while True:\n                v4 = mirror(v1[v3], a1, v3)\n                v1[v3] += 1\n                if v1[v3] == v2[v3]:\n                    v2[v3] *= a1\n                    v3 ^= 1\n                yield v4\n\n        def reverse(a1, a2):\n            v1 = 0\n            while a1:\n                v1 = v1 * a2 + a1 % a2\n                a1 = a1 // a2\n            return v1\n\n        def mirror_num(a1, a2):\n            while True:\n                v1 = next(a1)\n                if v1 == reverse(v1, a2):\n                    break\n            return v1\n        v1, v2 = (a1, 10)\n        v3 = num_gen(v1)\n        return sum((mirror_num(v3, v2) for v4 in range(a2)))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def kMirror(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def mirror(a1, a2, a3):\n            v1 = a1\n            if a3:\n                a1 //= a2\n            while a1:\n                v1 = v1 * a2 + a1 % a2\n                a1 //= a2\n            return v1\n\n        def num_gen(a1):\n            v1, v2 = ([1] * 2, [a1] * 2)\n            v3 = 1\n            while True:\n                v4 = mirror(v1[v3], a1, v3)\n                v1[v3] += 1\n                if v1[v3] == v2[v3]:\n                    v2[v3] *= a1\n                    v3 ^= 1\n                yield v4\n\n        def reverse(a1, a2):\n            v1 = 0\n            while a1:\n                v1 = v1 * a2 + a1 % a2\n                a1 = a1 // a2\n            return v1\n\n        def mirror_num(a1, a2):\n            while True:\n                v1 = next(a1)\n                if v1 == reverse(v1, a2):\n                    break\n            return v1\n        v1, v2 = (a1, 10)\n        v3 = num_gen(v1)\n        return sum((mirror_num(v3, v2) for v4 in range(a2)))\n"}
{"id": "llm_code\\p03291__unrelated.py", "text": "v1 = 10 ** 9 + 7\nv2 = input()\nv3 = len(v2)\nv4 = [0] * (v3 + 1)\nv5 = [0] * (v3 + 1)\nv6 = [0] * (v3 + 1)\nfor v7 in range(v3):\n    if v2[v7] == 'A':\n        v4[v7 + 1] = v4[v7] + 1\n    else:\n        v4[v7 + 1] = v4[v7]\n    if v2[v7] == 'B':\n        v5[v7 + 1] = v5[v7] + 1\n    else:\n        v5[v7 + 1] = v5[v7]\n    if v2[v7] == 'C':\n        v6[v7 + 1] = v6[v7] + 1\n    else:\n        v6[v7 + 1] = v6[v7]\nv8 = 0\nfor v7 in range(v3):\n    for v9 in range(v7 + 1, v3):\n        for v10 in range(v9 + 1, v3 + 1):\n            if v2[v7] == '?' and v2[v9] == '?' and (v2[v10 - 1] == '?'):\n                v8 += v4[v7] * v5[v9] * v6[v10] % v1\n            elif v2[v7] == '?' and v2[v9] == '?':\n                if v2[v10 - 1] == 'A':\n                    v8 += v4[v7] * v5[v9] * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v10 - 1] == 'B':\n                    v8 += v4[v7] * (v5[v9] - v5[v9 - 1]) * v6[v10] % v1\n                elif v2[v10 - 1] == 'C':\n                    v8 += v4[v7] * v5[v9] * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v7] == '?':\n                if v2[v9] == 'A':\n                    if v2[v10 - 1] == 'B':\n                        v8 += v4[v7] * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                    elif v2[v10 - 1] == 'C':\n                        v8 += v4[v7] * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v9] == 'B':\n                    if v2[v10 - 1] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v9] == 'C':\n                    if v2[v10 - 1] == 'A':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v9] == '?':\n                if v2[v7] == 'A':\n                    if v2[v10 - 1] == 'B':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                    elif v2[v10 - 1] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'B':\n                    if v2[v10 - 1] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'C':\n                    if v2[v10 - 1] == 'A':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v10 - 1] == '?':\n                if v2[v7] == 'A':\n                    if v2[v9] == 'B':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                    elif v2[v9] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'B':\n                    if v2[v9] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'C':\n                    if v2[v9] == 'A':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v7] == 'A' and v2[v9] == 'B' and (v2[v10 - 1] == 'C'):\n                v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\nprint(v8)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = 10 ** 9 + 7\nv2 = input()\nv3 = len(v2)\nv4 = [0] * (v3 + 1)\nv5 = [0] * (v3 + 1)\nv6 = [0] * (v3 + 1)\nfor v7 in range(v3):\n    if v2[v7] == 'A':\n        v4[v7 + 1] = v4[v7] + 1\n    else:\n        v4[v7 + 1] = v4[v7]\n    if v2[v7] == 'B':\n        v5[v7 + 1] = v5[v7] + 1\n    else:\n        v5[v7 + 1] = v5[v7]\n    if v2[v7] == 'C':\n        v6[v7 + 1] = v6[v7] + 1\n    else:\n        v6[v7 + 1] = v6[v7]\nv8 = 0\nfor v7 in range(v3):\n    for v9 in range(v7 + 1, v3):\n        for v10 in range(v9 + 1, v3 + 1):\n            if v2[v7] == '?' and v2[v9] == '?' and (v2[v10 - 1] == '?'):\n                v8 += v4[v7] * v5[v9] * v6[v10] % v1\n            elif v2[v7] == '?' and v2[v9] == '?':\n                if v2[v10 - 1] == 'A':\n                    v8 += v4[v7] * v5[v9] * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v10 - 1] == 'B':\n                    v8 += v4[v7] * (v5[v9] - v5[v9 - 1]) * v6[v10] % v1\n                elif v2[v10 - 1] == 'C':\n                    v8 += v4[v7] * v5[v9] * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v7] == '?':\n                if v2[v9] == 'A':\n                    if v2[v10 - 1] == 'B':\n                        v8 += v4[v7] * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                    elif v2[v10 - 1] == 'C':\n                        v8 += v4[v7] * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v9] == 'B':\n                    if v2[v10 - 1] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v9] == 'C':\n                    if v2[v10 - 1] == 'A':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v9] == '?':\n                if v2[v7] == 'A':\n                    if v2[v10 - 1] == 'B':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                    elif v2[v10 - 1] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'B':\n                    if v2[v10 - 1] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'C':\n                    if v2[v10 - 1] == 'A':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v10 - 1] == '?':\n                if v2[v7] == 'A':\n                    if v2[v9] == 'B':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                    elif v2[v9] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'B':\n                    if v2[v9] == 'C':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n                elif v2[v7] == 'C':\n                    if v2[v9] == 'A':\n                        v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\n            elif v2[v7] == 'A' and v2[v9] == 'B' and (v2[v10 - 1] == 'C'):\n                v8 += (v4[v7] - v4[v7 - 1]) * (v5[v9] - v5[v9 - 1]) * (v6[v10] - v6[v10 - 1]) % v1\nprint(v8)\n"}
{"id": "llm_code\\find-maximum-area-of-a-triangle__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maxArea(self, a1):\n        if not a1:\n            return -1\n        v1 = v2 = float('inf')\n        v3 = v4 = float('-inf')\n        v5 = {}\n        v6 = {}\n        v7 = {}\n        v8 = {}\n        for v9, v10 in a1:\n            v1 = min(v1, v9)\n            v3 = max(v3, v9)\n            v2 = min(v2, v10)\n            v4 = max(v4, v10)\n            if v9 not in v5:\n                v5[v9] = v10\n                v6[v9] = v10\n            else:\n                v5[v9] = min(v5[v9], v10)\n                v6[v9] = max(v6[v9], v10)\n            if v10 not in v7:\n                v7[v10] = v9\n                v8[v10] = v9\n            else:\n                v7[v10] = min(v7[v10], v9)\n                v8[v10] = max(v8[v10], v9)\n        v11 = 0\n        for v12 in v5:\n            v13 = v6[v12] - v5[v12]\n            v14 = max(v12 - v1, v3 - v12)\n            v11 = max(v11, v13 * v14)\n        for v15 in v7:\n            v14 = v8[v15] - v7[v15]\n            v13 = max(v15 - v2, v4 - v15)\n            v11 = max(v11, v14 * v13)\n        return v11 if v11 else -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maxArea(self, a1):\n        if not a1:\n            return -1\n        v1 = v2 = float('inf')\n        v3 = v4 = float('-inf')\n        v5 = {}\n        v6 = {}\n        v7 = {}\n        v8 = {}\n        for v9, v10 in a1:\n            v1 = min(v1, v9)\n            v3 = max(v3, v9)\n            v2 = min(v2, v10)\n            v4 = max(v4, v10)\n            if v9 not in v5:\n                v5[v9] = v10\n                v6[v9] = v10\n            else:\n                v5[v9] = min(v5[v9], v10)\n                v6[v9] = max(v6[v9], v10)\n            if v10 not in v7:\n                v7[v10] = v9\n                v8[v10] = v9\n            else:\n                v7[v10] = min(v7[v10], v9)\n                v8[v10] = max(v8[v10], v9)\n        v11 = 0\n        for v12 in v5:\n            v13 = v6[v12] - v5[v12]\n            v14 = max(v12 - v1, v3 - v12)\n            v11 = max(v11, v13 * v14)\n        for v15 in v7:\n            v14 = v8[v15] - v7[v15]\n            v13 = max(v15 - v2, v4 - v15)\n            v11 = max(v11, v14 * v13)\n        return v11 if v11 else -1\n"}
{"id": "llm_code\\p04000__s983050345.py", "text": "import sys\n\ndef f1():\n    v1, v2, v3 = map(int, sys.stdin.readline().split())\n    v4 = [0] * 10\n    v5 = (1, 0, -1, 0, 1, 1, -1, -1)\n    v6 = (0, 1, 0, -1, 1, -1, 1, -1)\n    v7 = {}\n    for v8 in range(v3):\n        v9, v10 = map(int, sys.stdin.readline().split())\n        v9, v10 = (v9 - 1, v10 - 1)\n        if f2(v1, v2, v9, v10):\n            v7[v9, v10] = v7.get((v9, v10), 0) + 1\n        for v11 in range(len(v5)):\n            if f2(v1, v2, v9 + v5[v11], v10 + v6[v11]):\n                v7[v9 + v5[v11], v10 + v6[v11]] = v7.get((v9 + v5[v11], v10 + v6[v11]), 0) + 1\n    for v12 in v7.values():\n        v4[v12] += 1\n    v4[0] = (v2 - 2) * (v1 - 2) - sum(v4)\n    print(*v4, sep='\\n')\n\ndef f2(a1, a2, a3, a4):\n    return 1 <= a3 <= a1 - 2 and 1 <= a4 <= a2 - 2\nif __name__ == '__main__':\n    f1()\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "import sys\n\ndef f1():\n    v1, v2, v3 = map(int, sys.stdin.readline().split())\n    v4 = [0] * 10\n    v5 = (1, 0, -1, 0, 1, 1, -1, -1)\n    v6 = (0, 1, 0, -1, 1, -1, 1, -1)\n    v7 = {}\n    for v8 in range(v3):\n        v9, v10 = map(int, sys.stdin.readline().split())\n        v9, v10 = (v9 - 1, v10 - 1)\n        if f2(v1, v2, v9, v10):\n            v7[v9, v10] = v7.get((v9, v10), 0) + 1\n        for v11 in range(len(v5)):\n            if f2(v1, v2, v9 + v5[v11], v10 + v6[v11]):\n                v7[v9 + v5[v11], v10 + v6[v11]] = v7.get((v9 + v5[v11], v10 + v6[v11]), 0) + 1\n    for v12 in v7.values():\n        v4[v12] += 1\n    v4[0] = (v2 - 2) * (v1 - 2) - sum(v4)\n    print(*v4, sep='\\n')\n\ndef f2(a1, a2, a3, a4):\n    return 1 <= a3 <= a1 - 2 and 1 <= a4 <= a2 - 2\nif __name__ == '__main__':\n    f1()\n"}
{"id": "human_code\\p03402__s007736739.py", "text": "v1, v2 = map(int, input().split())\nv3 = []\nif v1 > 10:\n    while v1 > 50:\n        v3.append('#.' * 50)\n        v3.append('#' * 100)\n        v1 -= 50\n    while v1 > 10:\n        v3.append('#.' * 10 + '#' * 80)\n        v3.append('#' * 100)\n        v1 -= 10\n    v2 -= 1\nv3.append('.' * 100)\nwhile v2 > 50:\n    v3.append('#.' * 50)\n    v3.append('.' * 100)\n    v2 -= 50\nwhile v2 > 10:\n    v3.append('#.' * 10 + '.' * 80)\n    v3.append('.' * 100)\n    v2 -= 10\nif v2 > v1:\n    v4 = v2 - v1\n    v3.append('#.' * v4 + '..' * (50 - v4))\n    v3.append('.' * 100)\n    for v5 in range(v1):\n        v3.append('#' * 100)\n        v3.append('.' * 100)\n    v3.pop()\nelif v1 > v2:\n    if v2 == 0:\n        v3.pop()\n    v3.append('#' * 100)\n    v4 = v1 - v2\n    v3.append('.#' * v4 + '##' * (50 - v4))\n    v3.append('#' * 100)\n    v2 -= 1\n    for v5 in range(v2):\n        v3.append('.' * 100)\n        v3.append('#' * 100)\nelse:\n    for v5 in range(v1):\n        v3.append('#' * 100)\n        v3.append('.' * 100)\n    v3.pop()\nprint(str(len(v3)) + ' 100')\nprint('\\n'.join(v3))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1, v2 = map(int, input().split())\nv3 = []\nif v1 > 10:\n    while v1 > 50:\n        v3.append('#.' * 50)\n        v3.append('#' * 100)\n        v1 -= 50\n    while v1 > 10:\n        v3.append('#.' * 10 + '#' * 80)\n        v3.append('#' * 100)\n        v1 -= 10\n    v2 -= 1\nv3.append('.' * 100)\nwhile v2 > 50:\n    v3.append('#.' * 50)\n    v3.append('.' * 100)\n    v2 -= 50\nwhile v2 > 10:\n    v3.append('#.' * 10 + '.' * 80)\n    v3.append('.' * 100)\n    v2 -= 10\nif v2 > v1:\n    v4 = v2 - v1\n    v3.append('#.' * v4 + '..' * (50 - v4))\n    v3.append('.' * 100)\n    for v5 in range(v1):\n        v3.append('#' * 100)\n        v3.append('.' * 100)\n    v3.pop()\nelif v1 > v2:\n    if v2 == 0:\n        v3.pop()\n    v3.append('#' * 100)\n    v4 = v1 - v2\n    v3.append('.#' * v4 + '##' * (50 - v4))\n    v3.append('#' * 100)\n    v2 -= 1\n    for v5 in range(v2):\n        v3.append('.' * 100)\n        v3.append('#' * 100)\nelse:\n    for v5 in range(v1):\n        v3.append('#' * 100)\n        v3.append('.' * 100)\n    v3.pop()\nprint(str(len(v3)) + ' 100')\nprint('\\n'.join(v3))\n"}
{"id": "human_code\\number-of-possible-sets-of-closing-branches__part1.py", "text": "class C1(object):\n\n    def numberOfSets(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2):\n            return all((a2[i][j] <= a2 for v1 in range(a1) if a1 & 1 << v1 for v2 in range(v1 + 1, a1) if a1 & 1 << v2))\n\n        def floydWarshall(a1, a2):\n            for v1 in range(len(a1)):\n                for v2 in range(v1 + 1, len(a1[v1])):\n                    a1[v2][v1] = a1[v1][v2] = min(a1[v1][v2], a1[v1][a2] + a1[a2][v2])\n\n        def backtracking(a1, a2, a3):\n            if a1 == a1:\n                result[0] += check(a2, a3)\n                return\n            for v1 in range(2):\n                v2 = [d[:] for v3 in a3]\n                if v1:\n                    floydWarshall(v2, a1)\n                backtracking(a1 + 1, a2 | v1 << a1, v2)\n        v1 = [[0 if u == v else float('inf') for v2 in range(a1)] for v3 in range(a1)]\n        for v3, v2, v4 in a3:\n            v1[v3][v2] = min(v1[v3][v2], v4)\n            v1[v2][v3] = min(v1[v2][v3], v4)\n        v5 = [0]\n        backtracking(0, 0, [d[:] for v6 in v1])\n        return v5[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def numberOfSets(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2):\n            return all((a2[i][j] <= a2 for v1 in range(a1) if a1 & 1 << v1 for v2 in range(v1 + 1, a1) if a1 & 1 << v2))\n\n        def floydWarshall(a1, a2):\n            for v1 in range(len(a1)):\n                for v2 in range(v1 + 1, len(a1[v1])):\n                    a1[v2][v1] = a1[v1][v2] = min(a1[v1][v2], a1[v1][a2] + a1[a2][v2])\n\n        def backtracking(a1, a2, a3):\n            if a1 == a1:\n                result[0] += check(a2, a3)\n                return\n            for v1 in range(2):\n                v2 = [d[:] for v3 in a3]\n                if v1:\n                    floydWarshall(v2, a1)\n                backtracking(a1 + 1, a2 | v1 << a1, v2)\n        v1 = [[0 if u == v else float('inf') for v2 in range(a1)] for v3 in range(a1)]\n        for v3, v2, v4 in a3:\n            v1[v3][v2] = min(v1[v3][v2], v4)\n            v1[v2][v3] = min(v1[v2][v3], v4)\n        v5 = [0]\n        backtracking(0, 0, [d[:] for v6 in v1])\n        return v5[0]\n"}
{"id": "llm_code\\maximum-score-of-a-good-subarray__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def maximumScore(self, a1, a2):\n        v1 = len(a1)\n        v2 = a1[a2]\n        v3 = a1[a2]\n        v4, v5 = (a2, a2)\n        while v4 > 0 or v5 < v1 - 1:\n            if v4 == 0:\n                v5 += 1\n                v3 = min(v3, a1[v5])\n            elif v5 == v1 - 1:\n                v4 -= 1\n                v3 = min(v3, a1[v4])\n            elif a1[v4 - 1] >= a1[v5 + 1]:\n                v4 -= 1\n                v3 = min(v3, a1[v4])\n            else:\n                v5 += 1\n                v3 = min(v3, a1[v5])\n            v2 = max(v2, v3 * (v5 - v4 + 1))\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def maximumScore(self, a1, a2):\n        v1 = len(a1)\n        v2 = a1[a2]\n        v3 = a1[a2]\n        v4, v5 = (a2, a2)\n        while v4 > 0 or v5 < v1 - 1:\n            if v4 == 0:\n                v5 += 1\n                v3 = min(v3, a1[v5])\n            elif v5 == v1 - 1:\n                v4 -= 1\n                v3 = min(v3, a1[v4])\n            elif a1[v4 - 1] >= a1[v5 + 1]:\n                v4 -= 1\n                v3 = min(v3, a1[v4])\n            else:\n                v5 += 1\n                v3 = min(v3, a1[v5])\n            v2 = max(v2, v3 * (v5 - v4 + 1))\n        return v2\n"}
{"id": "human_code\\split-linked-list-in-parts.py", "text": "class C1(object):\n\n    def splitListToParts(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = a1\n        while v2:\n            v2 = v2.__next__\n            v1 += 1\n        v3, v4 = divmod(v1, a2)\n        v5 = []\n        v2 = a1\n        for v6 in range(a2):\n            v7 = v2\n            for v8 in range(v3 - 1 + int(v6 < v4)):\n                if v2:\n                    v2 = v2.__next__\n            if v2:\n                v2.next, v2 = (None, v2.next)\n            v5.append(v7)\n        return v5\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def splitListToParts(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = a1\n        while v2:\n            v2 = v2.__next__\n            v1 += 1\n        v3, v4 = divmod(v1, a2)\n        v5 = []\n        v2 = a1\n        for v6 in range(a2):\n            v7 = v2\n            for v8 in range(v3 - 1 + int(v6 < v4)):\n                if v2:\n                    v2 = v2.__next__\n            if v2:\n                v2.next, v2 = (None, v2.next)\n            v5.append(v7)\n        return v5\n"}
{"id": "human_code\\permutations-iv__part1.py", "text": "class C1(object):\n\n    def permute(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        v2 = [1] * a1\n        for v3 in range(len(v2) - 1):\n            v2[v3 + 1] = min(v2[v3] * ((v3 + 2) // 2), a2)\n        v4 = [False] * a1\n        for v3 in range(a1):\n            for v5 in range(a1):\n                if not (not v4[v5] and (v3 == 0 and a1 % 2 == 0 or (v5 + 1) % 2 == (1 if not v1 else v1[-1] % 2 ^ 1))):\n                    continue\n                if a2 <= v2[a1 - 1 - v3]:\n                    break\n                a2 -= v2[a1 - 1 - v3]\n            else:\n                return []\n            v4[v5] = True\n            v1.append(v5 + 1)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def permute(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = []\n        v2 = [1] * a1\n        for v3 in range(len(v2) - 1):\n            v2[v3 + 1] = min(v2[v3] * ((v3 + 2) // 2), a2)\n        v4 = [False] * a1\n        for v3 in range(a1):\n            for v5 in range(a1):\n                if not (not v4[v5] and (v3 == 0 and a1 % 2 == 0 or (v5 + 1) % 2 == (1 if not v1 else v1[-1] % 2 ^ 1))):\n                    continue\n                if a2 <= v2[a1 - 1 - v3]:\n                    break\n                a2 -= v2[a1 - 1 - v3]\n            else:\n                return []\n            v4[v5] = True\n            v1.append(v5 + 1)\n        return v1\n"}
{"id": "llm_code\\p03762__s375434213.py", "text": "def f1():\n    return [int(e) for v1 in input().split()]\n\ndef f2():\n    return [s for v1 in input().split()]\n\ndef f3(a1, a2):\n    v1 = 0\n    v2 = max(a1)\n    v3 = max(a2)\n    v4 = min(a1)\n    v5 = min(a2)\n\n    def one_fold(a1, a2=False):\n        if len(a1) == 2:\n            if a2:\n                return [v2 - v4]\n            else:\n                return [v3 - v5]\n        else:\n            return [a1[i] - a1[i - 1] for v1 in range(1, len(a1))]\n    v6 = one_fold(a1, x=True)\n    v7 = one_fold(a2)\n    while True:\n        if len(v6) == 1 and len(v7) == 1:\n            break\n        for v8 in v6:\n            for v9 in v7:\n                v1 += v8 * v9\n        if len(v6) > len(v7):\n            v6 = one_fold(v6, x=True)\n        else:\n            v7 = one_fold(v7)\n    v1 += v2 * v3\n    return v1 % (pow(10, 9) + 7)\nif __name__ == '__main__':\n    v1, v2 = f1()\n    v3 = f1()\n    v4 = f1()\n    print(f3(v3, v4))\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1():\n    return [int(e) for v1 in input().split()]\n\ndef f2():\n    return [s for v1 in input().split()]\n\ndef f3(a1, a2):\n    v1 = 0\n    v2 = max(a1)\n    v3 = max(a2)\n    v4 = min(a1)\n    v5 = min(a2)\n\n    def one_fold(a1, a2=False):\n        if len(a1) == 2:\n            if a2:\n                return [v2 - v4]\n            else:\n                return [v3 - v5]\n        else:\n            return [a1[i] - a1[i - 1] for v1 in range(1, len(a1))]\n    v6 = one_fold(a1, x=True)\n    v7 = one_fold(a2)\n    while True:\n        if len(v6) == 1 and len(v7) == 1:\n            break\n        for v8 in v6:\n            for v9 in v7:\n                v1 += v8 * v9\n        if len(v6) > len(v7):\n            v6 = one_fold(v6, x=True)\n        else:\n            v7 = one_fold(v7)\n    v1 += v2 * v3\n    return v1 % (pow(10, 9) + 7)\nif __name__ == '__main__':\n    v1, v2 = f1()\n    v3 = f1()\n    v4 = f1()\n    print(f3(v3, v4))\n"}
{"id": "human_code\\p02949__s270971627.py", "text": "v1 = float('inf')\n\ndef f1(a1, a2, a3):\n    v1 = [0] + [v1] * (a2 - 1)\n    for v2 in range(a2):\n        for v3, v4, v5 in a1:\n            if v1[v3] == v1:\n                continue\n            if v1[v4] > v1[v3] + v5:\n                if v2 == a2 - 1:\n                    v1[v4] = -v1\n                else:\n                    v1[v4] = v1[v3] + v5\n    for v2 in range(a2):\n        for v3, v4, v5 in a1:\n            if v1[v3] == v1:\n                continue\n            v1[v4] = min(v1[v4], v1[v3] + v5)\n    return v1\nv2, v3, v4 = map(int, input().split())\nv5 = [None] * v3\nfor v6 in range(v3):\n    v7, v8, v9 = map(int, input().split())\n    v5[v6] = (v7 - 1, v8 - 1, -(v9 - v4))\nv10 = f1(v5, v2, 0)\nprint(-1 if v10[v2 - 1] == -v1 else max(0, -v10[v2 - 1]))\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = float('inf')\n\ndef f1(a1, a2, a3):\n    v1 = [0] + [v1] * (a2 - 1)\n    for v2 in range(a2):\n        for v3, v4, v5 in a1:\n            if v1[v3] == v1:\n                continue\n            if v1[v4] > v1[v3] + v5:\n                if v2 == a2 - 1:\n                    v1[v4] = -v1\n                else:\n                    v1[v4] = v1[v3] + v5\n    for v2 in range(a2):\n        for v3, v4, v5 in a1:\n            if v1[v3] == v1:\n                continue\n            v1[v4] = min(v1[v4], v1[v3] + v5)\n    return v1\nv2, v3, v4 = map(int, input().split())\nv5 = [None] * v3\nfor v6 in range(v3):\n    v7, v8, v9 = map(int, input().split())\n    v5[v6] = (v7 - 1, v8 - 1, -(v9 - v4))\nv10 = f1(v5, v2, 0)\nprint(-1 if v10[v2 - 1] == -v1 else max(0, -v10[v2 - 1]))\n"}
{"id": "human_code\\binary-tree-inorder-traversal__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def inorderTraversal(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = ([], a1)\n        while v2:\n            if v2.left is None:\n                v1.append(v2.val)\n                v2 = v2.right\n            else:\n                v3 = v2.left\n                while v3.right and v3.right != v2:\n                    v3 = v3.right\n                if v3.right is None:\n                    v3.right = v2\n                    v2 = v2.left\n                else:\n                    v1.append(v2.val)\n                    v3.right = None\n                    v2 = v2.right\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def inorderTraversal(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = ([], a1)\n        while v2:\n            if v2.left is None:\n                v1.append(v2.val)\n                v2 = v2.right\n            else:\n                v3 = v2.left\n                while v3.right and v3.right != v2:\n                    v3 = v3.right\n                if v3.right is None:\n                    v3.right = v2\n                    v2 = v2.left\n                else:\n                    v1.append(v2.val)\n                    v3.right = None\n                    v2 = v2.right\n        return v1\n"}
{"id": "human_code\\minimum-operations-to-form-subsequence-with-target-sum__part2.py", "text": "class C1(object):\n\n    def minOperations(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = sum(a1)\n        if v1 < a2:\n            return -1\n        a1.sort()\n        v2 = 0\n        while a2:\n            v3 = a1.pop()\n            if v3 <= a2:\n                a2 -= v3\n                v1 -= v3\n            elif v1 - v3 >= a2:\n                v1 -= v3\n            else:\n                a1.append(v3 // 2)\n                a1.append(v3 // 2)\n                v2 += 1\n        return v2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def minOperations(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = sum(a1)\n        if v1 < a2:\n            return -1\n        a1.sort()\n        v2 = 0\n        while a2:\n            v3 = a1.pop()\n            if v3 <= a2:\n                a2 -= v3\n                v1 -= v3\n            elif v1 - v3 >= a2:\n                v1 -= v3\n            else:\n                a1.append(v3 // 2)\n                a1.append(v3 // 2)\n                v2 += 1\n        return v2\n"}
{"id": "llm_code\\encode-string-with-shortest-length__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def encode(self, a1):\n        v1 = len(a1)\n        v2 = {}\n\n        def helper(a1, a2):\n            if a2 - a1 <= 1:\n                return a1[a1:a2]\n            v1 = (a1, a2)\n            if v1 in v2:\n                return v2[v1]\n            v2 = a1[a1:a2]\n            for v3 in range(a1 + 1, a2):\n                v4 = helper(a1, v3)\n                v5 = helper(v3, a2)\n                v6 = v4 + v5\n                if len(v6) < len(v2):\n                    v2 = v6\n            v7 = a2 - a1\n            if v7 > 1:\n                v8 = [0] * v7\n                v9 = 0\n                for v10 in range(1, v7):\n                    while v9 > 0 and a1[a1 + v10] != a1[a1 + v9]:\n                        v9 = v8[v9 - 1]\n                    if a1[a1 + v10] == a1[a1 + v9]:\n                        v9 += 1\n                    v8[v10] = v9\n                v11 = v7 - v8[v7 - 1]\n                if v11 < v7 and v7 % v11 == 0:\n                    v12 = helper(a1, a1 + v11)\n                    v13 = v7 // v11\n                    v14 = f'{v13}[{v12}]'\n                    if len(v14) < len(v2):\n                        v2 = v14\n            v2[v1] = v2\n            return v2\n        return helper(0, v1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def encode(self, a1):\n        v1 = len(a1)\n        v2 = {}\n\n        def helper(a1, a2):\n            if a2 - a1 <= 1:\n                return a1[a1:a2]\n            v1 = (a1, a2)\n            if v1 in v2:\n                return v2[v1]\n            v2 = a1[a1:a2]\n            for v3 in range(a1 + 1, a2):\n                v4 = helper(a1, v3)\n                v5 = helper(v3, a2)\n                v6 = v4 + v5\n                if len(v6) < len(v2):\n                    v2 = v6\n            v7 = a2 - a1\n            if v7 > 1:\n                v8 = [0] * v7\n                v9 = 0\n                for v10 in range(1, v7):\n                    while v9 > 0 and a1[a1 + v10] != a1[a1 + v9]:\n                        v9 = v8[v9 - 1]\n                    if a1[a1 + v10] == a1[a1 + v9]:\n                        v9 += 1\n                    v8[v10] = v9\n                v11 = v7 - v8[v7 - 1]\n                if v11 < v7 and v7 % v11 == 0:\n                    v12 = helper(a1, a1 + v11)\n                    v13 = v7 // v11\n                    v14 = f'{v13}[{v12}]'\n                    if len(v14) < len(v2):\n                        v2 = v14\n            v2[v1] = v2\n            return v2\n        return helper(0, v1)\n"}
{"id": "human_code\\p03626__s095817808.py", "text": "v1 = int(input())\nv2 = input()\nv3 = input()\nv4 = 0\nv5 = 0\nv6 = 1000000007\nv7 = True\nwhile v2:\n    if len(v2) > 1 and v2[0] == v2[1]:\n        v2 = v2[2:]\n        if v7:\n            v5 = 6\n            v4 = 0\n            v7 = False\n        else:\n            v5 = v4 * 2 + v5 * 3\n            v4 = 0\n    else:\n        v2 = v2[1:]\n        if v7:\n            v4 = 3\n            v5 = 0\n            v7 = False\n        else:\n            v4 = v4 * 2 + v5\n            v5 = 0\n    v4 %= v6\n    v5 %= v6\nprint((v5 + v4) % v6)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = input()\nv3 = input()\nv4 = 0\nv5 = 0\nv6 = 1000000007\nv7 = True\nwhile v2:\n    if len(v2) > 1 and v2[0] == v2[1]:\n        v2 = v2[2:]\n        if v7:\n            v5 = 6\n            v4 = 0\n            v7 = False\n        else:\n            v5 = v4 * 2 + v5 * 3\n            v4 = 0\n    else:\n        v2 = v2[1:]\n        if v7:\n            v4 = 3\n            v5 = 0\n            v7 = False\n        else:\n            v4 = v4 * 2 + v5\n            v5 = 0\n    v4 %= v6\n    v5 %= v6\nprint((v5 + v4) % v6)\n"}
{"id": "llm_code\\binary-tree-coloring-game__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2:\n\n    def btreeGameWinningMove(self, a1, a2, a3):\n\n        def subtree_size(a1):\n            if not a1:\n                return 0\n            return subtree_size(a1.left) + subtree_size(a1.right) + 1\n\n        def search(a1):\n            if not a1:\n                return (None, 0, 0)\n            if a1.val == a3:\n                v1 = subtree_size(a1.left)\n                v2 = subtree_size(a1.right)\n                return (a1, v1, v2)\n            v3 = search(a1.left)\n            if v3[0]:\n                return v3\n            v3 = search(a1.right)\n            if v3[0]:\n                return v3\n            return (None, 0, 0)\n        v1, v2, v3 = search(a1)\n        v4 = a2 - v2 - v3 - 1\n        v5 = max(v2, v3, v4)\n        return v5 > a2 - v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2:\n\n    def btreeGameWinningMove(self, a1, a2, a3):\n\n        def subtree_size(a1):\n            if not a1:\n                return 0\n            return subtree_size(a1.left) + subtree_size(a1.right) + 1\n\n        def search(a1):\n            if not a1:\n                return (None, 0, 0)\n            if a1.val == a3:\n                v1 = subtree_size(a1.left)\n                v2 = subtree_size(a1.right)\n                return (a1, v1, v2)\n            v3 = search(a1.left)\n            if v3[0]:\n                return v3\n            v3 = search(a1.right)\n            if v3[0]:\n                return v3\n            return (None, 0, 0)\n        v1, v2, v3 = search(a1)\n        v4 = a2 - v2 - v3 - 1\n        v5 = max(v2, v3, v4)\n        return v5 > a2 - v5\n"}
{"id": "llm_code\\design-neighbor-sum-service__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def __init__(self, a1):\n        self.board = a1\n        v1 = len(a1)\n        v2 = len(a1[0])\n        self.side_sums = {}\n        self.angle_sums = {}\n        v3 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        v4 = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v7 = self.board[v5][v6]\n                v8 = 0\n                for v9, v10 in v3:\n                    v11 = v5 + v9\n                    v12 = v6 + v10\n                    if 0 <= v11 < v1 and 0 <= v12 < v2:\n                        v8 += self.board[v11][v12]\n                self.side_sums[v7] = v8\n                v13 = 0\n                for v9, v10 in v4:\n                    v11 = v5 + v9\n                    v12 = v6 + v10\n                    if 0 <= v11 < v1 and 0 <= v12 < v2:\n                        v13 += self.board[v11][v12]\n                self.angle_sums[v7] = v13\n\n    def adjacentSum(self, a1):\n        return self.side_sums.get(a1, 0)\n\n    def diagonalSum(self, a1):\n        return self.angle_sums.get(a1, 0)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def __init__(self, a1):\n        self.board = a1\n        v1 = len(a1)\n        v2 = len(a1[0])\n        self.side_sums = {}\n        self.angle_sums = {}\n        v3 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        v4 = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n        for v5 in range(v1):\n            for v6 in range(v2):\n                v7 = self.board[v5][v6]\n                v8 = 0\n                for v9, v10 in v3:\n                    v11 = v5 + v9\n                    v12 = v6 + v10\n                    if 0 <= v11 < v1 and 0 <= v12 < v2:\n                        v8 += self.board[v11][v12]\n                self.side_sums[v7] = v8\n                v13 = 0\n                for v9, v10 in v4:\n                    v11 = v5 + v9\n                    v12 = v6 + v10\n                    if 0 <= v11 < v1 and 0 <= v12 < v2:\n                        v13 += self.board[v11][v12]\n                self.angle_sums[v7] = v13\n\n    def adjacentSum(self, a1):\n        return self.side_sums.get(a1, 0)\n\n    def diagonalSum(self, a1):\n        return self.angle_sums.get(a1, 0)\n"}
{"id": "human_code\\find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.count = a1\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[max(v1, v2)] = min(v1, v2)\n        self.count -= 1\n        return True\n\nclass C2(object):\n\n    def findCriticalAndPseudoCriticalEdges(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def MST(a1, a2, a3=None, a4=None):\n            v1 = C1(a1)\n            v2 = 0\n            if a4 is not None:\n                v3, v4, v5, v6 = a2[a4]\n                if v1.union_set(v3, v4):\n                    v2 += v5\n            for v7, (v3, v4, v5, v6) in enumerate(a2):\n                if v7 == a3:\n                    continue\n                if v1.union_set(v3, v4):\n                    v2 += v5\n            return v2 if v1.count == 1 else float('inf')\n        for v1, v2 in enumerate(a2):\n            v2.append(v1)\n        a2.sort(key=lambda x: x[2])\n        v3 = MST(a1, a2)\n        v4 = [[], []]\n        for v1, v2 in enumerate(a2):\n            if v3 < MST(a1, a2, unused=v1):\n                v4[0].append(v2[3])\n            elif v3 == MST(a1, a2, used=v1):\n                v4[1].append(v2[3])\n        return v4\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(a1))\n        self.count = a1\n\n    def find_set(self, a1):\n        if self.set[a1] != a1:\n            self.set[a1] = self.find_set(self.set[a1])\n        return self.set[a1]\n\n    def union_set(self, a1, a2):\n        v1, v2 = list(map(self.find_set, (a1, a2)))\n        if v1 == v2:\n            return False\n        self.set[max(v1, v2)] = min(v1, v2)\n        self.count -= 1\n        return True\n\nclass C2(object):\n\n    def findCriticalAndPseudoCriticalEdges(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        def MST(a1, a2, a3=None, a4=None):\n            v1 = C1(a1)\n            v2 = 0\n            if a4 is not None:\n                v3, v4, v5, v6 = a2[a4]\n                if v1.union_set(v3, v4):\n                    v2 += v5\n            for v7, (v3, v4, v5, v6) in enumerate(a2):\n                if v7 == a3:\n                    continue\n                if v1.union_set(v3, v4):\n                    v2 += v5\n            return v2 if v1.count == 1 else float('inf')\n        for v1, v2 in enumerate(a2):\n            v2.append(v1)\n        a2.sort(key=lambda x: x[2])\n        v3 = MST(a1, a2)\n        v4 = [[], []]\n        for v1, v2 in enumerate(a2):\n            if v3 < MST(a1, a2, unused=v1):\n                v4[0].append(v2[3])\n            elif v3 == MST(a1, a2, used=v1):\n                v4[1].append(v2[3])\n        return v4\n"}
{"id": "human_code\\remove-zero-sum-consecutive-nodes-from-linked-list.py", "text": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\nclass C2(object):\n\n    def removeZeroSumSublists(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = C1(0)\n        v2.next = a1\n        v3 = 0\n        v4 = collections.OrderedDict()\n        while v1:\n            v3 += v1.val\n            v5 = v4.get(v3, v1)\n            while v3 in v4:\n                v4.popitem()\n            v4[v3] = v5\n            v5.next = v1.__next__\n            v1 = v1.__next__\n        return v2.__next__\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\nclass C2(object):\n\n    def removeZeroSumSublists(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = v2 = C1(0)\n        v2.next = a1\n        v3 = 0\n        v4 = collections.OrderedDict()\n        while v1:\n            v3 += v1.val\n            v5 = v4.get(v3, v1)\n            while v3 in v4:\n                v4.popitem()\n            v4[v3] = v5\n            v5.next = v1.__next__\n            v1 = v1.__next__\n        return v2.__next__\n"}
{"id": "human_code\\build-binary-expression-tree-from-infix-expression.py", "text": "class C1(object):\n\n    def __init__(self, a1=' ', a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def expTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def compute(a1, a2):\n            v1, v2 = (a1.pop(), a1.pop())\n            a1.append(C1(val=a2.pop(), left=v2, right=v1))\n        v1 = {'+': 0, '-': 0, '*': 1, '/': 1}\n        v2, v3, v4 = ([], [], 0)\n        for v5 in range(len(a1)):\n            if a1[v5].isdigit():\n                v4 = v4 * 10 + int(a1[v5])\n                if v5 == len(a1) - 1 or not a1[v5 + 1].isdigit():\n                    v2.append(C1(val=str(v4)))\n                    v4 = 0\n            elif a1[v5] == '(':\n                v3.append(a1[v5])\n            elif a1[v5] == ')':\n                while v3[-1] != '(':\n                    compute(v2, v3)\n                v3.pop()\n            elif a1[v5] in v1:\n                while v3 and v3[-1] in v1 and (v1[v3[-1]] >= v1[a1[v5]]):\n                    compute(v2, v3)\n                v3.append(a1[v5])\n        while v3:\n            compute(v2, v3)\n        return v2[-1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=' ', a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def expTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def compute(a1, a2):\n            v1, v2 = (a1.pop(), a1.pop())\n            a1.append(C1(val=a2.pop(), left=v2, right=v1))\n        v1 = {'+': 0, '-': 0, '*': 1, '/': 1}\n        v2, v3, v4 = ([], [], 0)\n        for v5 in range(len(a1)):\n            if a1[v5].isdigit():\n                v4 = v4 * 10 + int(a1[v5])\n                if v5 == len(a1) - 1 or not a1[v5 + 1].isdigit():\n                    v2.append(C1(val=str(v4)))\n                    v4 = 0\n            elif a1[v5] == '(':\n                v3.append(a1[v5])\n            elif a1[v5] == ')':\n                while v3[-1] != '(':\n                    compute(v2, v3)\n                v3.pop()\n            elif a1[v5] in v1:\n                while v3 and v3[-1] in v1 and (v1[v3[-1]] >= v1[a1[v5]]):\n                    compute(v2, v3)\n                v3.append(a1[v5])\n        while v3:\n            compute(v2, v3)\n        return v2[-1]\n"}
{"id": "llm_code\\alert-using-same-key-card-three-or-more-times-in-a-one-hour-period__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def alertNames(self, a1, a2):\n\n        def to_minutes(a1):\n            v1, v2 = a1.split(':')\n            return int(v1) * 60 + int(v2)\n        v1 = {}\n        for v2 in range(len(a1)):\n            v3 = a1[v2]\n            v4 = to_minutes(a2[v2])\n            if v3 not in v1:\n                v1[v3] = []\n            v1[v3].append(v4)\n        v5 = []\n        for v3, v6 in v1.items():\n            v6.sort()\n            v7 = len(v6)\n            v8 = False\n            for v9 in range(v7 - 2):\n                if v6[v9 + 2] - v6[v9] <= 60:\n                    v8 = True\n                    break\n            if v8:\n                v5.append(v3)\n        v5.sort()\n        return v5\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def alertNames(self, a1, a2):\n\n        def to_minutes(a1):\n            v1, v2 = a1.split(':')\n            return int(v1) * 60 + int(v2)\n        v1 = {}\n        for v2 in range(len(a1)):\n            v3 = a1[v2]\n            v4 = to_minutes(a2[v2])\n            if v3 not in v1:\n                v1[v3] = []\n            v1[v3].append(v4)\n        v5 = []\n        for v3, v6 in v1.items():\n            v6.sort()\n            v7 = len(v6)\n            v8 = False\n            for v9 in range(v7 - 2):\n                if v6[v9 + 2] - v6[v9] <= 60:\n                    v8 = True\n                    break\n            if v8:\n                v5.append(v3)\n        v5.sort()\n        return v5\n"}
{"id": "human_code\\read-n-characters-given-read4.py", "text": "def f1(a1):\n    global file_content\n    v1 = 0\n    while v1 < len(file_content) and v1 < 4:\n        a1[v1] = file_content[v1]\n        v1 += 1\n    if len(file_content) > 4:\n        v2 = v2[4:]\n    else:\n        v2 = ''\n    return v1\n\nclass C1(object):\n\n    def read(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = [''] * 4\n        for v3 in range((a2 + 4 - 1) // 4):\n            v4 = min(f1(v2), a2 - v1)\n            a1[v1:v1 + v4] = v2[:v4]\n            v1 += v4\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "def f1(a1):\n    global file_content\n    v1 = 0\n    while v1 < len(file_content) and v1 < 4:\n        a1[v1] = file_content[v1]\n        v1 += 1\n    if len(file_content) > 4:\n        v2 = v2[4:]\n    else:\n        v2 = ''\n    return v1\n\nclass C1(object):\n\n    def read(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = [''] * 4\n        for v3 in range((a2 + 4 - 1) // 4):\n            v4 = min(f1(v2), a2 - v1)\n            a1[v1:v1 + v4] = v2[:v4]\n            v1 += v4\n        return v1\n"}
{"id": "human_code\\sum-of-subarray-ranges.py", "text": "class C1(object):\n\n    def subArrayRanges(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = []\n        for v3 in range(len(a1) + 1):\n            v4 = a1[v3] if v3 < len(a1) else float('inf')\n            while v2 and a1[v2[-1]] <= v4:\n                v5 = v2.pop()\n                v6 = v2[-1] if v2 else -1\n                v1 += a1[v5] * (v5 - v6) * (v3 - v5)\n            v2.append(v3)\n        v2 = []\n        for v3 in range(len(a1) + 1):\n            v4 = a1[v3] if v3 < len(a1) else float('-inf')\n            while v2 and a1[v2[-1]] >= v4:\n                v5 = v2.pop()\n                v6 = v2[-1] if v2 else -1\n                v1 -= a1[v5] * (v5 - v6) * (v3 - v5)\n            v2.append(v3)\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def subArrayRanges(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 0\n        v2 = []\n        for v3 in range(len(a1) + 1):\n            v4 = a1[v3] if v3 < len(a1) else float('inf')\n            while v2 and a1[v2[-1]] <= v4:\n                v5 = v2.pop()\n                v6 = v2[-1] if v2 else -1\n                v1 += a1[v5] * (v5 - v6) * (v3 - v5)\n            v2.append(v3)\n        v2 = []\n        for v3 in range(len(a1) + 1):\n            v4 = a1[v3] if v3 < len(a1) else float('-inf')\n            while v2 and a1[v2[-1]] >= v4:\n                v5 = v2.pop()\n                v6 = v2[-1] if v2 else -1\n                v1 -= a1[v5] * (v5 - v6) * (v3 - v5)\n            v2.append(v3)\n        return v1\n"}
{"id": "human_code\\random-flip-matrix.py", "text": "import random\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__n_rows = a1\n        self.__n_cols = a2\n        self.__n = a1 * a2\n        self.__lookup = {}\n\n    def flip(self):\n        \"\"\"\n        \"\"\"\n        self.__n -= 1\n        v1 = random.randint(0, self.__n)\n        v2 = self.__lookup.get(v1, v1)\n        self.__lookup[v1] = self.__lookup.get(self.__n, self.__n)\n        return divmod(v2, self.__n_cols)\n\n    def reset(self):\n        \"\"\"\n        \"\"\"\n        self.__n = self.__n_rows * self.__n_cols\n        self.__lookup = {}\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def __init__(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        self.__n_rows = a1\n        self.__n_cols = a2\n        self.__n = a1 * a2\n        self.__lookup = {}\n\n    def flip(self):\n        \"\"\"\n        \"\"\"\n        self.__n -= 1\n        v1 = random.randint(0, self.__n)\n        v2 = self.__lookup.get(v1, v1)\n        self.__lookup[v1] = self.__lookup.get(self.__n, self.__n)\n        return divmod(v2, self.__n_cols)\n\n    def reset(self):\n        \"\"\"\n        \"\"\"\n        self.__n = self.__n_rows * self.__n_cols\n        self.__lookup = {}\n"}
{"id": "llm_code\\p04000__s178339723.py", "text": "v1, v2, v3 = map(int, input().split())\nv4 = [tuple(map(int, input().split())) for v5 in range(v3)]\nv6 = [0] * 10\nif v3 == 0:\n    v6[0] = 999999996000000004\n    v6 = map(str, v6)\n    print('\\n'.join(v6))\n    exit(0)\nv7 = [[0] * v2 for v5 in range(v1)]\nfor v8 in v4:\n    v7[v8[0] - 1][v8[1] - 1] = 1\nfor v9 in range(v1 - 2):\n    for v10 in range(v2 - 2):\n        v11 = 0\n        for v5 in range(3):\n            for v12 in range(3):\n                v11 += v7[v9 + v5][v10 + v12]\n        v6[v11] += 1\nfor v5 in range(10):\n    print(v6[v5])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1, v2, v3 = map(int, input().split())\nv4 = [tuple(map(int, input().split())) for v5 in range(v3)]\nv6 = [0] * 10\nif v3 == 0:\n    v6[0] = 999999996000000004\n    v6 = map(str, v6)\n    print('\\n'.join(v6))\n    exit(0)\nv7 = [[0] * v2 for v5 in range(v1)]\nfor v8 in v4:\n    v7[v8[0] - 1][v8[1] - 1] = 1\nfor v9 in range(v1 - 2):\n    for v10 in range(v2 - 2):\n        v11 = 0\n        for v5 in range(3):\n            for v12 in range(3):\n                v11 += v7[v9 + v5][v10 + v12]\n        v6[v11] += 1\nfor v5 in range(10):\n    print(v6[v5])\n"}
{"id": "human_code\\p03157__s185119168.py", "text": "from collections import deque\n\ndef f1(a1):\n    v1 = deque([a1])\n    v2, v3 = (0, 0)\n    while len(v1) > 0:\n        v4, v5 = v1.popleft()\n        v2 += int(s[v4][v5] == '#')\n        v3 += int(s[v4][v5] == '.')\n        for v6, v7 in near[v4][v5]:\n            if (v6, v7) in frag:\n                continue\n            if s[v6][v7] != s[v4][v5]:\n                (v1.append((v6, v7)), frag.add((v6, v7)))\n    return v2 * v3\nv1, v2 = map(int, input().split())\nv3 = [input() for v4 in range(v1)]\nv5 = [[set() for v6 in range(v2)] for v7 in range(v1)]\nfor v7, v8 in enumerate(v3):\n    for v6, v9 in enumerate(v8):\n        for v10, v11 in [(v7 - 1, v6), (v7, v6 - 1), (v7 + 1, v6), (v7, v6 + 1)]:\n            if 0 <= v10 < v1 and 0 <= v11 < v2 and (v3[v10][v11] != v9):\n                v5[v7][v6].add((v10, v11))\nv12, v13 = (0, set())\nfor v7 in range(v1):\n    for v6 in range(v2):\n        if (v7, v6) not in v13:\n            v13.add((v7, v6))\n            v12 += f1((v7, v6))\nprint(v12)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "from collections import deque\n\ndef f1(a1):\n    v1 = deque([a1])\n    v2, v3 = (0, 0)\n    while len(v1) > 0:\n        v4, v5 = v1.popleft()\n        v2 += int(s[v4][v5] == '#')\n        v3 += int(s[v4][v5] == '.')\n        for v6, v7 in near[v4][v5]:\n            if (v6, v7) in frag:\n                continue\n            if s[v6][v7] != s[v4][v5]:\n                (v1.append((v6, v7)), frag.add((v6, v7)))\n    return v2 * v3\nv1, v2 = map(int, input().split())\nv3 = [input() for v4 in range(v1)]\nv5 = [[set() for v6 in range(v2)] for v7 in range(v1)]\nfor v7, v8 in enumerate(v3):\n    for v6, v9 in enumerate(v8):\n        for v10, v11 in [(v7 - 1, v6), (v7, v6 - 1), (v7 + 1, v6), (v7, v6 + 1)]:\n            if 0 <= v10 < v1 and 0 <= v11 < v2 and (v3[v10][v11] != v9):\n                v5[v7][v6].add((v10, v11))\nv12, v13 = (0, set())\nfor v7 in range(v1):\n    for v6 in range(v2):\n        if (v7, v6) not in v13:\n            v13.add((v7, v6))\n            v12 += f1((v7, v6))\nprint(v12)\n"}
{"id": "llm_code\\minimum-number-of-removals-to-make-mountain-array__grok-4.1-fast__v1.py", "text": "import bisect\n\nclass C1:\n\n    def minimumMountainRemovals(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = []\n        for v4 in range(v1):\n            v5 = bisect.bisect_left(v3, a1[v4])\n            v2[v4] = v5 + 1\n            if v5 == len(v3):\n                v3.append(a1[v4])\n            else:\n                v3[v5] = a1[v4]\n        v6 = [0] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            v5 = bisect.bisect_left(v3, a1[v4])\n            v6[v4] = v5 + 1\n            if v5 == len(v3):\n                v3.append(a1[v4])\n            else:\n                v3[v5] = a1[v4]\n        v7 = 1\n        for v4 in range(1, v1 - 1):\n            v7 = max(v7, v2[v4] + v6[v4] - 1)\n        return v1 - v7\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1:\n\n    def minimumMountainRemovals(self, a1):\n        v1 = len(a1)\n        v2 = [0] * v1\n        v3 = []\n        for v4 in range(v1):\n            v5 = bisect.bisect_left(v3, a1[v4])\n            v2[v4] = v5 + 1\n            if v5 == len(v3):\n                v3.append(a1[v4])\n            else:\n                v3[v5] = a1[v4]\n        v6 = [0] * v1\n        v3 = []\n        for v4 in range(v1 - 1, -1, -1):\n            v5 = bisect.bisect_left(v3, a1[v4])\n            v6[v4] = v5 + 1\n            if v5 == len(v3):\n                v3.append(a1[v4])\n            else:\n                v3[v5] = a1[v4]\n        v7 = 1\n        for v4 in range(1, v1 - 1):\n            v7 = max(v7, v2[v4] + v6[v4] - 1)\n        return v1 - v7\n"}
{"id": "human_code\\cut-off-trees-for-golf-event__part2.py", "text": "class C1(object):\n\n    def cutOffTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def minStep(a1, a2):\n            v1 = 0\n            v2 = {a1}\n            v3 = collections.deque([a1])\n            while v3:\n                v4 = len(v3)\n                for v5 in range(v4):\n                    v6, v7 = v3.popleft()\n                    if (v6, v7) == a2:\n                        return v1\n                    for v6, v7 in ((v6 + 1, v7), (v6 - 1, v7), (v6, v7 + 1), (v6, v7 - 1)):\n                        if not (0 <= v6 < m and 0 <= v7 < n and a1[v6][v7] and ((v6, v7) not in v2)):\n                            continue\n                        v3.append((v6, v7))\n                        v2.add((v6, v7))\n                v1 += 1\n            return -1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] > 1:\n                    heapq.heappush(v3, (a1[v4][v5], (v4, v5)))\n        v6 = (0, 0)\n        v7 = 0\n        while v3:\n            v8 = heapq.heappop(v3)\n            v9 = minStep(v6, v8[1])\n            if v9 < 0:\n                return -1\n            v7 += v9\n            v6 = v8[1]\n        return v7\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def cutOffTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def minStep(a1, a2):\n            v1 = 0\n            v2 = {a1}\n            v3 = collections.deque([a1])\n            while v3:\n                v4 = len(v3)\n                for v5 in range(v4):\n                    v6, v7 = v3.popleft()\n                    if (v6, v7) == a2:\n                        return v1\n                    for v6, v7 in ((v6 + 1, v7), (v6 - 1, v7), (v6, v7 + 1), (v6, v7 - 1)):\n                        if not (0 <= v6 < m and 0 <= v7 < n and a1[v6][v7] and ((v6, v7) not in v2)):\n                            continue\n                        v3.append((v6, v7))\n                        v2.add((v6, v7))\n                v1 += 1\n            return -1\n        v1, v2 = (len(a1), len(a1[0]))\n        v3 = []\n        for v4 in range(v1):\n            for v5 in range(v2):\n                if a1[v4][v5] > 1:\n                    heapq.heappush(v3, (a1[v4][v5], (v4, v5)))\n        v6 = (0, 0)\n        v7 = 0\n        while v3:\n            v8 = heapq.heappop(v3)\n            v9 = minStep(v6, v8[1])\n            if v9 < 0:\n                return -1\n            v7 += v9\n            v6 = v8[1]\n        return v7\n"}
{"id": "human_code\\check-if-the-rectangle-corner-is-reachable__part4.py", "text": "class C1(object):\n\n    def canReachCorner(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4, a5, a6):\n            return (a1 - a4) ** 2 + (a2 - a5) ** 2 <= (a3 + a6) ** 2\n\n        def bfs(a1, a2):\n            v1 = [False] * len(adj)\n            v1[a1] = True\n            v2 = [a1]\n            while v2:\n                v3 = []\n                for v4 in v2:\n                    for v5 in adj[v4]:\n                        if v1[v5]:\n                            continue\n                        v1[v5] = True\n                        v3.append(v5)\n                v2 = v3\n            return v1[a2]\n        v1 = [[] for v2 in range(len(a3) + 2)]\n        for v3 in range(len(a3)):\n            v4, v5, v6 = a3[v3]\n            if v4 - v6 <= 0 or v5 + v6 >= a2:\n                v1[v3].append(len(a3))\n                v1[len(a3)].append(v3)\n            if v4 + v6 >= a1 or v5 - v6 <= 0:\n                v1[v3].append(len(a3) + 1)\n                v1[len(a3) + 1].append(v3)\n            for v7 in range(v3):\n                v8, v9, v10 = a3[v7]\n                if not check(v4, v5, v6, v8, v9, v10):\n                    continue\n                v1[v3].append(v7)\n                v1[v7].append(v3)\n        return not bfs(len(a3), len(a3) + 1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def canReachCorner(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n\n        def check(a1, a2, a3, a4, a5, a6):\n            return (a1 - a4) ** 2 + (a2 - a5) ** 2 <= (a3 + a6) ** 2\n\n        def bfs(a1, a2):\n            v1 = [False] * len(adj)\n            v1[a1] = True\n            v2 = [a1]\n            while v2:\n                v3 = []\n                for v4 in v2:\n                    for v5 in adj[v4]:\n                        if v1[v5]:\n                            continue\n                        v1[v5] = True\n                        v3.append(v5)\n                v2 = v3\n            return v1[a2]\n        v1 = [[] for v2 in range(len(a3) + 2)]\n        for v3 in range(len(a3)):\n            v4, v5, v6 = a3[v3]\n            if v4 - v6 <= 0 or v5 + v6 >= a2:\n                v1[v3].append(len(a3))\n                v1[len(a3)].append(v3)\n            if v4 + v6 >= a1 or v5 - v6 <= 0:\n                v1[v3].append(len(a3) + 1)\n                v1[len(a3) + 1].append(v3)\n            for v7 in range(v3):\n                v8, v9, v10 = a3[v7]\n                if not check(v4, v5, v6, v8, v9, v10):\n                    continue\n                v1[v3].append(v7)\n                v1[v7].append(v3)\n        return not bfs(len(a3), len(a3) + 1)\n"}
{"id": "human_code\\p02705__s871933961.py", "text": "import math\nimport fractions\nimport bisect\nimport collections\nimport itertools\nimport heapq\nimport string\nimport sys\nimport copy\nfrom decimal import *\nfrom collections import deque\nfrom math import gcd\nsys.setrecursionlimit(10 ** 7)\nv1 = 10 ** 9 + 7\nv2 = float('inf')\n\ndef f1(a1, a2):\n    return a1 * a2 // gcd(a1, a2)\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return float(sys.stdin.readline())\n\ndef f4():\n    return sys.stdin.readline().split()\n\ndef f5():\n    return map(int, sys.stdin.readline().split())\n\ndef f6():\n    return map(lambda x: int(x) - 1, sys.stdin.readline().split())\n\ndef f7():\n    return map(float, sys.stdin.readline().split())\n\ndef f8():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f9():\n    return sorted(f8())\n\ndef f10():\n    return sorted(f8(), reverse=True)\n\ndef f11():\n    return list(map(float, sys.stdin.readline().split()))\n\ndef f12(a1, a2=''):\n    return a2.join(a1)\n\ndef f13(a1, a2):\n    return itertools.permutations(a1, a2)\n\ndef f14(a1, a2):\n    return math.factorial(a1) // math.factorial(a1 - a2)\n\ndef f15(a1, a2):\n    return itertools.combinations(a1, a2)\n\ndef f16(a1, a2):\n    return math.factorial(a1) // (math.factorial(a1 - a2) * math.factorial(a2))\n\ndef f17(a1, a2, a3, a4):\n    return ((a3 - a1) ** 2 + (a4 - a2) ** 2) ** 0.5\n\ndef f18(a1, a2):\n    return (a1 + a2) % v1\n\ndef f19(a1):\n    print(*a1, sep='\\n')\n\ndef f20(a1):\n    v1 = [True] * (a1 + 1)\n    v1[0] = False\n    v1[1] = False\n    for v2 in range(2, int(a1 ** 0.5) + 1):\n        if not v1[v2]:\n            continue\n        for v3 in range(v2 * 2, a1 + 1, v2):\n            v1[v3] = False\n    return v1\nv3 = f2()\nprint(2 * v3 * math.pi)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math\nimport fractions\nimport bisect\nimport collections\nimport itertools\nimport heapq\nimport string\nimport sys\nimport copy\nfrom decimal import *\nfrom collections import deque\nfrom math import gcd\nsys.setrecursionlimit(10 ** 7)\nv1 = 10 ** 9 + 7\nv2 = float('inf')\n\ndef f1(a1, a2):\n    return a1 * a2 // gcd(a1, a2)\n\ndef f2():\n    return int(sys.stdin.readline())\n\ndef f3():\n    return float(sys.stdin.readline())\n\ndef f4():\n    return sys.stdin.readline().split()\n\ndef f5():\n    return map(int, sys.stdin.readline().split())\n\ndef f6():\n    return map(lambda x: int(x) - 1, sys.stdin.readline().split())\n\ndef f7():\n    return map(float, sys.stdin.readline().split())\n\ndef f8():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef f9():\n    return sorted(f8())\n\ndef f10():\n    return sorted(f8(), reverse=True)\n\ndef f11():\n    return list(map(float, sys.stdin.readline().split()))\n\ndef f12(a1, a2=''):\n    return a2.join(a1)\n\ndef f13(a1, a2):\n    return itertools.permutations(a1, a2)\n\ndef f14(a1, a2):\n    return math.factorial(a1) // math.factorial(a1 - a2)\n\ndef f15(a1, a2):\n    return itertools.combinations(a1, a2)\n\ndef f16(a1, a2):\n    return math.factorial(a1) // (math.factorial(a1 - a2) * math.factorial(a2))\n\ndef f17(a1, a2, a3, a4):\n    return ((a3 - a1) ** 2 + (a4 - a2) ** 2) ** 0.5\n\ndef f18(a1, a2):\n    return (a1 + a2) % v1\n\ndef f19(a1):\n    print(*a1, sep='\\n')\n\ndef f20(a1):\n    v1 = [True] * (a1 + 1)\n    v1[0] = False\n    v1[1] = False\n    for v2 in range(2, int(a1 ** 0.5) + 1):\n        if not v1[v2]:\n            continue\n        for v3 in range(v2 * 2, a1 + 1, v2):\n            v1[v3] = False\n    return v1\nv3 = f2()\nprint(2 * v3 * math.pi)\n"}
{"id": "human_code\\p02685__s073557795.py", "text": "v1 = 998244353\nv2, v3, v4 = map(int, input().split())\nv5 = [0] + [1]\nfor v6 in range(2, v4 + 2):\n    v5.append(-(v1 // v6) * v5[v1 % v6] % v1)\n\ndef f1(a1, a2):\n    if a2 == 0:\n        return 1\n    else:\n        v1 = f1(a1, a2 // 2)\n        if a2 % 2 == 0:\n            return v1 ** 2 % v1\n        else:\n            return a1 * v1 ** 2 % v1\n\ndef f2(a1):\n    return f1(a1, v1 - 2)\nif v3 == 1 and v4 < v2 - 1:\n    print(0)\nelif v4 == v2 - 1:\n    print(f1(v3, v2))\nelse:\n    v7 = 0\n    v8 = f1(v3 - 1, v2 - 1)\n    v9 = 1\n    v10 = f2(v3 - 1)\n    for v6 in range(v4 + 1):\n        v7 += v8 * v9\n        v7 %= v1\n        v8 = v8 * v10 % v1\n        v9 = v9 * (v2 - v6 - 1) * v5[v6 + 1] % v1\n    v11 = v3 * v7 % v1\n    print(v11)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = 998244353\nv2, v3, v4 = map(int, input().split())\nv5 = [0] + [1]\nfor v6 in range(2, v4 + 2):\n    v5.append(-(v1 // v6) * v5[v1 % v6] % v1)\n\ndef f1(a1, a2):\n    if a2 == 0:\n        return 1\n    else:\n        v1 = f1(a1, a2 // 2)\n        if a2 % 2 == 0:\n            return v1 ** 2 % v1\n        else:\n            return a1 * v1 ** 2 % v1\n\ndef f2(a1):\n    return f1(a1, v1 - 2)\nif v3 == 1 and v4 < v2 - 1:\n    print(0)\nelif v4 == v2 - 1:\n    print(f1(v3, v2))\nelse:\n    v7 = 0\n    v8 = f1(v3 - 1, v2 - 1)\n    v9 = 1\n    v10 = f2(v3 - 1)\n    for v6 in range(v4 + 1):\n        v7 += v8 * v9\n        v7 %= v1\n        v8 = v8 * v10 % v1\n        v9 = v9 * (v2 - v6 - 1) * v5[v6 + 1] % v1\n    v11 = v3 * v7 % v1\n    print(v11)\n"}
{"id": "human_code\\divide-an-array-into-subarrays-with-minimum-cost-i__part1.py", "text": "import random\n\nclass C1(object):\n\n    def minimumCost(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=0, a4=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1 = len(a1) - 1\n            while a3 <= v1:\n                v2 = random.randint(a3, v1)\n                v3, v4 = tri_partition(a1, a3, v1, a1[v2], a4)\n                if v3 <= a2 <= v4:\n                    return\n                elif v3 > a2:\n                    v1 = v3 - 1\n                else:\n                    a3 = v4 + 1\n        nth_element(a1, 1 + (2 - 1), 1)\n        return a1[0] + a1[1] + a1[2]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import random\n\nclass C1(object):\n\n    def minimumCost(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def nth_element(a1, a2, a3=0, a4=lambda a, b: a < b):\n\n            def tri_partition(a1, a2, a3, a4, a5):\n                v1 = a2\n                while v1 <= a3:\n                    if a1[v1] == a4:\n                        v1 += 1\n                    elif a5(a1[v1], a4):\n                        a1[a2], a1[v1] = (a1[v1], a1[a2])\n                        a2 += 1\n                        v1 += 1\n                    else:\n                        a1[v1], a1[a3] = (a1[a3], a1[v1])\n                        a3 -= 1\n                return (a2, a3)\n            v1 = len(a1) - 1\n            while a3 <= v1:\n                v2 = random.randint(a3, v1)\n                v3, v4 = tri_partition(a1, a3, v1, a1[v2], a4)\n                if v3 <= a2 <= v4:\n                    return\n                elif v3 > a2:\n                    v1 = v3 - 1\n                else:\n                    a3 = v4 + 1\n        nth_element(a1, 1 + (2 - 1), 1)\n        return a1[0] + a1[1] + a1[2]\n"}
{"id": "human_code\\reorder-list.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return '{} -> {}'.format(self.val, repr(self.__next__))\n\nclass C2(object):\n\n    def reorderList(self, a1):\n        if a1 == None or a1.__next__ == None:\n            return a1\n        v1, v2, v3 = (a1, a1, None)\n        while v1 != None and v1.__next__ != None:\n            v1, v2, v3 = (v1.next.__next__, v2.__next__, v2)\n        v4, v3.next, v3 = (v2, None, None)\n        while v4 != None:\n            v4.next, v3, v4 = (v3, v4, v4.next)\n        v5, v6 = (a1, v3)\n        v7 = C1(0)\n        v4 = v7\n        while v5 != None and v6 != None:\n            v4.next, v4, v5 = (v5, v5, v5.__next__)\n            v4.next, v4, v6 = (v6, v6, v6.__next__)\n        return v7.__next__\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\n    def __repr__(self):\n        if self:\n            return '{} -> {}'.format(self.val, repr(self.__next__))\n\nclass C2(object):\n\n    def reorderList(self, a1):\n        if a1 == None or a1.__next__ == None:\n            return a1\n        v1, v2, v3 = (a1, a1, None)\n        while v1 != None and v1.__next__ != None:\n            v1, v2, v3 = (v1.next.__next__, v2.__next__, v2)\n        v4, v3.next, v3 = (v2, None, None)\n        while v4 != None:\n            v4.next, v3, v4 = (v3, v4, v4.next)\n        v5, v6 = (a1, v3)\n        v7 = C1(0)\n        v4 = v7\n        while v5 != None and v6 != None:\n            v4.next, v4, v5 = (v5, v5, v5.__next__)\n            v4.next, v4, v6 = (v6, v6, v6.__next__)\n        return v7.__next__\n"}
{"id": "human_code\\p02632__s037490768.py", "text": "def f1(a1, a2, a3):\n    return fac[a1] * facinv[a2] * facinv[a1 - a2] % a3\n\ndef f2(a1, a2):\n    for v1 in range(2, a1 + 1):\n        fac.append(fac[v1 - 1] * v1 % a2)\n        inv.append(-inv[a2 % v1] * (a2 // v1) % a2)\n        facinv.append(facinv[-1] * inv[-1] % a2)\nv1 = [1, 1]\nv2 = [1, 1]\nv3 = [0, 1]\nv4 = int(input())\nv5 = input()\nv6 = len(v5)\nv7 = 1000000007\nf2(v6 + v4 - 1, v7)\nv8 = 0\nfor v9 in range(v4 + 1):\n    v10 = pow(25, v4 - v9, v7)\n    v10 *= f1(v6 + v4 - v9 - 1, v4 - v9, v7)\n    v10 %= v7\n    v10 *= pow(26, v9, v7)\n    v10 %= v7\n    v8 += v10\n    v8 %= v7\nprint(v8)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1, a2, a3):\n    return fac[a1] * facinv[a2] * facinv[a1 - a2] % a3\n\ndef f2(a1, a2):\n    for v1 in range(2, a1 + 1):\n        fac.append(fac[v1 - 1] * v1 % a2)\n        inv.append(-inv[a2 % v1] * (a2 // v1) % a2)\n        facinv.append(facinv[-1] * inv[-1] % a2)\nv1 = [1, 1]\nv2 = [1, 1]\nv3 = [0, 1]\nv4 = int(input())\nv5 = input()\nv6 = len(v5)\nv7 = 1000000007\nf2(v6 + v4 - 1, v7)\nv8 = 0\nfor v9 in range(v4 + 1):\n    v10 = pow(25, v4 - v9, v7)\n    v10 *= f1(v6 + v4 - v9 - 1, v4 - v9, v7)\n    v10 %= v7\n    v10 *= pow(26, v9, v7)\n    v10 %= v7\n    v8 += v10\n    v8 %= v7\nprint(v8)\n"}
{"id": "human_code\\alternating-groups-iii.py", "text": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def numberOfAlternatingGroups(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class BIT(object):\n\n            def __init__(self, a1):\n                self.__bit = [0] * (a1 + 1)\n\n            def add(self, a1, a2):\n                a1 += 1\n                while a1 < len(self.__bit):\n                    self.__bit[a1] += a2\n                    a1 += a1 & -a1\n\n            def query(self, a1):\n                a1 += 1\n                v2 = 0\n                while a1 > 0:\n                    v2 += self.__bit[a1]\n                    a1 -= a1 & -a1\n                return v2\n\n        def update(a1, a2):\n            if a2 == +1:\n                sl.add(a1)\n                if len(sl) == 1:\n                    bit1.add(n, +1)\n                    bit2.add(n, +n)\n            v1 = sl.index(a1)\n            v2, v3 = ((v1 - 1) % len(sl), (v1 + 1) % len(sl))\n            if len(sl) != 1:\n                v4 = (sl[v3] - sl[v2] - 1) % n + 1\n                bit1.add(v4, a2 * -1)\n                bit2.add(v4, a2 * -v4)\n                v4 = (sl[v1] - sl[v2]) % n\n                bit1.add(v4, a2 * +1)\n                bit2.add(v4, a2 * +v4)\n                v4 = (sl[v3] - sl[v1]) % n\n                bit1.add(v4, a2 * +1)\n                bit2.add(v4, a2 * +v4)\n            if a2 == -1:\n                if len(sl) == 1:\n                    bit1.add(n, -1)\n                    bit2.add(n, -n)\n                sl.pop(v1)\n        v1 = len(a1)\n        v2 = SortedList()\n        v3, v4 = (BIT(v1 + 1), BIT(v1 + 1))\n        for v5 in range(v1):\n            if a1[v5] == a1[(v5 + 1) % v1]:\n                update(v5, +1)\n        v6 = []\n        for v7 in a2:\n            if v7[0] == 1:\n                v8 = v7[1]\n                v6.append(v4.query(v1) - v4.query(v8 - 1) - (v8 - 1) * (v3.query(v1) - v3.query(v8 - 1)) if v2 else v1)\n                continue\n            v9, v5, v10 = v7\n            if a1[v5] == v10:\n                continue\n            a1[v5] = v10\n            update((v5 - 1) % v1, +1 if a1[v5] == a1[(v5 - 1) % v1] else -1)\n            update(v5, +1 if a1[v5] == a1[(v5 + 1) % v1] else -1)\n        return v6\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from sortedcontainers import SortedList\n\nclass C1(object):\n\n    def numberOfAlternatingGroups(self, a1, a2):\n        \"\"\"\n        \"\"\"\n\n        class BIT(object):\n\n            def __init__(self, a1):\n                self.__bit = [0] * (a1 + 1)\n\n            def add(self, a1, a2):\n                a1 += 1\n                while a1 < len(self.__bit):\n                    self.__bit[a1] += a2\n                    a1 += a1 & -a1\n\n            def query(self, a1):\n                a1 += 1\n                v2 = 0\n                while a1 > 0:\n                    v2 += self.__bit[a1]\n                    a1 -= a1 & -a1\n                return v2\n\n        def update(a1, a2):\n            if a2 == +1:\n                sl.add(a1)\n                if len(sl) == 1:\n                    bit1.add(n, +1)\n                    bit2.add(n, +n)\n            v1 = sl.index(a1)\n            v2, v3 = ((v1 - 1) % len(sl), (v1 + 1) % len(sl))\n            if len(sl) != 1:\n                v4 = (sl[v3] - sl[v2] - 1) % n + 1\n                bit1.add(v4, a2 * -1)\n                bit2.add(v4, a2 * -v4)\n                v4 = (sl[v1] - sl[v2]) % n\n                bit1.add(v4, a2 * +1)\n                bit2.add(v4, a2 * +v4)\n                v4 = (sl[v3] - sl[v1]) % n\n                bit1.add(v4, a2 * +1)\n                bit2.add(v4, a2 * +v4)\n            if a2 == -1:\n                if len(sl) == 1:\n                    bit1.add(n, -1)\n                    bit2.add(n, -n)\n                sl.pop(v1)\n        v1 = len(a1)\n        v2 = SortedList()\n        v3, v4 = (BIT(v1 + 1), BIT(v1 + 1))\n        for v5 in range(v1):\n            if a1[v5] == a1[(v5 + 1) % v1]:\n                update(v5, +1)\n        v6 = []\n        for v7 in a2:\n            if v7[0] == 1:\n                v8 = v7[1]\n                v6.append(v4.query(v1) - v4.query(v8 - 1) - (v8 - 1) * (v3.query(v1) - v3.query(v8 - 1)) if v2 else v1)\n                continue\n            v9, v5, v10 = v7\n            if a1[v5] == v10:\n                continue\n            a1[v5] = v10\n            update((v5 - 1) % v1, +1 if a1[v5] == a1[(v5 - 1) % v1] else -1)\n            update(v5, +1 if a1[v5] == a1[(v5 + 1) % v1] else -1)\n        return v6\n"}
{"id": "human_code\\strange-printer-ii__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def isPrintable(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = list(range(2))\n\n        def has_cycle(a1, a2, a3):\n            v1 = [(1, a2)]\n            while v1:\n                v2, a2 = v1.pop()\n                if v2 == 1:\n                    a3[a2] = v1\n                    v1.append((2, a2))\n                    for v4 in a1[a2]:\n                        if v4 in a3:\n                            if a3[v4] == v2:\n                                continue\n                            return True\n                        v1.append((1, v4))\n                elif v2 == 2:\n                    a3[a2] = v2\n            return False\n        v3 = collections.defaultdict(lambda: [len(a1), len(a1[0]), -1, -1])\n        for v4, v5 in enumerate(a1):\n            for v6, v7 in enumerate(v5):\n                v3[v7][0] = min(v3[v7][0], v4)\n                v3[v7][1] = min(v3[v7][1], v6)\n                v3[v7][2] = max(v3[v7][2], v4)\n                v3[v7][3] = max(v3[v7][3], v6)\n        v8 = collections.defaultdict(set)\n        for v7, (v9, v10, v11, v12) in v3.items():\n            for v4 in range(v9, v11 + 1):\n                for v6 in range(v10, v12 + 1):\n                    if a1[v4][v6] != v7:\n                        v8[v7].add(a1[v4][v6])\n        v13 = {}\n        return all((v7 in v13 or not has_cycle(v8, v7, v13) for v7 in v3.keys()))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def isPrintable(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = list(range(2))\n\n        def has_cycle(a1, a2, a3):\n            v1 = [(1, a2)]\n            while v1:\n                v2, a2 = v1.pop()\n                if v2 == 1:\n                    a3[a2] = v1\n                    v1.append((2, a2))\n                    for v4 in a1[a2]:\n                        if v4 in a3:\n                            if a3[v4] == v2:\n                                continue\n                            return True\n                        v1.append((1, v4))\n                elif v2 == 2:\n                    a3[a2] = v2\n            return False\n        v3 = collections.defaultdict(lambda: [len(a1), len(a1[0]), -1, -1])\n        for v4, v5 in enumerate(a1):\n            for v6, v7 in enumerate(v5):\n                v3[v7][0] = min(v3[v7][0], v4)\n                v3[v7][1] = min(v3[v7][1], v6)\n                v3[v7][2] = max(v3[v7][2], v4)\n                v3[v7][3] = max(v3[v7][3], v6)\n        v8 = collections.defaultdict(set)\n        for v7, (v9, v10, v11, v12) in v3.items():\n            for v4 in range(v9, v11 + 1):\n                for v6 in range(v10, v12 + 1):\n                    if a1[v4][v6] != v7:\n                        v8[v7].add(a1[v4][v6])\n        v13 = {}\n        return all((v7 in v13 or not has_cycle(v8, v7, v13) for v7 in v3.keys()))\n"}
{"id": "llm_code\\intersection-of-two-linked-lists__grok-4.1-fast__v1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\nclass C2(object):\n\n    def getIntersectionNode(self, a1, a2):\n\n        def length(a1):\n            v1 = 0\n            v2 = a1\n            while v2:\n                v1 += 1\n                v2 = v2.next\n            return v1\n        v1 = length(a1)\n        v2 = length(a2)\n        v3 = a1\n        v4 = a2\n        if v1 > v2:\n            for v5 in range(v1 - v2):\n                v3 = v3.next\n        elif v2 > v1:\n            for v5 in range(v2 - v1):\n                v4 = v4.next\n        while v3 != v4:\n            v3 = v3.next\n            v4 = v4.next\n        return v3\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.next = None\n\nclass C2(object):\n\n    def getIntersectionNode(self, a1, a2):\n\n        def length(a1):\n            v1 = 0\n            v2 = a1\n            while v2:\n                v1 += 1\n                v2 = v2.next\n            return v1\n        v1 = length(a1)\n        v2 = length(a2)\n        v3 = a1\n        v4 = a2\n        if v1 > v2:\n            for v5 in range(v1 - v2):\n                v3 = v3.next\n        elif v2 > v1:\n            for v5 in range(v2 - v1):\n                v4 = v4.next\n        while v3 != v4:\n            v3 = v3.next\n            v4 = v4.next\n        return v3\n"}
{"id": "llm_code\\minimum-cost-to-buy-apples__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1(object):\n\n    def minCost(self, a1, a2, a3, a4):\n        v1 = a4 + 1\n        v2 = 10 ** 20\n        v3 = [[] for v4 in range(a1 + 1)]\n        for v5, v6, v7 in a2:\n            v8 = v5 - 1\n            v9 = v6 - 1\n            v10 = v7 * v1\n            v3[v8].append((v9, v10))\n            v3[v9].append((v8, v10))\n        v11 = a1\n        for v12 in range(a1):\n            v3[v11].append((v12, a3[v12]))\n        v13 = [v2] * (a1 + 1)\n        v13[v11] = 0\n        v14 = [(0, v11)]\n        while v14:\n            v15, v16 = heapq.heappop(v14)\n            if v15 > v13[v16]:\n                continue\n            for v17, v18 in v3[v16]:\n                v19 = v15 + v18\n                if v19 < v13[v17]:\n                    v13[v17] = v19\n                    heapq.heappush(v14, (v19, v17))\n        return v13[:a1]\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1(object):\n\n    def minCost(self, a1, a2, a3, a4):\n        v1 = a4 + 1\n        v2 = 10 ** 20\n        v3 = [[] for v4 in range(a1 + 1)]\n        for v5, v6, v7 in a2:\n            v8 = v5 - 1\n            v9 = v6 - 1\n            v10 = v7 * v1\n            v3[v8].append((v9, v10))\n            v3[v9].append((v8, v10))\n        v11 = a1\n        for v12 in range(a1):\n            v3[v11].append((v12, a3[v12]))\n        v13 = [v2] * (a1 + 1)\n        v13[v11] = 0\n        v14 = [(0, v11)]\n        while v14:\n            v15, v16 = heapq.heappop(v14)\n            if v15 > v13[v16]:\n                continue\n            for v17, v18 in v3[v16]:\n                v19 = v15 + v18\n                if v19 < v13[v17]:\n                    v13[v17] = v19\n                    heapq.heappush(v14, (v19, v17))\n        return v13[:a1]\n"}
{"id": "human_code\\maximum-segment-sum-after-removals__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(len(a1)))\n        self.rank = [0] * len(a1)\n        self.size = a1[:]\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        self.size[a2] += self.size[a1]\n        return True\n\n    def total(self, a1):\n        return self.size[self.find_set(a1)]\n\nclass C2(object):\n\n    def maximumSegmentSum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * len(a2)\n        v2 = [0] * len(a1)\n        v3 = C1(a1)\n        for v4 in reversed(range(1, len(a2))):\n            v5 = a2[v4]\n            v2[v5] = 1\n            if v5 - 1 >= 0 and v2[v5 - 1]:\n                v3.union_set(v5 - 1, v5)\n            if v5 + 1 < len(a1) and v2[v5 + 1]:\n                v3.union_set(v5, v5 + 1)\n            v1[v4 - 1] = max(v1[v4], v3.total(v5))\n        return v1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.set = list(range(len(a1)))\n        self.rank = [0] * len(a1)\n        self.size = a1[:]\n\n    def find_set(self, a1):\n        v1 = []\n        while self.set[a1] != a1:\n            v1.append(a1)\n            a1 = self.set[a1]\n        while v1:\n            self.set[v1.pop()] = a1\n        return a1\n\n    def union_set(self, a1, a2):\n        a1, a2 = (self.find_set(a1), self.find_set(a2))\n        if a1 == a2:\n            return False\n        if self.rank[a1] > self.rank[a2]:\n            a1, a2 = (a2, a1)\n        self.set[a1] = self.set[a2]\n        if self.rank[a1] == self.rank[a2]:\n            self.rank[a2] += 1\n        self.size[a2] += self.size[a1]\n        return True\n\n    def total(self, a1):\n        return self.size[self.find_set(a1)]\n\nclass C2(object):\n\n    def maximumSegmentSum(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = [0] * len(a2)\n        v2 = [0] * len(a1)\n        v3 = C1(a1)\n        for v4 in reversed(range(1, len(a2))):\n            v5 = a2[v4]\n            v2[v5] = 1\n            if v5 - 1 >= 0 and v2[v5 - 1]:\n                v3.union_set(v5 - 1, v5)\n            if v5 + 1 < len(a1) and v2[v5 + 1]:\n                v3.union_set(v5, v5 + 1)\n            v1[v4 - 1] = max(v1[v4], v3.total(v5))\n        return v1\n"}
{"id": "human_code\\diameter-of-binary-tree__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def diameterOfBinaryTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1):\n            v1 = 0\n            v2 = [(1, [a1, [0]])]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    a1, v6 = v4\n                    if not a1:\n                        continue\n                    v7, v8 = ([0], [0])\n                    v2.append((2, [a1, v7, v8, v6]))\n                    v2.append((1, [a1.right, v8]))\n                    v2.append((1, [a1.left, v7]))\n                elif v3 == 2:\n                    a1, v7, v8, v6 = v4\n                    v1 = max(v1, v7[0] + v8[0])\n                    v6[0] = 1 + max(v7[0], v8[0])\n            return v1\n        return iter_dfs(a1)\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1=0, a2=None, a3=None):\n        self.val = a1\n        self.left = a2\n        self.right = a3\n\nclass C2(object):\n\n    def diameterOfBinaryTree(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def iter_dfs(a1):\n            v1 = 0\n            v2 = [(1, [a1, [0]])]\n            while v2:\n                v3, v4 = v2.pop()\n                if v3 == 1:\n                    a1, v6 = v4\n                    if not a1:\n                        continue\n                    v7, v8 = ([0], [0])\n                    v2.append((2, [a1, v7, v8, v6]))\n                    v2.append((1, [a1.right, v8]))\n                    v2.append((1, [a1.left, v7]))\n                elif v3 == 2:\n                    a1, v7, v8, v6 = v4\n                    v1 = max(v1, v7[0] + v8[0])\n                    v6[0] = 1 + max(v7[0], v8[0])\n            return v1\n        return iter_dfs(a1)\n"}
{"id": "human_code\\closest-prime-numbers-in-range.py", "text": "import bisect\n\nclass C1(object):\n\n    def __init__(self, a1, a2, a3):\n        self.tree = [None] * (2 * 2 ** (a1 - 1).bit_length())\n        self.base = len(self.tree) // 2\n        self.query_fn = a3\n        for v1 in range(self.base, self.base + a1):\n            self.tree[v1] = a2(v1 - self.base)\n        for v1 in reversed(range(1, self.base)):\n            self.tree[v1] = a3(self.tree[2 * v1], self.tree[2 * v1 + 1])\n\n    def query(self, a1, a2):\n        a1 += self.base\n        a2 += self.base\n        v3 = v4 = None\n        while a1 <= a2:\n            if a1 & 1:\n                v3 = self.query_fn(v3, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v4 = self.query_fn(self.tree[a2], v4)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return self.query_fn(v3, v4)\n\ndef f2(a1):\n    v1 = []\n    v2 = [-1] * (a1 + 1)\n    for v3 in range(2, a1 + 1):\n        if v2[v3] == -1:\n            v2[v3] = v3\n            v1.append(v3)\n        for v4 in v1:\n            if v3 * v4 > a1 or v4 > v2[v3]:\n                break\n            v2[v3 * v4] = v4\n    return v1\nv1 = 10 ** 6\nv2 = f2(v1)\nv3 = C1(len(v2) - 1, build_fn=lambda i: [v2[i + 1] - v2[i], [v2[i], v2[i + 1]]], query_fn=lambda x, y: y if x is None else x if y is None else min(x, y))\n\nclass C2(object):\n\n    def closestPrimes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = bisect.bisect_left(v2, a1)\n        v2 = bisect.bisect_right(v2, a2) - 1\n        return v3.query(v1, v2 - 1)[1] if v1 <= v2 - 1 else [-1] * 2\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import bisect\n\nclass C1(object):\n\n    def __init__(self, a1, a2, a3):\n        self.tree = [None] * (2 * 2 ** (a1 - 1).bit_length())\n        self.base = len(self.tree) // 2\n        self.query_fn = a3\n        for v1 in range(self.base, self.base + a1):\n            self.tree[v1] = a2(v1 - self.base)\n        for v1 in reversed(range(1, self.base)):\n            self.tree[v1] = a3(self.tree[2 * v1], self.tree[2 * v1 + 1])\n\n    def query(self, a1, a2):\n        a1 += self.base\n        a2 += self.base\n        v3 = v4 = None\n        while a1 <= a2:\n            if a1 & 1:\n                v3 = self.query_fn(v3, self.tree[a1])\n                a1 += 1\n            if a2 & 1 == 0:\n                v4 = self.query_fn(self.tree[a2], v4)\n                a2 -= 1\n            a1 //= 2\n            a2 //= 2\n        return self.query_fn(v3, v4)\n\ndef f2(a1):\n    v1 = []\n    v2 = [-1] * (a1 + 1)\n    for v3 in range(2, a1 + 1):\n        if v2[v3] == -1:\n            v2[v3] = v3\n            v1.append(v3)\n        for v4 in v1:\n            if v3 * v4 > a1 or v4 > v2[v3]:\n                break\n            v2[v3 * v4] = v4\n    return v1\nv1 = 10 ** 6\nv2 = f2(v1)\nv3 = C1(len(v2) - 1, build_fn=lambda i: [v2[i + 1] - v2[i], [v2[i], v2[i + 1]]], query_fn=lambda x, y: y if x is None else x if y is None else min(x, y))\n\nclass C2(object):\n\n    def closestPrimes(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = bisect.bisect_left(v2, a1)\n        v2 = bisect.bisect_right(v2, a2) - 1\n        return v3.query(v1, v2 - 1)[1] if v1 <= v2 - 1 else [-1] * 2\n"}
{"id": "human_code\\p03096__s808975469.py", "text": "v1 = int(input())\nv2 = []\nfor v3 in range(v1):\n    v4 = int(input())\n    v2.append(v4)\nv5 = [0 for v3 in range(v1 + 1)]\nv5[0] = 1\nv6 = 10 ** 9 + 7\nv7 = [0 for v3 in range(2 * 10 ** 5 + 1)]\nfor v3 in range(v1):\n    v4 = v2[v3]\n    if v7[v4] == 0:\n        v5[v3 + 1] = v5[v3]\n        v7[v4] = v3 + 1\n        continue\n    elif v7[v4] != 0:\n        if v7[v4] == v3:\n            v7[v4] = v3 + 1\n            v5[v3 + 1] = v5[v3]\n        else:\n            v5[v3 + 1] = (v5[v3] + v5[v7[v4]]) % v6\n            v7[v4] = v3 + 1\nprint(v5[v1] % v6)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = []\nfor v3 in range(v1):\n    v4 = int(input())\n    v2.append(v4)\nv5 = [0 for v3 in range(v1 + 1)]\nv5[0] = 1\nv6 = 10 ** 9 + 7\nv7 = [0 for v3 in range(2 * 10 ** 5 + 1)]\nfor v3 in range(v1):\n    v4 = v2[v3]\n    if v7[v4] == 0:\n        v5[v3 + 1] = v5[v3]\n        v7[v4] = v3 + 1\n        continue\n    elif v7[v4] != 0:\n        if v7[v4] == v3:\n            v7[v4] = v3 + 1\n            v5[v3 + 1] = v5[v3]\n        else:\n            v5[v3 + 1] = (v5[v3] + v5[v7[v4]]) % v6\n            v7[v4] = v3 + 1\nprint(v5[v1] % v6)\n"}
{"id": "llm_code\\p02574__s297913014.py", "text": "def f1(a1, a2):\n    if a1 == 0:\n        return a2\n    return f1(a2 % a1, a1)\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 0\nv2.sort()\nfor v4 in v2:\n    v3 = f1(v3, v4)\nif v3 != 1:\n    print('not coprime')\n    exit()\nv5 = []\nv6 = [True] * 1100000\nv6[0] = v6[1] = False\nfor v7 in range(2, 1100000):\n    if not v6[v7]:\n        continue\n    for v8 in range(v7 * v7, 1100000, v7):\n        v6[v8] = False\n    v5.append(v7)\nv9 = [v4 for v4 in v2 if v6[v4]]\nv10 = [v4 for v4 in v2 if not v6[v4]]\nv5 = [p for v11 in range(1100) if v6[v11]]\nv12 = [False] * 1100000\nfor v4 in v9:\n    v12[v4] = True\nfor v13 in v10:\n    for v11 in v5:\n        if v13 == 1:\n            break\n        if v13 % v11 != 0:\n            continue\n        if v12[v11]:\n            print('setwise coprime')\n            exit()\n        v12[v11] = True\n        while v13 % v11 == 0:\n            v13 //= v11\n    if v13 > 1:\n        print('not coprime')\n        exit()\nprint('pairwise coprime')\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "def f1(a1, a2):\n    if a1 == 0:\n        return a2\n    return f1(a2 % a1, a1)\nv1 = int(input())\nv2 = list(map(int, input().split()))\nv3 = 0\nv2.sort()\nfor v4 in v2:\n    v3 = f1(v3, v4)\nif v3 != 1:\n    print('not coprime')\n    exit()\nv5 = []\nv6 = [True] * 1100000\nv6[0] = v6[1] = False\nfor v7 in range(2, 1100000):\n    if not v6[v7]:\n        continue\n    for v8 in range(v7 * v7, 1100000, v7):\n        v6[v8] = False\n    v5.append(v7)\nv9 = [v4 for v4 in v2 if v6[v4]]\nv10 = [v4 for v4 in v2 if not v6[v4]]\nv5 = [p for v11 in range(1100) if v6[v11]]\nv12 = [False] * 1100000\nfor v4 in v9:\n    v12[v4] = True\nfor v13 in v10:\n    for v11 in v5:\n        if v13 == 1:\n            break\n        if v13 % v11 != 0:\n            continue\n        if v12[v11]:\n            print('setwise coprime')\n            exit()\n        v12[v11] = True\n        while v13 % v11 == 0:\n            v13 //= v11\n    if v13 > 1:\n        print('not coprime')\n        exit()\nprint('pairwise coprime')\n"}
{"id": "human_code\\number-of-ways-of-cutting-a-pizza.py", "text": "class C1(object):\n\n    def ways(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = [[0] * len(a1[0]) for v3 in range(len(a1))]\n        for v4 in reversed(range(len(a1[0]))):\n            v5 = 0\n            for v6 in reversed(range(len(a1))):\n                v5 += int(a1[v6][v4] == 'A')\n                v2[v6][v4] = (v2[v6][v4 + 1] if v4 + 1 < len(a1[0]) else 0) + v5\n        v7 = [[[0] * a2 for v3 in range(len(a1[0]))] for v3 in range(len(a1))]\n        for v6 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[0]))):\n                v7[v6][v4][0] = 1\n                for v8 in range(1, a2):\n                    for v9 in range(v6 + 1, len(a1)):\n                        if v2[v6][v4] == v2[v9][v4]:\n                            continue\n                        if v2[v9][v4] == 0:\n                            break\n                        v7[v6][v4][v8] = (v7[v6][v4][v8] + v7[v9][v4][v8 - 1]) % v1\n                    for v9 in range(v4 + 1, len(a1[0])):\n                        if v2[v6][v4] == v2[v6][v9]:\n                            continue\n                        if v2[v6][v9] == 0:\n                            break\n                        v7[v6][v4][v8] = (v7[v6][v4][v8] + v7[v6][v9][v8 - 1]) % v1\n        return v7[0][0][a2 - 1]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def ways(self, a1, a2):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = [[0] * len(a1[0]) for v3 in range(len(a1))]\n        for v4 in reversed(range(len(a1[0]))):\n            v5 = 0\n            for v6 in reversed(range(len(a1))):\n                v5 += int(a1[v6][v4] == 'A')\n                v2[v6][v4] = (v2[v6][v4 + 1] if v4 + 1 < len(a1[0]) else 0) + v5\n        v7 = [[[0] * a2 for v3 in range(len(a1[0]))] for v3 in range(len(a1))]\n        for v6 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[0]))):\n                v7[v6][v4][0] = 1\n                for v8 in range(1, a2):\n                    for v9 in range(v6 + 1, len(a1)):\n                        if v2[v6][v4] == v2[v9][v4]:\n                            continue\n                        if v2[v9][v4] == 0:\n                            break\n                        v7[v6][v4][v8] = (v7[v6][v4][v8] + v7[v9][v4][v8 - 1]) % v1\n                    for v9 in range(v4 + 1, len(a1[0])):\n                        if v2[v6][v4] == v2[v6][v9]:\n                            continue\n                        if v2[v6][v9] == 0:\n                            break\n                        v7[v6][v4][v8] = (v7[v6][v4][v8] + v7[v6][v9][v8 - 1]) % v1\n        return v7[0][0][a2 - 1]\n"}
{"id": "human_code\\strings-differ-by-one-character.py", "text": "import collections\n\nclass C1(object):\n\n    def differByOne(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (10 ** 9 + 7, 113)\n        v3 = [0] * len(a1)\n        for v4, v5 in enumerate(a1):\n            for v6 in v5:\n                v3[v4] = (v2 * v3[v4] + (ord(v6) - ord('a'))) % v1\n        v7 = 1\n        for v8 in reversed(range(len(a1[0]))):\n            v9 = collections.defaultdict(list)\n            for v4, v5 in enumerate(a1):\n                v10 = (v3[v4] - v7 * (ord(v5[v8]) - ord('a'))) % v1\n                if v10 in v9:\n                    for v11 in v9[v10]:\n                        if a1[v11][:v8] + a1[v11][v8 + 1:] == v5[:v8] + v5[v8 + 1:]:\n                            return True\n                v9[v10].append(v4)\n            v7 = v2 * v7 % v1\n        return False\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def differByOne(self, a1):\n        \"\"\"\n        \"\"\"\n        v1, v2 = (10 ** 9 + 7, 113)\n        v3 = [0] * len(a1)\n        for v4, v5 in enumerate(a1):\n            for v6 in v5:\n                v3[v4] = (v2 * v3[v4] + (ord(v6) - ord('a'))) % v1\n        v7 = 1\n        for v8 in reversed(range(len(a1[0]))):\n            v9 = collections.defaultdict(list)\n            for v4, v5 in enumerate(a1):\n                v10 = (v3[v4] - v7 * (ord(v5[v8]) - ord('a'))) % v1\n                if v10 in v9:\n                    for v11 in v9[v10]:\n                        if a1[v11][:v8] + a1[v11][v8 + 1:] == v5[:v8] + v5[v8 + 1:]:\n                            return True\n                v9[v10].append(v4)\n            v7 = v2 * v7 % v1\n        return False\n"}
{"id": "human_code\\insert-delete-getrandom-o1-duplicates-allowed.py", "text": "from random import randint\nfrom collections import defaultdict\n\nclass C1(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__list = []\n        self.__used = defaultdict(list)\n\n    def insert(self, a1):\n        \"\"\"\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n        \"\"\"\n        v1 = a1 in self.__used\n        self.__list += ((a1, len(self.__used[a1])),)\n        self.__used[a1] += (len(self.__list) - 1,)\n        return not v1\n\n    def remove(self, a1):\n        \"\"\"\n        Removes a value from the collection. Returns true if the collection contained the specified element.\n        \"\"\"\n        if a1 not in self.__used:\n            return False\n        self.__used[self.__list[-1][0]][self.__list[-1][1]] = self.__used[a1][-1]\n        self.__list[self.__used[a1][-1]], self.__list[-1] = (self.__list[-1], self.__list[self.__used[a1][-1]])\n        self.__used[a1].pop()\n        if not self.__used[a1]:\n            self.__used.pop(a1)\n        self.__list.pop()\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the collection.\n        \"\"\"\n        return self.__list[randint(0, len(self.__list) - 1)][0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "from random import randint\nfrom collections import defaultdict\n\nclass C1(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.__list = []\n        self.__used = defaultdict(list)\n\n    def insert(self, a1):\n        \"\"\"\n        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.\n        \"\"\"\n        v1 = a1 in self.__used\n        self.__list += ((a1, len(self.__used[a1])),)\n        self.__used[a1] += (len(self.__list) - 1,)\n        return not v1\n\n    def remove(self, a1):\n        \"\"\"\n        Removes a value from the collection. Returns true if the collection contained the specified element.\n        \"\"\"\n        if a1 not in self.__used:\n            return False\n        self.__used[self.__list[-1][0]][self.__list[-1][1]] = self.__used[a1][-1]\n        self.__list[self.__used[a1][-1]], self.__list[-1] = (self.__list[-1], self.__list[self.__used[a1][-1]])\n        self.__used[a1].pop()\n        if not self.__used[a1]:\n            self.__used.pop(a1)\n        self.__list.pop()\n        return True\n\n    def getRandom(self):\n        \"\"\"\n        Get a random element from the collection.\n        \"\"\"\n        return self.__list[randint(0, len(self.__list) - 1)][0]\n"}
{"id": "llm_code\\p03007__s621625661.py", "text": "v1 = int(input())\nv2 = sorted(list(map(int, input().split())))\nv3 = []\nv4 = []\nfor v5 in v2:\n    if v5 >= 0:\n        v3.append(v5)\n    else:\n        v4.append(v5)\nv4.reverse()\nv6 = []\nwhile len(v3) > 0 and len(v4) > 0:\n    if v3[-1] > abs(v4[-1]):\n        v6.append((v3.pop(), v4.pop()))\n    else:\n        v6.append((v4.pop(), v3.pop()))\nwhile len(v3) > 1:\n    v6.append((v3.pop(), v3.pop()))\nwhile len(v4) > 1:\n    v6.append((v4.pop(), v4.pop()))\nprint(v6[-1][1] - v6[-1][0])\nfor v7 in range(v1 - 2):\n    print(v6[v7][0], v6[v7][1])\nprint(v6[-1][1], v6[-1][0])\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = int(input())\nv2 = sorted(list(map(int, input().split())))\nv3 = []\nv4 = []\nfor v5 in v2:\n    if v5 >= 0:\n        v3.append(v5)\n    else:\n        v4.append(v5)\nv4.reverse()\nv6 = []\nwhile len(v3) > 0 and len(v4) > 0:\n    if v3[-1] > abs(v4[-1]):\n        v6.append((v3.pop(), v4.pop()))\n    else:\n        v6.append((v4.pop(), v3.pop()))\nwhile len(v3) > 1:\n    v6.append((v3.pop(), v3.pop()))\nwhile len(v4) > 1:\n    v6.append((v4.pop(), v4.pop()))\nprint(v6[-1][1] - v6[-1][0])\nfor v7 in range(v1 - 2):\n    print(v6[v7][0], v6[v7][1])\nprint(v6[-1][1], v6[-1][0])\n"}
{"id": "llm_code\\minimum-operations-to-convert-number__grok-4.1-fast__v1.py", "text": "from collections import deque\n\nclass C1:\n\n    def minimumOperations(self, a1, a2, a3):\n        if a2 == a3:\n            return 0\n        v1 = 1000\n        v2 = [-1] * (v1 + 1)\n        v2[a2] = 0\n        v3 = deque([a2])\n        v4 = list({num for v5 in a1 if v5})\n        while v3:\n            v6 = v3.popleft()\n            v7 = v2[v6]\n            for v5 in v4:\n                v8 = [v6 + v5, v6 - v5, v6 ^ v5]\n                for v9 in v8:\n                    if 0 <= v9 <= v1 and v2[v9] == -1:\n                        v2[v9] = v7 + 1\n                        if v9 == a3:\n                            return v7 + 1\n                        v3.append(v9)\n        return -1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "from collections import deque\n\nclass C1:\n\n    def minimumOperations(self, a1, a2, a3):\n        if a2 == a3:\n            return 0\n        v1 = 1000\n        v2 = [-1] * (v1 + 1)\n        v2[a2] = 0\n        v3 = deque([a2])\n        v4 = list({num for v5 in a1 if v5})\n        while v3:\n            v6 = v3.popleft()\n            v7 = v2[v6]\n            for v5 in v4:\n                v8 = [v6 + v5, v6 - v5, v6 ^ v5]\n                for v9 in v8:\n                    if 0 <= v9 <= v1 and v2[v9] == -1:\n                        v2[v9] = v7 + 1\n                        if v9 == a3:\n                            return v7 + 1\n                        v3.append(v9)\n        return -1\n"}
{"id": "human_code\\symmetric-tree__part1.py", "text": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def isSymmetric(self, a1):\n        if a1 is None:\n            return True\n        v1 = []\n        v1.append(a1.left)\n        v1.append(a1.right)\n        while v1:\n            v2, v3 = (v1.pop(), v1.pop())\n            if v2 is None and v3 is None:\n                continue\n            if v2 is None or v3 is None or v2.val != v3.val:\n                return False\n            v1.append(v2.left)\n            v1.append(v3.right)\n            v1.append(v2.right)\n            v1.append(v3.left)\n        return True\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def __init__(self, a1):\n        self.val = a1\n        self.left = None\n        self.right = None\n\nclass C2(object):\n\n    def isSymmetric(self, a1):\n        if a1 is None:\n            return True\n        v1 = []\n        v1.append(a1.left)\n        v1.append(a1.right)\n        while v1:\n            v2, v3 = (v1.pop(), v1.pop())\n            if v2 is None and v3 is None:\n                continue\n            if v2 is None or v3 is None or v2.val != v3.val:\n                return False\n            v1.append(v2.left)\n            v1.append(v3.right)\n            v1.append(v2.right)\n            v1.append(v3.left)\n        return True\n"}
{"id": "llm_code\\minimum-cost-to-separate-sentence-into-rows__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minimumCost(self, a1, a2):\n        v1 = a1.split()\n        if not v1:\n            return 0\n        v2 = [len(w) for v3 in v1]\n        v4 = len(v2)\n        v5 = [float('inf')] * (v4 + 1)\n        v5[0] = 0\n        for v6 in range(1, v4 + 1):\n            v5[v6] = float('inf')\n            v7 = 0\n            for v8 in range(v6 - 1, -1, -1):\n                v7 += v2[v8]\n                if v8 < v6 - 1:\n                    v7 += 1\n                if v7 > a2:\n                    break\n                v9 = (a2 - v7) ** 2\n                v5[v6] = min(v5[v6], v5[v8] + v9)\n        v10 = float('inf')\n        v7 = 0\n        for v8 in range(v4 - 1, -1, -1):\n            v7 += v2[v8]\n            if v8 < v4 - 1:\n                v7 += 1\n            if v7 > a2:\n                break\n            v10 = min(v10, v5[v8])\n        return int(v10)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minimumCost(self, a1, a2):\n        v1 = a1.split()\n        if not v1:\n            return 0\n        v2 = [len(w) for v3 in v1]\n        v4 = len(v2)\n        v5 = [float('inf')] * (v4 + 1)\n        v5[0] = 0\n        for v6 in range(1, v4 + 1):\n            v5[v6] = float('inf')\n            v7 = 0\n            for v8 in range(v6 - 1, -1, -1):\n                v7 += v2[v8]\n                if v8 < v6 - 1:\n                    v7 += 1\n                if v7 > a2:\n                    break\n                v9 = (a2 - v7) ** 2\n                v5[v6] = min(v5[v6], v5[v8] + v9)\n        v10 = float('inf')\n        v7 = 0\n        for v8 in range(v4 - 1, -1, -1):\n            v7 += v2[v8]\n            if v8 < v4 - 1:\n                v7 += 1\n            if v7 > a2:\n                break\n            v10 = min(v10, v5[v8])\n        return int(v10)\n"}
{"id": "llm_code\\p03290__s596942557.py", "text": "from itertools import product\nv1, v2 = map(int, input().split())\nv3, v4 = zip(*[map(int, input().split()) for v5 in range(v1)])\nv6 = 10 ** 18\nv7 = v6\nfor v8 in product((0, 1), repeat=v1):\n    v9 = list(v3)\n    v10 = 0\n    v11 = 0\n    for v12 in range(v1):\n        if v8[v12]:\n            v11 += v4[v12]\n            v11 += v3[v12] * 100 * (v12 + 1)\n            v10 += v3[v12]\n            v9[v12] = 0\n        if v11 + sum((v9[v12] * 100 * (v12 + 1) for v12 in range(v1))) < v2:\n            continue\n    v13 = v1 - 1\n    while v11 < v2:\n        while not v9[v13]:\n            v13 -= 1\n        v11 += 100 * (v13 + 1)\n        v9[v13] -= 1\n        v10 += 1\n    if v10 < v7:\n        v7 = v10\nprint(v7)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "from itertools import product\nv1, v2 = map(int, input().split())\nv3, v4 = zip(*[map(int, input().split()) for v5 in range(v1)])\nv6 = 10 ** 18\nv7 = v6\nfor v8 in product((0, 1), repeat=v1):\n    v9 = list(v3)\n    v10 = 0\n    v11 = 0\n    for v12 in range(v1):\n        if v8[v12]:\n            v11 += v4[v12]\n            v11 += v3[v12] * 100 * (v12 + 1)\n            v10 += v3[v12]\n            v9[v12] = 0\n        if v11 + sum((v9[v12] * 100 * (v12 + 1) for v12 in range(v1))) < v2:\n            continue\n    v13 = v1 - 1\n    while v11 < v2:\n        while not v9[v13]:\n            v13 -= 1\n        v11 += 100 * (v13 + 1)\n        v9[v13] -= 1\n        v10 += 1\n    if v10 < v7:\n        v7 = v10\nprint(v7)\n"}
{"id": "llm_code\\minimizing-array-after-replacing-pairs-with-their-product__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def minArrayLength(self, a1, a2):\n        v1 = len(a1)\n        v2 = False\n        for v3 in a1:\n            if v3 == 0:\n                v2 = True\n                break\n        if v2:\n            return 1\n        v4 = 1\n        v5 = a1[0]\n        v6 = 1\n        while v6 < v1:\n            if v5 * a1[v6] <= a2:\n                v5 *= a1[v6]\n            else:\n                v4 += 1\n                v5 = a1[v6]\n            v6 += 1\n        return v4\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def minArrayLength(self, a1, a2):\n        v1 = len(a1)\n        v2 = False\n        for v3 in a1:\n            if v3 == 0:\n                v2 = True\n                break\n        if v2:\n            return 1\n        v4 = 1\n        v5 = a1[0]\n        v6 = 1\n        while v6 < v1:\n            if v5 * a1[v6] <= a2:\n                v5 *= a1[v6]\n            else:\n                v4 += 1\n                v5 = a1[v6]\n            v6 += 1\n        return v4\n"}
{"id": "human_code\\find-the-string-with-lcp.py", "text": "class C1(object):\n\n    def findTheString(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [-1] * len(a1)\n        v2 = 0\n        for v3 in range(len(a1)):\n            if v1[v3] != -1:\n                continue\n            if v2 == 26:\n                return ''\n            for v4 in range(v3, len(a1[0])):\n                if a1[v3][v4]:\n                    v1[v4] = v2\n            v2 += 1\n        for v3 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[0]))):\n                if a1[v3][v4] != ((a1[v3 + 1][v4 + 1] + 1 if v3 + 1 < len(a1) and v4 + 1 < len(a1[0]) else 1) if v1[v3] == v1[v4] else 0):\n                    return ''\n        return ''.join([chr(ord('a') + x) for v5 in v1])\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def findTheString(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [-1] * len(a1)\n        v2 = 0\n        for v3 in range(len(a1)):\n            if v1[v3] != -1:\n                continue\n            if v2 == 26:\n                return ''\n            for v4 in range(v3, len(a1[0])):\n                if a1[v3][v4]:\n                    v1[v4] = v2\n            v2 += 1\n        for v3 in reversed(range(len(a1))):\n            for v4 in reversed(range(len(a1[0]))):\n                if a1[v3][v4] != ((a1[v3 + 1][v4 + 1] + 1 if v3 + 1 < len(a1) and v4 + 1 < len(a1[0]) else 1) if v1[v3] == v1[v4] else 0):\n                    return ''\n        return ''.join([chr(ord('a') + x) for v5 in v1])\n"}
{"id": "llm_code\\smallest-number-in-infinite-set__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def __init__(self):\n        self.frontier = 1\n        self.minheap = []\n        self.tracked = set()\n\n    def popSmallest(self):\n        if self.minheap:\n            v1 = heapq.heappop(self.minheap)\n            self.tracked.remove(v1)\n            return v1\n        else:\n            v1 = self.frontier\n            self.frontier += 1\n            return v1\n\n    def addBack(self, a1):\n        if a1 < self.frontier:\n            if a1 not in self.tracked:\n                self.tracked.add(a1)\n                heapq.heappush(self.minheap, a1)\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def __init__(self):\n        self.frontier = 1\n        self.minheap = []\n        self.tracked = set()\n\n    def popSmallest(self):\n        if self.minheap:\n            v1 = heapq.heappop(self.minheap)\n            self.tracked.remove(v1)\n            return v1\n        else:\n            v1 = self.frontier\n            self.frontier += 1\n            return v1\n\n    def addBack(self, a1):\n        if a1 < self.frontier:\n            if a1 not in self.tracked:\n                self.tracked.add(a1)\n                heapq.heappush(self.minheap, a1)\n"}
{"id": "llm_code\\4sum__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def fourSum(self, a1, a2):\n        a1.sort()\n        v1 = []\n        v2 = len(a1)\n        for v3 in range(v2 - 3):\n            if v3 > 0 and a1[v3] == a1[v3 - 1]:\n                continue\n            for v4 in range(v3 + 1, v2 - 2):\n                if v4 > v3 + 1 and a1[v4] == a1[v4 - 1]:\n                    continue\n                v5 = a2 - a1[v3] - a1[v4]\n                v6 = v4 + 1\n                v7 = v2 - 1\n                while v6 < v7:\n                    v8 = a1[v6] + a1[v7]\n                    if v8 == v5:\n                        v1.append([a1[v3], a1[v4], a1[v6], a1[v7]])\n                        v6 += 1\n                        v7 -= 1\n                        while v6 < v7 and a1[v6] == a1[v6 - 1]:\n                            v6 += 1\n                        while v6 < v7 and a1[v7] == a1[v7 + 1]:\n                            v7 -= 1\n                    elif v8 < v5:\n                        v6 += 1\n                    else:\n                        v7 -= 1\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def fourSum(self, a1, a2):\n        a1.sort()\n        v1 = []\n        v2 = len(a1)\n        for v3 in range(v2 - 3):\n            if v3 > 0 and a1[v3] == a1[v3 - 1]:\n                continue\n            for v4 in range(v3 + 1, v2 - 2):\n                if v4 > v3 + 1 and a1[v4] == a1[v4 - 1]:\n                    continue\n                v5 = a2 - a1[v3] - a1[v4]\n                v6 = v4 + 1\n                v7 = v2 - 1\n                while v6 < v7:\n                    v8 = a1[v6] + a1[v7]\n                    if v8 == v5:\n                        v1.append([a1[v3], a1[v4], a1[v6], a1[v7]])\n                        v6 += 1\n                        v7 -= 1\n                        while v6 < v7 and a1[v6] == a1[v6 - 1]:\n                            v6 += 1\n                        while v6 < v7 and a1[v7] == a1[v7 + 1]:\n                            v7 -= 1\n                    elif v8 < v5:\n                        v6 += 1\n                    else:\n                        v7 -= 1\n        return v1\n"}
{"id": "llm_code\\maximum-number-of-events-that-can-be-attended__grok-4.1-fast__v1.py", "text": "import heapq\n\nclass C1:\n\n    def maxEvents(self, a1):\n        a1.sort(key=lambda x: x[0])\n        v1 = []\n        v2 = 0\n        v3 = 1\n        v4 = 0\n        v5 = max((x[1] for v6 in a1))\n        v7 = len(a1)\n        while v3 <= v5:\n            while v4 < v7 and a1[v4][0] <= v3:\n                heapq.heappush(v1, a1[v4][1])\n                v4 += 1\n            while v1 and v1[0] < v3:\n                heapq.heappop(v1)\n            if v1:\n                heapq.heappop(v1)\n                v2 += 1\n            v3 += 1\n        return v2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import heapq\n\nclass C1:\n\n    def maxEvents(self, a1):\n        a1.sort(key=lambda x: x[0])\n        v1 = []\n        v2 = 0\n        v3 = 1\n        v4 = 0\n        v5 = max((x[1] for v6 in a1))\n        v7 = len(a1)\n        while v3 <= v5:\n            while v4 < v7 and a1[v4][0] <= v3:\n                heapq.heappush(v1, a1[v4][1])\n                v4 += 1\n            while v1 and v1[0] < v3:\n                heapq.heappop(v1)\n            if v1:\n                heapq.heappop(v1)\n                v2 += 1\n            v3 += 1\n        return v2\n"}
{"id": "human_code\\longest-duplicate-substring.py", "text": "import collections\nfrom functools import reduce\n\nclass C1(object):\n\n    def longestDupSubstring(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = 26\n\n        def check(a1, a2):\n            v1 = pow(v2, a2, v1)\n            v2 = reduce(lambda x, y: (v2 * x + ord(y) - ord('a')) % v1, a1[:a2], 0)\n            v3 = collections.defaultdict(list)\n            v3[v2].append(a2 - 1)\n            for v4 in range(a2, len(a1)):\n                v2 = (v2 * v2 % v1 + ord(a1[v4]) - ord('a') - (ord(a1[v4 - a2]) - ord('a')) * v1 % v1) % v1\n                if v2 in v3:\n                    for v5 in v3[v2]:\n                        if a1[v5 - a2 + 1:v5 + 1] == a1[v4 - a2 + 1:v4 + 1]:\n                            return v4 - a2 + 1\n                v3[v2].append(v4)\n            return 0\n        v3, v4 = (1, len(a1) - 1)\n        while v3 <= v4:\n            v5 = v3 + (v4 - v3) // 2\n            if not check(a1, v5):\n                v4 = v5 - 1\n            else:\n                v3 = v5 + 1\n        v6 = check(a1, v4)\n        return a1[v6:v6 + v4]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\nfrom functools import reduce\n\nclass C1(object):\n\n    def longestDupSubstring(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = 26\n\n        def check(a1, a2):\n            v1 = pow(v2, a2, v1)\n            v2 = reduce(lambda x, y: (v2 * x + ord(y) - ord('a')) % v1, a1[:a2], 0)\n            v3 = collections.defaultdict(list)\n            v3[v2].append(a2 - 1)\n            for v4 in range(a2, len(a1)):\n                v2 = (v2 * v2 % v1 + ord(a1[v4]) - ord('a') - (ord(a1[v4 - a2]) - ord('a')) * v1 % v1) % v1\n                if v2 in v3:\n                    for v5 in v3[v2]:\n                        if a1[v5 - a2 + 1:v5 + 1] == a1[v4 - a2 + 1:v4 + 1]:\n                            return v4 - a2 + 1\n                v3[v2].append(v4)\n            return 0\n        v3, v4 = (1, len(a1) - 1)\n        while v3 <= v4:\n            v5 = v3 + (v4 - v3) // 2\n            if not check(a1, v5):\n                v4 = v5 - 1\n            else:\n                v3 = v5 + 1\n        v6 = check(a1, v4)\n        return a1[v6:v6 + v4]\n"}
{"id": "llm_code\\p03291__s312401701.py", "text": "v1 = dict()\nv1['A'] = []\nv1['B'] = []\nv1['C'] = []\nv1['?'] = []\nv2 = input()\nfor v3 in range(0, len(v2)):\n    v4 = v2[v3]\n    v1[v4].append(v3)\nv5 = 0\nv6 = [0] * 4\nv7 = 10 ** 9 + 7\nv6[0] = 1\nfor v8 in v2:\n    if v8 == '?':\n        for v3 in range(3, 0, -1):\n            v6[v3] = (v6[v3] * 3 + v6[v3 - 1]) % v7\n        v6[0] = v6[0] * 3 % v7\n    elif v8 == 'A':\n        v6[1] = (v6[1] + v6[0]) % v7\n    elif v8 == 'B':\n        v6[2] = (v6[2] + v6[1]) % v7\n    elif v8 == 'C':\n        v6[3] = (v6[3] + v6[2]) % v7\nprint(v6[3] % v7)\n", "label": 1, "source": "aigcodeset", "problem_id": "", "code": "v1 = dict()\nv1['A'] = []\nv1['B'] = []\nv1['C'] = []\nv1['?'] = []\nv2 = input()\nfor v3 in range(0, len(v2)):\n    v4 = v2[v3]\n    v1[v4].append(v3)\nv5 = 0\nv6 = [0] * 4\nv7 = 10 ** 9 + 7\nv6[0] = 1\nfor v8 in v2:\n    if v8 == '?':\n        for v3 in range(3, 0, -1):\n            v6[v3] = (v6[v3] * 3 + v6[v3 - 1]) % v7\n        v6[0] = v6[0] * 3 % v7\n    elif v8 == 'A':\n        v6[1] = (v6[1] + v6[0]) % v7\n    elif v8 == 'B':\n        v6[2] = (v6[2] + v6[1]) % v7\n    elif v8 == 'C':\n        v6[3] = (v6[3] + v6[2]) % v7\nprint(v6[3] % v7)\n"}
{"id": "llm_code\\strings-differ-by-one-character__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def differByOne(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = 131\n        v3 = len(a1)\n        if v3 < 2:\n            return False\n        v4 = len(a1[0])\n        v5 = [1] * (v4 + 1)\n        for v6 in range(1, v4 + 1):\n            v5[v6] = v5[v6 - 1] * v2 % v1\n        v7 = []\n        for v8 in a1:\n            v9 = [0] * (v4 + 1)\n            for v10 in range(v4):\n                v9[v10 + 1] = (v9[v10] * v2 + (ord(v8[v10]) - ord('a'))) % v1\n            v7.append(v9)\n        for v11 in range(v4):\n            v12 = {}\n            for v13 in range(v3):\n                v14 = v7[v13][v11]\n                v15 = v4 - v11 - 1\n                v16 = v7[v13][v11 + 1] * v5[v15] % v1\n                v17 = (v7[v13][v4] - v16 + v1) % v1\n                v18 = (v14 * v5[v15] % v1 + v17) % v1\n                if v18 in v12:\n                    for v19 in v12[v18]:\n                        v20 = a1[v19][:v11] + a1[v19][v11 + 1:]\n                        v21 = a1[v13][:v11] + a1[v13][v11 + 1:]\n                        if v20 == v21:\n                            return True\n                v12.setdefault(v18, []).append(v13)\n        return False\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def differByOne(self, a1):\n        v1 = 10 ** 9 + 7\n        v2 = 131\n        v3 = len(a1)\n        if v3 < 2:\n            return False\n        v4 = len(a1[0])\n        v5 = [1] * (v4 + 1)\n        for v6 in range(1, v4 + 1):\n            v5[v6] = v5[v6 - 1] * v2 % v1\n        v7 = []\n        for v8 in a1:\n            v9 = [0] * (v4 + 1)\n            for v10 in range(v4):\n                v9[v10 + 1] = (v9[v10] * v2 + (ord(v8[v10]) - ord('a'))) % v1\n            v7.append(v9)\n        for v11 in range(v4):\n            v12 = {}\n            for v13 in range(v3):\n                v14 = v7[v13][v11]\n                v15 = v4 - v11 - 1\n                v16 = v7[v13][v11 + 1] * v5[v15] % v1\n                v17 = (v7[v13][v4] - v16 + v1) % v1\n                v18 = (v14 * v5[v15] % v1 + v17) % v1\n                if v18 in v12:\n                    for v19 in v12[v18]:\n                        v20 = a1[v19][:v11] + a1[v19][v11 + 1:]\n                        v21 = a1[v13][:v11] + a1[v13][v11 + 1:]\n                        if v20 == v21:\n                            return True\n                v12.setdefault(v18, []).append(v13)\n        return False\n"}
{"id": "human_code\\p02901__s655723565.py", "text": "import sys\n\ndef f1(a1, a2, a3, a4, a5):\n    v1 = []\n    for v2 in range(a2):\n        v3 = 0\n        for v4 in range(a4[v2]):\n            v3 |= 1 << a5[v2][v4] - 1\n        v1.append([v3, a3[v2]])\n    v5 = 1001001001\n    v6 = [v5] * (1 << a1)\n    v6[0] = 0\n    for v3 in range(1 << a1):\n        for v2 in range(a2):\n            v7 = v3 | v1[v2][0]\n            v8 = v6[v3] + v1[v2][1]\n            v6[v7] = min(v6[v7], v8)\n    v9 = v6[-1]\n    print(-1 if v9 == v5 else v9)\n    pass\n\ndef f2():\n\n    def iterate_tokens():\n        for v1 in sys.stdin:\n            for v2 in v1.split():\n                yield v2\n    v1 = iterate_tokens()\n    v2 = int(next(v1))\n    v3 = int(next(v1))\n    v4, v5, v6 = ([], [], [])\n    for v7 in range(v3):\n        v4.append(int(next(v1)))\n        v5.append(int(next(v1)))\n        v6.append([int(next(v1)) for v7 in range(v5[-1])])\n    f1(v2, v3, v4, v5, v6)\nif __name__ == '__main__':\n    f2()\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import sys\n\ndef f1(a1, a2, a3, a4, a5):\n    v1 = []\n    for v2 in range(a2):\n        v3 = 0\n        for v4 in range(a4[v2]):\n            v3 |= 1 << a5[v2][v4] - 1\n        v1.append([v3, a3[v2]])\n    v5 = 1001001001\n    v6 = [v5] * (1 << a1)\n    v6[0] = 0\n    for v3 in range(1 << a1):\n        for v2 in range(a2):\n            v7 = v3 | v1[v2][0]\n            v8 = v6[v3] + v1[v2][1]\n            v6[v7] = min(v6[v7], v8)\n    v9 = v6[-1]\n    print(-1 if v9 == v5 else v9)\n    pass\n\ndef f2():\n\n    def iterate_tokens():\n        for v1 in sys.stdin:\n            for v2 in v1.split():\n                yield v2\n    v1 = iterate_tokens()\n    v2 = int(next(v1))\n    v3 = int(next(v1))\n    v4, v5, v6 = ([], [], [])\n    for v7 in range(v3):\n        v4.append(int(next(v1)))\n        v5.append(int(next(v1)))\n        v6.append([int(next(v1)) for v7 in range(v5[-1])])\n    f1(v2, v3, v4, v5, v6)\nif __name__ == '__main__':\n    f2()\n"}
{"id": "human_code\\p03013__s821255437.py", "text": "import math\nfrom collections import deque\nv1 = deque([1, 2])\nv2 = 1\n\ndef f1(a1):\n    global memo, floor\n    while a1 > v2:\n        v1.append(v1[-1] + v1[-2])\n        v1 += 1\n    return v1[a1 - 1]\nv3 = 1000000007\nv4, v5 = map(int, input().split())\nv6 = []\nv7 = -1\nfor v8 in range(v5):\n    v9 = int(input())\n    if v7 + 1 == v9:\n        print(0)\n        exit()\n    v6.append(v9 - v7 - 2)\n    v7 = v9\nv6.append(v4 - v7 - 1)\nv10 = 1\nfor v11 in v6:\n    if v11 == 0:\n        continue\n    v10 = v10 * f1(v11) % v3\nprint(v10)\n", "label": 0, "source": "aigcodeset", "problem_id": "", "code": "import math\nfrom collections import deque\nv1 = deque([1, 2])\nv2 = 1\n\ndef f1(a1):\n    global memo, floor\n    while a1 > v2:\n        v1.append(v1[-1] + v1[-2])\n        v1 += 1\n    return v1[a1 - 1]\nv3 = 1000000007\nv4, v5 = map(int, input().split())\nv6 = []\nv7 = -1\nfor v8 in range(v5):\n    v9 = int(input())\n    if v7 + 1 == v9:\n        print(0)\n        exit()\n    v6.append(v9 - v7 - 2)\n    v7 = v9\nv6.append(v4 - v7 - 1)\nv10 = 1\nfor v11 in v6:\n    if v11 == 0:\n        continue\n    v10 = v10 * f1(v11) % v3\nprint(v10)\n"}
{"id": "human_code\\balance-a-binary-search-tree__part2.py", "text": "class C1(object):\n\n    def balanceBST(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def inorderTraversalHelper(a1, a2):\n            if not a1:\n                return\n            inorderTraversalHelper(a1.left, a2)\n            a2.append(a1.val)\n            inorderTraversalHelper(a1.right, a2)\n\n        def sortedArrayToBstHelper(a1, a2, a3):\n            if a2 >= a3:\n                return None\n            v1 = a2 + (a3 - a2) // 2\n            v2 = TreeNode(a1[v1])\n            v2.left = sortedArrayToBstHelper(a1, a2, v1)\n            v2.right = sortedArrayToBstHelper(a1, v1 + 1, a3)\n            return v2\n        v1 = []\n        inorderTraversalHelper(a1, v1)\n        return sortedArrayToBstHelper(v1, 0, len(v1))\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def balanceBST(self, a1):\n        \"\"\"\n        \"\"\"\n\n        def inorderTraversalHelper(a1, a2):\n            if not a1:\n                return\n            inorderTraversalHelper(a1.left, a2)\n            a2.append(a1.val)\n            inorderTraversalHelper(a1.right, a2)\n\n        def sortedArrayToBstHelper(a1, a2, a3):\n            if a2 >= a3:\n                return None\n            v1 = a2 + (a3 - a2) // 2\n            v2 = TreeNode(a1[v1])\n            v2.left = sortedArrayToBstHelper(a1, a2, v1)\n            v2.right = sortedArrayToBstHelper(a1, v1 + 1, a3)\n            return v2\n        v1 = []\n        inorderTraversalHelper(a1, v1)\n        return sortedArrayToBstHelper(v1, 0, len(v1))\n"}
{"id": "human_code\\minimum-time-to-collect-all-apples-in-a-tree__part1.py", "text": "import collections\n\nclass C1(object):\n\n    def minTime(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = [0, 0]\n        v5 = [(1, (-1, 0, v4))]\n        while v5:\n            v6, v7 = v5.pop()\n            if v6 == 1:\n                v8, v9, v10 = v7\n                v10[:] = [0, int(a3[v9])]\n                for v11 in reversed(v1[v9]):\n                    if v11 == v8:\n                        continue\n                    v12 = [0, 0]\n                    v5.append((2, (v12, v10)))\n                    v5.append((1, (v9, v11, v12)))\n            else:\n                v12, v10 = v7\n                v10[0] += v12[0] + v12[1]\n                v10[1] |= bool(v12[0] + v12[1])\n        return 2 * v4[0]\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1(object):\n\n    def minTime(self, a1, a2, a3):\n        \"\"\"\n        \"\"\"\n        v1 = collections.defaultdict(list)\n        for v2, v3 in a2:\n            v1[v2].append(v3)\n            v1[v3].append(v2)\n        v4 = [0, 0]\n        v5 = [(1, (-1, 0, v4))]\n        while v5:\n            v6, v7 = v5.pop()\n            if v6 == 1:\n                v8, v9, v10 = v7\n                v10[:] = [0, int(a3[v9])]\n                for v11 in reversed(v1[v9]):\n                    if v11 == v8:\n                        continue\n                    v12 = [0, 0]\n                    v5.append((2, (v12, v10)))\n                    v5.append((1, (v9, v11, v12)))\n            else:\n                v12, v10 = v7\n                v10[0] += v12[0] + v12[1]\n                v10[1] |= bool(v12[0] + v12[1])\n        return 2 * v4[0]\n"}
{"id": "llm_code\\maximum-length-of-subarray-with-positive-product__grok-4.1-fast__v1.py", "text": "class C1:\n\n    def getMaxLen(self, a1):\n        v1 = 0\n        v2 = 0\n        v3 = len(a1)\n        while v2 < v3:\n            if a1[v2] == 0:\n                v2 += 1\n                continue\n            v4 = v2\n            while v4 < v3 and a1[v4] != 0:\n                v4 += 1\n            v4 -= 1\n            v5 = 0\n            v6 = -1\n            for v7 in range(v2, v4 + 1):\n                if a1[v7] < 0:\n                    v5 += 1\n                    if v6 == -1:\n                        v6 = v7\n            v8 = v4 - v2 + 1\n            if v5 % 2 == 0:\n                v1 = max(v1, v8)\n            elif v6 != -1:\n                v1 = max(v1, v4 - v6)\n            v2 = v4 + 1\n        return v1\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "class C1:\n\n    def getMaxLen(self, a1):\n        v1 = 0\n        v2 = 0\n        v3 = len(a1)\n        while v2 < v3:\n            if a1[v2] == 0:\n                v2 += 1\n                continue\n            v4 = v2\n            while v4 < v3 and a1[v4] != 0:\n                v4 += 1\n            v4 -= 1\n            v5 = 0\n            v6 = -1\n            for v7 in range(v2, v4 + 1):\n                if a1[v7] < 0:\n                    v5 += 1\n                    if v6 == -1:\n                        v6 = v7\n            v8 = v4 - v2 + 1\n            if v5 % 2 == 0:\n                v1 = max(v1, v8)\n            elif v6 != -1:\n                v1 = max(v1, v4 - v6)\n            v2 = v4 + 1\n        return v1\n"}
{"id": "llm_code\\count-number-of-trapezoids-ii__grok-4.1-fast__v1.py", "text": "import collections\n\nclass C1:\n\n    def countTrapezoids(self, a1):\n\n        def reduce_frac(a1, a2):\n            v1 = 0\n            v2, v3 = (abs(a1), abs(a2))\n            while v3:\n                v2, v3 = (v3, v2 % v3)\n            v1 = v2\n            if v1 == 0:\n                return (0, 0)\n            v4 = a1 // v1\n            v5 = a2 // v1\n            if v4 < 0 or (v4 == 0 and v5 < 0):\n                v4, v5 = (-v4, -v5)\n            return (v4, v5)\n        v1 = collections.defaultdict(int)\n        v2 = collections.defaultdict(int)\n        v3 = collections.defaultdict(int)\n        v4 = collections.defaultdict(int)\n        v5 = 0\n        v6 = 0\n        v7 = len(a1)\n        for v8 in range(v7):\n            v9, v10 = a1[v8]\n            for v11 in range(v8):\n                v12, v13 = a1[v11]\n                v14 = v12 - v9\n                v15 = v13 - v10\n                v16, v17 = reduce_frac(v14, v15)\n                if v16 == 0 and v17 == 0:\n                    continue\n                v18 = v17 * v9 - v16 * v10\n                v19 = (v16, v17, v18)\n                v20 = v14 * v14 + v15 * v15\n                v21 = (v16, v17, v20)\n                v22 = (v16, v17, v18, v20)\n                v5 += v1[v16, v17] - v2[v19]\n                v6 += v3[v21] - v4[v22]\n                v1[v16, v17] += 1\n                v2[v19] += 1\n                v3[v21] += 1\n                v4[v22] += 1\n        return v5 - v6 // 2\n", "label": 1, "source": "leetcode", "problem_id": "", "code": "import collections\n\nclass C1:\n\n    def countTrapezoids(self, a1):\n\n        def reduce_frac(a1, a2):\n            v1 = 0\n            v2, v3 = (abs(a1), abs(a2))\n            while v3:\n                v2, v3 = (v3, v2 % v3)\n            v1 = v2\n            if v1 == 0:\n                return (0, 0)\n            v4 = a1 // v1\n            v5 = a2 // v1\n            if v4 < 0 or (v4 == 0 and v5 < 0):\n                v4, v5 = (-v4, -v5)\n            return (v4, v5)\n        v1 = collections.defaultdict(int)\n        v2 = collections.defaultdict(int)\n        v3 = collections.defaultdict(int)\n        v4 = collections.defaultdict(int)\n        v5 = 0\n        v6 = 0\n        v7 = len(a1)\n        for v8 in range(v7):\n            v9, v10 = a1[v8]\n            for v11 in range(v8):\n                v12, v13 = a1[v11]\n                v14 = v12 - v9\n                v15 = v13 - v10\n                v16, v17 = reduce_frac(v14, v15)\n                if v16 == 0 and v17 == 0:\n                    continue\n                v18 = v17 * v9 - v16 * v10\n                v19 = (v16, v17, v18)\n                v20 = v14 * v14 + v15 * v15\n                v21 = (v16, v17, v20)\n                v22 = (v16, v17, v18, v20)\n                v5 += v1[v16, v17] - v2[v19]\n                v6 += v3[v21] - v4[v22]\n                v1[v16, v17] += 1\n                v2[v19] += 1\n                v3[v21] += 1\n                v4[v22] += 1\n        return v5 - v6 // 2\n"}
{"id": "human_code\\count-palindromic-subsequences__part1.py", "text": "class C1(object):\n\n    def countPalindromes(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = [0] * 10\n        v3 = [[[0] * 10 for v4 in range(10)] for v4 in range(len(a1) + 1)]\n        for v5 in range(len(a1)):\n            v3[v5 + 1] = [[v3[v5][i][j] for v6 in range(10)] for v7 in range(10)]\n            for v7 in range(10):\n                v3[v5 + 1][int(a1[v5])][v7] += v2[v7]\n            v2[int(a1[v5])] += 1\n        v2 = [0] * 10\n        v8 = [[0] * 10 for v4 in range(10)]\n        v9 = 0\n        for v5 in reversed(range(len(a1))):\n            for v7 in range(10):\n                for v6 in range(10):\n                    v9 = (v9 + v3[v5][v7][v6] * v8[v7][v6]) % v1\n            for v7 in range(10):\n                v8[int(a1[v5])][v7] += v2[v7]\n            v2[int(a1[v5])] += 1\n        return v9\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def countPalindromes(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = 10 ** 9 + 7\n        v2 = [0] * 10\n        v3 = [[[0] * 10 for v4 in range(10)] for v4 in range(len(a1) + 1)]\n        for v5 in range(len(a1)):\n            v3[v5 + 1] = [[v3[v5][i][j] for v6 in range(10)] for v7 in range(10)]\n            for v7 in range(10):\n                v3[v5 + 1][int(a1[v5])][v7] += v2[v7]\n            v2[int(a1[v5])] += 1\n        v2 = [0] * 10\n        v8 = [[0] * 10 for v4 in range(10)]\n        v9 = 0\n        for v5 in reversed(range(len(a1))):\n            for v7 in range(10):\n                for v6 in range(10):\n                    v9 = (v9 + v3[v5][v7][v6] * v8[v7][v6]) % v1\n            for v7 in range(10):\n                v8[int(a1[v5])][v7] += v2[v7]\n            v2[int(a1[v5])] += 1\n        return v9\n"}
{"id": "human_code\\map-of-highest-peak__part1.py", "text": "class C1(object):\n\n    def highestPeak(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        v2 = []\n        for v3, v4 in enumerate(a1):\n            for v5, v6 in enumerate(v4):\n                v4[v5] -= 1\n                if not v6:\n                    continue\n                v2.append((v3, v5))\n        while v2:\n            v7 = []\n            for v3, v5 in v2:\n                for v8, v9 in v1:\n                    v10, v11 = (v3 + v8, v5 + v9)\n                    if not (0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (a1[v10][v11] == -1)):\n                        continue\n                    a1[v10][v11] = a1[v3][v5] + 1\n                    v2.append((v10, v11))\n            v2 = v7\n        return a1\n", "label": 0, "source": "leetcode", "problem_id": "", "code": "class C1(object):\n\n    def highestPeak(self, a1):\n        \"\"\"\n        \"\"\"\n        v1 = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        v2 = []\n        for v3, v4 in enumerate(a1):\n            for v5, v6 in enumerate(v4):\n                v4[v5] -= 1\n                if not v6:\n                    continue\n                v2.append((v3, v5))\n        while v2:\n            v7 = []\n            for v3, v5 in v2:\n                for v8, v9 in v1:\n                    v10, v11 = (v3 + v8, v5 + v9)\n                    if not (0 <= v10 < len(a1) and 0 <= v11 < len(a1[0]) and (a1[v10][v11] == -1)):\n                        continue\n                    a1[v10][v11] = a1[v3][v5] + 1\n                    v2.append((v10, v11))\n            v2 = v7\n        return a1\n"}
